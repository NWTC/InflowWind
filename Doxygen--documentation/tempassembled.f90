!MODULARIZATION NOTES:
!  This file will eventually be replaced with an autogenerated one by the registry program
!  So, for now we will modify this as we develop, then setup the txt file for registry program to use
!     1) modify this to match new style
!     2) setup the InflowWind.txt file for the registry program
!     3) run the registry program to generate the InflowWind_Types.f90 file
!     4) verify that works correctly before removing this (compile with each and verify output)
!
!
!----------------------------------------------------------------------------------------------------
!FIXME: rename
MODULE SharedInflowDefs
! This module is used to define shared types and parameters that are used in the module InflowWind.
! 7 Oct 2009    B. Jonkman, NREL/NWTC
!----------------------------------------------------------------------------------------------------
!  
!..................................................................................................................................
! LICENSING
! Copyright (C) 2012  National Renewable Energy Laboratory
!
!    This file is part of InflowWind.
!
!    InflowWind is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as 
!    published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!
!    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
!    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
!    
!    You should have received a copy of the GNU General Public License along with InflowWind.  
!    If not, see <http://www.gnu.org/licenses/>.
!    
!**********************************************************************************************************************************

   USE NWTC_Library                                               ! Precision module
   IMPLICIT NONE
!   PRIVATE


      !---- Initialization data ---------------------------------------------------------------------
   TYPE, PUBLIC :: IfW_InitInputType
      ! Define inputs that the initialization routine may need here:
      ! e.g., the name of the input file, the file root name, etc.
         ! Filename and type
      CHARACTER(1024)               :: WindFileName
      INTEGER                       :: WindFileType
         ! Configuration Info
      REAL(ReKi)                    :: ReferenceHeight        ! reference height for HH and/or 4D winds (was hub height), in meters
      REAL(ReKi)                    :: Width                  ! width of the HH file (was 2*R), in meters
   END TYPE IfW_InitInputType


      ! ..... States ..............................................................................................................

   TYPE, PUBLIC :: IfW_ContinuousStateType
         ! Define continuous (differentiable) states here:
      REAL(ReKi) :: DummyContState                                            ! If you have continuous states, remove this variable
         ! If you have loose coupling with a variable-step integrator, store the actual time associated with the continuous states
         !    here (eg., REAL(DbKi) :: ContTime):
   END TYPE IfW_ContinuousStateType


   TYPE, PUBLIC :: IfW_DiscreteStateType
         ! Define discrete (nondifferentiable) states here:
      REAL(ReKi) :: DummyDiscState                                            ! If you have discrete states, remove this variable
   END TYPE IfW_DiscreteStateType


   TYPE, PUBLIC :: IfW_ConstraintStateType
         ! Define constraint states here:
      REAL(ReKi) :: DummyConstrState                                          !    If you have constraint states, remove this variable
   END TYPE IfW_ConstraintStateType


   TYPE, PUBLIC :: IfW_OtherStateType
         ! Define any data that are not considered actual "states" here:
         ! e.g. data used only for optimization purposes (indices for searching in an array, copies of previous calculations of output at a given time, etc.)
      INTEGER(IntKi) :: DummyOtherState                                       !    If you have other/optimzation states, remove this variable
   END TYPE IfW_OtherStateType


      ! ..... Parameters ..........................................................................................................

   TYPE, PUBLIC :: IfW_ParameterType

         ! Define parameters here that might need to be accessed from the outside world:

         ! Filename info
      CHARACTER(1024)               :: WindFileName
      CHARACTER(1024)               :: WindFileNameRoot
      CHARACTER(3)                  :: WindFileNameExt
      INTEGER                       :: WindFileType       = 0 ! This should be initially set to match the Undef_Wind parameter in the module

         ! Location
      REAL(ReKi)                    :: ReferenceHeight        ! reference height for HH and/or 4D winds (was hub height), in meters
      REAL(ReKi)                    :: Width                  ! width of the HH file, in meters
!NOTE: might be only for HH file
      REAL(ReKi)                    :: HalfWidth              ! half the width of the HH file (was 2*R), in meters

         ! Flags
      LOGICAL                       :: CT_Flag        = .FALSE.   ! determines if coherent turbulence is used
      LOGICAL                       :: Initialized    = .FALSE.   ! did we run the initialization?

   END TYPE IfW_ParameterType


      ! ..... Inputs ..............................................................................................................

   TYPE, PUBLIC :: IfW_InputType
         ! Define inputs that are contained on the mesh here:
!     TYPE(MeshType)                            ::
         ! Define inputs that are not on this mesh here:
      REAL(ReKi) :: DummyInput                                                ! If you have input data, remove this variable
   END TYPE IfW_InputType


      ! ..... Outputs .............................................................................................................

   TYPE, PUBLIC :: IfW_OutputType
         ! Define outputs that are contained on the mesh here:
!     TYPE(MeshType)                            ::
         ! Define outputs that are not on this mesh here:
      REAL(ReKi) :: DummyOutput                                               ! If you have output data, remove this variable
   END TYPE IfW_OutputType

!-=-=-=-=-=-=-=-=-=-=-
!-=-=-=-=-=-=-=-=-=-=-
!     Original stuff below that hasn't yet been moved.
!-=-=-=-=-=-=-=-=-=-=-
!-=-=-=-=-=-=-=-=-=-=-



!This was commented out before.
!   TYPE, PUBLIC :: InflLoc
!      REAL(ReKi)                    :: Position(3)                ! X, Y, Z
!   END TYPE InflLoc


   TYPE, PUBLIC :: InflIntrpOut
      REAL(ReKi)                    :: Velocity(3)                ! U, V, W
   END TYPE InflIntrpOut

   !-------------------------------------------------------------------------------------------------
   ! Shared parameters, defining the wind types
   ! THEY MUST BE UNIQUE!
   !-------------------------------------------------------------------------------------------------




END MODULE SharedInflowDefs



!!FIXME: add these in at some point.
!      ! ..... Jacobians ...........................................................................................................
!
!   TYPE, PUBLIC :: IfW_PartialOutputPInputType
!
!         ! Define the Jacobian of the output equations (Y) with respect to the inputs (u), dY/du (or Partial Y / Partial u):
!
!      TYPE(IfW_InputType) :: DummyOutput                                    ! If you have output equations and input data, update this variable
!
!   END TYPE IfW_PartialOutputPInputType
!
!
!   TYPE, PUBLIC :: IfW_PartialContStatePInputType
!
!         ! Define the Jacobian of the continuous state equations (X) with respect to the inputs (u), dX/du (or Partial X / Partial u):
!
!      TYPE(IfW_InputType) :: DummyContState                                 ! If you have continuous state equations and input data, update this variable
!
!   END TYPE IfW_PartialContStatePInputType
!
!
!   TYPE, PUBLIC :: IfW_PartialDiscStatePInputType
!
!         ! Define the Jacobian of the discrete state equations (Xd) with respect to the inputs (u), dXd/du (or Partial Xd / Partial u):
!
!      TYPE(IfW_InputType) :: DummyDiscState                                 ! If you have discrete state equations and input data, update this variable
!
!   END TYPE IfW_PartialDiscStatePInputType
!
!
!   TYPE, PUBLIC :: IfW_PartialConstrStatePInputType
!
!         ! Define the Jacobian of the constraint state equations (Z) with respect to the inputs (u), dZ/du (or Partial Z / Partial u):
!
!      TYPE(IfW_InputType) :: DummyConstrState                                ! If you have constraint state equations and input data, update this variable
!
!   END TYPE IfW_PartialConstrStatePInputType
!
!
!   TYPE, PUBLIC :: IfW_PartialOutputPContStateType
!
!         ! Define the Jacobian of the output equations (Y) with respect to the continuous states (x), dY/dx (or Partial Y / Partial x):
!
!      TYPE(IfW_ContinuousStateType) :: DummyOutput                                    ! If you have output equations and continuous states, update this variable
!
!   END TYPE IfW_PartialOutputPContStateType
!
!
!   TYPE, PUBLIC :: IfW_PartialContStatePContStateType
!
!         ! Define the Jacobian of the continuous state equations (X) with respect to the continuous states (x), dX/dx (or Partial X / Partial x):
!
!      TYPE(IfW_ContinuousStateType) :: DummyContState                                 ! If you have continuous state equations and continuous states, update this variable
!
!   END TYPE IfW_PartialContStatePContStateType
!
!
!   TYPE, PUBLIC :: IfW_PartialDiscStatePContStateType
!
!         ! Define the Jacobian of the discrete state equations (Xd) with respect to the continuous states (x), dXd/dx (or Partial Xd / Partial x):
!
!      TYPE(IfW_ContinuousStateType) :: DummyDiscState                                 ! If you have discrete state equations and continuous states, update this variable
!
!   END TYPE IfW_PartialDiscStatePContStateType
!
!
!   TYPE, PUBLIC :: IfW_PartialConstrStatePContStateType
!
!         ! Define the Jacobian of the constraint state equations (Z) with respect to the continuous states (x), dZ/dx (or Partial Z / Partial x):
!
!      TYPE(IfW_ContinuousStateType) :: DummyConstrState                                ! If you have constraint state equations and continuous states, update this variable
!
!   END TYPE IfW_PartialConstrStatePContStateType
!
!
!   TYPE, PUBLIC :: IfW_PartialOutputPDiscStateType
!
!         ! Define the Jacobian of the output equations (Y) with respect to the discrete states (xd), dY/dxd (or Partial Y / Partial xd):
!
!      TYPE(IfW_DiscreteStateType) :: DummyOutput                                    ! If you have output equations and discrete states, update this variable
!
!   END TYPE IfW_PartialOutputPDiscStateType
!
!
!   TYPE, PUBLIC :: IfW_PartialContStatePDiscStateType
!
!         ! Define the Jacobian of the continuous state equations (X) with respect to the discrete states (xd), dX/dxd (or Partial X / Partial xd):
!
!      TYPE(IfW_DiscreteStateType) :: DummyContState                                 ! If you have continuous state equations and discrete states, update this variable
!
!   END TYPE IfW_PartialContStatePDiscStateType
!
!
!   TYPE, PUBLIC :: IfW_PartialDiscStatePDiscStateType
!
!         ! Define the Jacobian of the discrete state equations (Xd) with respect to the discrete states (xd), dXd/dxd (or Partial Xd / Partial xd):
!
!      TYPE(IfW_DiscreteStateType) :: DummyDiscState                                 ! If you have discrete state equations and discrete states, update this variable
!
!   END TYPE IfW_PartialDiscStatePDiscStateType
!
!
!   TYPE, PUBLIC :: IfW_PartialConstrStatePDiscStateType
!
!         ! Define the Jacobian of the constraint state equations (Z) with respect to the discrete states (xd), dZ/dxd (or Partial Z / Partial xd):
!
!      TYPE(IfW_DiscreteStateType) :: DummyConstrState                                ! If you have constraint state equations and discrete states, update this variable
!
!   END TYPE IfW_PartialConstrStatePDiscStateType
!
!
!   TYPE, PUBLIC :: IfW_PartialOutputPConstrStateType
!
!         ! Define the Jacobian of the output equations (Y) with respect to the constraint states (z), dY/dz (or Partial Y / Partial z):
!
!      TYPE(IfW_ConstraintStateType) :: DummyOutput                                    ! If you have output equations and constraint states, update this variable
!
!   END TYPE IfW_PartialOutputPConstrStateType
!
!
!   TYPE, PUBLIC :: IfW_PartialContStatePConstrStateType
!
!         ! Define the Jacobian of the continuous state equations (X) with respect to the constraint states (z), dX/dz (or Partial X / Partial z):
!
!      TYPE(IfW_ConstraintStateType) :: DummyContState                                 ! If you have continuous state equations and constraint states, update this variable
!
!   END TYPE IfW_PartialContStatePConstrStateType
!
!
!   TYPE, PUBLIC :: IfW_PartialDiscStatePConstrStateType
!
!         ! Define the Jacobian of the discrete state equations (Xd) with respect to the constraint states (z), dXd/dz (or Partial Xd / Partial z):
!
!      TYPE(IfW_ConstraintStateType) :: DummyDiscState                                 ! If you have discrete state equations and constraint states, update this variable
!
!   END TYPE IfW_PartialDiscStatePConstrStateType
!
!
!   TYPE, PUBLIC :: IfW_PartialConstrStatePConstrStateType
!
!         ! Define the Jacobian of the constraint state equations (Z) with respect to the constraint states (z), dZ/dz (or Partial Z / Partial z):
!
!      TYPE(IfW_ConstraintStateType) :: DummyConstrState                                ! If you have constraint state equations and constraint states, update this variable
!
!   END TYPE IfW_PartialConstrStatePConstrStateType
!
MODULE   WindFile_Types
!FIXME: I'm not sure what to do with these. This might be the wrong place to be keeping this information.
!        -->   Can't make them parameters.
!        -->   I think these are used locally only, not by any external code. Can't really tell though since they used
!        -->   to be PUBLIC,PARAMETER.
!
!        --> Make these parameters within the module, but not shared to the outside world. Put in the subroutines?
!  
!..................................................................................................................................
! LICENSING
! Copyright (C) 2012  National Renewable Energy Laboratory
!
!    This file is part of InflowWind.
!
!    InflowWind is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as 
!    published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!
!    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
!    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
!    
!    You should have received a copy of the GNU General Public License along with InflowWind.  
!    If not, see <http://www.gnu.org/licenses/>.
!    
!**********************************************************************************************************************************


   ! The parameters here are not considered private, but are not accessable unless the module is called.
   IMPLICIT NONE


   INTEGER,PARAMETER          :: DEFAULT_Wind = -1    ! Undetermined wind type; calls internal routine to guess what type it is
   INTEGER,PARAMETER          :: Undef_Wind   =  0    ! This is the code for an undefined WindFileType
   INTEGER,PARAMETER          :: HH_Wind      =  1    ! Hub-Height wind file
   INTEGER,PARAMETER          :: FF_Wind      =  2    ! Binary full-field wind file
   INTEGER,PARAMETER          :: UD_Wind      =  3    ! User-defined wind
   INTEGER,PARAMETER          :: FD_Wind      =  4    ! 4-dimensional wind (LES)
   INTEGER,PARAMETER          :: CTP_Wind     =  5    ! Coherent turbulence wind field (superimpose KH billow on background wind)
   INTEGER,PARAMETER          :: HAWC_Wind    =  6    ! Binary full-field wind file in HAWC format

END MODULE   WindFile_Types
MODULE CTWind
! This module uses reads coherent turbulence parameter (CTP) files and processes the data in them
! to get coherent turbulence which is later superimposed on a background wind field (the super-
! positioning occurs elsewhere).  The turbulence in this module is part of the KH billow, which
! can be read using FDWind.  As a result, the scaling here should be similiar to FDWind.
!
! This module assumes that the origin, (0,0,0), is located at the tower centerline at ground level,
! and that all units are specified in the metric system (using meters and seconds).
! Data is shifted by half the grid width when used with FFWind.
!
!  Created 25-Sept-2009 by B. Jonkman, National Renewable Energy Laboratory
!     using subroutines and modules from AeroDyn v12.58
!
!----------------------------------------------------------------------------------------------------

   USE                     NWTC_Library
   USE                     SharedInflowDefs
   USE                     WindFile_Types

   IMPLICIT                NONE
   PRIVATE
   
      
   INTEGER, PARAMETER           :: NumComps  = 3                              ! number of components
   
            ! CT_Wind
   REAL(ReKi)                   :: DelYCTgrid                                 ! The nondimensional distance between grid points in the y direction.
   REAL(ReKi)                   :: DelZCTgrid                                 ! The nondimensional distance between grid points in the z direction.
   REAL(ReKi)                   :: CTDistSc                                   ! Disturbance scale (ratio of wave height to rotor diameter).
   REAL(ReKi)                   :: CTOffset (NumComps)                        ! Offsets to convert integer data to actual wind speeds.
   REAL(ReKi)                   :: CTScale  (NumComps)                        ! Scaling factors to convert integer data to actual wind speeds.

   
   REAL(ReKi), ALLOCATABLE      :: CTvelU   (:,:,:)                         ! The y-z grid velocity data (U components) for the lower- and upper-bound time slices
   REAL(ReKi), ALLOCATABLE      :: CTvelV   (:,:,:)                         ! The y-z grid velocity data (V components) for the lower- and upper-bound time slices
   REAL(ReKi), ALLOCATABLE      :: CTvelW   (:,:,:)                         ! The y-z grid velocity data (W components) for the lower- and upper-bound time slices
   REAL(ReKi)                   :: CTLy                                       ! Fractional location of tower centerline from right (looking downwind) to left side of the dataset.
   REAL(ReKi)                   :: CTLz                                       ! Fractional location of hub height from bottom to top of dataset.
   REAL(ReKi)                   :: CTScaleVel                                 ! Scaling velocity, U0.  2*U0 is the difference in wind speed between the top and bottom of the wave.
   REAL(ReKi), ALLOCATABLE      :: Tdata    (:)                               ! The list of times for the CT-wind input files.  
   
   REAL(ReKi)                   :: CT_Zref                                    ! The reference height for the CT file (the bottom of the billow)
   REAL(ReKi)                   :: CTYHWid                                    ! The half the width of the background dataset, used to compute the CTwind time offset
   REAL(ReKi)                   :: CTYmax                                     ! The dimensional lateral width of the dataset.
   REAL(ReKi)                   :: CTYt                                       ! Distance of the tower from the right side of the dataset (looking downwind).
   REAL(ReKi)                   :: CTZmax                                     ! The dimensional vertical height of the dataset.
   REAL(ReKi)                   :: InvMCTWS                                   ! The multiplicative inverse of the mean hub height wind speed for the CT wind data

   INTEGER                      :: CT_DF_Y                                    ! The decimation factor for the CT wind data in the y direction.
   INTEGER                      :: CT_DF_Z                                    ! The decimation factor for the CT wind data in the z direction.
   INTEGER                      :: CTvel_files(2)                             ! Times for the CT wind files stored in CTvel arrays.

   INTEGER                      :: IndCT_hi                                   ! An index into the 3rd dimension of the CTvel arrays, indicating the upper time slice (allows us to avoid copying array)
   INTEGER                      :: IndCT_lo                                   ! An index into the 3rd dimension of the CTvel arrays, indicating the lower time slice (allows us to avoid copying array)
   
   INTEGER                      :: NumCTt                                     ! The number of CT wind grids, no more than one grid per time step.
   INTEGER                      :: NumCTy                                     ! The number of CT wind grid points in the y direction.
   INTEGER                      :: NumCTyD                                    ! The decimated number of CT wind grid points in the y direction.
   INTEGER                      :: NumCTyD1                                   ! The decimated number of CT wind grid points in the y direction minus 1.
   INTEGER                      :: NumCTz                                     ! The number of CT wind grid points in the z direction.
   INTEGER                      :: NumCTzD                                    ! The decimated number of CT wind grid points in the z direction.
   INTEGER                      :: NumCTzD1                                   ! The decimated number of CT wind grid points in the z direction minus 1.
   INTEGER, SAVE                :: TimeIndx  = 0                              ! Index into the time array
   INTEGER, ALLOCATABLE         :: TimeStpCT (:)                              ! The list of time steps from the original LE simulation, associated with the CT-wind times.

   INTEGER                      :: CTWindUnit                                 ! unit number used to read the wind files at each call to CT_GetWindSpeed()
   
   LOGICAL                      :: CTVertShft                                 ! Flag to indicate whether or not to shift the z values for the w component.

   CHARACTER(3)                 :: CText                                      ! The extension used for coherent turbulence data files. (usually "les" or "dns")
   CHARACTER(1024)              :: CTSpath                                    ! The path to the CT wind files.

   TYPE :: CTWindFiles
      CHARACTER(1024)           :: CTTSfile                                   ! The name of the file containing the time-step history of the wind files.
      CHARACTER(1024)           :: CTbackgr                                   ! The name of the background wind data
   END TYPE CTWindFiles


   TYPE, PUBLIC :: CT_Backgr
      CHARACTER(1024)           :: WindFile                                   ! The name of the background wind file
      INTEGER                   :: WindFileType                               ! The type of background wind file (currently only FF)
      LOGICAL                   :: CoherentStr                                ! If the coherent time step file is blank or doesn't exist, this is FALSE (use the background only)
   END TYPE CT_Backgr
            
   
   PUBLIC                       :: CT_Init
   PUBLIC                       :: CT_GetWindSpeed
   PUBLIC                       :: CT_SetRefVal
   PUBLIC                       :: CT_Terminate

CONTAINS
!====================================================================================================
SUBROUTINE CT_Init(UnWind, WindFile, BackGrndValues, ErrStat)
!  This subroutine is called at the beginning of a simulation.  It reads the CTP file to obtain
!  the name of the CTS file, the path locating the binary KH files, and decimation factors.
!  It returns the background wind file and type; it also returns a flag that determines if CT wind
!  files are ACTUALLY to be used (e.g., if the CTS file is blank or there is one line of zero in the
!  CTS time array).  
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: WindFile                     ! Name of the CTP (.ctp) wind file
   TYPE(CT_Backgr), INTENT(OUT)   :: BackGrndValues               ! output background values
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise


      ! Local Variables:
      
   TYPE(CTWindFiles)              :: CTP_files
   CHARACTER(3)                   :: CT_SC_ext                    ! extension of the scaling file
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( TimeIndx /= 0 ) THEN  
      CALL WrScr( ' CTWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
!      CALL NWTC_Init()    ! Initialized in IfW_Init
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Read the CTP file and set the background data info to be returned later
   !-------------------------------------------------------------------------------------------------
   
   CALL ReadCTP( UnWind, WindFile, CTP_files, ErrStat )
   IF (ErrStat /= 0) RETURN           
   
  
   BackGrndValues%WindFile     = CTP_files%CTbackgr
   BackGrndValues%WindFileType = FF_Wind             !bjj: perhaps we should check the wind type here
   
   !-------------------------------------------------------------------------------------------------
   ! Read the CTTS file to get the time step and file number arrays
   !-------------------------------------------------------------------------------------------------   
   CALL ReadCTTS( UnWind, CTP_files%CTTSfile, CT_SC_ext, ErrStat )

   IF (ErrStat == 0 .AND. NumCTt > 1) THEN    
      BackGrndValues%CoherentStr  = .TRUE.
      
      !-------------------------------------------------------------------------------------------------
      ! Read file containing scaling for the binary large-eddy files
      !-------------------------------------------------------------------------------------------------
      CALL ReadCTScales( UnWind, TRIM( CTSpath )//'\Scales.'//TRIM( CT_SC_ext ), ErrStat )
      IF (ErrStat /= 0) RETURN


      CTScale(:)  = CTScaleVel*CTScale(:)
      CTOffset(:) = CTScaleVel*CTOffset(:)

   ELSE              
      
      IF (ErrStat <= 0) THEN
         
            ! The file is missing, blank (or possibly incomplete), or has only 1 time step line (which  
            ! is zero); Go on without the CT file, using just the background

         CALL ProgWarn( ' Coherent turbulence wind file will be turned off.' )
         
         BackGrndValues%CoherentStr  = .FALSE.
         CALL CT_Terminate( ErrStat )          
         
      END IF

      RETURN
      
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Set some values that don't change during the run
   !-------------------------------------------------------------------------------------------------
      
   CTYHWid        = 0.0                                                    ! This value is used to perform a time shift (the equivalent distance of FFYHWid [approx. rotor radius])
   CT_Zref        = -1.0                                                   ! This value needs to be set after the corresponding background turbulence has been read (or the CTS file should be changed)

   NumCTyD        = ( NumCTy + CT_DF_Y - 1 )/CT_DF_Y                       ! The decimated number of CT wind grid points in the y direction.
   NumCTzD        = ( NumCTz + CT_DF_Z - 1 )/CT_DF_Z                       ! The decimated number of CT wind grid points in the z direction.
   NumCTyD1       = NumCTyD - 1                                            ! The decimated number of CT wind grid points in the y direction minus 1.
   NumCTzD1       = NumCTzD - 1                                            ! The decimated number of CT wind grid points in the z direction minus 1.

   CTYt           = CTYmax*CTLy                                            ! Distance of the tower from the right side of the dataset (looking downwind).
!   CTZt           = CTZmax*CTLz                                            ! Distance of the hub from the bottom of the dataset.
   DelYCTgrid     = 1.0/NumCTyD1                                           ! The nondimensional distance between grid points in the y direction.
   DelZCTgrid     = 1.0/NumCTzD1                                           ! The nondimensional distance between grid points in the z direction.
    

     
   !-------------------------------------------------------------------------------------------------
   ! Allocate the wind array and initialize it
   !-------------------------------------------------------------------------------------------------
   
   IF (.NOT. ALLOCATED(CTvelU) ) THEN
      ALLOCATE ( CTvelU(NumCTyD,NumCTzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the CTvelU array.' )
         RETURN
      END IF
   END IF   
   
   IF (.NOT. ALLOCATED(CTvelV) ) THEN
!      CALL AllocAry( CTvelV, NumCTyD, NumCTzD, 2, 'CTvelV', ErrStat ) !AllRAry3 AllocAry
      ALLOCATE ( CTvelV(NumCTyD,NumCTzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the CTvelV array.' )
         RETURN
      END IF
   END IF   
   
   IF (.NOT. ALLOCATED(CTvelW) ) THEN
!      CALL AllocAry( CTvelW, NumCTyD, NumCTzD, 2, 'CTvelW', ErrStat ) !AllRAry3 AllocAry
      ALLOCATE ( CTvelW(NumCTyD,NumCTzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the CTvelW array.' )
         RETURN
      END IF
   END IF   

   CTvelU(:,:,:) = 0.0                                                    ! the original velocity data      
   CTvelV(:,:,:) = 0.0                                                    ! the original velocity data      
   CTvelW(:,:,:) = 0.0                                                    ! the original velocity data      
      
   !-------------------------------------------------------------------------------------------------
   ! Initialize the arrays and set the initialization flag
   !-------------------------------------------------------------------------------------------------   
   CTvel_files(:) = 0                                                      ! the name of the files currently in the CTvel array
   CTWindUnit     = UnWind                                                 ! This unit is needed to open the binary files at each step
   TimeIndx       = 1
    
   RETURN

END SUBROUTINE CT_Init
!====================================================================================================
SUBROUTINE CT_SetRefVal(Height, HWidth, ErrStat)

   REAL(ReKi), INTENT(IN)           :: Height                                 ! a reference height (should be hub height)
   REAL(ReKi), INTENT(IN), OPTIONAL :: HWidth                                 ! a reference offset (should be half grid width [~rotor radius])
   INTEGER,    INTENT(OUT)          :: ErrStat                                ! returns 0 if no error; non-zero otherwise


   !-------------------------------------------------------------------------------------------------     
   ! Check that we've initialized everything first
   !-------------------------------------------------------------------------------------------------     
     
   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Initialialize the CTWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE IF ( CT_Zref >= 0 ) THEN
      CALL WrScr( ' Cannot reset the CTWind reference height in the middle of a simulation.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0         
   END IF      


   !-------------------------------------------------------------------------------------------------     
   ! Set the grid shift using the half-width
   !-------------------------------------------------------------------------------------------------     
   IF ( PRESENT( HWidth ) ) THEN
      CTYHWid = HWidth
        
      IF ( CTYHWid < 0 ) THEN
         CALL WrScr( ' Reference width in CTWind cannot be negative.')
         CTYHWid = 0
         ErrStat = 1
      END IF
   END IF
 
 
   !-------------------------------------------------------------------------------------------------     
   ! Set the reference height (bottom of the KH billow) using the input hub-height
   !-------------------------------------------------------------------------------------------------     
      ! CTZt = CTZmax*CTLz             ! the distance between the hub and the bottom of the dataset

   CT_Zref = Height - CTZmax*CTLz      ! the height of the bottom of the KH billow

   IF ( CT_Zref < 0 ) THEN
      CALL WrScr( ' Reference height in CTWind cannot be negative.')
      CT_Zref = 0
      ErrStat = 1
   END IF      

   
END SUBROUTINE CT_SetRefVal
!====================================================================================================
FUNCTION CT_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are are 
! requested.  It returns the velocities at the specified time and space that are superimposed on
! a background wind flow.  This function interpolates into the full-field CT wind arrays, performing
! a time shift based on the average windspeed. The modified time is used to decide which pair of time 
! slices to interpolate within and between. After finding the two time slices, it decides which four 
! grid points bound the (Y,Z) pair. It does a bilinear interpolation for (Y,Z) on each bounding time 
! slice, then linearly interpolates between the 2 time slices. This routine assumes that X is downwind, 
! Y is to the left when looking downwind and Z is up.  In the time (X) and Z directions, steady winds 
! are used when extrapolation is required.  The dataset is assumed to be periodic in the Y direction.
!----------------------------------------------------------------------------------------------------
 
      ! Passed variables:
      
   REAL(ReKi),        INTENT(IN) :: Time                                   ! the time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)                       ! the position (X,Y,Z)
   INTEGER,           INTENT(OUT):: ErrStat                                ! returns 0 if no error; non-zero otherwise
   TYPE(InflIntrpOut)            :: CT_GetWindSpeed                        ! the resultant wind speed
   
   
      ! Local Variables:

   REAL(ReKi)                    :: Iyz_th                                 ! Temporary interpolated value. (time hi, all y, all z)
   REAL(ReKi)                    :: Iyz_tl                                 ! Temporary interpolated value. (time lo, all y, all z)
   REAL(ReKi)                    :: Iyhz                                   ! Temporary interpolated value. (y hi, all z)
   REAL(ReKi)                    :: Iylz                                   ! Temporary interpolated value. (y lo, all z)
   REAL(ReKi)                    :: TimeShifted                            ! Shifted time (necessary because we're keeping x constant)
   REAL(ReKi)                    :: Tgrid                                  ! Fractional distance between time grids.
   REAL(ReKi)                    :: Ygrid                                  ! Fractional distance between grids in the y direction.
   REAL(ReKi)                    :: Ynorm                                  ! Nondimensional lateral distance of the analysis point from right side of dataset (looking downwind).
   REAL(ReKi)                    :: Zgrid(3)                               ! Fractional distance between grids in the z direction.
   REAL(ReKi)                    :: Znorm                                  ! Nondimensional vertical distance of the analysis point from bottom of dataset.

   INTEGER                       :: I
   INTEGER                       :: IYHi
   INTEGER                       :: IYLo
   INTEGER                       :: IZHi(3)
   INTEGER                       :: IZLo(3)


   !-------------------------------------------------------------------------------------------------     
   ! Check that we've initialized everything first
   !-------------------------------------------------------------------------------------------------     
     
   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Initialialize the CTWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE IF ( CT_Zref < 0 ) THEN
      CALL WrScr( ' Set the reference height in the CTWind module before calling CT_GetWindSpeed.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------     
   ! Perform the time shift. At time=0, a point half the grid width downstream will index into the zero 
   ! time slice.  CTYHWid is used to shift the CT wind the same as FF wind is shifted.
   ! This assumes that the coherent turbulence events are moving at MCTWS
   !-------------------------------------------------------------------------------------------------     

   TimeShifted = TIME + ( CTYHWid - InputPosition(1) )*InvMCTWS


   !-------------------------------------------------------------------------------------------------
   ! Find the bounding time slices:
   ! Linearly interpolate in time (or set to 0 before and/or after) 
   ! (compare with NWTC_Num.f90\InterpStpReal) 
   !-------------------------------------------------------------------------------------------------

      ! Let's check the limits first.

   IF ( TimeShifted <= Tdata(1) )  THEN
   
      TimeIndx = 1
      Tgrid    = 0.0
                     
!      CT_GetWindSpeed%Velocity(:) = 0.0
!      RETURN
                           
   ELSE IF ( TimeShifted >= Tdata(NumCTt) )  THEN
   
      TimeIndx = NumCTt - 1
      Tgrid    = 1.0

!      CT_GetWindSpeed%Velocity(:) = 0.0
!      RETURN
      
   ELSE
   
         ! Let's interpolate!

      TimeIndx = MAX( MIN( TimeIndx, NumCTt-1 ), 1 )


      DO 

         IF ( TimeShifted < Tdata(TimeIndx) )  THEN

            TimeIndx = TimeIndx - 1

         ELSE IF ( TimeShifted >= Tdata(TimeIndx+1) )  THEN

            TimeIndx = TimeIndx + 1

         ELSE
         
            Tgrid = MIN( MAX( ( TimeShifted - Tdata(TimeIndx) )/( Tdata(TimeIndx+1) - Tdata(TimeIndx) ), 0.0 ), 1.0 )
            EXIT

         END IF

      END DO
      
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Read the data at the two time steps, if necessary
   !-------------------------------------------------------------------------------------------------
     
   IF ( TimeStpCT(TimeIndx) == CTvel_files(2) ) THEN
      IndCT_lo = 2      
      IndCT_hi = 1
            
   ELSE
      IndCT_lo = 1
      IndCT_hi = 2 
        
      IF ( TimeStpCT(TimeIndx) /= CTvel_files(IndCT_lo) ) THEN         
         CTvel_files(IndCT_lo) = TimeStpCT(TimeIndx)
         CALL ReadCTData ( CTWindUnit, CTvel_files(IndCT_lo), IndCT_lo, ErrStat  )
      END IF
      
   END IF
   

   IF ( CTvel_files(IndCT_hi) /= TimeStpCT(TimeIndx+1) ) THEN
      
      CTvel_files(IndCT_hi) = TimeStpCT(TimeIndx+1)
      CALL ReadCTData ( CTWindUnit, CTvel_files(IndCT_hi), IndCT_hi, ErrStat  )

   END IF
         

   !-------------------------------------------------------------------------------------------------
   ! Calculate the y values;                   The lower-right corner is (1,1) when looking downwind.
   ! note that the KH data is periodic in this direction
   !-------------------------------------------------------------------------------------------------
   
   Ynorm = ( CTYt + InputPosition(2) )/CTYmax

      ! Ensure Ynorm is not negative.  The wave is periodic in y.

   IF ( Ynorm < 0.0 ) THEN
      Ynorm = 1.0 + MOD(Ynorm, 1.0)
   ENDIF

   Ygrid = MIN( MAX( MOD( Ynorm, DelYCTgrid ), 0.0 ), 1.0 )
   IYLo  = MAX( MOD( INT( Ynorm*NumCTyD1 ) + 1, NumCTyD1 ), 1 )
   IYHi =  MOD( IYLo, NumCTyD ) + 1


   !-------------------------------------------------------------------------------------------------
   ! Calculate the z values                   The lower-right corner is (1,1) when looking downwind.
   ! Note: the equivalent Znorm for the w-component may be shifted vertically by half the original
   ! grid spacing. (the K-H data staggers w differently than u & v).  We store IZLo, IZHi, and 
   ! Zgrid in an array to account for this difference.
   !-------------------------------------------------------------------------------------------------

   Znorm = MIN( MAX( ( InputPosition(3) - CT_Zref )/CTZmax, 0.0 ), 1.0 ) ! non-dimensional height (CT_Zref is the bottom of the billow)

      ! Find out fractionally how far we are between grids in time and between grid points in each direction.
      ! Limit values to avoid extrapolation.  We need this for interpolation later on.

   Zgrid(1:2)   = MIN( MAX( MOD( Znorm, DelZCTgrid ), 0.0 ), 1.0 )
   IZLo(1:2)    = MAX( INT( Znorm*NumCTzD1 ) + 1, 1 )            ! Make sure the lowest possible value is 1.

      ! If we are located at the upper end of the z dimension, decrement the index by one and set the grid coordinate to 1.

   IF ( IZLo(1) == NumCTzD )  THEN
      IZLo(1:2)  = NumCTzD1
      Zgrid(1:2) = 1.0
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Find the equivalent Znorm for the w-component, which may be shifted vertically by half 
   ! the original grid spacing. (This is necessary due to the fact that the K-H data staggers w 
   ! differently than u & v).  LES and DNS scale differently.
   !-------------------------------------------------------------------------------------------------

   IF ( CTVertShft )  THEN
      Znorm = MAX( Znorm - 0.5*DelZCTgrid/CT_DF_Z, 0.0 )
      
      Zgrid(3) = MIN( MAX( MOD( Znorm, DelZCTgrid ), 0.0 ), 1.0 )
      IZLo(3)  = MAX( INT( Znorm*NumCTzD1 ) + 1, 1 )       ! Make sure the lowest possible value is 1.


         ! If we are located at the upper end of the z dimension, decrement the index by one and set the grid coordinate to 1.

      IF ( IZLo(3) == NumCTzD )  THEN
         IZLo(3)  = NumCTzD1
         Zgrid(3) = 1.0
      ENDIF
                 
   ELSE
      IZLo(3) = IZLo(1)
      Zgrid(3)= Zgrid(1)          
   ENDIF

   IZHi(:) = IZLo(:) + 1
   
!bjj: old versions used Zgrid(3) = Zgrid(1) without regard to CTVertShft. It seemed wrong to me so I changed it.

   !-------------------------------------------------------------------------------------------------
   !  Interpolate for U component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

      I = 1
         ! linearaly interpolate in the lower time slice
      Iylz   = ( CTvelU(IYLo,IZHi(I),IndCT_lo) - CTvelU(IYLo,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelU(IYLo,IZLo(I),IndCT_lo)
      Iyhz   = ( CTvelU(IYHi,IZHi(I),IndCT_lo) - CTvelU(IYHi,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelU(IYHi,IZLo(I),IndCT_lo)     
      Iyz_tl = ( Iyhz - Iylz )*Ygrid + Iylz

         ! linearaly interpolate in the upper time slice
      Iylz   = ( CTvelU(IYLo,IZHi(I),IndCT_hi) - CTvelU(IYLo,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelU(IYLo,IZLo(I),IndCT_hi)
      Iyhz   = ( CTvelU(IYHi,IZHi(I),IndCT_hi) - CTvelU(IYHi,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelU(IYHi,IZLo(I),IndCT_hi)     
      Iyz_th = ( Iyhz - Iylz )*Ygrid + Iylz

      CT_GetWindSpeed%Velocity(I) = ( Iyz_th - Iyz_tl )*Tgrid + Iyz_tl


   !-------------------------------------------------------------------------------------------------
   !  Interpolate for V component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

      I = 2

         ! linearaly interpolate in the lower time slice
      Iylz   = ( CTvelV(IYLo,IZHi(I),IndCT_lo) - CTvelV(IYLo,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelV(IYLo,IZLo(I),IndCT_lo)
      Iyhz   = ( CTvelV(IYHi,IZHi(I),IndCT_lo) - CTvelV(IYHi,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelV(IYHi,IZLo(I),IndCT_lo)     
      Iyz_tl = ( Iyhz - Iylz )*Ygrid + Iylz

         ! linearaly interpolate in the upper time slice
      Iylz   = ( CTvelV(IYLo,IZHi(I),IndCT_hi) - CTvelV(IYLo,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelV(IYLo,IZLo(I),IndCT_hi)
      Iyhz   = ( CTvelV(IYHi,IZHi(I),IndCT_hi) - CTvelV(IYHi,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelV(IYHi,IZLo(I),IndCT_hi)     
      Iyz_th = ( Iyhz - Iylz )*Ygrid + Iylz

      CT_GetWindSpeed%Velocity(I) = ( Iyz_th - Iyz_tl )*Tgrid + Iyz_tl


   !-------------------------------------------------------------------------------------------------
   !  Interpolate for W component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

      I = 3

         ! linearaly interpolate in the lower time slice
      Iylz   = ( CTvelW(IYLo,IZHi(I),IndCT_lo) - CTvelW(IYLo,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelW(IYLo,IZLo(I),IndCT_lo)
      Iyhz   = ( CTvelW(IYHi,IZHi(I),IndCT_lo) - CTvelW(IYHi,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelW(IYHi,IZLo(I),IndCT_lo)     
      Iyz_tl = ( Iyhz - Iylz )*Ygrid + Iylz

         ! linearaly interpolate in the upper time slice
      Iylz   = ( CTvelW(IYLo,IZHi(I),IndCT_hi) - CTvelW(IYLo,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelW(IYLo,IZLo(I),IndCT_hi)
      Iyhz   = ( CTvelW(IYHi,IZHi(I),IndCT_hi) - CTvelW(IYHi,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelW(IYHi,IZLo(I),IndCT_hi)     
      Iyz_th = ( Iyhz - Iylz )*Ygrid + Iylz

      CT_GetWindSpeed%Velocity(I) = ( Iyz_th - Iyz_tl )*Tgrid + Iyz_tl


   RETURN

END FUNCTION CT_GetWindSpeed
!====================================================================================================
SUBROUTINE ReadCTData ( UnWind, CTFileNo, Itime, ErrStat )
!    This subroutine is used to read one time-step's worth of large-eddy
!    zero-mean wind data for each wind component from a file.
!----------------------------------------------------------------------------------------------------


      ! Passed variables.

   INTEGER,       INTENT(IN)     :: UnWind                                    ! The I/O unit of the input file
   INTEGER,       INTENT(IN)     :: CTFileNo                                  ! The number of the file to read
   INTEGER,       INTENT(IN)     :: Itime                                     ! The index of the time slice
   INTEGER,       INTENT(OUT)    :: ErrStat                                   ! returns 0 if no error; non-zero otherwise

      ! Local variables.

!   CHARACTER(1),PARAMETER        :: Comp(NumComps) = (/'u', 'v', 'w' /)       ! the wind components
   CHARACTER(5)                  :: CTnum                                     ! string equivalent of input variable CTFileNo
   CHARACTER(1024)               :: FileName                                  ! The name of the input data file
   
   
   IF ( CTFileNo == 0 ) THEN
   
      CTvelU(:,:,Itime) = 0.0
      CTvelV(:,:,Itime) = 0.0
      CTvelW(:,:,Itime) = 0.0
      
   ELSE
         ! Loop through the components

      WRITE( CTnum, '(I5.5)' ) CTFileNo


      FileName = TRIM( CTSpath )//'\u\u_16i_'//CTnum//'.'//TRIM( CText )
      CALL LoadCTData( UnWind, TRIM(FileName), Itime, 1, CTvelU, ErrStat )
      IF ( ErrStat /= 0 ) RETURN
      

      FileName = TRIM( CTSpath )//'\v\v_16i_'//CTnum//'.'//TRIM( CText )
      CALL LoadCTData( UnWind, TRIM(FileName), Itime, 2, CTvelV, ErrStat )
      IF ( ErrStat /= 0 ) RETURN
      
      
      FileName = TRIM( CTSpath )//'\w\w_16i_'//CTnum//'.'//TRIM( CText )
      CALL LoadCTData( UnWind, TRIM(FileName), Itime, 3, CTvelW, ErrStat )
      IF ( ErrStat /= 0 ) RETURN
      
   
   END IF

   RETURN
   
END SUBROUTINE ReadCTData
!====================================================================================================
SUBROUTINE LoadCTData( UnWind, FileName, ITime, IComp, Vel, ErrStat )
!  This function is used to read the input parameters for the coherent turbulence events, 
!  based on the large-eddy simulation.
!----------------------------------------------------------------------------------------------------

      ! Passed variables.

   INTEGER,       INTENT(IN)     :: UnWind                                    ! The I/O unit of the input file
   CHARACTER(*),  INTENT(IN)     :: FileName                                  ! The name of the file to open
   INTEGER,       INTENT(IN)     :: Itime                                     ! The index of the time slice
   INTEGER,       INTENT(IN)     :: IComp                                     ! The index of the component
   REAL(ReKi),    INTENT(INOUT)  :: Vel    (NumCTyD,NumCTzD,2)                ! returns the velocity array (don't use INTENT OUT!)  
   INTEGER,       INTENT(OUT)    :: ErrStat                                   ! returns 0 if no error; non-zero otherwise

   INTEGER(B2Ki)                 :: Com    (NumCTy)                           ! Temporary array to hold component's integer values for a given Z.
   INTEGER                       :: IY                                        ! A DO index for indexing the arrays in the y direction.
   INTEGER                       :: IYK                                       ! An index for the decimated arrays in the y direction.
   INTEGER                       :: IZ                                        ! A DO index for indexing the arrays in the z direction.
   INTEGER                       :: IZK                                       ! An index for the decimated arrays in the z direction.



   !-------------------------------------------------------------------------------------------------
   ! Open the input file
   !-------------------------------------------------------------------------------------------------

   CALL OpenUInBEFile( UnWind, TRIM(FileName), 2*NumCTy, ErrStat )
   IF (ErrStat /= 0) RETURN


   !-------------------------------------------------------------------------------------------------
   ! Read the data and fill the arrays
   !-------------------------------------------------------------------------------------------------
      
   IZK = 0                          ! the Z index into the array (necessary b/c of decimation factor)
   DO IZ=1,NumCTz,CT_DF_Z

      READ (UnWind,REC=IZ,IOSTAT=ErrStat)  Com

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Error reading record '//TRIM( Num2LStr( IZ ) )//' of the binary CT wind file, "' &
                           //TRIM( FileName )//'."')
         RETURN                           

      ENDIF

      IZK = IZK + 1
      IYK = 0                       ! the Y index into the array (necessary b/c of decimation factor)
      
      DO IY=1,NumCTy,CT_DF_Y
         IYK = IYK + 1
         Vel(IYK,IZK,ITime) = CTScale(IComp)*Com(IY) + CTOffset(IComp)
      ENDDO ! IY

   ENDDO ! IZ


   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
      CLOSE ( UnWind )

   RETURN


END SUBROUTINE LoadCTData
!====================================================================================================
SUBROUTINE ReadCTP( UnWind, FileName, CTPscaling, ErrStat )
!  This function is used to read the input parameters for the coherent turbulence events, 
!  based on the large-eddy simulation.
!----------------------------------------------------------------------------------------------------


      ! Passed variables.

   INTEGER,            INTENT(IN)  :: UnWind                                   ! The I/O unit of the input file
   CHARACTER(*),       INTENT(IN)  :: FileName                                 ! The name of the input data file
   TYPE(CTWindFiles),  INTENT(OUT) :: CTPscaling                               ! The file names contained in the CTP file
   INTEGER,            INTENT(OUT) :: ErrStat                                  ! returns 0 if no error; non-zero otherwise


      ! Local variables.
      
   CHARACTER(1024)                 :: HeaderLine                               ! The header text in the file
   CHARACTER(1024)                 :: TmpPath

   !-------------------------------------------------------------------------------------------------
   ! Open the CTP input file
   !-------------------------------------------------------------------------------------------------
   
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) RETURN


   !-------------------------------------------------------------------------------------------------
   ! Read the CTP input file
   !-------------------------------------------------------------------------------------------------
   CALL ReadStr( UnWind, TRIM( FileName ), HeaderLine, 'Header line', 'The header line in the CTP file', ErrStat )
   IF (ErrStat /= 0) RETURN   
   CALL WrScr ( ' Heading of the CT-wind-parameter file: "'//TRIM(HeaderLine)//'"' )


   CALL ReadCom( UnWind, TRIM( FileName ), 'parameter header line', ErrStat )
   IF (ErrStat /= 0) RETURN
   

   CALL ReadVar( UnWind, TRIM( FileName ), CTSpath,  'CTSpath',  & 
                  'Location (path) of the binary coherent turbulence dataset', ErrStat )
   IF (ErrStat /= 0) RETURN
                  

   CALL ReadVar( UnWind, TRIM( FileName ), CTPscaling%CTTSfile, 'CTTSfile', &
                  'File containing the time steps for the coherent turbulence events (.cts)', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   
   IF ( PathIsRelative( CTPscaling%CTTSfile ) ) THEN
      CALL GetPath( FileName, TmpPath ) 
      CTPscaling%CTTSfile = TRIM(TmpPath)//TRIM(CTPscaling%CTTSfile)
   END IF      

   CALL ReadVar( UnWind, TRIM( FileName ), CTPscaling%CTbackgr, 'CTbackgr', 'File containing the background wind', ErrStat )
   IF (ErrStat /= 0) RETURN

   IF ( PathIsRelative( CTPscaling%CTbackgr ) ) THEN
      CALL GetPath( FileName, TmpPath ) 
      CTPscaling%CTbackgr = TRIM(TmpPath)//TRIM(CTPscaling%CTbackgr)
   END IF      


   CALL ReadVar( UnWind, TRIM( FileName ), CT_DF_Y, 'CT_DF_Y', 'Decimation factor for wind data in the Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CT_DF_Z, 'CT_DF_Z', 'Decimation factor for wind data in the Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN

   
   !-------------------------------------------------------------------------------------------------
   ! Close the CTP input file
   !-------------------------------------------------------------------------------------------------
   
   CLOSE( UnWind )


END SUBROUTINE ReadCTP
!====================================================================================================
SUBROUTINE ReadCTTS ( UnWind, FileName, CT_SC_ext, ErrStat )
!  This subroutine is used to read the input parameters calculated in TurbSim for the scaling of 
!  coherent turbulence events.  It reads the .cts file and saves the time step and file number arrays.
!----------------------------------------------------------------------------------------------------


      ! Passed variables.

   INTEGER,            INTENT(IN)  :: UnWind                                   ! The I/O unit of the input file
   CHARACTER(*),       INTENT(IN)  :: FileName                                 ! The name of the input data file
   INTEGER,            INTENT(OUT) :: ErrStat                                  ! returns 0 if no error; -1 if the file is blank or can't be opened;                                                                               ! non-zero otherwise
   CHARACTER(3),       INTENT(OUT) :: CT_SC_ext                                ! The extension used for coherent turbulence scale files.(usually "les", "dns", or "dat")

      ! Local variables
   INTEGER                         :: IT                                       ! Loop counter

   !-------------------------------------------------------------------------------------------------
   ! Initialize variables
   !-------------------------------------------------------------------------------------------------

   NumCTt = 0

   !-------------------------------------------------------------------------------------------------
   ! Open the CTS input file
   !-------------------------------------------------------------------------------------------------
   
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) THEN
      ErrStat = -1
      RETURN
   END IF
   
   !-------------------------------------------------------------------------------------------------
   ! Read the header of the CTS input file
   !-------------------------------------------------------------------------------------------------
   
      ! Check to see if the first value is numeric (old) or the file type (new) and start again
      
   READ ( UnWind, *, IOSTAT=ErrStat ) CTScaleVel       
   REWIND( UnWind )  


   IF ( ErrStat /= 0 )  THEN   ! try again
            
      CALL ReadVar( UnWind, TRIM( FileName ), CText, 'CText', 'FileType ', ErrStat ) 
      IF ( ErrStat /= 0 ) THEN
         ErrStat = SIGN( 1, ErrStat)
         RETURN
      END IF
      CT_SC_ext = CText      
      
      CALL ReadVar( UnWind, TRIM( FileName ), CTScaleVel, 'CTScaleVel', ' ', ErrStat ) 
      IF ( ErrStat /= 0 ) RETURN
   ELSE  ! assume LES files
   
      CALL ReadVar( UnWind, TRIM( FileName ), CTScaleVel, 'CTScaleVel', ' ', ErrStat ) 

      CText     = 'les'
      CT_SC_ext = 'dat'
   END IF
   
   CALL ReadVar( UnWind, TRIM( FileName ), InvMCTWS, 'MeanCTWS', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   InvMCTWS = 1.0 / InvMCTWS
      

   CALL ReadVar( UnWind, TRIM( FileName ), CTYmax, 'CTYmax', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   

   CALL ReadVar( UnWind, TRIM( FileName ), CTZmax, 'CTZmax', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CTDistSc, 'CTDistSc', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CTLy, 'CTLy', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   
   
   CALL ReadVar( UnWind, TRIM( FileName ), CTLz, 'CTLz', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   
   
   CALL ReadVar( UnWind, TRIM( FileName ), NumCTt, 'NumCTt', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   !-------------------------------------------------------------------------------------------------
   ! Allocate space for the arrays
   !-------------------------------------------------------------------------------------------------

   IF (.NOT. ALLOCATED(Tdata) ) THEN
      ALLOCATE ( Tdata(NumCTt) , STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the Tdata array.' )
         RETURN
      END IF
   END IF

   IF (.NOT. ALLOCATED(TimeStpCT) ) THEN
      ALLOCATE ( TimeStpCT(NumCTt) , STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the TimeStpCT array.' )
         RETURN
      END IF
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Read the arrays from the CTS input file
   !-------------------------------------------------------------------------------------------------
   
   DO IT=1,NumCTt

      READ (UnWind,*,IOSTAT=ErrStat)  Tdata(IT), TimeStpCT(IT)

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error reading record '//TRIM( Num2LStr( IT ) )//' of the CT-wind time-steps file, "' &
                         //TRIM( FileName )//'."')

         NumCTt = IT - 1
         RETURN
      ENDIF

   ENDDO ! IT


   !-------------------------------------------------------------------------------------------------
   ! Close the CTS input file
   !-------------------------------------------------------------------------------------------------
   CLOSE( UnWind )


   RETURN
   
END SUBROUTINE ReadCTTS
!====================================================================================================
SUBROUTINE ReadCTScales ( UnWind, FileName, ErrStat )
!  This subroutine is used to read the input parameters for the coherent turbulence events, based
!  on the large-eddy simulation.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,            INTENT(IN)  :: UnWind                                   ! The I/O unit of the input file
   CHARACTER(*),       INTENT(IN)  :: FileName                                 ! The name of the input data file
   INTEGER,            INTENT(OUT) :: ErrStat                                  ! returns 0 if no error; non-zero otherwise


      ! Local variables
      
   INTEGER                         :: I                                        ! Array counter

   !-------------------------------------------------------------------------------------------------
   ! Open the file with the scales (les or dns)
   !-------------------------------------------------------------------------------------------------

   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) RETURN
   

   !-------------------------------------------------------------------------------------------------
   ! Read the file with the scales (les or dns)
   !-------------------------------------------------------------------------------------------------

   CALL ReadCom( UnWind, TRIM( FileName ), 'First line', ErrStat )
   IF (ErrStat /= 0) RETURN

   CALL ReadVar( UnWind, TRIM( FileName ), CTVertShft, 'CTVertShft', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN

   DO I = 1,3
      CALL ReadVar( UnWind, TRIM( FileName ), CTScale(I), 'CTScale('//TRIM(Num2LStr(I))//')', ' ', ErrStat ) 
      IF ( ErrStat /= 0 )  RETURN
   
      CALL ReadVar( UnWind, TRIM( FileName ), CTOffset(I), 'CTOffset('//TRIM(Num2LStr(I))//')', ' ', ErrStat ) 
      IF ( ErrStat /= 0 )  RETURN
   END DO !I

   CALL ReadVar( UnWind, TRIM( FileName ), NumCTy, 'NumCTy', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN

   CALL ReadVar( UnWind, TRIM( FileName ), NumCTz, 'NumCTz', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   !-------------------------------------------------------------------------------------------------
   ! Close the file with the scales (les or dns)
   !-------------------------------------------------------------------------------------------------
   
   CLOSE( UnWind )
   

   RETURN
   
END SUBROUTINE ReadCTScales
!====================================================================================================
SUBROUTINE CT_Terminate( ErrStat )
! This subroutine closes files, deallocates memory, and un-sets the initialization flag
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise


   CLOSE( CTWindUnit )
   
   ErrStat = 0

   IF ( ALLOCATED( CTvelU    ) )  DEALLOCATE( CTvelU,    STAT=ErrStat )
   IF ( ALLOCATED( CTvelV    ) )  DEALLOCATE( CTvelV,    STAT=ErrStat )
   IF ( ALLOCATED( CTvelW    ) )  DEALLOCATE( CTvelW,    STAT=ErrStat )
   IF ( ALLOCATED( Tdata     ) )  DEALLOCATE( Tdata,     STAT=ErrStat )
   IF ( ALLOCATED( TimeStpCT ) )  DEALLOCATE( TimeStpCT, STAT=ErrStat )

   TimeIndx = 0

END SUBROUTINE CT_Terminate
!====================================================================================================
END MODULE CTWind
MODULE FDWind
! This module reads and processes 4-dimensional wind fields.
! The subroutines were originally created by Marshall Buhl to read LES data provided by researchers
! at NCAR. It was later updated by Bonnie Jonkman to read DNS data provided by researchers at CoRA.
!
! Data are assumed to be in units of meters and seconds.
!
!  7 Oct 2009    B. Jonkman, NREL/NWTC using subroutines from AeroDyn 12.57
!----------------------------------------------------------------------------------------------------  

   USE                     NWTC_Library
   USE                     SharedInflowDefs
   USE                     WindFile_Types

   IMPLICIT                NONE
   PRIVATE
  
      ! FD_Wind
      
   REAL(ReKi)                   :: DelXgrid                                   ! The nondimensional distance between grid points in the x direction.
   REAL(ReKi)                   :: DelYgrid                                   ! The nondimensional distance between grid points in the y direction.
   REAL(ReKi)                   :: DelZgrid                                   ! The nondimensional distance between grid points in the z direction.
   REAL(ReKi)                   :: FDper                                      ! Total time in dataset.
   REAL(ReKi)                   :: FDTime   (2)                               ! Times for the 4D wind files.
   REAL(ReKi), ALLOCATABLE      :: FDu      (:,:,:,:)                         ! The u-component array of 4D wind data.
   REAL(ReKi), ALLOCATABLE      :: FDv      (:,:,:,:)                         ! The v-component array of 4D wind data.
   REAL(ReKi), ALLOCATABLE      :: FDw      (:,:,:,:)                         ! The w-component array of 4D wind data.
   REAL(ReKi), ALLOCATABLE      :: FDuData  (:,:,:,:)                         ! The u-component array of all 4D wind data when used with advection.
   REAL(ReKi), ALLOCATABLE      :: FDvData  (:,:,:,:)                         ! The v-component array of all 4D wind data when used with advection.
   REAL(ReKi), ALLOCATABLE      :: FDwData  (:,:,:,:)                         ! The w-component array of all 4D wind data when used with advection.
   REAL(ReKi)                   :: Lx                                         ! Fractional location of tower centerline from upwind end to downwind end of the dataset.
   REAL(ReKi)                   :: Ly                                         ! Fractional location of tower centerline from right (looking downwind) to left side of the dataset.
   REAL(ReKi)                   :: Lz                                         ! Fractional location of hub height from bottom to top of dataset.
   REAL(ReKi)                   :: Offsets  (3)                               ! Offsets to convert integer data to actual wind speeds.
   REAL(ReKi), SAVE             :: PrevTime                                   ! The previous time this was called -- so we can go back in time if necessary
   REAL(ReKi)                   :: RotDiam                                    ! Rotor diameter.
   REAL(ReKi)                   :: ScalFact (3)                               ! Scaling factors to convert integer data to actual wind speeds.
   REAL(ReKi)                   :: ScaleVel                                   ! Scaling velocity, U0.  2*U0 is the difference in wind speed between the top and bottom of the wave.
   REAL(ReKi), ALLOCATABLE      :: Times4D  (:)                               ! The list of times for the 4D-wind input files.
   REAL(ReKi)                   :: Tm_max                                     ! The total nondimensional time of the dataset.
   REAL(ReKi)                   :: TSclFact                                   ! Scale factor for time (h/U0).
   REAL(ReKi)                   :: T_4D_En                                    ! Time at which the wave event ends.
   REAL(ReKi)                   :: T_4D_St                                    ! Time at which the wave event starts.
   REAL(ReKi)                   :: Xmax                                       ! The dimensional downwind length of the dataset.
   REAL(ReKi)                   :: Xt                                         ! Distance of the tower from the upwind end of the dataset.
   REAL(ReKi)                   :: Ymax                                       ! The dimensional lateral width of the dataset.
   REAL(ReKi)                   :: Yt                                         ! Distance of the tower from the right side of the dataset (looking downwind).
   REAL(ReKi)                   :: Zmax                                       ! The dimensional vertical height of the dataset.
   REAL(ReKi)                   :: Zt                                         ! Distance of the hub from the bottom of the dataset.
   REAL(ReKi)                   :: Zref                                       ! The reference height (hub height)

   INTEGER                      :: FD_DF_X                                    ! The decimation factor for the 4D wind data in the x direction.
   INTEGER                      :: FD_DF_Y                                    ! The decimation factor for the 4D wind data in the y direction.
   INTEGER                      :: FD_DF_Z                                    ! The decimation factor for the 4D wind data in the z direction.
   INTEGER                      :: FDFileNo                                   ! The 4D wind file number.
   INTEGER                      :: FDRecL                                     ! The length, in bytes, of the LE binary records.
   INTEGER                      :: Ind4DAdv                                   ! Index of the file to be used in advection
   INTEGER                      :: Ind4Dnew                                   ! Index of the newest 4D wind file.
   INTEGER                      :: Ind4Dold                                   ! Index of the older 4D wind file.
   INTEGER                      :: Num4Dt                                     ! The number of 4D wind grids, one grid per time step.
   INTEGER, PARAMETER           :: Num4DtD = 2                                ! The number of 4D wind grids stored in memory, normally 2
   INTEGER                      :: Num4Dx                                     ! The number of 4D wind grid points in the x direction.
   INTEGER                      :: Num4DxD                                    ! The decimated number of 4D wind grid points in the x direction.
   INTEGER                      :: Num4DxD1                                   ! The decimated number of 4D wind grid points in the x direction minus 1.
   INTEGER                      :: Num4Dy                                     ! The number of 4D wind grid points in the y direction.
   INTEGER                      :: Num4DyD                                    ! The decimated number of 4D wind grid points in the y direction.
   INTEGER                      :: Num4DyD1                                   ! The decimated number of 4D wind grid points in the y direction minus 1.
   INTEGER                      :: Num4Dz                                     ! The number of 4D wind grid points in the z direction.
   INTEGER                      :: Num4DzD                                    ! The decimated number of 4D wind grid points in the z direction.
   INTEGER                      :: Num4DzD1                                   ! The decimated number of 4D wind grid points in the z direction minus 1.
   INTEGER                      :: NumAdvect                                  ! Number of frozen timesteps to advect past the turbine
   INTEGER                      :: Shft4Dnew                                  ! Number of times the x-data needs to be shifted for advection
   INTEGER, ALLOCATABLE         :: Times4DIx (:)                              ! Index number of the 4D time files (used for advection)

   INTEGER                      :: FDUnit                                     ! Unit number for reading wind files

   LOGICAL                      :: Advect                                     ! Flag to indicate whether or not to advect a given data set or to just use the time step files 
   LOGICAL                      :: VertShft                                   ! Flag to indicate whether or not to shift the z values for the w component.

   LOGICAL, SAVE                :: Initialized = .FALSE.

   CHARACTER(5), ALLOCATABLE    :: AdvFiles (:)
   CHARACTER(1024)              :: FDSpath                                    ! The path to the 4D wind files.


   PUBLIC                       :: FD_Init
   PUBLIC                       :: FD_GetWindSpeed
   PUBLIC                       :: FD_Terminate
   PUBLIC                       :: FD_GetValue


CONTAINS
!====================================================================================================
SUBROUTINE FD_Init(UnWind, WindFile, RefHt, ErrStat)
!  This subroutine is called at the beginning of a simulation to initialize the module.  
!----------------------------------------------------------------------------------------------------

      ! Passed variables
      
   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: WindFile                     ! Name of the 4D wind parameter file (.fdp)
   REAL(ReKi),      INTENT(IN)    :: RefHt                        ! The reference height for the billow (should be hub height)
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors; non-zero otherwise

      ! Local variables

   CHARACTER(1024)                :: FDTSfile                     ! name of the 4D time step file
   REAL(ReKi)                     :: FDTimStp                     ! Average time step for 4D wind data.
   INTEGER                        :: IT
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' FDWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
!      CALL NWTC_Init()    ! Initialized in IfW_Init
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Set the reference height for the wind file (this takes the place of HH that was used earlier)
   !-------------------------------------------------------------------------------------------------

   ZRef = RefHt         
   
   !-------------------------------------------------------------------------------------------------
   ! Read the main 4D input file
   !-------------------------------------------------------------------------------------------------
   
   CALL ReadFDP( UnWind, WindFile, FDTSfile, ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   !-------------------------------------------------------------------------------------------------
   ! Get the times array, which must be scaled and shifted later using TSclFact and T_4D_St
   !-------------------------------------------------------------------------------------------------

   CALL Read4Dtimes ( UnWind, FDTSfile, ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   
   !-------------------------------------------------------------------------------------------------
   ! Calculate some values that don't change during the run.
   !-------------------------------------------------------------------------------------------------

   FDRecL      = 2*Num4Dx*Num4Dy                                           ! The length, in bytes, of the 4D binary records.
   Num4DxD     = ( Num4Dx + FD_DF_X - 1 )/FD_DF_X                          ! The decimated number of 4D wind grid points in the x direction.
   Num4DyD     = ( Num4Dy + FD_DF_Y - 1 )/FD_DF_Y                          ! The decimated number of 4D wind grid points in the y direction.
   Num4DzD     = ( Num4Dz + FD_DF_Z - 1 )/FD_DF_Z                          ! The decimated number of 4D wind grid points in the z direction.
   Num4DxD1    = Num4DxD - 1                                               ! The decimated number of 4D wind grid points in the x direction minus 1.
   Num4DyD1    = Num4DyD - 1                                               ! The decimated number of 4D wind grid points in the y direction minus 1.
   Num4DzD1    = Num4DzD - 1                                               ! The decimated number of 4D wind grid points in the z direction minus 1.

   Tm_max      = Times4D(Num4Dt)                                           ! Time of end of dataset.
   IF ( ADVECT ) THEN
      FDTimStp   = Xmax / ( ( Num4Dx - 1 )*( ScaleVel )*Num4Dt )           ! The timestep is calculated by the approximation dx/dt ~= U0 (divide by num4dt to get delta for a full timestep).
      FDper      = FDTimStp * Num4Dt                                       ! Total time in dataset. (We have periodic time, so multiply by number of time steps, without subtracting 1)
      TSclFact   = FDper / Tm_max                                          ! Equivalent scale factor for time.
   ELSE
      FDper       = TSclFact*Tm_max                                        ! Total time in dataset.
      FDTimStp    = FDper/( Num4Dt - 1 )                                   ! Average time step.
   ENDIF

   T_4D_En     = T_4D_St + FDper                                           ! Time for the end of the dataset.
   Xt          = Xmax*Lx                                                   ! Distance of the tower from the upwind end of the dataset.
   Yt          = Ymax*Ly                                                   ! Distance of the tower from the right side of the dataset (looking downwind).
   Zt          = Zmax*Lz                                                   ! Distance of the hub from the bottom of the dataset.
   DelXgrid    = 1.0/Num4DxD1                                              ! The nondimensional distance between grid points in the x direction.
   DelYgrid    = 1.0/Num4DyD1                                              ! The nondimensional distance between grid points in the y direction.
   DelZgrid    = 1.0/Num4DzD1                                              ! The nondimensional distance between grid points in the z direction.


   !-------------------------------------------------------------------------------------------------
   ! Scale and shift the times array using TSclFact and T_4D_St
   !-------------------------------------------------------------------------------------------------

   DO IT=1,Num4Dt
      
      Times4D(IT) = TSclFact*Times4D(IT) + T_4D_St

   ENDDO ! IT


   !-------------------------------------------------------------------------------------------------
   ! Allocate velocity arrays and fill Data arrays for advection (DNS files)
   !-------------------------------------------------------------------------------------------------

   IF (.NOT. ALLOCATED(FDu) ) THEN
!      CALL AllocAry ( FDu, Num4DxD, Num4DyD, Num4DzD, 2, 'U-component velocity array (FDu)', ErrStat)
      ALLOCATE ( FDu(Num4DxD,Num4DyD,Num4DzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the U-component velocity array (FDu) array.' )
         RETURN
      END IF
   END IF
   
   IF (.NOT. ALLOCATED(FDv) ) THEN
!      CALL AllocAry ( FDv, Num4DxD, Num4DyD, Num4DzD, 2, 'V-component velocity array (FDv)', ErrStat)
      ALLOCATE ( FDv(Num4DxD,Num4DyD,Num4DzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the V-component velocity array (FDv) array.' )
         RETURN
      END IF
   END IF

   IF (.NOT. ALLOCATED(FDw) ) THEN
!      CALL AllocAry ( FDw, Num4DxD, Num4DyD, Num4DzD, 2, 'W-component velocity array (FDw)', ErrStat)
      ALLOCATE ( FDw(Num4DxD,Num4DyD,Num4DzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the W-component velocity array (FDw) array.' )
         RETURN
      END IF
   END IF

   IF ( ADVECT ) THEN

      IF (.NOT. ALLOCATED(FDuData) ) THEN
!         CALL AllocAry ( FDuData, Num4DxD, Num4DyD, Num4DzD, Num4Dt, 'U-component velocity array (FDuData)', ErrStat)
         ALLOCATE ( FDuData(Num4DxD,Num4DyD,Num4DzD,Num4Dt), STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error allocating memory for the U-component velocity array (FDuData) array.' )
            RETURN
         END IF
      END IF

      IF (.NOT. ALLOCATED(FDvData) ) THEN
!         CALL AllocAry ( FDvData, Num4DxD, Num4DyD, Num4DzD, Num4Dt, 'V-component velocity array (FDvData)', ErrStat)
         ALLOCATE ( FDvData(Num4DxD,Num4DyD,Num4DzD,Num4Dt), STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error allocating memory for the V-component velocity array (FDvData) array.' )
            RETURN
         END IF
      END IF

      IF (.NOT. ALLOCATED(FDwData) ) THEN
!         CALL AllocAry ( FDwData, Num4DxD, Num4DyD, Num4DzD, Num4Dt, 'W-component velocity array (FDwData)', ErrStat)
         ALLOCATE ( FDwData(Num4DxD,Num4DyD,Num4DzD,Num4Dt), STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error allocating memory for the W-component velocity array (FDwData) array.' )
            RETURN
         END IF
      END IF

      CALL ReadAll4DData(UnWind, ErrStat) !This needs AdvFiles(:), which was is read in ReadFDP()
      IF ( ErrStat /= 0 ) RETURN

   ENDIF

     
   !-------------------------------------------------------------------------------------------------
   ! Determine the first file needed for this simulation.
   !-------------------------------------------------------------------------------------------------
   Ind4Dold  = 1                                                           ! Put the old stuff in the first part of the array.
   Ind4Dnew  = 2                                                           ! Put the new stuff in the second part of the array.

   Shft4Dnew = 0


   IF ( T_4D_St >= 0.0 )  THEN
      FDFileNo = 1
   ELSE
      FDFileNo = Num4Dt
      DO IT=1,Num4Dt
         IF ( Times4D(IT) > 0.0 )  THEN
            FDFileNo = IT - 1
            EXIT
         END IF
      END DO ! IT
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Open, read, and close the first set of files.
   !-------------------------------------------------------------------------------------------------
   FDTime(Ind4Dold) = Times4D(FDFileNo)                                 ! Set the time for this file.

   IF ( ADVECT ) THEN
      CALL Load4DData(Ind4Dold)     ! load data stored in FDuData, FDvData, and FDwData arrays
   ELSE
      CALL LoadLESData( UnWind, FDFileNo, Ind4Dold, ErrStat )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Open, read, and close the second set of files.
   !-------------------------------------------------------------------------------------------------
   FDFileNo  = FDFileNo + 1


   IF ( ADVECT ) THEN
      FDFileNo = MOD(FDFileNo-1,Num4Dt) + 1

      IF (FDFileNo == 1) THEN
         Shft4Dnew = Shft4Dnew + 1

         IF (Ind4DAdv <= NumAdvect) THEN                             ! Ind4DAdv was set in ReadFDP
            IF ( MOD( Shft4Dnew, Num4Dx ) == 0 ) THEN
               CALL ReadAll4DData(UnWind, ErrStat)
               IF ( ErrStat /= 0 ) RETURN
            END IF
         END IF

      ENDIF

      FDTime(Ind4Dnew) = Times4D(FDFileNo) + Shft4Dnew*FDPer         ! Set the time for this file.

      CALL Load4DData( Ind4Dnew )    ! shift the data

   ELSE   
      FDTime(Ind4Dnew) = Times4D(FDFileNo)                                           ! Set the time for this file.

      CALL LoadLESData( UnWind, FDFileNo, Ind4Dnew, ErrStat )
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Set the initialization flag
   !-------------------------------------------------------------------------------------------------
   FDUnit      = UnWind
   PrevTime    = 0.0
   
   Initialized = .TRUE.
   
   RETURN

END SUBROUTINE FD_Init
!====================================================================================================
SUBROUTINE ReadFDP ( UnWind, FileName, FDTSfile, ErrStat )
!  This subroutine is used to read the input parameters for the large-eddy simulation.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: FileName                     ! Then name of the LE data file.
   CHARACTER(*),    INTENT(OUT)   :: FDTSfile                     ! The name of the file containing the time-step history of the wind files.
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise


      ! Local variables

   CHARACTER(1024)                :: HeaderLine
   CHARACTER(1),PARAMETER         :: Comp(3) = (/'U', 'V', 'W' /) ! the wind components

   REAL(ReKi)                     :: CoefTE                       ! Coefficient of thermal expansion.
   REAL(ReKi)                     :: DistScal                     ! Disturbance scale (ratio of wave height to rotor diameter) from input file.
   REAL(ReKi)                     :: Grav                         ! Gravitational acceleration.
   REAL(ReKi)                     :: LenScale                     ! Length scale (h).
   REAL(ReKi)                     :: Ri                           ! Richardson number.
   REAL(ReKi)                     :: Ubot                         ! Steady u-component wind speed at the bottom of the wave.
   REAL(ReKi)                     :: Zm_maxo                      ! The nondimensional vertical height of the untrimmed dataset.

   REAL(ReKi)                     :: Xm_max                       ! The nondimensional downwind length of the dataset.
   REAL(ReKi)                     :: Ym_max                       ! The nondimensional lateral width of the dataset.
   REAL(ReKi)                     :: Zm_max                       ! The nondimensional vertical height of the dataset.

   INTEGER                        :: I

   !-------------------------------------------------------------------------------------------------
   ! Open the 4D parameter file for reading
   !-------------------------------------------------------------------------------------------------
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) RETURN   


   !-------------------------------------------------------------------------------------------------
   ! Read the 4D parameter input file
   !-------------------------------------------------------------------------------------------------

      !..............................................................................................
      ! Read the 4D wind parameters specific to this turbine simulation.  
      !..............................................................................................

   CALL ReadStr( UnWind, TRIM( FileName ), HeaderLine, 'Header line', 'The header line in the FTP file', ErrStat )
   IF (ErrStat /= 0) RETURN   
   CALL WrScr ( ' Heading of the 4D-wind-parameter file: "'//TRIM(HeaderLine)//'"' )


   CALL ReadCom( UnWind, TRIM( FileName ), 'Header line', ErrStat )
   IF (ErrStat /= 0) RETURN
      

   CALL ReadVar( UnWind, TRIM( FileName ), FDSpath,  'FDSpath', 'Location (path) of the binary dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FDTSfile,  'FDTSfile', & 
                                  'Name of the file containing the time-step history of the wind files', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ubot,  'Ubot', 'Steady u-component wind speed at the bottom of the wave', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), DistScal,  'DistScal', 'Disturbance scale', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Lx,  'Lx', &
                            'Fractional location of tower centerline from upwind end to downwind end of the dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ly,  'Ly', &
                 'Fractional location of tower centerline from right (looking downwind) to left side of the dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Lz,  'Lz', &
                                          'Fractional location of hub height from bottom to top of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), T_4D_St,  'T_4D_St', 'Time at which the wave event starts', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), ScaleVel,  'ScaleVel', &
                 'Scaling velocity, U0: half the difference in wind speed between the top and bottom of the billow.', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), RotDiam,  'RotDiam', 'Rotor diameter', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FD_DF_X,  'FD_DF_X', 'Decimation factor in X direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FD_DF_Y,  'FD_DF_Y', 'Decimation factor in Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FD_DF_Z,  'FD_DF_Z', 'Decimation factor in Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadCom( UnWind, TRIM( FileName ), 'blank line', ErrStat )
   IF (ErrStat /= 0) RETURN

      !..............................................................................................
      ! Read the 4D wind parameters specific to the K-H billow simulation being used.  
      !..............................................................................................

   CALL ReadCom( UnWind, TRIM( FileName ), 'LES parameters specific to the K-H billow simulation being used', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), VertShft,  'VertShft', & 
                           'Flag to indicate whether or not to shift the z values for the w component', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Xm_max,  'Xm_max', & 
                           'Maximum nondimensional downwind distance from center of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ym_max,  'Ym_max', & 
                           'Maximum nondimensional lateral distance from center of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Zm_max,  'Zm_max', & 
                           'Maximum nondimensional vertical distance from center of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Zm_maxo,  'Zm_maxo', & 
                 'Maximum nondimensional vertical distance from center of untrimmed dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   DO I = 1,3

      CALL ReadVar( UnWind, TRIM( FileName ), ScalFact(I),  Comp(I)//'Scl', & 
                    Comp(I)//'-component scale factor for converting from integers to reals', ErrStat )
      IF (ErrStat /= 0) RETURN
      ScalFact(I) = ScalFact(I) * ScaleVel


      CALL ReadVar( UnWind, TRIM( FileName ), Offsets(I), Comp(I)//'Off', & 
                    Comp(I)//'-component offset for converting from integers to reals', ErrStat )
      IF (ErrStat /= 0) RETURN
      Offsets(I) = Offsets(I) * ScaleVel
      
   END DO   
   Offsets (1) = Offsets (1) + ScaleVel + Ubot                           ! u-component offset to convert integer data to actual wind speeds.


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dt, 'Num4Dt', 'The number of LE grids, one grid per time step', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dx, 'Num4Dx', 'The number of LE grid points in the x direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dy, 'Num4Dy', 'The number of LE grid points in the y direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dz, 'Num4Dz', 'The number of LE grid points in the z direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ri, 'Ri', 'Richardson number', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CoefTE, 'CoefTE', 'Coefficient of thermal expansion', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Grav, 'Grav', 'Gravitational acceleration', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Advect, 'Advect', 'Advection flag', ErrStat )
   
   IF (ErrStat /= 0) THEN
   
      Advect   = .FALSE.
      Ind4DAdv = 0
      ErrStat  = 0
      CALL WrScr( ' Advection will not be used.')
      
   ELSE
   
      IF (Advect) THEN
         IF ( FD_DF_X /= 1 ) THEN
            CALL WrScr( ' FD_DF_X must be 1 when using advection. ' )
            FD_DF_X = 1            
         ENDIF

         CALL ReadVar( UnWind, TRIM( FileName ), NumAdvect, 'NumAdvect', 'Number of 4D files for advection', ErrStat )
         IF (ErrStat /= 0) RETURN
         

         IF ( NumAdvect < 1 ) THEN
            CALL WrScr( ' NumAdvect in 4D-wind-parameter file, "'//TRIM( FileName )//'," must be at least 1.' )
            ErrStat = 1
            RETURN
         ENDIF

         IF ( .NOT. ALLOCATED( AdvFiles ) ) THEN
!            CALL AllocAry( AdvFiles, NumAdvect, 'AdvFiles array', ErrStat )
            ALLOCATE ( AdvFiles(NumAdvect), STAT=ErrStat )

            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error allocating memory for the AdvFiles array.' )
               RETURN
            END IF
         ENDIF

         CALL ReadAryLines( UnWind, TRIM( FileName ), AdvFiles, NumAdvect, 'AdvFiles', 'Advection file names', ErrStat )
         IF (ErrStat /= 0) RETURN
         Ind4DAdv = 1
         
      ELSE
         Ind4DAdv = 0
      ENDIF !Advect == .TRUE.
   
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Close the 4D parameter input file
   !-------------------------------------------------------------------------------------------------
   CLOSE ( UnWind )
   
   !-------------------------------------------------------------------------------------------------
   ! Close the 4D parameter input file
   !-------------------------------------------------------------------------------------------------

   LenScale    = RotDiam*DistScal/Zm_max                             ! Length scale (h).
   Xmax        = Xm_max*LenScale                                     ! The dimensional length of the dataset.
   Ymax        = Ym_max*LenScale                                     ! The dimensional width of the dataset
   Zmax        = Zm_max*LenScale                                     ! The dimensional vertical height of the dataset.
   TSclFact    = LenScale/ScaleVel                                   ! Scale factor for time (h/U0).

   

   RETURN

END SUBROUTINE ReadFDP
!====================================================================================================
SUBROUTINE Read4Dtimes ( UnWind, FileName, ErrStat )
!  This subroutine is used to read the time array for the 4D data.  The times in the file are 
!  non-dimensional and non-uniformly spaced. They are scaled using TSclFact to obtain units of seconds
!  and T_4D_St is added to allow the billow to start at non-zero time.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: FileName                     ! Then name of the LE data file.
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise


      ! Local variables

   INTEGER                        :: I                            ! Loop counter

   !-------------------------------------------------------------------------------------------------
   ! Allocate arrays to store the data in
   !-------------------------------------------------------------------------------------------------
   
   IF (.NOT. ALLOCATED( Times4D) ) THEN
!      CALL AllocAry( Times4D, Num4Dt, '4D time array', ErrStat)
      ALLOCATE ( Times4D(Num4Dt), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the Times4D array.' )
         RETURN
      END IF
   END IF
      
   IF (.NOT. ALLOCATED( Times4DIx) ) THEN
!      CALL AllocAry( Times4DIx, Num4Dt, '4D time array', ErrStat)
      ALLOCATE ( Times4DIx(Num4Dt), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the Times4DIx array.' )
         RETURN
      END IF
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Open the 4D times file
   !-------------------------------------------------------------------------------------------------
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   !-------------------------------------------------------------------------------------------------
   ! Read the 4D times file
   !-------------------------------------------------------------------------------------------------
   CALL ReadCom( UnWind, TRIM( FileName ), 'first line', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   DO I=1,Num4Dt

      READ (UnWind,*,IOSTAT=ErrStat)  Times4DIx(I), Times4D(I)

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Error reading line '//TRIM( Num2LStr( I+1 ) )// &
                        ' of the 4D-wind time-steps file, "'//TRIM( FileName )//'."')
         RETURN                        

      ENDIF
      
   ENDDO ! I

   
   !-------------------------------------------------------------------------------------------------
   ! Close the 4D times file
   !-------------------------------------------------------------------------------------------------
   
   CLOSE ( UnWind )  
   
   RETURN     
   
END SUBROUTINE Read4Dtimes
!====================================================================================================
SUBROUTINE ReadAll4DData(UnWind, ErrStat)
! This subroutine reads the data into one array to be accessed later when ADVECT=.TRUE. Since there 
! are just a few time steps, we'll load them into memory to (hopefully) save I/O time.
!----------------------------------------------------------------------------------------------------

   INTEGER, INTENT(IN)        :: UnWind
   INTEGER, INTENT(OUT)       :: ErrStat                            ! 
   INTEGER                    :: IT

   CHARACTER(1)               :: FDNum
   CHARACTER(20)              :: DNSFileName                        ! String containing part of the current file name.


   DO IT = 1,Num4Dt

      WRITE(FDNum,'(I1.1)') Times4DIx(IT)
      DNSFileName = TRIM(AdvFiles(Ind4DAdv))//'_'//TRIM(FDNum)//'.dns'

      CALL Read4DData ( UnWind, TRIM( FDSpath )//'\u\u_16i_'//TRIM(DNSFileName), FDuData, IT, ScalFact(1), Offsets(1), ErrStat )
      IF ( ErrStat /= 0 ) RETURN

      CALL Read4DData ( UnWind, TRIM( FDSpath )//'\v\v_16i_'//TRIM(DNSFileName), FDvData, IT, ScalFact(2), Offsets(2), ErrStat )
      IF ( ErrStat /= 0 ) RETURN

      CALL Read4DData ( UnWind, TRIM( FDSpath )//'\w\w_16i_'//TRIM(DNSFileName), FDwData, IT, ScalFact(3), Offsets(3), ErrStat )
      IF ( ErrStat /= 0 ) RETURN

   ENDDO ! IT

   Ind4DAdv = Ind4DAdv + 1

   RETURN

END SUBROUTINE ReadAll4DData
!====================================================================================================
SUBROUTINE LoadLESData( UnWind, FileNo, Indx, ErrStat )
! This subroutine reads binary data from the U, V, and W files and stores them in the arrays FDu,
! FDv, and FDw (by calling Read4DData).
!----------------------------------------------------------------------------------------------------
      ! Passed variables

   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,         INTENT(IN)    :: FileNo                       ! current file number to read
   INTEGER,         INTENT(IN)    :: Indx                         ! index into the data arrays
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise
   
      ! local variables
   CHARACTER(5)                   :: FDNum
   CHARACTER(20)                  :: LESFileName                  ! String containing part of the current file name.      
   
      
      ! get the file name for the file number
      
   WRITE(FDNum,'(I5.5)', IOStat=ErrStat) FileNo
   IF ( ErrStat /= 0 ) RETURN
   
   LESFileName = TRIM(FDNum)//'.les'


      ! set the paths and read the data for each component
      
   CALL Read4DData ( UnWind, TRIM( FDSpath )//'\u\u_16i_'//TRIM(LESFileName), FDu, Indx, ScalFact(1), Offsets(1), ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   CALL Read4DData ( UnWind, TRIM( FDSpath )//'\v\v_16i_'//TRIM(LESFileName), FDv, Indx, ScalFact(2), Offsets(2), ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   CALL Read4DData ( UnWind, TRIM( FDSpath )//'\w\w_16i_'//TRIM(LESFileName), FDw, Indx, ScalFact(3), Offsets(3), ErrStat )


END SUBROUTINE LoadLESData
!====================================================================================================
SUBROUTINE Read4DData ( UnWind, FileName, Comp, Indx4, Scale, Offset,  ErrStat)
! This subroutine is used to read one time-step's worth of large-eddy wind data for one component 
! from a file.
!----------------------------------------------------------------------------------------------------

      ! Passed variables
      
   INTEGER,     INTENT(IN)    :: UnWind               ! The I/O unit of the LE file.
   CHARACTER(*),INTENT(IN)    :: FileName             ! Then name of the LE data file.

   REAL(ReKi),  INTENT(INOUT) :: Comp (:,:,:,:)       ! The velocity array [do NOT make this INTENT(OUT): other parts of the array may become undefined]
   INTEGER,     INTENT(IN)    :: Indx4                ! The index of the 4th dimension of Comp, which is to be read.
   REAL(ReKi),  INTENT(IN)    :: Scale                ! The scale factor for converting from intergers to non-normalized reals.
   REAL(ReKi),  INTENT(IN)    :: Offset               ! The offset for converting from intergers to non-normalized reals.

   INTEGER,     INTENT(OUT)   :: ErrStat              ! The returned status of a READ.
      
      ! Local variables

   INTEGER                    :: IX                   ! A DO index for indexing the arrays in the x direction.
   INTEGER                    :: IXK                  ! An index for the decimated arrays in the x direction.
   INTEGER                    :: IY                   ! A DO index for indexing the arrays in the y direction.
   INTEGER                    :: IYK                  ! An index for the decimated arrays in the y direction.
   INTEGER                    :: IZ                   ! A DO index for indexing the arrays in the z direction.
   INTEGER                    :: IZK                  ! An index for the decimated arrays in the z direction.

   INTEGER(B2Ki)              :: Com (Num4Dx,Num4Dy)  ! Temporary array to hold component's integer values for a given Z.


   !-------------------------------------------------------------------------------------------------
   ! Open the binary input file
   !-------------------------------------------------------------------------------------------------
   CALL OpenUInBEFile( UnWind, TRIM( FileName ), FDRecL, ErrStat )
   IF ( ErrStat /= 0 ) RETURN


   !-------------------------------------------------------------------------------------------------
   ! Read the input file
   !-------------------------------------------------------------------------------------------------

   IZK = 0
   DO IZ=1,Num4Dz,FD_DF_Z

      READ (UnWind,REC=IZ,IOSTAT=ErrStat)  Com

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Error reading record '//TRIM( Num2LStr( IZ ) )// & 
                                            ' of the binary 4D wind file, "'//TRIM( FileName )//'".')
         RETURN

      ENDIF

      IZK = IZK + 1                                ! IZK = ( IZ - 1 + FD_DF_Z )/FD_DF_Z
      IYK = 0
      
      DO IY=1,Num4Dy,FD_DF_Y
         
         IYK = IYK + 1                             ! IYK = ( IY - 1 + FD_DF_Y )/FD_DF_Y
         
         DO IX=1,Num4Dx,FD_DF_X
         
               ! shift the x-index, if necessary, to perform Advection
               
            !IXK = ( IX + FD_DF_X - 1 )/FD_DF_X
            IXK = ( MOD(IX+Shft4Dnew-1,Num4Dx) + FD_DF_X )/FD_DF_X
         
            Comp(IXK,IYK,IZK,Indx4) = Scale*Com(IX,IY) + Offset
         
         ENDDO ! IX
         
      ENDDO ! IY

   ENDDO ! IZ


   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
   CLOSE ( UnWind )

   RETURN

END SUBROUTINE Read4DData
!====================================================================================================
SUBROUTINE Load4DData( InpIndx )
! This subroutine takes the data from the storage array (used when ADVECT=.TRUE., shifts it if necessary, 
! and loads it into the array for the time slice indexed by InpIndx.
!----------------------------------------------------------------------------------------------------

   INTEGER, INTENT(IN) :: InpIndx

   INTEGER             :: IX
   INTEGER             :: IXK


   DO IX=1,Num4Dx,FD_DF_X

         ! shift the x-index, if necessary, to perform Advection
      IXK = ( MOD(IX+Shft4Dnew-1,Num4Dx) + FD_DF_X )/FD_DF_X

      FDu(IXK,:,:,InpIndx) = FDuData(IX,:,:,FDFileNo)
      FDv(IXK,:,:,InpIndx) = FDvData(IX,:,:,FDFileNo)
      FDw(IXK,:,:,InpIndx) = FDwData(IX,:,:,FDFileNo)

   ENDDO ! IX


   RETURN

END SUBROUTINE Load4DData
!====================================================================================================
FUNCTION FD_GetValue(RVarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the RVarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------

   CHARACTER(*),   INTENT(IN)    :: RVarName
   INTEGER,        INTENT(OUT)   :: ErrStat
   REAL(ReKi)                    :: FD_GetValue

   
   CHARACTER(20)                 :: VarNameUC
   

   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FDWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = RVarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
            
      CASE ('ROTDIAM' )
         FD_GetValue = RotDiam         
         
      CASE DEFAULT
         CALL WrScr( ' Invalid variable name in FD_GetRValue().' )
         ErrStat = 1
         
   END SELECT

END FUNCTION FD_GetValue
!====================================================================================================
FUNCTION FD_GetWindSpeed(Time, InputPosition, ErrStat)
! This function is used to interpolate into the 4D wind arrays.  It receives X, Y, Z and TIME from the 
! calling routine.  The time since the start of the 4D data is used to decide which pair of time slices 
! to interpolate within and between.  After finding the two time slices, it decides which eight grid 
! points bound the (X,Y,Z) pair. It does a trilinear interpolation for each time slice. Linear 
! interpolation is then used to interpolate between time slices.  This routine assumes that X is 
! downwind, Y is to the left when looking downwind and Z is up.  It also assumes that no 
! extrapolation will be needed except in time and the Z direction.  In those cases, the appropriate
! steady winds are used.
!----------------------------------------------------------------------------------------------------

      ! Passed variables:
      
   REAL(ReKi),        INTENT(IN) :: Time                                   ! the time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)                       ! structure that contains the position
   INTEGER,           INTENT(OUT):: ErrStat                                ! returns 0 if no error; non-zero otherwise
   TYPE(InflIntrpOut)            :: FD_GetWindSpeed                        ! the resultant wind speed


      ! Local Variables:

   REAL(ReKi)                 :: Ixhyz                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Ixlyz                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Ixyzo                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Iyhz                                      ! Temporary interpolated value.
   REAL(ReKi)                 :: Iylz                                      ! Temporary interpolated value.
   REAL(ReKi)                 :: Ixyzn                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Tgrid                                     ! Fractional distance between time grids.
   REAL(ReKi)                 :: Xgrid                                     ! Fractional distance between grids in the x direction.
   REAL(ReKi)                 :: Xnorm                                     ! Nondimensional downwind distance of the analysis point from upwind end of dataset.
   REAL(ReKi)                 :: Ygrid                                     ! Fractional distance between grids in the y direction.
   REAL(ReKi)                 :: Ynorm                                     ! Nondimensional lateral distance of the analysis point from right side of dataset (looking downwind).
   REAL(ReKi)                 :: Zgrid                                     ! Fractional distance between grids in the z direction.
   REAL(ReKi)                 :: Zgrid_w                                   ! Fractional distance between grids in the z direction for the w component.
   REAL(ReKi)                 :: Znorm                                     ! Nondimensional vertical distance of the analysis point from bottom of dataset.
   REAL(ReKi)                 :: Znorm_w                                   ! Nondimensional vertical distance of the analysis point from bottom of dataset for the w component.

   INTEGER                    :: IT                                        ! Index for do loop
   INTEGER                    :: IXHI                                      ! Index for the more-positive x value.
   INTEGER                    :: IXLO                                      ! Index for the more-negative x value.
   INTEGER                    :: IYHI                                      ! Index for the more-positive y value.
   INTEGER                    :: IYLO                                      ! Index for the more-negative y value.
   INTEGER                    :: IZHI                                      ! Index for the more-positive z value.
   INTEGER                    :: IZHI_w                                    ! Index for the more-positive z value for the w component.
   INTEGER                    :: IZLO                                      ! Index for the more-negative z value.
   INTEGER                    :: IZLO_w                                    ! Index for the more-negative z value for the w component.

   !-------------------------------------------------------------------------------------------------     
   ! Check that we've initialized everything first
   !-------------------------------------------------------------------------------------------------     
     
   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FDWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE 
      ErrStat = 0   
   END IF      

   !-------------------------------------------------------------------------------------------------     
   ! If the TIME is greater than the time for the last file read, read another set of files until we straddle the current time.
   ! Stick with the last file if we've exhausted the data.
   ! We're assuming here that the simulation time step is smaller than the wind-file time step.
   !-------------------------------------------------------------------------------------------------     

   IF ( Time < PrevTime .AND. Time < FDTime(Ind4Dold) ) THEN  ! bjj: GET THE CORRECT TIME if we're going backward!
     
      !----------------------------------------------------------------------------------------------
      ! Determine the first file needed for this simulation.
      !----------------------------------------------------------------------------------------------
      Ind4Dold  = 1                                                           ! Put the old stuff in the first part of the array.
      Ind4Dnew  = 2                                                           ! Put the new stuff in the second part of the array.
      
      FDFileNo  = Num4Dt
      DO IT=1,Num4Dt
         IF ( Times4D(IT) > Time )  THEN
            FDFileNo = IT - 1
            EXIT
         END IF
      END DO ! IT
         
      !----------------------------------------------------------------------------------------------
      ! Open, read, and close the first set of files.
      !----------------------------------------------------------------------------------------------
      FDTime(Ind4Dold) = Times4D(FDFileNo)                                 ! Set the time for this file.

      IF ( ADVECT ) THEN
         CALL Load4DData(Ind4Dold)     ! load data stored in FDuData, FDvData, and FDwData arrays
      ELSE
         CALL LoadLESData( FDUnit, FDFileNo, Ind4Dold, ErrStat )
      END IF
            
      !----------------------------------------------------------------------------------------------
      ! Open, read, and close the second set of files.
      !----------------------------------------------------------------------------------------------
      FDFileNo  = MIN(FDFileNo + 1, Num4Dt)
      Shft4Dnew = 0
      
      IF ( ADVECT ) THEN
         FDFileNo = MOD(FDFileNo-1,Num4Dt) + 1

         IF (FDFileNo == 1) THEN
            Shft4Dnew = Shft4Dnew + 1

            IF (Ind4DAdv <= NumAdvect) THEN                             ! Ind4DAdv was set in ReadFDP
               IF ( MOD( Shft4Dnew, Num4Dx ) == 0 ) THEN
                  CALL ReadAll4DData(FDUnit, ErrStat)
                  IF ( ErrStat /= 0 ) RETURN
               END IF
            END IF

         ENDIF

         FDTime(Ind4Dnew) = Times4D(FDFileNo) + Shft4Dnew*FDPer         ! Set the time for this file.

         CALL Load4DData( Ind4Dnew )    ! shift the data

      ELSE   
         FDTime(Ind4Dnew) = Times4D(FDFileNo)                                           ! Set the time for this file.
!
         CALL LoadLESData( FDUnit, FDFileNo, Ind4Dnew, ErrStat )
      ENDIF
                     
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Move forward in time
   !-------------------------------------------------------------------------------------------------

   DO WHILE ( Time > FDTime(Ind4Dnew) .AND. ( Time < T_4D_En .OR. ADVECT ) )

      Ind4Dnew         = Ind4Dold                                          ! Reverse array indices (1 or 2).
      Ind4Dold         = 3 - Ind4Dnew
      FDFileNo         = FDFileNo + 1                                      ! Increment file number.


      IF ( ADVECT ) THEN
         FDFileNo = MOD(FDFileNo-1,Num4Dt) + 1

         IF (FDFileNo == 1) THEN
               Shft4Dnew = Shft4Dnew + 1

               IF (Ind4DAdv <= NumAdvect) THEN
                  IF ( MOD( Shft4Dnew, Num4Dx ) == 0 ) THEN
                     CALL ReadAll4DData(FDUnit, ErrStat)
                     IF ( ErrStat /= 0 ) RETURN
                  END IF                  
               ENDIF

         ENDIF

         FDTime(Ind4Dnew) = Times4D(FDFileNo) + Shft4Dnew*FDPer

         CALL Load4DData( Ind4Dnew )  ! shift the data
      ELSE
         FDTime(Ind4Dnew) = Times4D(FDFileNo)

         CALL LoadLESData( FDUnit, FDFileNo, Ind4Dnew, ErrStat )
      ENDIF

   ENDDO


   !.................................................................................................
   ! Find the bounding rows, columns, and planes for the X,Y,Z position.  The near, lower-right  
   ! corner is (1,1,1) when looking downwind. Make sure the lowest possible value is 1.
   !.................................................................................................


   !-------------------------------------------------------------------------------------------------
   ! get values of Time for interpolation. Linear interpolation; Nearest-neighbor extrapolation.
   !-------------------------------------------------------------------------------------------------

      ! Find out fractionally how far we are between grids in time and between grid points in each direction.
      !  Limit values to avoid extrapolation.  We need this for interpolation later on.

   Tgrid = MIN( MAX( ( Time - FDTime(Ind4Dold) )/( FDTime(Ind4Dnew) - FDTime(Ind4Dold) ), 0.0 ), 1.0 )


   !-------------------------------------------------------------------------------------------------
   ! get values of X for interpolation. Grid is periodic in X.
   !-------------------------------------------------------------------------------------------------
   Xnorm = ( Xt + InputPosition(1) )/Xmax

   DO WHILE ( Xnorm < 0.0 )   ! Ensure Xnorm is not negative.  The wave is periodic in x.
      Xnorm = Xnorm + 1.0
   ENDDO

   Xgrid = MIN( MAX( MOD( Xnorm, DelXgrid ), 0.0 ), 1.0 )
   IXLo  = MAX( MOD( INT( Xnorm*Num4DxD1 ) + 1, Num4DxD1 ), 1 )
   IXHi  = MOD( IXLo, Num4DxD ) + 1

   !-------------------------------------------------------------------------------------------------
   ! get values of Y for interpolation. Grid is periodic in Y.
   !-------------------------------------------------------------------------------------------------
   Ynorm = ( Yt + InputPosition(2) )/Ymax

   DO WHILE ( Ynorm < 0.0 )  ! Ensure Ynorm is not negative.  The wave is periodic in y.
      Ynorm = Ynorm + 1.0
   ENDDO

   Ygrid = MIN( MAX( MOD( Ynorm, DelYgrid ), 0.0 ), 1.0 )
   IYLo  = MAX( MOD( INT( Ynorm*Num4DyD1 ) + 1, Num4DyD1 ), 1 )
   IYHi  = MOD( IYLo, Num4DyD ) + 1

   !-------------------------------------------------------------------------------------------------
   ! get values of Z for interpolation.  Linear interpolation; Nearest-neighbor extrapolation.  
   !-------------------------------------------------------------------------------------------------
   Znorm = MIN( MAX( ( Zt + InputPosition(3) - ZRef )/Zmax, 0.0 ), 1.0 ) !bjj: define ZRef

   Zgrid = MIN( MAX( MOD( Znorm, DelZgrid ), 0.0 ), 1.0 )
   IZLo  = MAX( INT( Znorm*Num4DzD1 ) + 1, 1 )

      ! If we are located at the upper end of the z dimension, decrement the index by one and set the grid coordinate to 1.

   IF ( IZLo == Num4DzD )  THEN
      IZLo  = Num4DzD1
      Zgrid = 1.0
   ENDIF
   IZHi = IZLo + 1

      !..............................................................................................
      ! Find the equivalent Znorm (Znorm_w) for the w-component, which may be shifted vertically
      ! by half the original grid spacing.
      !..............................................................................................

   IF ( VertShft ) THEN
      Znorm_w = MAX( Znorm - 0.5*DelZgrid/FD_DF_Z, 0.0 )
   ELSE
      Znorm_w = Znorm
   ENDIF

   Zgrid_w = MIN( MAX( MOD( Znorm_w, DelZgrid ), 0.0 ), 1.0 )
   IZLo_w  = MAX( INT( Znorm_w*Num4DzD1 ) + 1, 1 )

   IF ( IZLo_w == Num4DzD )  THEN
      IZLo_w  = Num4DzD1
      Zgrid_w = 1.0
   ENDIF

   IZHi_w = IZLo_w + 1


   !-------------------------------------------------------------------------------------------------
   ! Interpolate for u component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

   Iylz  = ( FDu(IXLo,IYLo,IZHi,Ind4Dold) - FDu(IXLo,IYLo,IZLo,Ind4Dold) )*Zgrid + FDu(IXLo,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDu(IXLo,IYHi,IZHi,Ind4Dold) - FDu(IXLo,IYHi,IZLo,Ind4Dold) )*Zgrid + FDu(IXLo,IYHi,IZLo,Ind4Dold)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDu(IXHi,IYLo,IZHi,Ind4Dold) - FDu(IXHi,IYLo,IZLo,Ind4Dold) )*Zgrid + FDu(IXHi,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDu(IXHi,IYHi,IZHi,Ind4Dold) - FDu(IXHi,IYHi,IZLo,Ind4Dold) )*Zgrid + FDu(IXHi,IYHi,IZLo,Ind4Dold)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzo = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   Iylz  = ( FDu(IXLo,IYLo,IZHi,Ind4Dnew) - FDu(IXLo,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDu(IXLo,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDu(IXLo,IYHi,IZHi,Ind4Dnew) - FDu(IXLo,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDu(IXLo,IYHi,IZLo,Ind4Dnew)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDu(IXHi,IYLo,IZHi,Ind4Dnew) - FDu(IXHi,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDu(IXHi,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDu(IXHi,IYHi,IZHi,Ind4Dnew) - FDu(IXHi,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDu(IXHi,IYHi,IZLo,Ind4Dnew)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzn = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   FD_GetWindSpeed%Velocity(1) = ( Ixyzn - Ixyzo )*Tgrid + Ixyzo

   !-------------------------------------------------------------------------------------------------
   ! Interpolate for v component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

   Iylz  = ( FDv(IXLo,IYLo,IZHi,Ind4Dold) - FDv(IXLo,IYLo,IZLo,Ind4Dold) )*Zgrid + FDv(IXLo,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDv(IXLo,IYHi,IZHi,Ind4Dold) - FDv(IXLo,IYHi,IZLo,Ind4Dold) )*Zgrid + FDv(IXLo,IYHi,IZLo,Ind4Dold)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDv(IXHi,IYLo,IZHi,Ind4Dold) - FDv(IXHi,IYLo,IZLo,Ind4Dold) )*Zgrid + FDv(IXHi,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDv(IXHi,IYHi,IZHi,Ind4Dold) - FDv(IXHi,IYHi,IZLo,Ind4Dold) )*Zgrid + FDv(IXHi,IYHi,IZLo,Ind4Dold)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzo = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   Iylz  = ( FDv(IXLo,IYLo,IZHi,Ind4Dnew) - FDv(IXLo,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDv(IXLo,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDv(IXLo,IYHi,IZHi,Ind4Dnew) - FDv(IXLo,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDv(IXLo,IYHi,IZLo,Ind4Dnew)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDv(IXHi,IYLo,IZHi,Ind4Dnew) - FDv(IXHi,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDv(IXHi,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDv(IXHi,IYHi,IZHi,Ind4Dnew) - FDv(IXHi,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDv(IXHi,IYHi,IZLo,Ind4Dnew)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzn = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   FD_GetWindSpeed%Velocity(2) = ( Ixyzn - Ixyzo )*Tgrid + Ixyzo

   !-------------------------------------------------------------------------------------------------
   ! Interpolate for w component of wind within the grid.
   !-------------------------------------------------------------------------------------------------
   !bjj: should Zgrid actually be Zgrid_w here?  I changed it so that it's consistent
   
   Iylz  = ( FDw(IXLo,IYLo,IZHi_w,Ind4Dold) - FDw(IXLo,IYLo,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXLo,IYLo,IZLo_w,Ind4Dold)
   Iyhz  = ( FDw(IXLo,IYHi,IZHi_w,Ind4Dold) - FDw(IXLo,IYHi,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXLo,IYHi,IZLo_w,Ind4Dold)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDw(IXHi,IYLo,IZHi_w,Ind4Dold) - FDw(IXHi,IYLo,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXHi,IYLo,IZLo_w,Ind4Dold)
   Iyhz  = ( FDw(IXHi,IYHi,IZHi_w,Ind4Dold) - FDw(IXHi,IYHi,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXHi,IYHi,IZLo_w,Ind4Dold)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzo = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   Iylz  = ( FDw(IXLo,IYLo,IZHi_w,Ind4Dnew) - FDw(IXLo,IYLo,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXLo,IYLo,IZLo_w,Ind4Dnew)
   Iyhz  = ( FDw(IXLo,IYHi,IZHi_w,Ind4Dnew) - FDw(IXLo,IYHi,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXLo,IYHi,IZLo_w,Ind4Dnew)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDw(IXHi,IYLo,IZHi_w,Ind4Dnew) - FDw(IXHi,IYLo,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXHi,IYLo,IZLo_w,Ind4Dnew)
   Iyhz  = ( FDw(IXHi,IYHi,IZHi_w,Ind4Dnew) - FDw(IXHi,IYHi,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXHi,IYHi,IZLo_w,Ind4Dnew)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzn = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   FD_GetWindSpeed%Velocity(3) = ( Ixyzn - Ixyzo )*Tgrid + Ixyzo


   !-------------------------------------------------------------------------------------------------
   ! Set the previous time here to compare with later...
   !-------------------------------------------------------------------------------------------------
   PrevTime = Time

   RETURN
   
END FUNCTION FD_GetWindSpeed
!====================================================================================================
SUBROUTINE FD_Terminate( ErrStat )
! This subroutine deallocates arrays, closes files, and un-sets the initialization flag.
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise


   CLOSE( FDunit )

   ErrStat = 0

   IF ( ALLOCATED( FDu       ) )   DEALLOCATE( FDu,       STAT=ErrStat )
   IF ( ALLOCATED( FDv       ) )   DEALLOCATE( FDv,       STAT=ErrStat )
   IF ( ALLOCATED( FDw       ) )   DEALLOCATE( FDw,       STAT=ErrStat )
   IF ( ALLOCATED( FDuData   ) )   DEALLOCATE( FDuData,   STAT=ErrStat )  
   IF ( ALLOCATED( FDvData   ) )   DEALLOCATE( FDvData,   STAT=ErrStat )
   IF ( ALLOCATED( FDwData   ) )   DEALLOCATE( FDwData,   STAT=ErrStat )
   IF ( ALLOCATED( Times4D   ) )   DEALLOCATE( Times4D,   STAT=ErrStat )
   IF ( ALLOCATED( Times4DIx ) )   DEALLOCATE( Times4DIx, STAT=ErrStat )
   IF ( ALLOCATED( AdvFiles  ) )   DEALLOCATE( AdvFiles,  STAT=ErrStat )

   Initialized = .FALSE.

END SUBROUTINE FD_Terminate
!====================================================================================================
END MODULE FDWind
MODULE FFWind
!
!  This module uses full-field binary wind files to determine the wind inflow.
!  This module assumes that the origin, (0,0,0), is located at the tower centerline at ground level,
!  and that all units are specified in the metric system (using meters and seconds).
!  Data is shifted by half the grid width to account for turbine yaw (so that data in the X 
!  direction actually starts at -1*FFYHWid meters).
!
!  Created 25-Sept-2009 by B. Jonkman, National Renewable Energy Laboratory
!     using subroutines and modules from AeroDyn v12.58
!
!----------------------------------------------------------------------------------------------------

   USE      NWTC_Library
   USE      SharedInflowDefs
   USE                     WindFile_Types

   IMPLICIT NONE

   PRIVATE                                                        ! By default, everything in FFWind is private (methods, data, types, etc.)
   
      ! former FF_Wind module
      
   REAL(ReKi), ALLOCATABLE          :: FFData  (:,:,:,:)          ! Array of FF data
   REAL(ReKi), ALLOCATABLE          :: FFtower (:,:,:)            ! Array of data along the tower, below the FF array

   REAL(ReKi)                       :: FFDTime                    ! delta time
   REAL(ReKi)                       :: FFRate                     ! data rate in Hz (1/FFDTime)
   REAL(ReKi)                       :: FFYHWid                    ! half the grid width
   REAL(ReKi)                       :: FFZHWid                    ! half the grid height
   REAL(ReKi)                       :: RefHt                      ! the reference (hub) height of the grid in meters 
   REAL(ReKi)                       :: GridBase                   ! the height of the bottom of the grid in meters
   REAL(ReKi)                       :: InitXPosition              ! the initial x location of the wind file (distance the FF file will be offset)
   REAL(ReKi)                       :: InvFFYD                    ! reciprocal of delta y
   REAL(ReKi)                       :: InvFFZD                    ! reciprocal of delta z
   REAL(ReKi)                       :: InvMFFWS                   ! reciprocal of the mean wind speed (MeanFFWS)
   REAL(ReKi)                       :: MeanFFWS                   ! the mean wind speed (as defined in the FF file), not necessarially the mean of the portion of the wind used
   REAL(ReKi)                       :: TotalTime                  ! the total time in the simulation

   INTEGER                          :: NFFComp                    ! number of wind components
   INTEGER                          :: NFFSteps                   ! number of time steps in the FF array
   INTEGER                          :: NYGrids                    ! number of points in the lateral (y) direction of the grids
   INTEGER                          :: NZGrids                    ! number of points in the vertical (z) direction of the grids
   INTEGER                          :: NTGrids                    ! number of points in the vertical (z) direction on the tower (below the grids)
         
   LOGICAL, SAVE                    :: Initialized = .FALSE.      ! flag that determines if the module has been initialized
   LOGICAL                          :: Periodic    = .FALSE.      ! flag that determines if the wind is periodic


   INTERFACE FF_GetValue
      MODULE PROCEDURE FF_GetRValue                               ! routine to return scalar real values 
   END INTERFACE


   PUBLIC                           :: FF_Init                    ! initialization subroutine to read the FF grids
   PUBLIC                           :: FF_GetWindSpeed            ! interpolation function that returns velocities at specified time and space
   PUBLIC                           :: FF_GetValue                ! interface to return requested values
   PUBLIC                           :: FF_Terminate               ! subroutine that deallocates memory stored in the FFWind module

CONTAINS
!====================================================================================================
SUBROUTINE FF_Init ( UnWind, BinFile, ErrStat )
!  This routine is used read the full-field turbulence data.
!  09/25/97 - Created by M. Buhl from GETFILES in ViewWind.
!  09/23/09 - modified by B. Jonkman: this subroutine was split into several subroutines (was ReadFF)
!----------------------------------------------------------------------------------------------------

   IMPLICIT                       NONE


      ! Passed Variables:
      
   INTEGER,      INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered
   
   CHARACTER(*), INTENT(IN)    :: BinFile                      ! Name of the binary FF wind file

      ! Local Variables:

   REAL(ReKi)                  :: TI      (3)                  ! turbulence intensities of the wind components as defined in the FF file, not necessarially the actual TI
   REAL(ReKi)                  :: BinTI   (3)                  ! turbulence intensities of the wind components as defined in the FF binary file, not necessarially the actual TI
   REAL(ReKi)                  :: UBar
   REAL(ReKi)                  :: ZCenter
   
   INTEGER(B2Ki)               :: Dum_Int2
   INTEGER                     :: DumInt
   INTEGER                     :: I
   LOGICAL                     :: CWise
   LOGICAL                     :: Exists
   CHARACTER( 1028 )           :: SumFile                      ! length is LEN(BinFile) + the 4-character extension.
   CHARACTER( 1028 )           :: TwrFile                      ! length is LEN(BinFile) + the 4-character extension.


      !----------------------------------------------------------------------------------------------
      ! Check that the module hasn't already been initialized.
      !----------------------------------------------------------------------------------------------   
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' FFWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
!      CALL NWTC_Init()    ! Initialized in IfW_Init
   END IF   


      !----------------------------------------------------------------------------------------------
      ! Open the binary file, read its "header" (first 2-byte integer) to determine what format
      ! binary file it is, and close it.
      !----------------------------------------------------------------------------------------------

   CALL OpenBInpFile (UnWind, TRIM(BinFile), ErrStat)
   IF (ErrStat /= 0) RETURN
      
   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2
   CLOSE( UnWind )
   
   IF (ErrStat /= 0) THEN
      CALL WrScr( ' Error reading first binary integer from file "'//TRIM(BinFile)//'."' )
      RETURN
   END IF
   
      !----------------------------------------------------------------------------------------------
      ! Read the files to get the required FF data.
      !----------------------------------------------------------------------------------------------   
   DumInt = Dum_Int2  ! change to default INTEGER, instead of INT(2) to compare in SELECT below
    
   SELECT CASE (DumInt)  
   
      CASE ( 7, 8 )                                                    ! TurbSim binary format
         
         CALL Read_TurbSim_FF(UnWind, TRIM(BinFile), ErrStat)
         
      CASE ( -1, -2, -3, -99 )                                         ! Bladed-style binary format
      
         !...........................................................................................
         ! Create full-field summary file name from binary file root name.  Also get tower file
         ! name.
         !...........................................................................................

            CALL GetRoot(BinFile, SumFile)
            
            TwrFile = TRIM(SumFile)//'.twr'
            SumFile = TRIM(SumFile)//'.sum'
      
         !...........................................................................................
         ! Read the summary file to get necessary scaling information
         !...........................................................................................
   
            CALL Read_Summary_FF (UnWind, TRIM(SumFile), CWise, ZCenter, TI, ErrStat ) 
            IF (ErrStat /= 0) RETURN
            
            UBar = MeanFFWS      ! temporary storage .... this is our only check to see if the summary and binary files "match"

         !...........................................................................................
         ! Open the binary file and read its header
         !...........................................................................................
         
            CALL OpenBInpFile (UnWind, TRIM(BinFile), ErrStat)

            IF (ErrStat /= 0) RETURN

            IF ( Dum_Int2 == -99 ) THEN                                       ! Newer-style BLADED format
               CALL Read_Bladed_FF_Header1 (UnWind, BinTI, ErrStat)    
               
                  ! If the TIs are also in the binary file (BinTI > 0), 
                  ! use those numbers instead of ones from the summary file
                  
               DO I =1,NFFComp                  
                  IF ( BinTI(I) > 0 ) TI(I) = BinTI(I)
               END DO
               
            ELSE
               CALL Read_Bladed_FF_Header0 (UnWind, ErrStat)                  ! Older-style BLADED format
            END IF

            IF (ErrStat /= 0) RETURN

         !...........................................................................................
         ! Let's see if the summary and binary FF wind files go together before continuing.
         !...........................................................................................
               
            IF ( ABS( UBar - MeanFFWS ) > 0.1 )  THEN
               CALL WrScr( ' Error: Incompatible mean hub-height wind speeds in FF wind files. '//&
                           '(Check that the .sum and .wnd files were generated together.)' )
               ErrStat = 1
               RETURN
            ENDIF

         !...........................................................................................
         ! Calculate the height of the bottom of the grid
         !...........................................................................................

            GridBase = ZCenter - FFZHWid         ! the location, in meters, of the bottom of the grid

         !...........................................................................................
         ! Read the binary grids (converted to m/s) and close the file
         !...........................................................................................

            CALL Read_Bladed_Grids( UnWind, CWise, TI, ErrStat) 
            CLOSE ( UnWind )
                           
            IF ( ErrStat /= 0 ) RETURN
   
         !...........................................................................................
         ! Read the tower points file
         !...........................................................................................
   
            INQUIRE ( FILE=TRIM(TwrFile) , EXIST=Exists )

            IF (  Exists )  THEN  
               CALL Read_FF_Tower( UnWind, TRIM(TwrFile), ErrStat  )
            ELSE
               NTgrids = 0            
            END IF                        

                               
      CASE DEFAULT
         
         CALL WrScr( ' Error: Unrecognized binary wind file type.' )
         ErrStat = 1
         RETURN
                  
   END SELECT


   IF (Periodic) THEN
      InitXPosition = 0                ! start at the hub
      TotalTime     = NFFSteps*FFDTime
   ELSE
      InitXPosition = FFYHWid          ! start half the grid with ahead of the turbine
      TotalTime     = (NFFSteps-1)*FFDTime      
   END IF
      
   Initialized = .TRUE.
   
   RETURN
   
END SUBROUTINE FF_Init
!====================================================================================================
SUBROUTINE Read_Bladed_FF_Header0 (UnWind, ErrStat)
!   Reads the binary headers from the turbulence files of the old Bladed variety.  Note that
!   because of the normalization, neither NZGrids or NYGrids are larger than 32 points.
!   21-Sep-2009 - B. Jonkman, NREL/NWTC.
!----------------------------------------------------------------------------------------------------


   IMPLICIT                      NONE


      ! Passed Variables:
      
   INTEGER,   INTENT(IN)      :: UnWind
   INTEGER,   INTENT(OUT)     :: ErrStat

      ! Local Variables:

   REAL(ReKi)                 :: FFXDelt
   REAL(ReKi)                 :: FFYDelt
   REAL(ReKi)                 :: FFZDelt

   INTEGER(B2Ki)              :: Dum_Int2

   INTEGER                    :: I

   !-------------------------------------------------------------------------------------------------
   ! Read the header (file has just been opened)
   !-------------------------------------------------------------------------------------------------

   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! -NFFC (file ID)

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading number of wind components from binary FF file.' )
         RETURN
      END IF
      NFFComp = -1*Dum_Int2
         

   READ (UnWind, IOSTAT=ErrStat) Dum_Int2                                                    ! delta z (mm)
    
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dz from binary FF file.' )
         RETURN
      END IF
      FFZDelt = 0.001*Dum_Int2
      InvFFZD = 1.0/FFZDelt


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! delta y (mm)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dy from binary FF file.' )
         RETURN
      END IF
      FFYDelt = 0.001*Dum_Int2
      InvFFYD = 1.0/FFYDelt


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! delta x (mm)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dx from binary FF file.' )
         RETURN
      END IF
      FFXDelt = 0.001*Dum_Int2


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! half the number of time steps
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading number of time steps from binary FF file.' )
         RETURN
      END IF
      NFFSteps = 2*Dum_Int2


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! 10 times the mean full-field wind speed
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading mean full-field wind speed from binary FF file.' )
         RETURN
      END IF
      MeanFFWS = 0.1*Dum_Int2
      InvMFFWS = 1.0/MeanFFWS
      FFDTime  = FFXDelt/MeanFFWS
      FFRate   = 1.0/FFDTime

      
   DO I = 1,5   
   
      READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                ! unused variables: zLu, yLu, xLu, dummy, random seed

         IF (ErrStat /= 0) THEN
            CALL WrScr( ' Error reading 2-byte integers from binary FF file.' )
            RETURN
         END IF
         
   END DO


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! 1000*nz

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading nz from binary FF file.' )
         RETURN
      END IF
      NZGrids  = Dum_Int2/1000
      FFZHWid  = 0.5*FFZDelt*( NZGrids - 1 )    ! half the vertical size of the grid


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! 1000*ny
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading ny from binary FF file.' )
         RETURN
      END IF   
      NYGrids  = Dum_Int2/1000
      FFYHWid  = 0.5*FFYDelt*( NYGrids - 1 )


   IF (NFFComp == 3) THEN
   
      DO I=1,6
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                             ! unused variables: zLv, yLv, xLv, zLw, yLw, xLw
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 2-byte length scales from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I
      
   END IF !NFFComp


   RETURN
   
END SUBROUTINE Read_Bladed_FF_Header0
!====================================================================================================
SUBROUTINE Read_Bladed_FF_Header1 (UnWind, TI, ErrStat)
!   Reads the binary headers from the turbulence files of the new Bladed variety.
!   16-May-2002 - Windward Engineering.
!   21-Sep-2009 - B. Jonkman, NREL.  updated to trap errors and add extra parameters for MANN model
!----------------------------------------------------------------------------------------------------


   IMPLICIT                      NONE


      ! Passed Variables:
      
   INTEGER,   INTENT(IN)      :: UnWind
   REAL(ReKi), INTENT(OUT)    :: TI(3)
   INTEGER,   INTENT(OUT)     :: ErrStat

      ! Local Variables:

   REAL(ReKi)                 :: FFXDelt
   REAL(ReKi)                 :: FFYDelt
   REAL(ReKi)                 :: FFZDelt

   REAL(SiKi)                 :: Dum_Real4
   INTEGER(B2Ki)              :: Dum_Int2
   INTEGER(B4Ki)              :: Dum_Int4

   INTEGER                    :: I
   INTEGER                    :: TurbType


   TI(:) = -1                                                                                !Initialize to -1 (not all models contain TI)

   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! -99 (file ID)

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading integer from binary FF file.' )
         RETURN
      END IF

   
   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! turbulence type

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading turbulence type from binary FF file.' )
         RETURN
      END IF
      TurbType = Dum_Int2


   SELECT CASE (TurbType)
      CASE(1, 2) 
         !----------------------------------------
         !1-component Von Karman (1) or Kaimal (2)
         !----------------------------------------
            NFFComp = 1
                  
      CASE(3, 5) 
         !----------------------------------------
         !3-component Von Karman (3) or IEC-2 
         ! Kaimal (5)
         !----------------------------------------
            NFFComp = 3
         
      CASE(4) 
         !----------------------------------------
         !improved Von Karman
         !----------------------------------------
      
            READ (UnWind, IOSTAT=ErrStat) Dum_Int4                                           ! number of components (should be 3)
            
               IF (ErrStat /= 0) THEN           
                  CALL WrScr( ' Error reading number of components from binary FF file.' )
                  RETURN
               END IF
               NFFComp = Dum_Int4
            
            READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                          ! Latitude (deg)
            
               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading latitude from binary FF file.' )  
                  RETURN
               END IF

            READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                          ! Roughness length (m)

               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading roughness length from binary FF file.' )
                  RETURN
               END IF
            
            READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                          ! Reference height (m) = Z(1) + GridHeight / 2.0

               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading reference height from binary FF file.' )
                  RETURN
               END IF
            
            
            DO I = 1,3
               READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                       ! TI(u, v, w) (%)
               
                  IF (ErrStat /= 0) THEN
                     CALL WrScr( ' Error reading TI('//'TRIM(Num2LStr(I))'//') from binary FF file.' )
                     RETURN
                  END IF
                  TI(I) = Dum_Real4                                                          ! This overwrites the TI read in the summary file
                  
            END DO !I            
                             
                  
      CASE (7, 8)
         !----------------------------------------
         ! General Kaimal (7) or  Mann model (8)
         !----------------------------------------
      
            READ (UnWind, IOSTAT=ErrStat) Dum_Int4                                           ! number of bytes in header
            
               IF (ErrStat /= 0) THEN           
                  CALL WrScr( ' Error reading number of header records from binary FF file.' )
                  RETURN
               END IF

            READ (UnWind, IOSTAT=ErrStat) Dum_Int4                                           ! number of components
            
               IF (ErrStat /= 0) THEN           
                  CALL WrScr( ' Error reading number of data from binary FF file.' )
                  RETURN
               END IF
               NFFComp = Dum_Int4

                                  
      CASE DEFAULT
      
         CALL ProgWarn( ' AeroDyn does not recognize the full-field turbulence file type ='//TRIM(Num2LStr(TurbType))//'.' )
                  
   END SELECT !TurbType


   READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                                   ! delta z (m)
    
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dz from binary FF file.' )
         RETURN
      END IF
      FFZDelt = Dum_Real4
      InvFFZD = 1.0/FFZDelt


   READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                                  ! delta y (m)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dy from binary FF file.' )
         RETURN
      END IF
      FFYDelt = Dum_Real4
      InvFFYD = 1.0/FFYDelt

   READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                                  ! delta x (m)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dx from binary FF file.' )
         RETURN
      END IF
      FFXDelt = Dum_Real4


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                   ! half the number of time steps
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading number of time steps from binary FF file.' )
         RETURN
      END IF
      NFFSteps = 2*Dum_Int4


   READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                                  ! mean full-field wind speed
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading mean full-field wind speed from binary FF file.' )
         RETURN
      END IF
      MeanFFWS = Dum_Real4
      InvMFFWS = 1.0/MeanFFWS
      FFDTime  = FFXDelt/MeanFFWS
      FFRate   = 1.0/FFDTime

      
   DO I = 1,3   
   
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                               ! unused variables: zLu, yLu, xLu

         IF (ErrStat /= 0) THEN
            CALL WrScr( ' Error reading 4-byte length scales from binary FF file.' )
            RETURN
         END IF
         
   END DO
   
   
   DO I = 1,2
   
      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                ! unused variables: dummy, random seed
      
         IF (ErrStat /= 0) THEN
            CALL WrScr( ' Error reading 4-byte integers from binary FF file.' )
            RETURN
         END IF
         
   END DO


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                   ! nz

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading nz from binary FF file.' )
         RETURN
      END IF
      NZGrids  = Dum_Int4
      FFZHWid  = 0.5*FFZDelt*( NZGrids - 1 )    ! half the vertical size of the grid


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                   ! ny
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading ny from binary FF file.' )
         RETURN
      END IF   
      NYGrids  = Dum_Int4
      FFYHWid  = 0.5*FFYDelt*( NYGrids - 1 )


   IF (NFFComp == 3) THEN
   
      DO I=1,6
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables: zLv, yLv, xLv, zLw, yLw, xLw
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte length scales from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I
      
   END IF !NFFComp



   IF ( TurbType == 7 ) THEN     ! General Kaimal model
   
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variable: coherence decay constant
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading coherence decay constant from binary FF file.' )
               RETURN
            END IF

         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables: coherence scale parameter in m
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading coherence scale parameter from binary FF file.' )
               RETURN
            END IF
         
   ELSE IF ( TurbType == 8 ) THEN     ! Mann model
      
      DO I=1,2
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables: shear parameter (gamma), scale length
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,4
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,3
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,2
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,3
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,2
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I


   END IF !TurbType


   RETURN
   
END SUBROUTINE Read_Bladed_FF_Header1
!====================================================================================================
SUBROUTINE Read_Bladed_Grids ( UnWind, CWise, TI, ErrStat )
! This subroutine continues reading UnWind, starting after the headers have been read.
! It reads the grids and converts the data to un-normalized wind speeds in m/s.
!----------------------------------------------------------------------------------------------------

   INTEGER,     INTENT(IN)    :: UnWind
   LOGICAL,     INTENT(IN)    :: CWise
   REAL(ReKi),  INTENT(IN)    :: TI      (3)                  ! turbulence intensities of the wind components as defined in the FF file, not necessarially the actual TI
   INTEGER,     INTENT(OUT)   :: ErrStat

   REAL(ReKi), PARAMETER      :: FF_Offset(3) = (/ 1.0, 0.0, 0.0 /)  ! used for "un-normalizing" the data

   INTEGER                    :: CFirst
   INTEGER                    :: CLast
   INTEGER                    :: CStep
   INTEGER(B2Ki)              :: Dum_Int2
   INTEGER                    :: I
   INTEGER                    :: IC
   INTEGER                    :: IR
   INTEGER                    :: IT
   
   INTEGER                    :: TmpNumSteps


   !-------------------------------------------------------------------------------------------------
   ! Generate an informative message.
   !-------------------------------------------------------------------------------------------------
      
   CALL WrScr1( ' Reading a '//TRIM( Num2LStr(NYGrids) )//'x'//TRIM( Num2LStr(NZGrids) )//  &
            ' grid ('//TRIM( Num2LStr(FFYHWid*2) )//' m wide, '// &
            TRIM( Num2LStr(GridBase) )//' m to '//TRIM( Num2LStr(GridBase+FFZHWid*2) )//&
            ' m above ground) with a characterstic wind speed of '//TRIM( Num2LStr(MeanFFWS) )//' m/s. ' )

   !-------------------------------------------------------------------------------------------------
   ! Allocate space for the FF array 
   !-------------------------------------------------------------------------------------------------

   TmpNumSteps = NFFSteps + 1       ! add another step, just in case there is an odd number of steps.

!bjj: should we reorganize this FFData array so we access the data faster?
   
   IF ( .NOT. ALLOCATED( FFData ) ) THEN
      ALLOCATE ( FFData(NZGrids,NYGrids,NFFComp,TmpNumSteps),STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Cannot allocate the full-field wind data array.' )
         RETURN

      ENDIF
      
   ELSE
      IF (SIZE(FFDATA,1) /= NZGrids .OR. SIZE(FFDATA,2) /= NYGrids .OR. &
          SIZE(FFDATA,3) /= NFFComp .OR. SIZE(FFDATA,3) /= TmpNumSteps ) THEN
          
            ! Let's make the array the correct size (we should never get here, but you never know)
            
         DEALLOCATE( FFData )
          
         ALLOCATE ( FFData(NZGrids,NYGrids,NFFComp,TmpNumSteps),STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN

            CALL WrScr( ' Cannot allocate the full-field wind data array.' )
            RETURN

         END IF ! Error
          
      END IF !Incorrect size
   END IF ! allocated

   !-------------------------------------------------------------------------------------------------
   ! Initialize the data and set column indexing to account for direction of turbine rotation (CWise)
   !-------------------------------------------------------------------------------------------------
   
   FFData(:,:,:,:) = 0.0                        ! we may have only one component
   
   IF ( CWise )  THEN
      CFirst    = NYGrids
      CLast     = 1
      CStep     = -1
   ELSE
      CFirst    = 1
      CLast     = NYGrids
      CStep     = 1
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Loop through all the time steps, reading the data and converting to m/s
   !-------------------------------------------------------------------------------------------------
!bjj: should we reorganize this FFData array so we access the data faster?
  
   NFFSteps = TmpNumSteps
  
TIME_LOOP:  DO IT=1,TmpNumSteps     ! time (add 1 to see if there is an odd number of grids)
   
      DO IR=1,NZGrids               ! the rows (vertical)
      
         DO IC=CFirst,CLast,CStep   ! the columns (lateral)
         
            DO I=1,NFFComp          ! wind components (U, V, W)
            
               READ (UnWind,IOStat=ErrStat)  Dum_Int2
               IF (ErrStat /= 0) THEN
                  IF ( IT == TmpNumSteps ) THEN ! There really were an even number of steps
                     NFFSteps = TmpNumSteps - 1
                     ErrStat  = 0
                     EXIT TIME_LOOP       
                  ELSE               
                     CALL WrScr( ' Error reading binary data file. ic = '//TRIM(Num2LStr(ic))// &
                                    ', ir = '//TRIM(Num2LStr(ir))//', it = '//TRIM(Num2LStr(it))// &
                                    ', nffsteps = '//TRIM(Num2LStr(nffsteps)) )
                     ErrStat = 1
                     RETURN
                  END IF
               ELSE               
                  FFData(IR,IC,I,IT) = MeanFFWS*(FF_Offset(I)+0.00001*TI(I)*Dum_Int2) 
               END IF
               
            END DO !I

         END DO !IC

      END DO !IR

   END DO TIME_LOOP !IT
   
   IF ( Periodic ) THEN
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data (period of '//TRIM( Num2LStr( FFDTime*NFFSteps ) )//' seconds).' )
   ELSE                     
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data ('//TRIM( Num2LStr( FFDTime*( NFFSteps - 1 ) ) )//' seconds).' )
   END IF

END SUBROUTINE Read_Bladed_Grids
!====================================================================================================
SUBROUTINE Read_Summary_FF ( UnWind, FileName, CWise, ZCenter, TI, ErrStat )
! This subroutine reads the text summary file to get normalizing parameters, the location of the
! grid, and the direction the grid was written to the binary file
!----------------------------------------------------------------------------------------------------

   INTEGER,     INTENT(IN)    :: UnWind         ! unit number for the file to open
   CHARACTER(*),INTENT(IN)    :: FileName       ! name of the summary file
   LOGICAL,     INTENT(OUT)   :: CWise          ! rotation (for reading the order of the binary data)
   REAL(ReKi),  INTENT(OUT)   :: ZCenter        ! the height at the center of the grid
   REAL(ReKi),  INTENT(OUT)   :: TI      (3)    ! turbulence intensities of the wind components as defined in the FF file, not necessarially the actual TI
   INTEGER,     INTENT(OUT)   :: ErrStat        ! returns 0 if no error encountered in the subroutine
   
   REAL(ReKi)                 :: ZGOffset       ! The vertical offset of the turbine on rectangular grid (allows turbulence not centered on turbine hub)

   
   INTEGER, PARAMETER         :: NumStrings = 6 ! number of strings to be looking for in the file

   INTEGER                    :: FirstIndx      ! The first character of a line where data is located
   INTEGER                    :: I              ! A loop counter
   INTEGER                    :: LastIndx       ! The last  character of a line where data is located
   INTEGER                    :: LineCount      ! Number of lines that have been read in the file
   INTEGER                    :: Status         ! Status from I/O calls
   
   LOGICAL                    :: StrNeeded(NumStrings)   ! if the string has been found
   
   CHARACTER(1024)            :: LINE           ! temporary storage for reading a line from the file
   
      !----------------------------------------------------------------------------------------------
      ! Initialize some variables
      !----------------------------------------------------------------------------------------------

   ErrStat      = 0
   LineCount    = 0
   StrNeeded(:) = .TRUE.
   ZGOffset     = 0.0
   RefHt        = 0.0
   Periodic     = .FALSE.
   
      !----------------------------------------------------------------------------------------------
      ! Open summary file.
      !----------------------------------------------------------------------------------------------
      
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat) 


      !----------------------------------------------------------------------------------------------
      ! Read the summary file.
      !----------------------------------------------------------------------------------------------

   DO WHILE ( ( ErrStat == 0 ) .AND. StrNeeded(NumStrings) )

      LineCount = LineCount + 1

      READ ( UnWind, '(A)', IOSTAT=ErrStat ) LINE
      IF ( ErrStat /= 0 ) THEN
      
         IF ( StrNeeded(NumStrings-1) ) THEN  ! the "HEIGHT OFFSET" StrNeeded(NumStrings) parameter is not necessary.  We'll assume it's zero if we didn't find it.
            CALL WrScr( ' Error reading line #'//TRIM(Num2LStr(LineCount))//' of the summary file, "'//TRIM(FileName)//'"' )
            CALL WrScr( 'Could not find all of the required parameters.' )
            ErrStat = NumStrings+1
            RETURN
         ELSE           
            EXIT
         ENDIF
         
      END IF
      
      CALL Conv2UC ( LINE )
            

      IF ( StrNeeded(1) ) THEN
      
         !-------------------------------------------------------------------------------------------
         ! #1: Get the rotation direction, using the string "CLOCKWISE" 
         !-------------------------------------------------------------------------------------------
            
         IF ( INDEX( LINE, 'CLOCKWISE' ) > 0 ) THEN
            
            READ (LINE, *, IOSTAT = Status)  CWise          ! Look for True/False values

            IF ( Status /= 0 ) THEN                         ! Look for Yes/No values instead

               LINE = ADJUSTL ( LINE )                      ! Remove leading spaces from input line

               SELECT CASE (LINE(1:1) )
                  CASE ('Y')
                     CWise = .TRUE.
                  CASE ('N')
                     CWise = .FALSE.
                  CASE DEFAULT                  
                     CALL WrScr( ' Error reading rotation direction (CLOCKWISE) from FF summary file.' )
                     ErrStat = 1
                     RETURN
               END SELECT
               
            END IF ! Status /= 0
            StrNeeded(1) = .FALSE.
            
         END IF   ! INDEX for "CLOCKWISE"
         
      ELSEIF ( StrNeeded(2) ) THEN
      
         !-------------------------------------------------------------------------------------------
         ! #2: Get the hub height, using the strings "HUB HEIGHT" or "ZHUB"
         !-------------------------------------------------------------------------------------------

         IF ( INDEX( LINE, 'HUB HEIGHT' ) > 0 .OR. INDEX( LINE, 'ZHUB' ) > 0 ) THEN
         
            READ (LINE, *, IOSTAT = Status) RefHt
         
            IF ( Status /= 0 ) THEN
               CALL WrScr( ' Error reading hub height from FF summary file.' )
               ErrStat = 2
               RETURN
            END IF ! Status /= 0
            StrNeeded(2) = .FALSE.
                  
         END IF !INDEX for "HUB HEIGHT" or "ZHUB"
         
         
!      ELSEIF ( StrNeeded(3) ) THEN
!
!         !-------------------------------------------------------------------------------------------
!         ! #3: Get the grid width (& height, if available), using the strings "GRID WIDTH" or "RDIAM"
!         !    If GRID HEIGHT is specified, use it, too. -- THIS IS UNNECESSARY AS IT'S STORED IN THE BINARY FILE
!         !-------------------------------------------------------------------------------------------         

      ELSEIF ( StrNeeded(4) ) THEN
      
         !-------------------------------------------------------------------------------------------
         ! #4: Get the mean wind speed "UBAR" and turbulence intensities from following lines for 
         !     scaling Bladed-style FF binary files
         !-------------------------------------------------------------------------------------------         

         IF ( INDEX( LINE, 'UBAR') > 0 ) THEN

            FirstIndx = INDEX( LINE, '=' ) + 1        ! Look for the equal siqn to find the number we're looking for

            READ ( LINE( FirstIndx:LEN(LINE) ), *, IOSTAT=Status ) MeanFFWS

            IF ( Status /= 0 ) THEN
               CALL WrScr( ' Error reading UBar binary data normalizing parameter from FF summary file.' )
               ErrStat = 4
               RETURN
            END IF ! Status /= 0      

            DO I = 1,3

               LineCount = LineCount + 1

               READ ( UnWind, '(A)', IOSTAT=Status ) LINE
               IF ( Status /= 0 ) THEN
                  CALL WrScr( ' Error reading line #'//TRIM(Num2LStr(LineCount))//' of the summary file, "'//TRIM(FileName)//'"' )
                  CALL WrScr( 'Could not find all of the required parameters.' )
                  ErrStat = Status
                  RETURN
               END IF

               FirstIndx = INDEX( LINE, '=' ) + 1     ! Read the number between the = and % signs
               LastIndx  = INDEX( LINE, '%' ) - 1

               IF ( LastIndx <= FirstIndx ) LastIndx = LEN( LINE )   ! If there's no % sign, read to the end of the line

               READ ( LINE( FirstIndx:LastIndx ), *, IOSTAT=Status ) TI(I)
               IF ( Status /= 0 ) THEN
                  CALL WrScr( ' Error reading TI('//TRIM(Num2LStr(I))//') binary data normalizing parameter from FF summary file.' )
                  ErrStat = 4
                  RETURN
               END IF ! Status /= 0      

            END DO !I

            StrNeeded(4) = .FALSE.            

          END IF
      
      ELSEIF ( StrNeeded(5) ) THEN
         
         !-------------------------------------------------------------------------------------------
         ! #5: Get the grid "HEIGHT OFFSET", if it exists (in TurbSim). Otherwise, assume it's zero 
         !           ZGOffset = HH - GridBase - FFZHWid
         !-------------------------------------------------------------------------------------------         
         IF ( INDEX( LINE, 'HEIGHT OFFSET' ) > 0  ) THEN
         
            FirstIndx = INDEX ( LINE, '=' ) + 1

            READ ( LINE( FirstIndx:LEN(LINE) ), *, IOSTAT=Status ) ZGOffset            
                  
            IF ( Status /= 0 ) THEN
               CALL WrScr( ' Error reading height offset from FF summary file.' )
               ErrStat = 5
               RETURN
            END IF ! Status /= 0
                  
            StrNeeded(5) = .FALSE.
            
         END IF !INDEX for "HEIGHT OFFSET"

      ELSEIF ( StrNeeded(6) ) THEN
         
         !-------------------------------------------------------------------------------------------
         ! #5: Get the grid "PERIODIC", if it exists (in TurbSim). Otherwise, assume it's  
         !        not a periodic file
         !-------------------------------------------------------------------------------------------         
         IF ( INDEX( LINE, 'PERIODIC' ) > 0  ) THEN
         
            Periodic     = .TRUE.                  
            StrNeeded(6) = .FALSE.
            
         END IF !INDEX for "PERIODIC"
         
      END IF ! StrNeeded
      
      
   END DO !WHILE

   ErrStat = 0    ! We made it to the end of the file
   
   !-------------------------------------------------------------------------------------------------
   ! Close the summary file
   !-------------------------------------------------------------------------------------------------         
   
   CLOSE ( UnWind )


   !-------------------------------------------------------------------------------------------------
   ! Calculate the height of the grid center
   !-------------------------------------------------------------------------------------------------         

    ZCenter  = RefHt - ZGOffset


END SUBROUTINE Read_Summary_FF
!====================================================================================================
SUBROUTINE Read_TurbSim_FF(UnWind,WindFile, ErrStat)
! This subroutine reads the binary TurbSim-format FF file (.bts).  It fills the FFData array with
! velocity data for the grids and fills the FFtower array with velocities at points on the tower 
! (if data exists).
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,      INTENT(IN)   :: UnWind            ! unit number for the wind file
   CHARACTER(*), INTENT(IN)   :: WindFile          ! name of the binary TurbSim file
   INTEGER,      INTENT(OUT)  :: ErrStat           ! error status return value (0=no error; non-zero is error)

      ! Local Variables:

   REAL(SiKi)                 :: Dum_Real4         ! dummy 4-byte real number
   INTEGER(B1Ki)              :: Dum_Int1          ! dummy 1-byte integer
   INTEGER(B2Ki)              :: Dum_Int2          ! dummy 2-byte integer
   INTEGER(B4Ki)              :: Dum_Int4          ! dummy 4-byte integer

   INTEGER                    :: IC                ! loop counter for wind components
   INTEGER                    :: IT                ! loop counter for time
   INTEGER                    :: IY                ! loop counter for y
   INTEGER                    :: IZ                ! loop counter for z
   INTEGER                    :: NChar             ! number of characters in the description string
   
   REAL(SiKi)                 :: Vslope(3)         ! slope  for "un-normalizing" data
   REAL(SiKi)                 :: Voffset(3)        ! offset for "un-normalizing" data
            
   CHARACTER(1024)            :: DescStr           ! description string contained in the file


   NFFComp = 3                                              ! this file contains 3 wind components
         
   !-------------------------------------------------------------------------------------------------
   ! Open the file
   !-------------------------------------------------------------------------------------------------

   CALL OpenBInpFile (UnWind, TRIM(WindFile), ErrStat)
   IF (ErrStat /= 0) RETURN
      
   !-------------------------------------------------------------------------------------------------
   ! Read the header information
   !-------------------------------------------------------------------------------------------------
      READ (UnWind, IOSTAT=ErrStat)  Dum_Int2               ! the file identifier, INT(2)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the file identifier in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF         
         Periodic = Dum_Int2 == INT( 8, B2Ki) ! the number 7 is used for non-periodic wind files; 8 is periodic wind


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4               ! the number of grid points vertically, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of z grid points in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NZgrids = Dum_Int4       

     
      READ (UnWind, IOSTAT=ErrStat) Dum_Int4                ! the number of grid points laterally, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of y grid points in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NYgrids = Dum_Int4


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4               ! the number of tower points, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of tower points in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NTgrids = Dum_Int4
         

      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4               ! the number of time steps, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of time steps in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NFFSteps = Dum_Int4


      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! grid spacing in vertical direction (dz), REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dz in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         InvFFZD = 1.0/Dum_Real4                            ! 1/dz
         FFZHWid = 0.5*(NZgrids-1)*Dum_Real4                ! half the grid height


      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! grid spacing in lateral direction (dy), REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dy in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         InvFFYD = 1.0 / Dum_Real4                          ! 1/dy
         FFYHWid = 0.5*(NYgrids-1)*Dum_Real4                ! half grid grid width


      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! grid spacing in time (dt), REAL(4), in m/s
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dt in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         FFDTime = Dum_Real4
         FFRate  = 1.0/FFDTime
                  
                  
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! the mean wind speed at hub height, REAL(4), in m/s
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading mean wind speed in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         MeanFFWS = Dum_Real4
         InvMFFWS = 1.0 / MeanFFWS
         
         
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! height of the hub, REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading zHub in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         RefHt = Dum_Real4
         
         
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! height of the bottom of the grid, REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading GridBase in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         GridBase = Dum_Real4

 !        ZGOffset = RefHt - GridBase  - FFZHWid
         
         
      !----------------------------------------------------------------------------------------------
      ! Read the binary scaling factors
      !----------------------------------------------------------------------------------------------         
         
         DO IC = 1,NFFComp         
            READ (UnWind, IOSTAT=ErrStat)  Vslope(IC)       ! the IC-component slope for scaling, REAL(4)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr ( ' Error reading Vslope('//Num2LStr(IC)//') in the FF binary file "'//TRIM( WindFile )//'."' )
                  RETURN
               ENDIF


            READ (UnWind, IOSTAT=ErrStat)  Voffset(IC)      ! the IC-component offset for scaling, REAL(4)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr ( ' Error reading Voffset('//Num2LStr(IC)//') in the FF binary file "'//TRIM( WindFile )//'."' )
                  RETURN
               ENDIF
               
         END DO !IC


      !----------------------------------------------------------------------------------------------
      ! Read the description string: "Generated by TurbSim (vx.xx, dd-mmm-yyyy) on dd-mmm-yyyy at hh:mm:ss."
      !----------------------------------------------------------------------------------------------

         READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                ! the number of characters in the description string, max 200, INT(4)
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error reading NCHAR in the FF binary file "'//TRIM( WindFile )//'."' )
               RETURN
            ENDIF
            nchar = Dum_Int4
            
         DescStr = ''                                       ! Initialize the description string
         
         DO IC=1,nchar

            READ (UnWind, IOSTAT=ErrStat) Dum_Int1          ! the ASCII integer representation of the character, INT(1)
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error reading description line in the FF binary file "'//TRIM( WindFile )//'."' )
               RETURN
            ENDIF
            
            IF ( LEN(DescStr) >= IC ) THEN
               DescStr(IC:IC) = ACHAR( Dum_Int1 )              ! converted ASCII characters
            ELSE
               CALL WrScr ( ' Description string too long.' )
               EXIT
            END IF

         ENDDO !IC


   !-------------------------------------------------------------------------------------------------
   ! Get the grid and tower velocities
   !-------------------------------------------------------------------------------------------------

   CALL WrScr1( ' Reading a '//TRIM( Num2LStr(NYGrids) )//'x'//TRIM( Num2LStr(NZGrids) )//  &
            ' grid ('//TRIM( Num2LStr(FFYHWid*2) )//' m wide, '// &
            TRIM( Num2LStr(GridBase) )//' m to '//TRIM( Num2LStr(GridBase+FFZHWid*2) )//&
            ' m above ground) with a characterstic wind speed of '//TRIM( Num2LStr(MeanFFWS) )//' m/s. '//TRIM(DescStr) )
               
               
   !----------------------------------------------------------------------------------------------
   ! Allocate arrays for the FF grid as well as the tower points, if they exist
   !----------------------------------------------------------------------------------------------
            
      IF ( .NOT. ALLOCATED( FFData ) ) THEN
         ALLOCATE ( FFData(NZGrids,NYGrids,NFFComp,NFFSteps), STAT=ErrStat )
               
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr( ' Cannot allocate the full-field wind data array.' )
            RETURN
         ENDIF         
      ENDIF
         
     
      IF ( NTgrids > 0 ) THEN
      
         IF ( .NOT. ALLOCATED( FFtower ) ) THEN
            ALLOCATE( FFtower( NFFComp, NTgrids, NFFSteps ), STAT=ErrStat )
            
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Cannot allocate the tower wind data array.' )
               RETURN
            ENDIF            
         ENDIF
         
      ENDIF         
      
   !-------------------------------------------------------------------------------------------------
   ! Read the 16-bit data and scale it to 32-bit reals
   !-------------------------------------------------------------------------------------------------
               
      ! Loop through time.

      DO IT=1,NFFSteps
      
         !...........................................................................................
         ! Read grid data at this time step.
         !...........................................................................................

         DO IZ=1,NZgrids
            ! Zgrid(IZ) = Z1 + (IZ-1)*dz                 ! Vertical location of grid data point, in m relative to ground

            DO IY=1,NYgrids
               ! Ygrid(IY) = -0.5*(ny-1)*dy + (IY-1)*dy  ! Horizontal location of grid data point, in m relative to tower centerline
            
               DO IC=1,NFFComp                           ! number of wind components (U, V, W)

                  READ (UnWind, IOSTAT=ErrStat)  Dum_Int2      ! normalized wind-component, INT(2)
                  IF ( ErrStat /= 0 )  THEN
                     CALL WrScr ( ' Error reading grid wind components in the FF binary file "'//TRIM( WindFile )//'."' )
                     RETURN
                  ENDIF
                  
                  FFData(IZ,IY,IC,IT) = ( Dum_Int2 - Voffset(IC) ) / VSlope(IC)

               ENDDO !IC

            ENDDO !IY
            
         ENDDO ! IZ


         !...........................................................................................
         ! Read the tower data at this time step.
         !...........................................................................................
            
         DO IZ=1,NTgrids         ! If NTgrids<1, there are no tower points & FFtower is not allocated

            ! Ytower     = 0               ! Lateral location of the tower data point, in m relative to tower centerline
            ! Ztower(IZ) = Z1 - (IZ-1)*dz  ! Vertical location of tower data point, in m relative to ground

            DO IC=1,NFFComp   ! number of wind components

               READ (UnWind, IOSTAT=ErrStat)  Dum_Int2      ! normalized wind-component, INT(2)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr ( ' Error reading tower wind components in the FF binary file "'//TRIM( WindFile )//'."' )
                  RETURN
               ENDIF
               
               FFtower(IC,IZ,IT) = ( Dum_Int2 - Voffset(IC) ) / VSlope(IC)  ! wind-component scaled to m/s

            ENDDO !IC

         ENDDO ! IZ


      ENDDO ! IT

   !-------------------------------------------------------------------------------------------------
   ! close the file and return
   !-------------------------------------------------------------------------------------------------
   
   CLOSE ( UnWind )


   IF ( Periodic ) THEN
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data (period of '//TRIM( Num2LStr( FFDTime*( NFFSteps ) ) )//' seconds).' )
   ELSE
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data ('//TRIM( Num2LStr( FFDTime*( NFFSteps - 1 ) ) )//' seconds).' )
   END IF                  

   RETURN

END SUBROUTINE READ_TurbSim_FF
!====================================================================================================
SUBROUTINE Read_FF_Tower( UnWind, WindFile, ErrStat )
! This subroutine reads the binary tower file that corresponds with the Bladed-style FF binary file.
! The FF grid must be read before this subroutine is called! (many checks are made to ensure the
! files belong together)
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,      INTENT(IN)   :: UnWind            ! unit number for the wind file
   CHARACTER(*), INTENT(IN)   :: WindFile          ! name of the binary TurbSim file
   INTEGER,      INTENT(OUT)  :: ErrStat           ! error status return value (0=no error; non-zero is error)

      ! Local Variables:

   REAL(SiKi)                 :: Dum_Real4         ! dummy 4-byte real number
   INTEGER(B2Ki)              :: Dum_Int2          ! dummy 2-byte integer
   INTEGER(B4Ki)              :: Dum_Int4          ! dummy 4-byte integer

   INTEGER                    :: IC                ! loop counter for wind components
   INTEGER                    :: IT                ! loop counter for time
   INTEGER                    :: IZ                ! loop counter for z
   
   REAL(ReKi), PARAMETER      :: TOL = 1E-4        ! tolerence for wind file comparisons

   REAL(ReKi), PARAMETER      :: FF_Offset(3) = (/ 1.0, 0.0, 0.0 /)  ! used for "un-normalizing" the data
   REAL(SiKi)                 :: TI       (3)      ! scaling values for "un-normalizing the data" [approx. turbulence intensities of the wind components]

   !-------------------------------------------------------------------------------------------------
   ! 
   !-------------------------------------------------------------------------------------------------

   NTgrids = 0

   IF ( NFFComp /= 3 ) THEN
      CALL WrScr( ' Error: Tower binary files require 3 wind components.' )
      ErrStat = 1
      RETURN
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Open the file
   !-------------------------------------------------------------------------------------------------

   CALL OpenBInpFile (UnWind, TRIM(WindFile), ErrStat)
   IF (ErrStat /= 0) THEN
      ErrStat = -1
      RETURN
   END IF
      
   !-------------------------------------------------------------------------------------------------
   ! Read the header information and check that it's compatible with the FF Bladed-style binary
   ! parameters already read.
   !-------------------------------------------------------------------------------------------------
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! dz, in meters [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dz in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( ABS(Dum_Real4*InvFFZD-1) > TOL ) THEN
            CALL WrScr ( ' Resolution in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF
         
         
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! dx, in meters [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dx in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         
         IF ( ABS(Dum_Real4*InvMFFWS/FFDTime-1) > TOL ) THEN
            CALL WrScr ( ' Time resolution in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF
         

      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! Zmax, in meters [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading GridBase in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( ABS(Dum_Real4/GridBase-1) > TOL ) THEN
            CALL WrScr ( ' Height in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                  ! NumOutSteps [4-byte INTEGER]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading NumOutSteps in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( Dum_Int4 /= NFFSteps ) THEN
            CALL WrScr ( ' Number of time steps in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                  ! NumZ      [4-byte INTEGER]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading NumZ in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NTgrids = Dum_Int4
         

      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! UHub      [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading UHub in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( ABS(Dum_Real4*InvMFFWS - 1) > TOL ) THEN
            CALL WrScr ( ' Mean wind speed in the FF binary file does not match the tower file.' )
            ErrStat = 1
            NTgrids = 0
            RETURN
         END IF


      DO IC=1,3
         READ (UnWind, IOSTAT=ErrStat)  TI(IC)               ! TI(u), TI(v), TI(w)  [4-byte REAL]
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error reading TI('//TRIM(Num2LStr(IC))//') in the binary tower file "' &
                               //TRIM( WindFile )//'."' )
               NTgrids = 0                               
               RETURN
            ENDIF
      END DO      

   !----------------------------------------------------------------------------------------------
   ! Allocate arrays for the tower points
   !----------------------------------------------------------------------------------------------        
     
      IF ( NTgrids > 0 ) THEN
      
         IF ( .NOT. ALLOCATED( FFtower ) ) THEN
!            CALL AllocAry( FFtower, NFFComp, NTgrids, NFFSteps, 'tower wind data', ErrStat )            
            ALLOCATE ( FFtower(NFFComp,NTgrids,NFFSteps), STAT=ErrStat )

            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error allocating memory for the tower wind data array.' )
               NTgrids = 0
               RETURN
            END IF

         ELSE
            ! Check sizes here!
         ENDIF
         
      ENDIF         
      
   !-------------------------------------------------------------------------------------------------
   ! Read the 16-bit time-series data and scale it to 32-bit reals
   !-------------------------------------------------------------------------------------------------
               
      ! Loop through time.

      DO IT=1,NFFSteps

         DO IZ=1,NTgrids         ! If NTgrids<1, there are no tower points & FFtower is not allocated

            ! Ytower     = 0               ! Lateral location of the tower data point, in m relative to tower centerline
            ! Ztower(IZ) = Z1 - (IZ-1)*dz  ! Vertical location of tower data point, in m relative to ground

            DO IC=1,NFFComp   ! number of wind components

               READ (UnWind, IOSTAT=ErrStat)  Dum_Int2      ! normalized wind-component, INT(2)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr( ' Error reading binary tower data file. it = '//TRIM(Num2LStr(it))// &
                                 ', nffsteps = '//TRIM(Num2LStr(nffsteps)) )
                  ErrStat = 1  
                  NTgrids = 0            
                  RETURN
               ENDIF
               
               FFtower(IC,IZ,IT) = MeanFFWS*(FF_Offset(IC)+0.00001*TI(IC)*Dum_Int2)   ! wind-component scaled to m/s

            ENDDO !IC

         ENDDO ! IZ


      ENDDO ! IT   

   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
   CLOSE ( UnWind )


   CALL WrScr ( ' Processed '//TRIM( Num2LStr(NFFSteps) )//' time steps of '//TRIM( Num2LStr(NTgrids) )//'x1 tower data grids.')


   RETURN

END SUBROUTINE Read_FF_Tower
!====================================================================================================
FUNCTION FF_GetRValue(RVarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the RVarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------

   CHARACTER(*),   INTENT(IN)    :: RVarName
   INTEGER,        INTENT(OUT)   :: ErrStat
   REAL(ReKi)                    :: FF_GetRValue

   
   CHARACTER(20)                 :: VarNameUC
   

   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FFWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = RVarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
   
      CASE ('HUBHEIGHT', 'REFHEIGHT' )
         FF_GetRValue = RefHt
         
      CASE ('GRIDWIDTH', 'FFYWID' )
         FF_GetRValue = FFYHWid*2

      CASE ('GRIDHEIGHT', 'FFZWID' )
         FF_GetRValue = FFZHWid*2
         
      CASE ('MEANFFWS' )
         FF_GetRValue = MeanFFWS         
         
      CASE DEFAULT
         CALL WrScr( ' Invalid variable name in FF_GetRValue().' )
         ErrStat = 1
         
   END SELECT

END FUNCTION FF_GetRValue
!====================================================================================================
FUNCTION FF_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are are 
! requested.  It determines if the point is on the FF grid or tower points and calls the
! corresponding interpolation routine, which returns the velocities at the specified time and space.
!----------------------------------------------------------------------------------------------------
   
   REAL(ReKi),        INTENT(IN) :: Time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)
   INTEGER,           INTENT(OUT):: ErrStat
   TYPE(InflIntrpOut)            :: FF_GetWindSpeed
   
   REAL(ReKi), PARAMETER         :: TOL = 1E-3
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   
   
   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FFWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      

   
   !-------------------------------------------------------------------------------------------------
   ! Find out if the location is on the grid on on tower points; interpolate and return the value.
   !-------------------------------------------------------------------------------------------------   

    FF_GetWindSpeed%Velocity = FF_Interp(Time,InputPosition, ErrStat)


!   IF ( InputPosition(3) >= GridBase - TOL ) THEN  
!   
!         ! Get the velocities interpolated on the FF grid
!      
!      FF_GetWindSpeed%Velocity = FF_Interp(Time,InputPosition, ErrStat)
!      
!   ELSE
!   
!         ! Get the velocities interpolated below the FF grid, on the tower points
!
!      IF ( NTgrids < 1 ) THEN
!      
!         CALL WrScr( ' Error: FF interpolation height is below the grid and no tower points have been defined.' )
!         ErrStat = 1
!         RETURN
!         
!      ELSE
!      
!         FF_GetWindSpeed%Velocity = FF_TowerInterp(Time,InputInfo%Position, ErrStat)
!         
!      END IF   ! NTgrids < 1
!      
!   
!   END IF      ! InputInfo%Position(3)>= GridBase


END FUNCTION FF_GetWindSpeed
!====================================================================================================
FUNCTION FF_Interp(Time, Position, ErrStat)
!    This function is used to interpolate into the full-field wind array or tower array if it has   
!    been defined and is necessary for the given inputs.  It receives X, Y, Z and
!    TIME from the calling routine.  It then computes a time shift due to a nonzero X based upon 
!    the average windspeed.  The modified time is used to decide which pair of time slices to interpolate
!    within and between.  After finding the two time slices, it decides which four grid points bound the 
!    (Y,Z) pair.  It does a bilinear interpolation for each time slice. Linear interpolation is then used 
!    to interpolate between time slices.  This routine assumes that X is downwind, Y is to the left when  
!    looking downwind and Z is up.  It also assumes that no extrapolation will be needed.
!    
!    If tower points are used, it assumes the velocity at the ground is 0.  It interpolates between
!    heights and between time slices, but ignores the Y input.
!
!    11/07/94 - Created by M. Buhl from the original TURBINT.
!    09/25/97 - Modified by M. Buhl to use f90 constructs and new variable names.  Renamed to FF_Interp.
!    09/23/09 - Modified by B. Jonkman to use arguments instead of modules to determine time and position.  
!               Height is now relative to the ground
!
!----------------------------------------------------------------------------------------------------

   IMPLICIT                      NONE

   REAL(ReKi),      INTENT(IN) :: Position(3)       ! takes the place of XGrnd, YGrnd, ZGrnd
   REAL(ReKi),      INTENT(IN) :: Time
   REAL(ReKi)                  :: FF_Interp(3)      ! The U, V, W velocities

   INTEGER,         INTENT(OUT):: ErrStat

      ! Local Variables:

   REAL(ReKi)                  :: TimeShifted
   REAL(ReKi),PARAMETER        :: Tol = 1.0E-3      ! a tolerance for determining if two reals are the same (for extrapolation)
   REAL(ReKi)                  :: W_YH_Z
   REAL(ReKi)                  :: W_YH_ZH
   REAL(ReKi)                  :: W_YH_ZL
   REAL(ReKi)                  :: W_YL_Z
   REAL(ReKi)                  :: W_YL_ZH
   REAL(ReKi)                  :: W_YL_ZL
   REAL(ReKi)                  :: Wnd      (2)
   REAL(ReKi)                  :: T
   REAL(ReKi)                  :: TGRID
   REAL(ReKi)                  :: Y
   REAL(ReKi)                  :: YGRID
   REAL(ReKi)                  :: Z
   REAL(ReKi)                  :: ZGRID

   INTEGER                    :: IDIM
   INTEGER                    :: IG
   INTEGER                    :: IT
   INTEGER                    :: ITHI
   INTEGER                    :: ITLO
   INTEGER                    :: IYHI
   INTEGER                    :: IYLO
   INTEGER                    :: IZHI
   INTEGER                    :: IZLO
   
   LOGICAL                    :: OnGrid
   
   !-------------------------------------------------------------------------------------------------
   ! Initialize variables
   !-------------------------------------------------------------------------------------------------

   FF_Interp(:)          = 0.0                         ! the output velocities (in case NFFComp /= 3)
   Wnd(:)                = 0.0                         ! just in case we're on an end point

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding time slices.
   !-------------------------------------------------------------------------------------------------

   ! Perform the time shift.  At time=0, a point half the grid width downstream (FFYHWid) will index into the zero time slice.  
   ! If we did not do this, any point downstream of the tower at the beginning of the run would index outside of the array.   
   ! This all assumes the grid width is at least as large as the rotor.  If it isn't, then the interpolation will not work.


   TimeShifted = TIME + ( InitXPosition - Position(1) )*InvMFFWS    ! in distance, X: InputInfo%Position(1) - InitXPosition - TIME*MeanFFWS
      

   IF ( Periodic ) THEN ! translate TimeShifted to ( 0 <= TimeShifted < TotalTime )

      TimeShifted = MODULO( TimeShifted, TotalTime )
   
      TGRID = TimeShifted*FFRate
      ITLO  = INT( TGRID )             ! convert REAL to INTEGER (add 1 later because our grids start at 1, not 0) 
      T     = TGRID - ITLO             ! a value between 0 and 1 that indicates a relative location between ITLO and ITHI   
      
      ITLO = ITLO + 1
      IF ( ITLO == NFFSteps ) THEN
         ITHI = 1
      ELSE
         ITHI = ITLO + 1
      END IF
      
      
   ELSE
   
      TGRID = TimeShifted*FFRate
      ITLO  = INT( TGRID )             ! convert REAL to INTEGER (add 1 later because our grids start at 1, not 0) 
      T     = TGRID - ITLO             ! a value between 0 and 1 that indicates a relative location between ITLO and ITHI   
   
      ITLO = ITLO + 1                  ! add one since our grids start at 1, not 0 
      ITHI = ITLO + 1   

      IF ( ITLO >= NFFSteps .OR. ITLO < 1 ) THEN
         IF ( ITLO == NFFSteps  ) THEN
            ITHI = ITLO   
            IF ( T <= TOL ) THEN ! we're on the last point
               T = 0.0
            ELSE  ! We'll extrapolate one dt past the last value in the file
               ITLO = ITHI - 1
            END IF         
         ELSE                 
            CALL WrScr( ' Error: FF wind array was exhausted at '//TRIM( Num2LStr( REAL( TIME,   ReKi ) ) )// & 
                           ' seconds (trying to access data at '//TRIM( Num2LStr( REAL( TimeShifted, ReKi ) ) )//' seconds).'  )
            ErrStat = 1   
            RETURN
         END IF
      ENDIF

   END IF


   !-------------------------------------------------------------------------------------------------
   ! Find the bounding rows for the Z position. [The lower-left corner is (1,1) when looking upwind.]
   !-------------------------------------------------------------------------------------------------

   ZGRID = ( Position(3) - GridBase )*InvFFZD

   IF (ZGRID > -1*TOL) THEN
      OnGrid = .TRUE.
      
      IZLO = INT( ZGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
      IZHI = IZLO + 1

      Z = ZGRID - ( IZLO - 1 )            ! a value between 0 and 1 that indicates a relative location between IZLO and IZHI

      IF ( IZLO < 1 ) THEN
         IF ( IZLO == 0 .AND. Z >= 1.0-TOL ) THEN
            Z    = 0.0 
            IZLO = 1
         ELSE
            CALL WrScr( ' Error: FF wind array boundaries violated. Grid too small in Z direction (Z='//&
                        TRIM(Num2LStr(Position(3)))//' m is below the grid).' )
            ErrStat = 1   
            RETURN
         END IF
      ELSEIF ( IZLO >= NZGrids ) THEN
         IF ( IZLO == NZGrids .AND. Z <= TOL ) THEN
            Z    = 0.0
            IZHI = IZLO                   ! We're right on the last point, which is still okay
         ELSE      
            CALL WrScr( ' Error: FF wind array boundaries violated. Grid too small in Z direction (Z='//&
                        TRIM(Num2LStr(Position(3)))//' m is above the grid).' )
            ErrStat = 3   
            RETURN
         END IF         
      ENDIF

   ELSE
   
      OnGrid = .FALSE.  ! this is on the tower
      
      IF ( NTGrids < 1 ) THEN
         CALL WrScr ( ' Error: FF wind array boundaries violated. Grid too small in Z direction '// &
                       '(height (Z='//TRIM(Num2LStr(Position(3)))//' m) is below the grid and no tower points are defined).' )
         ErrStat = 1
         RETURN
      END IF

      IZLO = INT( -1.0*ZGRID ) + 1            ! convert REAL to INTEGER, then add one since our grids start at 1, not 0      
      

      IF ( IZLO >= NTGrids ) THEN  !our dz is the difference between the bottom tower point and the ground
         IZLO = NTGrids
         
         Z    = 1.0 - Position(3) / (GridBase - (IZLO-1)/InvFFZD) !check that this isn't 0         
      ELSE
         Z    = ABS(ZGRID) - (IZLO - 1)
      END IF
      IZHI = IZLO + 1
            
   END IF


   IF ( OnGrid ) THEN      ! The tower points don't use this

      !-------------------------------------------------------------------------------------------------
      ! Find the bounding columns for the Y position. [The lower-left corner is (1,1) when looking upwind.]
      !-------------------------------------------------------------------------------------------------

         YGRID = ( Position(2) + FFYHWid )*InvFFYD    ! really, it's (Position(2) - -1.0*FFYHWid)

         IYLO = INT( YGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
         IYHI = IYLO + 1

         Y    = YGRID - ( IYLO - 1 )         ! a value between 0 and 1 that indicates a relative location between IYLO and IYHI
         
         IF ( IYLO >= NYGrids .OR. IYLO < 1 ) THEN
            IF ( IYLO == 0 .AND. Y >= 1.0-TOL ) THEN
               Y    = 0.0 
               IYLO = 1
            ELSE IF ( IYLO == NYGrids .AND. Y <= TOL ) THEN
               Y    = 0.0
               IYHI = IYLO                   ! We're right on the last point, which is still okay      
            ELSE
               CALL WrScr( ' Error FF wind array boundaries violated: Grid too small in Y direction. Y=' &
                             //TRIM(Num2LStr(Position(2)))//'; Y boundaries = ['//TRIM(Num2LStr(-1.0*FFYHWid)) &
                             //', '//TRIM(Num2LStr(FFYHWid))//']' )
               ErrStat = 2   
               RETURN
            END IF
         ENDIF

      !-------------------------------------------------------------------------------------------------
      ! Interpolate on the grid 
      !-------------------------------------------------------------------------------------------------

      DO IDIM=1,NFFComp       ! all the components

         IT = ITLO            ! Start using the ITLO slice
   
         DO IG=1,2            ! repeat for 2 time slices (by changing the value of IT. note that we can't loop from IXLO to IXHI because they could be NFFSteps and 1 respectively)

            !-------------------------------------------------------------------------------------------
            ! Get the wind velocity values for the four corners of the grid for this time.
            !-------------------------------------------------------------------------------------------

            W_YL_ZL = FFData( IZLO, IYLO, IDIM, IT )
            W_YL_ZH = FFData( IZHI, IYLO, IDIM, IT )
            W_YH_ZL = FFData( IZLO, IYHI, IDIM, IT )
            W_YH_ZH = FFData( IZHI, IYHI, IDIM, IT )


            !-------------------------------------------------------------------------------------------
            ! Interpolate within the grid for this time.
            !-------------------------------------------------------------------------------------------

            W_YL_Z  = ( W_YL_ZH - W_YL_ZL )*Z + W_YL_ZL
            W_YH_Z  = ( W_YH_ZH - W_YH_ZL )*Z + W_YH_ZL
            Wnd(IG) = ( W_YH_Z  - W_YL_Z  )*Y + W_YL_Z

            IT = ITHI            ! repeat for the using the ITHI slice

         END DO !IG

         !----------------------------------------------------------------------------------------------
         ! Interpolate between the two times.
         !----------------------------------------------------------------------------------------------
         
         FF_Interp(IDIM) = ( Wnd(2) - Wnd(1) ) * T + Wnd(1)    ! interpolated velocity
         
      END DO !IDIM

   ELSE
   
   !-------------------------------------------------------------------------------------------------
   ! Interpolate on the tower array
   !-------------------------------------------------------------------------------------------------
      
      DO IDIM=1,NFFComp    ! all the components

         IT = ITLO            ! Start using the ITLO slice

         DO IG=1,2            ! repeat for 2 time slices (by changing the value of IT. note that we can't loop from IXLO to IXHI because they could be NFFSteps and 1 respectively)

            !-------------------------------------------------------------------------------------------
            ! Get the wind velocity values for the two corners of the grid for this time.
            !-------------------------------------------------------------------------------------------

            W_YH_ZL = FFTower( IDIM, IZLO, IT )
            
            IF ( IZHI > NTGrids ) THEN
               W_YH_ZH = 0.0
            ELSE
               W_YH_ZH = FFTower( IDIM, IZHI, IT )
            END IF


            !-------------------------------------------------------------------------------------------
            ! Interpolate within the grid for this time.
            !-------------------------------------------------------------------------------------------

            Wnd(IG) = ( W_YH_ZH - W_YH_ZL )*Z + W_YH_ZL

            IT = ITHI            ! repeat for the using the ITHI slice

         END DO !IG

         !----------------------------------------------------------------------------------------------
         ! Interpolate between the two times.
         !----------------------------------------------------------------------------------------------
         
         FF_Interp(IDIM) = ( Wnd(2) - Wnd(1) ) * T + Wnd(1)    ! interpolated velocity
         
      END DO !IDIM
   
   END IF ! OnGrid

   RETURN
   
END FUNCTION FF_Interp
!====================================================================================================
SUBROUTINE FF_Terminate( ErrStat )
!  This subroutine cleans up any data that is still allocated.  The (possibly) open files are 
!  closed in InflowWindMod.
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   ErrStat = 0

   IF ( ALLOCATED( FFData  ) )   DEALLOCATE( FFData,  STAT=ErrStat )   
   IF ( ALLOCATED( FFTower ) )   DEALLOCATE( FFTower, STAT=ErrStat )   
   
   Initialized = .FALSE.


END SUBROUTINE FF_Terminate
!====================================================================================================
END MODULE FFWind

MODULE HAWCWind
!
!  This module uses full-field binary wind files to determine the wind inflow.
!  This module assumes that the origin, (0,0,0), is located at the tower centerline at ground level,
!  and that all units are specified in the metric system (using meters and seconds).
!  Data is assumed periodic in the X direction (and thus not shifted like FFWind files are).
!
!  Created 25-June-2010 by B. Jonkman, National Renewable Energy Laboratory
!     using subroutines and modules from AeroDyn v12.58
!
!----------------------------------------------------------------------------------------------------

   USE      NWTC_Library
   USE      SharedInflowDefs
   USE                     WindFile_Types

   IMPLICIT NONE

   PRIVATE                                                        ! By default, everything in HAWCWind is private (methods, data, types, etc.)
   
      
   REAL(ReKi), ALLOCATABLE          :: WindData  (:,:,:,:)        ! Array of FF data for all 3 wind components

   REAL(ReKi)                       :: deltaXInv                  ! multiplicative inverse of delta X
   REAL(ReKi)                       :: deltaYInv                  ! multiplicative inverse of delta Y
   REAL(ReKi)                       :: deltaZInv                  ! multiplicative inverse of delta Z

   INTEGER, PARAMETER               :: NC = 3                     ! number of wind components
   INTEGER                          :: NX                         ! number of points in the X direction
   INTEGER                          :: NY                         ! number of points in the Y direction
   INTEGER                          :: NZ                         ! number of points in the Z direction

   REAL(ReKi)                       :: GridBase                   ! the height of the bottom of the grid (Z direction) in meters
   REAL(ReKi)                       :: LengthX                    ! the grid length in the X direction (distance between point 1 and the next point 1 [because it is periodic])
   REAL(ReKi)                       :: LengthYHalf                ! half the grid width
   REAL(ReKi)                       :: RefHt                      ! the reference (hub) height of the grid in meters 
   REAL(ReKi)                       :: URef                       ! the mean wind speed in m/s at height RefHt meters (as defined in the input file)

         
   LOGICAL, SAVE                    :: Initialized = .FALSE.      ! flag that determines if the module has been initialized


   PUBLIC                           :: HW_Init                    ! initialization subroutine to read the FF grids
   PUBLIC                           :: HW_GetWindSpeed            ! interpolation function that returns velocities at specified time and space
   PUBLIC                           :: HW_GetValue                ! interface to return requested values
   PUBLIC                           :: HW_Terminate               ! subroutine that deallocates memory stored in the FFWind module

CONTAINS
!====================================================================================================
SUBROUTINE HW_Init ( UnWind, InpFileName, ErrStat )
!  This routine is used read the full-field turbulence data stored in HAWC format.
!----------------------------------------------------------------------------------------------------

   IMPLICIT                       NONE


      ! Passed Variables:
      
   INTEGER,      INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered
   
   CHARACTER(*), INTENT(IN)    :: InpFileName                  ! Name of the input text file

      ! Local Variables:

   REAL(SiKi)                  :: DumReal                      ! real variable to temporarially store values read from binary file

   REAL(ReKi)                  :: dx
   REAL(ReKi)                  :: dy
   REAL(ReKi)                  :: dz
   REAL(ReKi)                  :: PLExp                        ! Power law exponent, for the PL mean wind profile type
   REAL(ReKi)                  :: U                            ! The mean wind speed
   REAL(ReKi)                  :: Z                            ! The height above ground/sea level
   REAL(ReKi)                  :: Z0                           ! Surface layer roughness length in meters, used for LOG profile type
    
  
   INTEGER                     :: IC                           ! Loop counter for the number of wind components
   INTEGER                     :: IX                           ! Loop counter for the number of grid points in the X direction
   INTEGER                     :: IY                           ! Loop counter for the number of grid points in the Y direction
   INTEGER                     :: IZ                           ! Loop counter for the number of grid points in the Z direction

   CHARACTER( 1024 )           :: DataFiles ( 3 )              ! Names of the files containing the 3 wind components   
   CHARACTER(3)                :: WindProfileType              ! character code of mean wind profile type


   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' HAWCWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
!      CALL NWTC_Init()    ! Initialized in IfW_Init
   END IF   

! bjj: this (reading the file) should perhaps be in a subroutine...

   !-------------------------------------------------------------------------------------------------
   ! Open the text file 
   !-------------------------------------------------------------------------------------------------

   CALL OpenFInpFile ( UnWind, TRIM(InpFileName), ErrStat )
   IF (ErrStat /= 0) RETURN

   
   !-------------------------------------------------------------------------------------------------
   ! Read some header information in the text file 
   !-------------------------------------------------------------------------------------------------
   
   CALL ReadCom( UnWind, InpFileName, 'Header 1', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Header 2', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Header 3', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Header 4', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Parameters for HAWC-format binary files', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   
   !-------------------------------------------------------------------------------------------------
   ! Read file names and scaling info from the file
   !-------------------------------------------------------------------------------------------------

   CALL ReadVar( UnWind, InpFileName, DataFiles(1), 'FileName_u', 'Name of the u-component binary file', ErrStat )
   IF (ErrStat /= 0) RETURN

   CALL ReadVar( UnWind, InpFileName, DataFiles(2), 'FileName_v', 'Name of the v-component binary file', ErrStat )
   IF (ErrStat /= 0) RETURN

   CALL ReadVar( UnWind, InpFileName, DataFiles(3), 'FileName_w', 'Name of the w-component binary file', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, InpFileName, NX, 'nx', 'Number of grid points in the X direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( NX < 1 ) THEN
      CALL WrScr ( ' HAWCWind error reading "nx": number of grid points in the X direction must be at least 1.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, NY, 'ny', 'Number of grid points in the Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( NY < 1 ) THEN
      CALL WrScr ( ' HAWCWind error reading "ny": number of grid points in the Y direction must be at least 1.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, NZ, 'nz', 'Number of grid points in the Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( NZ < 1 ) THEN
      CALL WrScr ( ' HAWCWind error reading "nz": number of grid points in the Z direction must be at least 1.')
      ErrStat = 1
      RETURN
   END IF
   

   CALL ReadVar( UnWind, InpFileName, dx, 'dx', 'Distance between two points in the X direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( DX < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "dx": the grid spacing in the X direction must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, dy, 'dy', 'Distance between two points in the Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( DY < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "dy": the grid spacing in the Y direction must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, dz, 'dz', 'Distance between two points in the Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( DZ < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "dz": the grid spacing in the Z direction must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, RefHt, 'RefHt', 'Grid reference height', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( RefHt < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "RefHt": the grid reference height must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF

 
   !-------------------------------------------------------------------------------------------------
   ! Read the section to determine the mean wind profile
   !-------------------------------------------------------------------------------------------------
 
   CALL ReadCom( UnWind, InpFileName, 'mean wind profile parameters (added to HAWC-format files)', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, InpFileName, WindProfileType, 'WindProfileType', 'Wind profile type', ErrStat )
   IF (ErrStat /= 0) RETURN

    
   CALL ReadVar( UnWind, InpFileName, URef, 'URef', 'Reference wind speed', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( URef < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error: the reference wind speed, URef, must not be negative.' )
      ErrStat = 1
      RETURN   
   END IF

    
   CALL ReadVar( UnWind, InpFileName, PLExp, 'PLExp', 'Power law exponent', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, InpFileName, Z0, 'Z0', 'Surface roughness length', ErrStat )   
   IF (ErrStat /= 0) RETURN  
   
   IF ( Z0 <= EPSILON(Z0) ) THEN
      CALL WrScr ( ' HAWCWind error: the surface roughness length, Z0, must be greater than zero.' )
      ErrStat = 1
      RETURN   
   END IF
   
   !-------------------------------------------------------------------------------------------------
   ! Close the file.
   !-------------------------------------------------------------------------------------------------

   CLOSE ( UnWind )


   !-------------------------------------------------------------------------------------------------
   ! Set some internal module parameters based on input file values
   !-------------------------------------------------------------------------------------------------

   LengthX     = dx*nx !(nx-1)   !because the turbulence box is periodic in the X direction, we need to consider the length between point 1 and the next point 1 (instead of between points 1 and nx)
   LengthYHalf = 0.5*dy*(ny-1)
   GridBase    = RefHt - 0.5*(nz-1)*dz

   IF ( GridBase <= 0.0 ) THEN
      CALL WrScr( ' HAWCWind error: the bottom of the grid is located at a height of '//&
                      TRIM( Num2LStr(GridBase) )//' meters, which is below the ground.' )
      ErrStat = 1
      RETURN
   END IF 


   deltaXInv   = 1.0 / dx
   deltaYInv   = 1.0 / dy
   deltaZInv   = 1.0 / dz
   
   
   !-------------------------------------------------------------------------------------------------
   ! Allocate space for the wind arrays.
   !-------------------------------------------------------------------------------------------------

   IF (.NOT. ALLOCATED(WindData) ) THEN
      ALLOCATE( WindData( NZ, NY, NX, NC ), STAT=ErrStat )
      IF ( ErrStat /= 0 ) THEN
         CALL WrScr ( " Error allocating space for HAWCWind's WindData array." )
         RETURN
      END IF
   END IF
      

   !-------------------------------------------------------------------------------------------------
   ! Read the 3 files containg the turbulent wind speeds.
   !-------------------------------------------------------------------------------------------------
!bjj: check these indices... they do not seem to be very consistant between the WAsP IEC Turbulence
!     simulator and documentation of OC3 file formats... the current implementation is from the 
!     OC3/Kenneth Thompson documentation.

      ! The array must be filled so that x(i) < x(i+1), y(i) < y(i+1), and z(i) < z(i+1)
      ! Also, note that the time axis is the negative x axis.

   DO IC = 1,NC
   
      CALL OpenBInpFile ( UnWind, DataFiles(IC), ErrStat )
   
      DO IX = NX,1,-1                  ! Time is the opposite of X ....
         DO IY = NY,1,-1
            DO IZ = 1,NZ 
            
               READ( UnWind, IOSTAT=ErrStat ) DumReal
               
               WindData( IZ, IY, IX, IC ) = DumReal    ! possible type conversion here
               
               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading binary data from "'//TRIM(DataFiles(IC))//'".' )
                  CALL WrScr( ' I/O error '//TRIM(Num2LStr(ErrStat))//' occurred at IZ='//TRIM(Num2LStr(IZ))//&
                                                   ', IY='//TRIM(Num2LStr(IY))//', IX='//TRIM(Num2LStr(IX))//'.' )
                  CLOSE ( UnWind )
                  RETURN
               END IF
                              
            END DO
         END DO
      END DO
      
      CLOSE ( UnWind )
      
   END DO

   
   !-------------------------------------------------------------------------------------------------
   ! Add the mean wind speed to the u component.
   !-------------------------------------------------------------------------------------------------

   CALL Conv2UC( WindProfileType )
                 
   
   IF ( RefHt > 0.0 ) THEN
   
      DO IZ = 1,NZ

         Z = GridBase  + ( IZ - 1 )*dz
         
         SELECT CASE ( TRIM(WindProfileType) )
   
            CASE ( 'PL' )         
               U = URef*( Z / RefHt )**PLExp      ! [IEC 61400-1 6.3.1.2 (10)]
      
            CASE ( 'LOG' )
            
               IF ( Z /= Z0 ) THEN
                  U = URef*( LOG( Z / Z0 ) )/( LOG( RefHt / Z0 ) )
               ELSE
                  U = 0.0
               ENDIF
            
            CASE DEFAULT
            
               CALL WrScr( ' Invalid wind profile type in HAWCWind.' )
               ErrStat = 1
               RETURN
      
         END SELECT
   
         WindData( IZ, :, :, 1 ) = WindData( IZ, :, :, 1 ) + U
            

      END DO ! IZ
   END IF ! RefHt
   
   
   !-------------------------------------------------------------------------------------------------
   ! Set initialized flag and return
   !-------------------------------------------------------------------------------------------------
   
   Initialized = .TRUE.

   RETURN
   
END SUBROUTINE HW_Init
!====================================================================================================
FUNCTION HW_GetValue(RVarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the RVarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------

   CHARACTER(*),   INTENT(IN)    :: RVarName
   INTEGER,        INTENT(OUT)   :: ErrStat
   REAL(ReKi)                    :: HW_GetValue

   
   CHARACTER(20)                 :: VarNameUC
   

   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the HAWCWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = RVarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
   
      CASE ( 'REFHEIGHT' )
         HW_GetValue = RefHt
         
      CASE ('GRIDWIDTH' )
         HW_GetValue = LengthYHalf*2

      CASE ('GRIDHEIGHT' )
         HW_GetValue = NZ/deltaZInv
         
      CASE ('UREF' )
         HW_GetValue = URef        
         
      CASE DEFAULT
         CALL WrScr( ' HAWCWind error: invalid variable name in HW_GetRValue().' )
         ErrStat = 1
         
   END SELECT

END FUNCTION HW_GetValue
!!====================================================================================================
FUNCTION HW_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are are 
! requested.  It determines if the point is on the FF grid or tower points and calls the
! corresponding interpolation routine, which returns the velocities at the specified time and space.
!----------------------------------------------------------------------------------------------------
   
   REAL(ReKi),        INTENT(IN) :: Time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)
   INTEGER,           INTENT(OUT):: ErrStat
   TYPE(InflIntrpOut)            :: HW_GetWindSpeed
     
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   
   
   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FFWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      

   
   !-------------------------------------------------------------------------------------------------
   ! interpolate and return the value.
   !-------------------------------------------------------------------------------------------------   

    HW_GetWindSpeed%Velocity = HW_LinearInterp(Time,InputPosition, ErrStat)


END FUNCTION HW_GetWindSpeed
!====================================================================================================
FUNCTION HW_LinearInterp(Time, Position, ErrStat)
!    This function is used to interpolate into the full-field wind array for the given inputs. It receives 
!    X, Y, Z and TIME from the calling routine.  It then computes a time shift in the X axis based upon 
!    the average windspeed.  The modified position is used to decide which pair of X grids to interpolate
!    within and between.  After finding the two X slices, it decides which four grid points bound the 
!    (Y,Z) pair.  It does a bilinear interpolation for each X slice. Linear interpolation is then used 
!    to interpolate between the X slices.  This routine assumes that X is downwind, Y is to the left when  
!    looking downwind and Z is up.  It also assumes that no extrapolation will be needed.
!    
!    If tower points are used, it assumes the velocity at the ground is 0.  It interpolates between
!    heights and between time slices, but ignores the Y input.
!
!    09/23/09 - Modified by B. Jonkman to use arguments instead of modules to determine time and position.  
!               Height is now relative to the ground
!
!----------------------------------------------------------------------------------------------------

   IMPLICIT                      NONE

   REAL(ReKi),      INTENT(IN) :: Position(3)       ! takes the place of XGrnd, YGrnd, ZGrnd
   REAL(ReKi),      INTENT(IN) :: Time
   REAL(ReKi)                  :: HW_LinearInterp(3)      ! The U, V, W velocities

   INTEGER,         INTENT(OUT):: ErrStat

      ! Local Variables:

   REAL(ReKi)                  :: ShiftedXPosition
   REAL(ReKi),PARAMETER        :: Tol = 1.0E-3      ! a tolerance for determining if two reals are the same (for extrapolation)
   REAL(ReKi)                  :: W_YH_Z
   REAL(ReKi)                  :: W_YH_ZH
   REAL(ReKi)                  :: W_YH_ZL
   REAL(ReKi)                  :: W_YL_Z
   REAL(ReKi)                  :: W_YL_ZH
   REAL(ReKi)                  :: W_YL_ZL
   REAL(ReKi)                  :: Wnd      (2)
   REAL(ReKi)                  :: X                 ! a value between 0 and 1 that indicates a relative location between IXLO and IXHI
   REAL(ReKi)                  :: XGRID             ! the position in the X direction relative to the first grid point
   REAL(ReKi)                  :: Y                 ! a value between 0 and 1 that indicates a relative location between IYLO and IYHI
   REAL(ReKi)                  :: YGRID             ! the position in the Y direction relative to the first grid point
   REAL(ReKi)                  :: Z                 ! a value between 0 and 1 that indicates a relative location between IZLO and IZHI
   REAL(ReKi)                  :: ZGRID             ! the position in the Z direction relative to the first grid point             

   INTEGER                     :: IC                ! loop counter for number of grid points
   INTEGER                     :: IG                ! loop counter for X grids
   INTEGER                     :: IX                ! variable to store IXLO and IXHI while looping
   INTEGER                     :: IXHI              ! high index into the array in the X dimension
   INTEGER                     :: IXLO              ! low  index into the array in the X dimension
   INTEGER                     :: IYHI              ! high index into the array in the Y dimension
   INTEGER                     :: IYLO              ! low  index into the array in the Y dimension
   INTEGER                     :: IZHI              ! high index into the array in the Z dimension
   INTEGER                     :: IZLO              ! low  index into the array in the Z dimension
   
   
   !-------------------------------------------------------------------------------------------------
   ! Initialize variables
   !-------------------------------------------------------------------------------------------------

   HW_LinearInterp(:)    = 0.0                         ! the output velocities (in case NFFComp /= 3)
   Wnd(:)                = 0.0                         ! just in case we're on an end point

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding X slices.
   !-------------------------------------------------------------------------------------------------

! bjj: should we shift by MIN(YHalfWid,FFZHWid)?
         
         ! Assume Taylor's Frozen Turbulence Hypothesis applies: u(X,Y,Z,t) = u( X-U*t, Y, Z, 0)

   ShiftedXPosition = Position(1) - TIME*URef      !this puts the first X grid point at the undeflected tower centerline

   
      ! The wind file is periodic so we'll translate this position to ( 0 <= ShiftedXPosition < LengthX )
   
   ShiftedXPosition = MODULO( ShiftedXPosition, LengthX )
    
   XGrid            = ShiftedXPosition*deltaXInv
   
   IXLO = INT( XGrid ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
   
   IF ( IXLO == NX ) THEN
      IXHI = 1
   ELSE
      IXHI = IXLO + 1
      
! BJJ: assuming LengthX and NX have been correctly defined, this cannot happen:      
!      IF ( IXLO > NX .OR. IXLO < 1 ) THEN
!            CALL WrScr( ' HAWCWind error: wind array was exhausted at '//TRIM( Num2LStr( REAL( TIME,   ReKi ) ) )//' seconds '//& 
!                        '(trying to access X data at '//TRIM( Num2LStr( REAL( ShiftedXPosition, ReKi ) ) )//' m).'  )
!            ErrStat = 1   
!            RETURN
!      ENDIF
      
   END IF
   
   X = XGrid - ( IXLO - 1 )         ! a value between 0 and 1 that indicates a relative location between IXLO and IXHI

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding rows for the Z position. [The lower-left corner is (1,1) when looking upwind.]
   !-------------------------------------------------------------------------------------------------

   ZGRID = ( Position(3) - GridBase )*deltaZInv

     
   IZLO = INT( ZGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
   IZHI = IZLO + 1

   Z = ZGRID - ( IZLO - 1 )            ! a value between 0 and 1 that indicates a relative location between IZLO and IZHI

   IF ( IZLO < 1 ) THEN
      IF ( IZLO == 0 .AND. Z >= 1.0-TOL ) THEN
         Z    = 0.0 
         IZLO = 1
      ELSE
         CALL WrScr( ' HAWCWind error: wind array boundaries violated. Grid too small in Z direction (Z='//&
                     TRIM(Num2LStr(Position(3)))//' m is below the grid).' )
         ErrStat = 1   
         RETURN
      END IF
   ELSEIF ( IZLO >= NZ ) THEN
      IF ( IZLO == NZ .AND. Z <= TOL ) THEN
         Z    = 0.0
         IZHI = IZLO                   ! We're right on the last point, which is still okay
      ELSE      
         CALL WrScr( ' HAWCWind error: wind array boundaries violated. Grid too small in Z direction (Z='//&
                     TRIM(Num2LStr(Position(3)))//' m is above the grid).' )
         ErrStat = 3   
         RETURN
      END IF         
   ENDIF
   

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding columns for the Y position. [The lower-left corner is (1,1) when looking upwind.]
   !-------------------------------------------------------------------------------------------------

   YGRID = ( Position(2) + LengthYHalf )*deltaYInv    ! really, it's (Position(2) - -1.0*YHalfWid)

   IYLO = INT( YGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
   IYHI = IYLO + 1

   Y    = YGRID - ( IYLO - 1 )         ! a value between 0 and 1 that indicates a relative location between IYLO and IYHI
   
   IF ( IYLO >= NY .OR. IYLO < 1 ) THEN
      IF ( IYLO == 0 .AND. Y >= 1.0-TOL ) THEN
         Y    = 0.0 
         IYLO = 1
      ELSE IF ( IYLO == NY .AND. Y <= TOL ) THEN
         Y    = 0.0
         IYHI = IYLO                   ! We're right on the last point, which is still okay      
      ELSE
         CALL WrScr( ' HAWCWind error: wind array boundaries violated: Grid too small in Y direction. Y=' &
                        //TRIM(Num2LStr(Position(2)))//'; Y boundaries = ['//TRIM(Num2LStr(-1.0*LengthYHalf)) &
                        //', '//TRIM(Num2LStr(LengthYHalf))//']' )
         ErrStat = 2   
         RETURN
      END IF
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Interpolate on the Y-Z grid for each X (time) slice
   !-------------------------------------------------------------------------------------------------

   DO IC=1,NC            ! all the components

      IX = IXLO          ! start using the first time (X) slice

      DO IG = 1,2        ! repeat for 2 time slices (by changing the value of IX. note that we can't loop from IXLO to IXHI because they could be NX and 1 respectively)

         !-------------------------------------------------------------------------------------------
         ! Get the wind velocity values for the four corners of the grid for this time.
         !-------------------------------------------------------------------------------------------

         W_YL_ZL = WindData( IZLO, IYLO, IX, IC )
         W_YL_ZH = WindData( IZHI, IYLO, IX, IC )
         W_YH_ZL = WindData( IZLO, IYHI, IX, IC )
         W_YH_ZH = WindData( IZHI, IYHI, IX, IC )


         !-------------------------------------------------------------------------------------------
         ! Interpolate within the grid for this time.
         !-------------------------------------------------------------------------------------------

         W_YL_Z  = ( W_YL_ZH - W_YL_ZL )*Z + W_YL_ZL
         W_YH_Z  = ( W_YH_ZH - W_YH_ZL )*Z + W_YH_ZL
         Wnd(IG) = ( W_YH_Z  - W_YL_Z  )*Y + W_YL_Z

         IX = IXHI  ! repeat for the second time (X) slice

      END DO !IX

      !----------------------------------------------------------------------------------------------
      ! Interpolate between the two times.
      !----------------------------------------------------------------------------------------------
      
      HW_LinearInterp( IC ) = ( Wnd(2) - Wnd(1) ) * X + Wnd(1)    ! interpolated velocity
      
   END DO !IDIM


   RETURN
   
END FUNCTION HW_LinearInterp
!====================================================================================================
SUBROUTINE HW_Terminate( ErrStat )
!  This subroutine cleans up any data that is still allocated.  The (possibly) open files are 
!  closed in InflowWindMod.
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   ErrStat = 0

   IF ( ALLOCATED( WindData  ) )   DEALLOCATE( WindData,  STAT=ErrStat )   
   
   Initialized = .FALSE.


END SUBROUTINE HW_Terminate
!====================================================================================================
END MODULE HAWCWind
MODULE HHWind
! This module contains all the data and procedures that define hub-height wind files. This could 
! more accurately be called a point wind file since the wind speed at any point is calculated by 
! shear applied to the point where wind is defined.  It is basically uniform wind over the rotor disk.
! The entire file is read on initialization, then the columns that make up the wind file are
! interpolated to the time requested, and wind is calculated based on the location in space.
!
! the file contains header information (rows that contain "!"), followed by numeric data stored in
! 8 columns:   (1) Time                                  [s]
!              (2) Horizontal wind speed       (V)       [m/s]
!              (3) Wind direction              (Delta)   [deg]
!              (4) Vertical wind speed         (VZ)      [m/s]
!              (5) Horizontal linear shear     (HLinShr) [-]
!              (6) Vertical power-law shear    (VShr)    [-]
!              (7) Vertical linear shear       (VLinShr) [-]
!              (8) Gust (horizontal) velocity  (VGust)   [m/s]
!
! The horizontal wind speed at (X, Y, Z) is then calculated using the interpolated columns by
!   Vh = V * ( Z/RefHt ) ** VShr                                        ! power-law wind shear
!      + V * HLinShr/RefWid * ( Y * COS(Delta) + X * SIN(Delta) )       ! horizontal linear shear
!      + V * VLinShr/RefWid * ( Z-RefHt )                               ! vertical linear shear
!      + VGust                                                          ! gust speed
!----------------------------------------------------------------------------------------------------

   USE                     NWTC_Library
   USE                     SharedInflowDefs
   USE                     WindFile_Types
   
   IMPLICIT                NONE
   PRIVATE

      
   REAL(ReKi), ALLOCATABLE      :: Tdata  (:)                              ! Time array from the HH wind file
   REAL(ReKi), ALLOCATABLE      :: DELTA  (:)                              ! HH Wind direction (angle)
   REAL(ReKi), ALLOCATABLE      :: V      (:)                              ! HH horizontal wind speed
   REAL(ReKi), ALLOCATABLE      :: VZ     (:)                              ! wind, including tower shadow, along the Z axis
   REAL(ReKi), ALLOCATABLE      :: HSHR   (:)                              ! HH Horizontal linear shear
   REAL(ReKi), ALLOCATABLE      :: VSHR   (:)                              ! HH vertical shear exponent
   REAL(ReKi), ALLOCATABLE      :: VLINSHR(:)                              ! HH vertical linear shear
   REAL(ReKi), ALLOCATABLE      :: VGUST  (:)                              ! HH wind gust

   REAL(ReKi)                   :: LinearizeDels(7)                        ! The delta values for linearization -- perhaps at some point, this could be T/F and we determine the deltas by sqrt(eps) or something similar
   REAL(ReKi)                   :: RefHt                                   ! reference height; was HH (hub height); used to center the wind
   REAL(ReKi)                   :: RefWid                                  ! reference width; was 2*R (=rotor diameter); used to scale the linear shear
   
   INTEGER                      :: NumDataLines
   INTEGER, SAVE                :: TimeIndx = 0                            ! An index into the Tdata array (to allow us faster searching, starting search from previous one)

   LOGICAL, SAVE                :: Linearize = .FALSE.                     ! If this is TRUE, we are linearizing
   
   TYPE, PUBLIC                 :: HH_Info
      REAL(ReKi)                :: ReferenceHeight
      REAL(ReKi)                :: Width
   END TYPE HH_Info
      
   PUBLIC                       :: HH_Init
   PUBLIC                       :: HH_GetWindSpeed
   PUBLIC                       :: HH_Terminate
   PUBLIC                       :: HH_SetLinearizeDels
   PUBLIC                       :: HH_Get_ADhack_WindSpeed                  ! REMOVE THIS!!!!

CONTAINS
!====================================================================================================
SUBROUTINE HH_Init(UnWind, WindFile, WindInfo, ErrStat)
! A subroutine to initialize the HHWind module.  It reads the HH file and stores the data in an
! array to use later.  It requires an initial reference height (hub height) and width (rotor diameter),
! both in meters, which are used to define the volume where wind velocities will be calculated.  This
! information is necessary because of the way the shears are defined.
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,      INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered
   TYPE(HH_Info),INTENT(IN)    :: WindInfo                     ! Additional information needed to initialize this wind type
   
   CHARACTER(*), INTENT(IN)    :: WindFile                     ! Name of the text HH wind file

      ! local variables
            
   INTEGER, PARAMETER          :: NumCols = 8                  ! Number of columns in the HH file
   REAL(ReKi)                  :: TmpData(NumCols)             ! Temp variable for reading all columns from a line 
   REAL(ReKi)                  :: DelDiff                      ! Temp variable for storing the direction difference

   INTEGER                     :: I
   INTEGER                     :: NumComments
   INTEGER                     :: ILine                        ! Counts the line number in the file
   INTEGER, PARAMETER          :: MaxTries = 100
   CHARACTER(1024)             :: Line                         ! Temp variable for reading whole line from file

    
   !-------------------------------------------------------------------------------------------------
   ! Check that it's not already initialized
   !-------------------------------------------------------------------------------------------------
      
   IF ( TimeIndx /= 0 ) THEN  
      CALL WrScr( ' HHWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
!      CALL NWTC_Init()    ! Initialized in IfW_Init
      
      LinearizeDels(:) = 0.0
      Linearize        = .FALSE.
   END IF   

  
   !-------------------------------------------------------------------------------------------------
   ! Open the file for reading
   !-------------------------------------------------------------------------------------------------
   CALL OpenFInpFile (UnWind, TRIM(WindFile), ErrStat)
   
   IF ( ErrStat /= 0 ) RETURN

   !-------------------------------------------------------------------------------------------------
   ! Find the number of comment lines
   !-------------------------------------------------------------------------------------------------
   LINE = '!'                          ! Initialize the line for the DO WHILE LOOP
   NumComments = -1
   
   DO WHILE (INDEX( LINE, '!' ) > 0 ) ! Lines containing "!" are treated as comment lines
      NumComments = NumComments + 1
      
      READ(UnWind,'( A )',IOSTAT=ErrStat) LINE
            
      IF ( ErrStat /=0 ) THEN
         CALL WrScr ( ' Error reading from HH wind file on line '//TRIM(Num2LStr(NumComments))//'.' )
         RETURN
      END IF
      
   END DO !WHILE
   
   !-------------------------------------------------------------------------------------------------
   ! Find the number of data lines
   !-------------------------------------------------------------------------------------------------
   NumDataLines = 0
   
   READ(LINE,*,IOSTAT=ErrStat) ( TmpData(I), I=1,NumCols )

   DO WHILE (ErrStat == 0)  ! read the rest of the file (until an error occurs)
      NumDataLines = NumDataLines + 1               
      
      READ(UnWind,*,IOSTAT=ErrStat) ( TmpData(I), I=1,NumCols )

   END DO !WHILE


   IF (NumDataLines < 1) THEN
      CALL WrScr ( ' Error reading data from HH wind file on line '//TRIM(Num2LStr(NumDataLines+NumComments))//'.' )
      RETURN
   ELSE
      CALL WrScr ( ' Reading '//TRIM(Num2LStr(NumDataLines))//' lines of data from the HH wind file.' )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Allocate arrays for the HH data
   !-------------------------------------------------------------------------------------------------
   ! BJJ note: If the subroutine AllocAry() is called, the CVF compiler with A2AD does not work
   !   properly.  The arrays are not properly read even though they've been allocated.
   !-------------------------------------------------------------------------------------------------
   
   IF (.NOT. ALLOCATED(Tdata) ) THEN
      ALLOCATE ( Tdata(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH time array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(V) ) THEN
      ALLOCATE ( V(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH horizontal wind speed array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(Delta) ) THEN
      ALLOCATE ( Delta(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH wind direction array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VZ) ) THEN
      ALLOCATE ( VZ(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH vertical wind speed array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(HShr) ) THEN
      ALLOCATE ( HShr(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH horizontal linear shear array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VShr) ) THEN
      ALLOCATE ( VShr(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH vertical power-law shear exponent array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VLinShr) ) THEN
      ALLOCATE ( VLinShr(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH vertical linear shear array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VGust) ) THEN
      ALLOCATE ( VGust(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH gust velocity array.' )
         RETURN
      END IF   
   END IF
   

   !-------------------------------------------------------------------------------------------------
   ! Rewind the file (to the beginning) and skip the comment lines
   !-------------------------------------------------------------------------------------------------
   REWIND( UnWind )
   
   DO I=1,NumComments
      CALL ReadCom( UnWind, TRIM(WindFile), 'Header line #'//TRIM(Num2LStr(I)), ErrStat )
      IF ( ErrStat /= 0 ) RETURN
   END DO !I


   !-------------------------------------------------------------------------------------------------
   ! Read the data arrays
   !-------------------------------------------------------------------------------------------------

   DO I=1,NumDataLines
         
      CALL ReadAry( UnWind, TRIM(WindFile), TmpData(1:NumCols), NumCols, 'TmpData', & 
                'Data from HH line '//TRIM(Num2LStr(NumComments+I)), ErrStat )
      IF (ErrStat /= 0) RETURN
                 
      Tdata(  I) = TmpData(1)
      V(      I) = TmpData(2)
      Delta(  I) = TmpData(3)*D2R 
      VZ(     I) = TmpData(4)
      HShr(   I) = TmpData(5)
      VShr(   I) = TmpData(6)
      VLinSHR(I) = TmpData(7)
      VGust(  I) = TmpData(8)           
      
   END DO !I


   !-------------------------------------------------------------------------------------------------
   ! Make sure the wind direction isn't jumping more than 180 degrees between any 2 consecutive
   ! input times.  (Avoids interpolation errors with modular arithemetic.)
   !-------------------------------------------------------------------------------------------------

   DO I=2,NumDataLines
   
      ILine = 1
      
      DO WHILE ( ILine < MaxTries )
     
         DelDiff = ( Delta(I) - Delta(I-1) )

         IF ( ABS( DelDiff ) < Pi ) EXIT  ! exit inner loop

         Delta(I) = Delta(I) - SIGN( TwoPi, DelDiff )
         
         ILine = ILine + 1

      END DO
      
      IF ( ILine >= MaxTries ) THEN
         CALL WrScr( ' Error calculating wind direction from HH file. Delta(' &
               // TRIM(Num2LStr(I  )) // ') = ' // TRIM(Num2LStr(Delta(I))) // '; Delta(' & 
               // TRIM(Num2LStr(I+1)) // ') = ' // TRIM(Num2LStr(Delta(I+1))) )
         ErrStat = 1
      END IF
           

   END DO !I


   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
   
   CLOSE( UnWind )
   

   !-------------------------------------------------------------------------------------------------
   ! Print warnings and messages
   !-------------------------------------------------------------------------------------------------
!   CALL WrScr ( ' Processed '//TRIM( Num2LStr( NumDataLines ) )//' records of HH data' )
   
   
   IF ( Tdata(1) > 0.0 ) THEN
      CALL ProgWarn( 'The hub-height wind file : "'//TRIM(ADJUSTL(WindFile))//'" starts at a time '// & 
                     'greater than zero. Interpolation errors may result.')
   ENDIF
   
   IF ( NumDataLines == 1 ) THEN
      CALL WrScr( ' Only 1 line in HH wind file. Steady, hub-height horizontal wind speed = '//TRIM(Num2LStr(V(1)))//' m/s.' )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Set the initial index into the time array (it indicates that we've initialized the module, too)
   ! and initialize the spatial scaling for the wind calculations
   !-------------------------------------------------------------------------------------------------
   TimeIndx = 1            

   RefHt  = WindInfo%ReferenceHeight
   RefWid = WindInfo%Width   


   RETURN
     
END SUBROUTINE HH_Init
!====================================================================================================
FUNCTION HH_GetWindSpeed(Time, InputPosition, ErrStat)
! This subroutine linearly interpolates the columns in the HH input file to get the values for 
! the requested time, then uses the interpolated values to calclate the wind speed at a point
! in space represented by InputPosition.
!----------------------------------------------------------------------------------------------------

   REAL(ReKi),        INTENT(IN) :: Time                 ! time from the start of the simulation
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)     ! input information: positions X,Y,Z
   INTEGER,           INTENT(OUT):: ErrStat              ! error status
   TYPE(InflIntrpOut)            :: HH_GetWindSpeed      ! return velocities (U,V,W)
   
   REAL(ReKi)                    :: CosDelta             ! cosine of Delta_tmp
   REAL(ReKi)                    :: Delta_tmp            ! interpolated Delta   at input TIME
   REAL(ReKi)                    :: HShr_tmp             ! interpolated HShr    at input TIME
   REAL(ReKi)                    :: P                    ! temporary storage for slope (in time) used in linear interpolation
   REAL(ReKi)                    :: SinDelta             ! sine of Delta_tmp
   REAL(ReKi)                    :: V_tmp                ! interpolated V       at input TIME
   REAL(ReKi)                    :: VGust_tmp            ! interpolated VGust   at input TIME
   REAL(ReKi)                    :: VLinShr_tmp          ! interpolated VLinShr at input TIME
   REAL(ReKi)                    :: VShr_tmp             ! interpolated VShr    at input TIME
   REAL(ReKi)                    :: VZ_tmp               ! interpolated VZ      at input TIME
   REAL(ReKi)                    :: V1                   ! temporary storage for horizontal velocity
   

   !-------------------------------------------------------------------------------------------------
   ! verify the module was initialized first
   !-------------------------------------------------------------------------------------------------

   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Error: Call HH_Init() before getting wind speed.')
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
      
   !-------------------------------------------------------------------------------------------------
   ! Linearly interpolate in time (or used nearest-neighbor to extrapolate) 
   ! (compare with NWTC_Num.f90\InterpStpReal)
   !-------------------------------------------------------------------------------------------------

    IF ( Linearize ) THEN  !get the perturbed wind speed

      TimeIndx      = 1
      V_tmp         = V      (1) + LinearizeDels(1)
      Delta_tmp     = Delta  (1) + LinearizeDels(2)
      VZ_tmp        = VZ     (1) + LinearizeDels(3)
      HShr_tmp      = HShr   (1) + LinearizeDels(4)
      VShr_tmp      = VShr   (1) + LinearizeDels(5)
      VLinShr_tmp   = VLinShr(1) + LinearizeDels(6)
      VGust_tmp     = VGust  (1) + LinearizeDels(7)

      ! Let's check the limits.
   ELSE IF ( Time <= Tdata(1) .OR. NumDataLines == 1 )  THEN
   
      TimeIndx      = 1
      V_tmp         = V      (1)
      Delta_tmp     = Delta  (1)
      VZ_tmp        = VZ     (1)
      HShr_tmp      = HShr   (1)
      VShr_tmp      = VShr   (1)
      VLinShr_tmp   = VLinShr(1)
      VGust_tmp     = VGust  (1)   
         
   ELSE IF ( Time >= Tdata(NumDataLines) )  THEN
   
      TimeIndx      = NumDataLines - 1
      V_tmp         = V      (NumDataLines)
      Delta_tmp     = Delta  (NumDataLines)
      VZ_tmp        = VZ     (NumDataLines)
      HShr_tmp      = HShr   (NumDataLines)
      VShr_tmp      = VShr   (NumDataLines)
      VLinShr_tmp   = VLinShr(NumDataLines)
      VGust_tmp     = VGust  (NumDataLines)
      
   ELSE
   
         ! Let's interpolate!

      TimeIndx = MAX( MIN( TimeIndx, NumDataLines-1 ), 1 )

      DO

         IF ( Time < Tdata(TimeIndx) )  THEN

            TimeIndx = TimeIndx - 1

         ELSE IF ( Time >= Tdata(TimeIndx+1) )  THEN

            TimeIndx = TimeIndx + 1

         ELSE
            P           = ( Time - Tdata(TimeIndx) )/( Tdata(TimeIndx+1) - Tdata(TimeIndx) )
            V_tmp       = ( V(      TimeIndx+1) - V(      TimeIndx) )*P + V(      TimeIndx)
            Delta_tmp   = ( Delta(  TimeIndx+1) - Delta(  TimeIndx) )*P + Delta(  TimeIndx)
            VZ_tmp      = ( VZ(     TimeIndx+1) - VZ(     TimeIndx) )*P + VZ(     TimeIndx)
            HShr_tmp    = ( HShr(   TimeIndx+1) - HShr(   TimeIndx) )*P + HShr(   TimeIndx)
            VShr_tmp    = ( VShr(   TimeIndx+1) - VShr(   TimeIndx) )*P + VShr(   TimeIndx)
            VLinShr_tmp = ( VLinShr(TimeIndx+1) - VLinShr(TimeIndx) )*P + VLinShr(TimeIndx)
            VGust_tmp   = ( VGust(  TimeIndx+1) - VGust(  TimeIndx) )*P + VGust(  TimeIndx)
            EXIT

         END IF

      END DO
      
   END IF

   
   !-------------------------------------------------------------------------------------------------
   ! calculate the wind speed at this time
   !-------------------------------------------------------------------------------------------------
   
   CosDelta = COS( Delta_tmp )
   SinDelta = SIN( Delta_tmp )
   
   V1 = V_tmp * ( ( InputPosition(3)/RefHt ) ** VShr_tmp &                                  ! power-law wind shear
        + ( HShr_tmp   * ( InputPosition(2) * CosDelta + InputPosition(1) * SinDelta ) &    ! horizontal linear shear
        +  VLinShr_tmp * ( InputPosition(3)-RefHt ) )/RefWid  ) &                           ! vertical linear shear
        + VGUST_tmp                                                                         ! gust speed
   
   HH_GetWindSpeed%Velocity(1) =  V1 * CosDelta
   HH_GetWindSpeed%Velocity(2) = -V1 * SinDelta
   HH_GetWindSpeed%Velocity(3) =  VZ_tmp      


   RETURN

END FUNCTION HH_GetWindSpeed
!====================================================================================================
FUNCTION HH_Get_ADHack_WindSpeed(Time, InputPosition, ErrStat)
! This subroutine linearly interpolates the columns in the HH input file to get the values for 
! the requested time, then uses the interpolated values to calclate the wind speed at a point
! in space represented by InputPosition. THIS FUNCTION SHOULD BE REMOVED!!!!! (used for DISK VEL ONLY)
!----------------------------------------------------------------------------------------------------

   REAL(ReKi),        INTENT(IN) :: Time                 ! time from the start of the simulation
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)     ! input information: positions X,Y,Z   -   NOT USED HERE!!!
   INTEGER,           INTENT(OUT):: ErrStat              ! error status
   TYPE(InflIntrpOut)            :: HH_Get_ADHack_WindSpeed      ! return velocities (U,V,W)
   
   REAL(ReKi)                    :: Delta_tmp            ! interpolated Delta   at input TIME
   REAL(ReKi)                    :: P                    ! temporary storage for slope (in time) used in linear interpolation
   REAL(ReKi)                    :: V_tmp                ! interpolated V       at input TIME
   REAL(ReKi)                    :: VZ_tmp               ! interpolated VZ      at input TIME
   

   !-------------------------------------------------------------------------------------------------
   ! verify the module was initialized first
   !-------------------------------------------------------------------------------------------------

   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Error: Call HH_Init() before getting wind speed.')
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
      
   !-------------------------------------------------------------------------------------------------
   ! Linearly interpolate in time (or use nearest-neighbor to extrapolate) 
   ! (compare with NWTC_Num.f90\InterpStpReal)
   !-------------------------------------------------------------------------------------------------

     ! Let's check the limits.

   IF ( Time <= Tdata(1) .OR. NumDataLines == 1)  THEN
   
      TimeIndx      = 1
      V_tmp         = V      (1)
      Delta_tmp     = Delta  (1)
      VZ_tmp        = VZ     (1)
         
   ELSE IF ( Time >= Tdata(NumDataLines) )  THEN
   
      TimeIndx      = NumDataLines - 1
      V_tmp         = V      (NumDataLines)
      Delta_tmp     = Delta  (NumDataLines)
      VZ_tmp        = VZ     (NumDataLines)
      
   ELSE
   
         ! Let's interpolate!

      TimeIndx = MAX( MIN( TimeIndx, NumDataLines-1 ), 1 )

      DO

         IF ( Time < Tdata(TimeIndx) )  THEN

            TimeIndx = TimeIndx - 1

         ELSE IF ( Time >= Tdata(TimeIndx+1) )  THEN

            TimeIndx = TimeIndx + 1

         ELSE
            P           = ( Time - Tdata(TimeIndx) )/( Tdata(TimeIndx+1) - Tdata(TimeIndx) )
            V_tmp       = ( V(      TimeIndx+1) - V(      TimeIndx) )*P + V(      TimeIndx)
            Delta_tmp   = ( Delta(  TimeIndx+1) - Delta(  TimeIndx) )*P + Delta(  TimeIndx)
            VZ_tmp      = ( VZ(     TimeIndx+1) - VZ(     TimeIndx) )*P + VZ(     TimeIndx)
            EXIT

         END IF

      END DO
      
   END IF
   
   !-------------------------------------------------------------------------------------------------
   ! calculate the wind speed at this time
   !-------------------------------------------------------------------------------------------------
      
   HH_Get_ADHack_WindSpeed%Velocity(1) =  V_tmp * COS( Delta_tmp )
   HH_Get_ADHack_WindSpeed%Velocity(2) = -V_tmp * SIN( Delta_tmp )
   HH_Get_ADHack_WindSpeed%Velocity(3) =  VZ_tmp      


   RETURN

END FUNCTION HH_Get_ADHack_WindSpeed
!====================================================================================================
SUBROUTINE HH_SetLinearizeDels( Perturbations, ErrStat )
! This subroutine sets the perturbation values for the linearization scheme.
!----------------------------------------------------------------------------------------------------

   REAL(ReKi),       INTENT(IN)  :: Perturbations(7)     ! purturbations for each of the 7 input parameters
   INTEGER,          INTENT(OUT) :: ErrStat              ! time from the start of the simulation

   !-------------------------------------------------------------------------------------------------
   ! verify the module was initialized first
   !-------------------------------------------------------------------------------------------------

   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Error: Call HH_Init() before getting wind speed.')
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF

   Linearize = .TRUE.
   LinearizeDels(:) = Perturbations(:)

   RETURN

END SUBROUTINE HH_SetLinearizeDels
!====================================================================================================
SUBROUTINE HH_Terminate(ErrStat)

   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered

   INTEGER                     :: SumErrs
   
   SumErrs = 0

   IF ( ALLOCATED(Tdata  ) ) DEALLOCATE( Tdata,   STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(DELTA  ) ) DEALLOCATE( DELTA,   STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(V      ) ) DEALLOCATE( V,       STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VZ     ) ) DEALLOCATE( VZ,      STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(HSHR   ) ) DEALLOCATE( HSHR,    STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VSHR   ) ) DEALLOCATE( VSHR,    STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VGUST  ) ) DEALLOCATE( VGUST,   STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VLINSHR) ) DEALLOCATE( VLINSHR, STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)

   ErrStat  = SumErrs
   TimeIndx = 0            
   
END SUBROUTINE HH_Terminate   
!====================================================================================================
END MODULE HHWind
MODULE UserWind
!  The purpose of this module is to allow user-defined wind.  
!----------------------------------------------------------------------------------------------------

   USE                           NWTC_Library
   USE                           SharedInflowDefs
   USE                     WindFile_Types

   IMPLICIT                      NONE
   PRIVATE
    
    
      ! define variables for UserWind here
      
   LOGICAL, SAVE              :: Initialized = .FALSE.         ! This variable indicates if the initialization routine has been run
   
   REAL(ReKi)                 :: UWmeanU                       ! Possibly instantaneous, disk-averaged wind speeds.
   REAL(ReKi)                 :: UWmeanV                       !
   REAL(ReKi)                 :: UWmeanW                       !   
   

      ! allow the initialization and termination routines to be public (called from outside)

   PUBLIC                     :: UsrWnd_Init
   PUBLIC                     :: UsrWnd_Terminate
   PUBLIC                     :: UsrWnd_GetValue
   PUBLIC                     :: UsrWnd_GetWindSpeed

CONTAINS
!====================================================================================================
SUBROUTINE UsrWnd_Init(ErrStat)
!  This subroutine is called at the beginning of
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' UserWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
!      CALL NWTC_Init()    ! Initialized in IfW_Init
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Perform any initialization steps here (read input files, etc.)
   !-------------------------------------------------------------------------------------------------
   
   CALL WrScr( '***** NOTE: User-defined wind employed *****' )


      ! Set the disk-average wind vector.
   
   UWmeanU = 10.0
   UWmeanV =  0.0
   UWmeanW =  0.0

   
   !-------------------------------------------------------------------------------------------------
   ! Set the initialization flag
   !-------------------------------------------------------------------------------------------------
   
   Initialized = .TRUE.
   
   RETURN

END SUBROUTINE UsrWnd_Init
!====================================================================================================
FUNCTION UsrWnd_GetValue(VarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the VarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------
   
   CHARACTER(*),   INTENT(IN)    :: VarName
   INTEGER,        INTENT(OUT)   :: ErrStat           ! return 0 if no errors; non-zero otherwise
   REAL(ReKi)                    :: UsrWnd_GetValue

   
   CHARACTER(20)                 :: VarNameUC         ! upper-case VarName
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN   
      CALL WrScr( 'Initialize UserWind before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = VarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
   
      CASE ('MEANU' )
         UsrWnd_GetValue = UWmeanU
         
      CASE ('MEANV' )
         UsrWnd_GetValue = UWmeanV

      CASE ('MEANW' )
         UsrWnd_GetValue = UWmeanW
         
      CASE DEFAULT
         CALL WrScr( ' Invalid variable name in UsrWnd_GetValue().' )
         ErrStat = 1
         
   END SELECT
      
   

END FUNCTION UsrWnd_GetValue
!====================================================================================================
FUNCTION UsrWnd_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are 
! requested. It returns the velocities at the specified time and space.
!----------------------------------------------------------------------------------------------------
   
   REAL(ReKi),        INTENT(IN) :: Time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)        ! X,Y,Z (z is 0 at ground level)
   INTEGER,           INTENT(OUT):: ErrStat                 ! return 0 if no errors; non-zero otherwise
   TYPE(InflIntrpOut)            :: UsrWnd_GetWindSpeed
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   
   IF ( .NOT. Initialized ) THEN   
      CALL WrScr( 'Initialize UserWind before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Calculate the wind speed at this time and position.
   !-------------------------------------------------------------------------------------------------   
   !     Time
   !     X = InputPosition(1)           ! relative to the undeflected tower centerline (positive downwind)
   !     Y = InputPosition(2)           ! relative to the undeflected tower centerline (positive left when looking downwind)
   !     Z = InputPosition(3)           ! relative to the ground (0 is ground level)
   !-------------------------------------------------------------------------------------------------

      ! We'll test this with steady winds for now.

   UsrWnd_GetWindSpeed%Velocity(1) = 10.0    ! U velocity (along positive X)
   UsrWnd_GetWindSpeed%Velocity(2) =  0.0    ! V velocity (along positive Y)
   UsrWnd_GetWindSpeed%Velocity(3) =  0.0    ! V velocity (along positive Z)
   

END FUNCTION UsrWnd_GetWindSpeed
!====================================================================================================
SUBROUTINE UsrWnd_Terminate(ErrStat)
!  This subroutine is called at the end of program execution (including after fatal errors occur).  
!  It should close any files that could be open and deallocate any arrays that have been allocated.
!----------------------------------------------------------------------------------------------------
      
   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   ErrStat = 0

   !-------------------------------------------------------------------------------------------------
   ! Close files
   !-------------------------------------------------------------------------------------------------
      
      
   !-------------------------------------------------------------------------------------------------
   ! Deallocate arrays
   !-------------------------------------------------------------------------------------------------

      
   !-------------------------------------------------------------------------------------------------
   ! Set the initialization flag
   !-------------------------------------------------------------------------------------------------
   
   Initialized = .FALSE.

END SUBROUTINE UsrWnd_Terminate
!====================================================================================================
END MODULE UserWind
MODULE InflowWind_Subs
! This module is used to read and process the (undisturbed) inflow winds.  It must be initialized
! using InflowWind_Init() with the name of the file, the file type, and possibly reference height and
! width (depending on the type of wind file being used).  This module calls appropriate routines
! in the wind modules so that the type of wind becomes seamless to the user.  InflowWind_Terminate()
! should be called when the program has finshed.
!
! Data are assumed to be in units of meters and seconds.  Z is measured from the ground (NOT the hub!).
!
!  7 Oct 2009    Initial Release with AeroDyn 13.00.00      B. Jonkman, NREL/NWTC
! 14 Nov 2011    v1.00.01b-bjj                              B. Jonkman
!  1 Aug 2012    v1.01.00a-bjj                              B. Jonkman
! 10 Aug 2012    v1.01.00b-bjj                              B. Jonkman
!----------------------------------------------------------------------------------------------------
!  
!..................................................................................................................................
! LICENSING
! Copyright (C) 2012  National Renewable Energy Laboratory
!
!    This file is part of InflowWind.
!
!    InflowWind is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as 
!    published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!
!    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
!    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
!    
!    You should have received a copy of the GNU General Public License along with InflowWind.  
!    If not, see <http://www.gnu.org/licenses/>.
!    
!**********************************************************************************************************************************

   USE                              NWTC_Library
   USE                              SharedInflowDefs
   USE                              WindFile_Types

   !-------------------------------------------------------------------------------------------------
   ! The included wind modules
   !-------------------------------------------------------------------------------------------------

   USE                              FFWind               ! full-field binary wind files
   USE                              HHWind               ! hub-height text wind files
   USE                              FDWind               ! 4-D binary wind files
   USE                              CTWind               ! coherent turbulence from KH billow - binary file superimposed on another wind type
   USE                              UserWind             ! user-defined wind module
   USE                              HAWCWind             ! full-field binary wind files in HAWC format


   IMPLICIT                         NONE
!NOTE: don't make this private. Then none of these routines will be available to the module. Don't make it public either because then anything can get to them.

CONTAINS
!====================================================================================================
SUBROUTINE GetWindType( ParamData, ErrStat, ErrMsg )
!  This subroutine checks the file FileName to see what kind of wind file we are using.  Used when
!  the wind file type is unknown.
!----------------------------------------------------------------------------------------------------
!FIXME: may want to change this to a subroutine that sets stuff in the passed IfW_ParameterType variable

   IMPLICIT             NONE


      ! Passed Variables:

   TYPE( IfW_ParameterType),        INTENT(INOUT)     :: ParamData
   INTEGER(IntKi),                  INTENT(  OUT)     :: ErrStat
   CHARACTER(*),                    INTENT(  OUT)     :: ErrMsg


      ! Local Variables:

   INTEGER                                            :: IND
   LOGICAL                                            :: Exists

   CHARACTER(1024)                                    :: FileName       ! Temporary name holder
   CHARACTER(  3)                                     :: FileNameEnd
   CHARACTER(  8)                                     :: WndFilNam      ! Temporary name holder

   CHARACTER(1024)                                    :: FileRoot


   ErrStat  = 0
   ErrMsg   = ""

   !-------------------------------------------------------------------------------------------------
   ! Check for user-defined wind file first; file starts with "USERWIND"
   !-------------------------------------------------------------------------------------------------

   WndFilNam = ParamData%WindFileName
   FileName  = ParamData%WindFileName
   CALL Conv2UC( WndFilNam )              ! convert name to upper case

   IF ( WndFilNam == 'USERWIND' )  THEN

      CALL WrScr1( ' Detected user-defined wind file.' )
      ParamData%WindFileType = UD_Wind

      RETURN
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Get the file extension (or at least what we expect the extension to be)
   !-------------------------------------------------------------------------------------------------
   CALL GetRoot ( ParamData%WindFileName, ParamData%WindFileNameRoot )            ! Get the root name

   IND = LEN_TRIM( ParamData%WindFileNameRoot ) + 1
   IF ( IND < LEN_TRIM( ParamData%WindFileName ) ) THEN
         ! Get the extention, starting at first character past (may not be the whole "extension")
      FileNameEnd = ParamData%WindFileName(IND+1:)
      CALL Conv2UC (FileNameEnd)
   ELSE
      FileNameEnd = ""
      IND = 0
   END IF


   !-------------------------------------------------------------------------------------------------
   ! If there was no '.' in the file name, assume FF, and add a .wnd extension
   !-------------------------------------------------------------------------------------------------
   IF ( IND == 0 ) THEN
      CALL WrScr1(' No file extension found. Assuming '//TRIM(FileName)// &
                  ' is a binary FF wind file with a ".wnd" extension.')
      ParamData%WindFileType = FF_Wind
      FileName = TRIM(FileName)//'.wnd'
      RETURN
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Base the file type on the extension
   !-------------------------------------------------------------------------------------------------
   SELECT CASE ( TRIM(FileNameEnd) )
      CASE ('WND')

            ! If a summary file exists, assume FF; otherwise, assume HH file.

         INQUIRE ( FILE=FileName(1:IND)//'sum' , EXIST=Exists )
         IF (Exists) THEN
            CALL WrScr1(' Assuming '//TRIM(FileName)//' is a binary FF wind file.')
            ParamData%WindFileType = FF_Wind
         ELSE
            CALL WrScr1(' Assuming '//TRIM(FileName)//' is a formatted HH wind file.')
            ParamData%WindFileType = HH_Wind
         END IF

      CASE ('BTS')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a binary FF wind file.')
         ParamData%WindFileType = FF_Wind

      CASE ('CTP')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a coherent turbulence wind file.')
         ParamData%WindFileType = CTP_Wind

      CASE ('FDP')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a binary 4-dimensional wind file.')
         ParamData%WindFileType = FD_Wind

      CASE ('HWC')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' contains full-field wind parameters in HAWC format.')
         ParamData%WindFileType = HAWC_Wind

      CASE DEFAULT
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a formatted HH wind file.')
         ParamData%WindFileType = HH_Wind

   END SELECT


RETURN
END SUBROUTINE GetWindType
!====================================================================================================
SUBROUTINE InflowWind_LinearizePerturbation( ParamData, LinPerturbations, ErrStat )
! This function is used in FAST's linearization scheme.  It should be fixed at some point.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   TYPE( IfW_ParameterType),        INTENT(INOUT)     :: ParamData

   INTEGER,                         INTENT(OUT)       :: ErrStat

   REAL(ReKi),                      INTENT(IN)        :: LinPerturbations(7)



      ! Local variables


   ErrStat = 0

   SELECT CASE ( ParamData%WindFileType )
      CASE (HH_Wind)

         CALL HH_SetLinearizeDels( LinPerturbations, ErrStat )

      CASE ( FF_Wind, UD_Wind, FD_Wind, HAWC_Wind )

         CALL WrScr( ' Error: Linearization is valid only with HH wind files.' )
         ErrStat = 1

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in InflowWind_LinearizePerturbation(). '// &
                     'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1

   END SELECT


END SUBROUTINE InflowWind_LinearizePerturbation
!! FIXME: This has been removed for now. I don't know what will happen to this after the conversion to the framework. Might still be needed at that point.
!! !====================================================================================================
!! FUNCTION InflowWind_ADhack_diskVel( Time, InpPosition, ErrStat )
!! ! This function should be deleted ASAP.  It's purpose is to reproduce results of AeroDyn 12.57;
!! ! when a consensus on the definition of "average velocity" is determined, this function will be
!! ! removed.  InpPosition(2) should be the rotor radius; InpPosition(3) should be hub height
!! !----------------------------------------------------------------------------------------------------
!! 
!!       ! Passed variables
!! 
!!    REAL(ReKi), INTENT(IN)     :: Time
!!    REAL(ReKi), INTENT(IN)     :: InpPosition(3)
!!    INTEGER, INTENT(OUT)       :: ErrStat
!! 
!!       ! Function definition
!!    REAL(ReKi)                 :: InflowWind_ADhack_diskVel(3)
!! 
!!       ! Local variables
!!    TYPE(InflIntrpOut)         :: NewVelocity             ! U, V, W velocities
!!    REAL(ReKi)                 :: Position(3)
!!    INTEGER                    :: IY
!!    INTEGER                    :: IZ
!! 
!! 
!!    ErrStat = 0
!! 
!!    SELECT CASE ( ParamData%WindFileType )
!!       CASE (HH_Wind)
!! 
!! !      VXGBAR =  V * COS( DELTA )
!! !      VYGBAR = -V * SIN( DELTA )
!! !      VZGBAR =  VZ
!! 
!!          Position    = (/ REAL(0.0, ReKi), REAL(0.0, ReKi), InpPosition(3) /)
!!          NewVelocity = HH_Get_ADHack_WindSpeed(Time, Position, ErrStat)
!! 
!!          InflowWind_ADhack_diskVel(:) = NewVelocity%Velocity(:)
!! 
!! 
!!       CASE (FF_Wind)
!! !      VXGBAR = MeanFFWS
!! !      VYGBAR = 0.0
!! !      VZGBAR = 0.0
!! 
!!          InflowWind_ADhack_diskVel(1)   = FF_GetValue('MEANFFWS', ErrStat)
!!          InflowWind_ADhack_diskVel(2:3) = 0.0
!! 
!!       CASE (UD_Wind)
!! !      VXGBAR = UWmeanU
!! !      VYGBAR = UWmeanV
!! !      VZGBAR = UWmeanW
!! 
!!          InflowWind_ADhack_diskVel(1)   = UsrWnd_GetValue('MEANU', ErrStat)
!!          IF (ErrStat /= 0) RETURN
!!          InflowWind_ADhack_diskVel(2)   = UsrWnd_GetValue('MEANV', ErrStat)
!!          IF (ErrStat /= 0) RETURN
!!          InflowWind_ADhack_diskVel(3)   = UsrWnd_GetValue('MEANW', ErrStat)
!! 
!!       CASE (FD_Wind)
!! !      XGrnd = 0.0
!! !      YGrnd = 0.5*RotDiam
!! !      ZGrnd = 0.5*RotDiam
!! !      CALL FD_Interp
!! !      VXGBAR = FDWind( 1 )
!! !      VYGBAR = FDWind( 2 )
!! !      VZGBAR = FDWind( 3 )
!! !
!! !      XGrnd =  0.0
!! !      YGrnd = -0.5*RotDiam
!! !      ZGrnd =  0.5*RotDiam
!! !      CALL FD_Interp
!! !      VXGBAR = VXGBAR + FDWind( 1 )
!! !      VYGBAR = VYGBAR + FDWind( 2 )
!! !      VZGBAR = VZGBAR + FDWind( 3 )
!! !
!! !      XGrnd =  0.0
!! !      YGrnd = -0.5*RotDiam
!! !      ZGrnd = -0.5*RotDiam
!! !      CALL FD_Interp
!! !      VXGBAR = VXGBAR + FDWind( 1 )
!! !      VYGBAR = VYGBAR + FDWind( 2 )
!! !      VZGBAR = VZGBAR + FDWind( 3 )
!! !
!! !      XGrnd =  0.0
!! !      YGrnd =  0.5*RotDiam
!! !      ZGrnd = -0.5*RotDiam
!! !      CALL FD_Interp
!! !      VXGBAR = 0.25*( VXGBAR + FDWind( 1 ) )
!! !      VYGBAR = 0.25*( VYGBAR + FDWind( 2 ) )
!! !      VZGBAR = 0.25*( VZGBAR + FDWind( 3 ) )
!! 
!! 
!!          Position(1) = 0.0
!!          InflowWind_ADhack_diskVel(:) = 0.0
!! 
!!          DO IY = -1,1,2
!!             Position(2)  =  IY*FD_GetValue('RotDiam',ErrStat)
!! 
!!             DO IZ = -1,1,2
!!                Position(3)  = IZ*InpPosition(2) + InpPosition(3)
!! 
!!                NewVelocity = InflowWind_GetVelocity(Time, Position, ErrStat)
!!                InflowWind_ADhack_diskVel(:) = InflowWind_ADhack_diskVel(:) + NewVelocity%Velocity(:)
!!             END DO
!!          END DO
!!          InflowWind_ADhack_diskVel(:) = 0.25*InflowWind_ADhack_diskVel(:)
!! 
!!       CASE (HAWC_Wind)
!!          InflowWind_ADhack_diskVel(1)   = HW_GetValue('UREF', ErrStat)
!!          InflowWind_ADhack_diskVel(2:3) = 0.0
!! 
!!       CASE DEFAULT
!!          CALL WrScr(' Error: Undefined wind type in InflowWind_ADhack_diskVel(). '// &
!!                     'Call WindInflow_Init() before calling this function.' )
!!          ErrStat = 1
!! 
!!    END SELECT
!! 
!!    RETURN
!! 
!! END FUNCTION InflowWind_ADhack_diskVel
!====================================================================================================
FUNCTION InflowWind_ADhack_DIcheck( ParamData, ErrStat )
! This function should be deleted ASAP.  It's purpose is to reproduce results of AeroDyn 12.57;
! it performs a wind speed check for the dynamic inflow initialization
! it returns MFFWS for the FF wind files; for all others, a sufficiently large number is used ( > 8 m/s)
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   TYPE( IfW_ParameterType),        INTENT(INOUT)     :: ParamData

   INTEGER,                         INTENT(OUT)       :: ErrStat

      ! Function definition
   REAL(ReKi)                 :: InflowWind_ADhack_DIcheck


   ErrStat = 0

   SELECT CASE ( ParamData%WindFileType )
      CASE (HH_Wind, UD_Wind, FD_Wind )

         InflowWind_ADhack_DIcheck = 50  ! just return something greater than 8 m/s

      CASE (FF_Wind)

         InflowWind_ADhack_DIcheck = FF_GetValue('MEANFFWS', ErrStat)

      CASE (HAWC_Wind)

         InflowWind_ADhack_DIcheck = HW_GetValue('UREF', ErrStat)

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in InflowWind_ADhack_DIcheck(). '// &
                    'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1

   END SELECT

   RETURN

END FUNCTION InflowWind_ADhack_DIcheck
!====================================================================================================
END MODULE InflowWind_Subs





!!----Remove this functionality for now. Might put it back in sometime after the conversion to the new framework ----
!!    FUNCTION InflowWind_GetMean(StartTime, EndTime, delta_time, InputPosition,  ErrStat )
!!    !  This function returns the mean wind speed
!!    !----------------------------------------------------------------------------------------------------
!!
!!          ! passed variables
!!       REAL(ReKi),       INTENT(IN)  :: StartTime
!!       REAL(ReKi),       INTENT(IN)  :: EndTime
!!       REAL(ReKi),       INTENT(IN)  :: delta_time
!!       REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
!!       INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise
!!
!!          ! function definition
!!       REAL(ReKi)                    :: InflowWind_GetMean(3)      ! MEAN U, V, W
!!
!!          ! local variables
!!       REAL(ReKi)                    :: Time
!!       REAL(DbKi)                    :: SumVel(3)
!!       INTEGER                       :: I
!!       INTEGER                       :: Nt
!!
!!       TYPE(InflIntrpOut)            :: NewVelocity             ! U, V, W velocities
!!
!!
!!       Nt = (EndTime - StartTime) / delta_time
!!
!!       SumVel(:) = 0.0
!!       ErrStat   = 0
!!
!!
!!       DO I=1,Nt
!!
!!          Time = StartTime + (I-1)*delta_time
!!
!!          NewVelocity = InflowWind_GetVelocity(Time, InputPosition, ErrStat)
!!          IF ( ErrStat /= 0 ) THEN
!!             InflowWind_GetMean(:) = SumVel(:) / REAL(I-1, ReKi)
!!             RETURN
!!          ELSE
!!             SumVel(:) = SumVel(:) + NewVelocity%Velocity(:)
!!          END IF
!!
!!       END DO
!!
!!       InflowWind_GetMean(:) = SumVel(:) / REAL(Nt, ReKi)
!!
!!
!!    END FUNCTION InflowWind_GetMean
!!    !====================================================================================================
!!    FUNCTION InflowWind_GetStdDev(StartTime, EndTime, delta_time, InputPosition,  ErrStat )
!!    !  This function returns the mean wind speed (mean, std, TI, etc)
!!    !----------------------------------------------------------------------------------------------------
!!
!!          ! passed variables
!!       REAL(ReKi),       INTENT(IN)  :: StartTime
!!       REAL(ReKi),       INTENT(IN)  :: EndTime
!!       REAL(ReKi),       INTENT(IN)  :: delta_time
!!       REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
!!       INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise
!!
!!          ! function definition
!!       REAL(ReKi)                    :: InflowWind_GetStdDev(3)    ! STD U, V, W
!!
!!          ! local variables
!!       REAL(ReKi)                    :: Time
!!       REAL(ReKi), ALLOCATABLE       :: Velocity(:,:)
!!       REAL(DbKi)                    :: SumAry(3)
!!       REAL(DbKi)                    :: MeanVel(3)
!!       INTEGER                       :: I
!!       INTEGER                       :: Nt
!!
!!       TYPE(InflIntrpOut)            :: NewVelocity             ! U, V, W velocities
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Initialize
!!       !-------------------------------------------------------------------------------------------------
!!
!!       InflowWind_GetStdDev(:) = 0.0
!!
!!       Nt = (EndTime - StartTime) / delta_time
!!
!!       IF ( Nt < 2 ) RETURN    ! StdDev is 0
!!
!!
!!       IF (.NOT. ALLOCATED(Velocity)) THEN
!!    !      CALL AllocAry( Velocity, 3, Nt, 'StdDev velocity', ErrStat)
!!          ALLOCATE ( Velocity(3, Nt), STAT=ErrStat )
!!
!!          IF ( ErrStat /= 0 )  THEN
!!             CALL WrScr ( ' Error allocating memory for the StdDev velocity array.' )
!!             RETURN
!!          END IF
!!       END IF
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the mean, storing the velocity for later
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          Time = StartTime + (I-1)*delta_time
!!
!!          NewVelocity = InflowWind_GetVelocity(Time, InputPosition, ErrStat)
!!          IF ( ErrStat /= 0 ) RETURN
!!          Velocity(:,I) = NewVelocity%Velocity(:)
!!          SumAry(:)     = SumAry(:) + NewVelocity%Velocity(:)
!!
!!       END DO
!!
!!       MeanVel(:) = SumAry(:) / REAL(Nt, ReKi)
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the standard deviation
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          SumAry(:) = SumAry(:) + ( Velocity(:,I) - MeanVel(:) )**2
!!
!!       END DO ! I
!!
!!       InflowWind_GetStdDev(:) = SQRT( SumAry(:) / ( Nt - 1 ) )
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Deallocate
!!       !-------------------------------------------------------------------------------------------------
!!       IF ( ALLOCATED(Velocity) ) DEALLOCATE( Velocity )
!!
!!
!!    END FUNCTION InflowWind_GetStdDev
!!    !====================================================================================================
!!    FUNCTION InflowWind_GetTI(StartTime, EndTime, delta_time, InputPosition,  ErrStat )
!!    !  This function returns the TI of the wind speed.  It's basically a copy of InflowWind_GetStdDev,
!!    !  except the return value is divided by the mean U-component wind speed.
!!    !----------------------------------------------------------------------------------------------------
!!
!!          ! passed variables
!!       REAL(ReKi),       INTENT(IN)  :: StartTime
!!       REAL(ReKi),       INTENT(IN)  :: EndTime
!!       REAL(ReKi),       INTENT(IN)  :: delta_time
!!       REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
!!       INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise
!!
!!          ! function definition
!!       REAL(ReKi)                    :: InflowWind_GetTI(3)        ! TI U, V, W
!!
!!          ! local variables
!!       REAL(ReKi)                    :: Time
!!       REAL(ReKi), ALLOCATABLE       :: Velocity(:,:)
!!       REAL(DbKi)                    :: SumAry(3)
!!       REAL(DbKi)                    :: MeanVel(3)
!!       INTEGER                       :: I
!!       INTEGER                       :: Nt
!!
!!       TYPE(InflIntrpOut)            :: NewVelocity             ! U, V, W velocities
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Initialize
!!       !-------------------------------------------------------------------------------------------------
!!
!!       InflowWind_GetTI(:) = 0.0
!!
!!       Nt = (EndTime - StartTime) / delta_time
!!
!!       IF ( Nt < 2 ) RETURN    ! StdDev is 0
!!
!!
!!       IF (.NOT. ALLOCATED(Velocity)) THEN
!!    !      CALL AllocAry( Velocity, 3, Nt, 'TI velocity', ErrStat)
!!          ALLOCATE ( Velocity(3, Nt), STAT=ErrStat )
!!
!!          IF ( ErrStat /= 0 )  THEN
!!             CALL WrScr ( ' Error allocating memory for the TI velocity array.' )
!!             RETURN
!!          END IF
!!       END IF
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the mean, storing the velocity for later
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          Time = StartTime + (I-1)*delta_time
!!
!!          NewVelocity = InflowWind_GetVelocity(Time, InputPosition, ErrStat)
!!          IF ( ErrStat /= 0 ) RETURN
!!          Velocity(:,I) = NewVelocity%Velocity(:)
!!          SumAry(:)     = SumAry(:) + NewVelocity%Velocity(:)
!!
!!       END DO
!!
!!       MeanVel(:) = SumAry(:) / REAL(Nt, ReKi)
!!
!!       IF ( ABS(MeanVel(1)) <= EPSILON(MeanVel(1)) ) THEN
!!          CALL WrScr( ' Wind speed is small in InflowWind_GetTI(). TI is undefined.' )
!!          ErrStat = 1
!!          RETURN
!!       END IF
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the standard deviation
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          SumAry(:) = SumAry(:) + ( Velocity(:,I) - MeanVel(:) )**2
!!
!!       END DO ! I
!!
!!       InflowWind_GetTI(:) = SQRT( SumAry(:) / ( Nt - 1 ) ) / MeanVel(1)
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Deallocate
!!       !-------------------------------------------------------------------------------------------------
!!       IF ( ALLOCATED(Velocity) ) DEALLOCATE( Velocity )
!!
!!
!!    END FUNCTION InflowWind_GetTI
!**********************************************************************************************************************************
! This module is used to read and process the (undisturbed) inflow winds.  It must be initialized
! using InflowWind_Init() with the name of the file, the file type, and possibly reference height and
! width (depending on the type of wind file being used).  This module calls appropriate routines
! in the wind modules so that the type of wind becomes seamless to the user.  IfW_End()
! should be called when the program has finshed.
!
! Data are assumed to be in units of meters and seconds.  Z is measured from the ground (NOT the hub!).
!
!  7 Oct 2009    Initial Release with AeroDyn 13.00.00         B. Jonkman, NREL/NWTC
! 14 Nov 2011    v1.00.01b-bjj                                 B. Jonkman
!  1 Aug 2012    v1.01.00a-bjj                                 B. Jonkman
! 10 Aug 2012    v1.01.00b-bjj                                 B. Jonkman
!    Dec 2012    v2.00.00a-adp   conversion to Framework       A. Platt
!
!..................................................................................................................................
! Files with this module:
!  InflowWind_Subs.f90
!  InflowWind.txt       -- InflowWind_Types will be auto-generated based on the descriptions found in this file.
!
!..................................................................................................................................
! LICENSING
! Copyright (C) 2012  National Renewable Energy Laboratory
!
!    This file is part of InflowWind.
!
!    InflowWind is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as
!    published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!
!    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
!    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License along with InflowWind.
!    If not, see <http://www.gnu.org/licenses/>.
!
!**********************************************************************************************************************************
MODULE InflowWind_Module


   USE                              SharedInflowDefs
!   USE                              InflowWind_Types   !FIXME: this file will replace SharedInflowDefs when I can get it to work with the framework registry generator.
   USE                              NWTC_Library
   USE                              WindFile_Types

      !-------------------------------------------------------------------------------------------------
      ! The included wind modules
      !-------------------------------------------------------------------------------------------------

   USE                              FFWind               ! full-field binary wind files
   USE                              HHWind               ! hub-height text wind files
   USE                              FDWind               ! 4-D binary wind files
   USE                              CTWind               ! coherent turbulence from KH billow - binary file superimposed on another wind type
   USE                              UserWind             ! user-defined wind module
   USE                              HAWCWind             ! full-field binary wind files in HAWC format


      !-------------------------------------------------------------------------------------------------
      ! The subroutines
      !-------------------------------------------------------------------------------------------------

   USE                              InflowWind_Subs      ! all the subroutines live here now.




   IMPLICIT NONE
   PRIVATE

   INTEGER(IntKi), PARAMETER            :: DataFormatID = 1           ! Update this value if the data types change (used in IfW_Pack())
!FIXME: tie this to InitOut as well.
   TYPE(ProgDesc), PARAMETER            :: IfW_ProgDesc = ProgDesc( 'InflowWind', 'v1.00.00', '27-Dec-2012' )

!   CHARACTER(99),PARAMETER        :: InflowWindVer = 'InflowWind (v1.01.00b-bjj, 10-Aug-2012)'


      ! ..... Public Subroutines ...................................................................................................

   PUBLIC :: IfW_Init                                 ! Initialization routine
   PUBLIC :: IfW_End                                  ! Ending routine (includes clean up)

!   PUBLIC :: InflowWind_UpdateStates                   ! Loose coupling routine for solving for constraint states, integrating continuous states, and updating discrete states
!   PUBLIC :: InflowWind_CalcOutput                     ! Routine for computing outputs
!
!   PUBLIC :: InflowWind_CalcConstrStateResidual        ! Tight coupling routine for returning the constraint state residual
!   PUBLIC :: InflowWind_CalcContStateDeriv             ! Tight coupling routine for computing derivatives of continuous states
!   PUBLIC :: InflowWind_UpdateDiscState                ! Tight coupling routine for updating discrete states
!
!   PUBLIC :: InflowWind_JacobianPInput                 ! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) equations all with respect to the inputs (u)
!   PUBLIC :: InflowWind_JacobianPContState             ! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) equations all with respect to the continuous states (x)
!   PUBLIC :: InflowWind_JacobianPDiscState             ! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) equations all with respect to the discrete states (xd)
!   PUBLIC :: InflowWind_JacobianPConstrState           ! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) equations all with respect to the constraint states (z)
!
!   PUBLIC :: InflowWind_Pack                           ! Routine to pack (save) data into one array of bytes
!   PUBLIC :: InflowWind_Unpack                         ! Routine to unpack an array of bytes into data structures usable by the module

!-=- Original bits follow -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


   !-------------------------------------------------------------------------------------------------
   ! Private internal variables
   !-------------------------------------------------------------------------------------------------

!FIXME: handle this differently -- should be allocated by the library function to get an open unit number
      ! store as parameter in parametertype
   INTEGER                        :: UnWind   = 91          ! The unit number used for wind inflow files


   !-------------------------------------------------------------------------------------------------
   ! Definitions of public types and routines
   !-------------------------------------------------------------------------------------------------

!FIXME: should not be public anymore
   PUBLIC                         :: InflowWind_GetVelocity    ! function to get wind speed at point in space and time

!FIXME: not public anymore. may not even exist when done.
!   PUBLIC                         :: InflowWind_ADhack_diskVel ! used to keep old AeroDyn functionality--remove soon!
!   PUBLIC                         :: InflowWind_ADhack_DIcheck ! used to keep old AeroDyn functionality--remove soon!

!FIXME: not public anymore.
!   PUBLIC                         :: InflowWind_LinearizePerturbation !used for linearization; should be modified

!!----Removed during conversion to new framework: may put back in as part of OtherStates
!!       PUBLIC                         :: InflowWind_GetMean        ! function to get the mean wind speed at a point in space
!!       PUBLIC                         :: InflowWind_GetStdDev      ! function to calculate standard deviation at a point in space
!!       PUBLIC                         :: InflowWind_GetTI          ! function to get TI at a point in space


CONTAINS
!====================================================================================================
  SUBROUTINE IfW_Init( InitData, InputGuess, ParamData, ContStates, DiscStates, ConstrStateGuess, OtherStates, &
                            OutData, Interval, ErrStat, ErrMsg )
!   SUBROUTINE IfW_Init( InitData, ParamData, Interval, ErrStat, ErrMsg )
! This routine is called at the start of the simulation to perform initialization steps.
! The parameters are set here and not changed during the simulation.
! The initial states and initial guess for the input are defined.
!----------------------------------------------------------------------------------------------------
!  Open and read the wind files, allocating space for necessary variables


         ! Initialization data and guesses

      TYPE( IfW_InitInputType ),          INTENT(IN   )  :: InitData          ! Input data for initialization
      TYPE( IfW_InputType ),              INTENT(  OUT)  :: InputGuess        ! An initial guess for the input; the input mesh must be defined
      TYPE( Ifw_ParameterType ),          INTENT(  OUT)  :: ParamData         ! Parameters
      TYPE( IfW_ContinuousStateType ),    INTENT(  OUT)  :: ContStates        ! Initial continuous states
      TYPE( IfW_DiscreteStateType ),      INTENT(  OUT)  :: DiscStates        ! Initial discrete states
      TYPE( IfW_ConstraintStateType ),    INTENT(  OUT)  :: ConstrStateGuess  ! Initial guess of the constraint states
      TYPE( IfW_OtherStateType ),         INTENT(  OUT)  :: OtherStates       ! Initial other/optimization states
      TYPE( IfW_OutputType ),             INTENT(  OUT)  :: OutData           ! Initial output (outputs are not calculated; only the output mesh is initialized)
      REAL(DbKi),                         INTENT(INOUT)  :: Interval          ! Coupling interval in seconds: InflowWind does not change this.


         ! Error Handling

      INTEGER(IntKi),                     INTENT(  OUT)  :: ErrStat     ! Error status of the operation
      CHARACTER(*),                       INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None


         ! Local variables

      TYPE(HH_Info)                                      :: HHInitInfo
      TYPE(CT_Backgr)                                    :: BackGrndValues


!NOTE: It isn't entirely clear what the purpose of Height is. Does it sometimes occur that Height  /= ParamData%ReferenceHeight???
      REAL(ReKi)                                         :: Height      ! Retrieved from FF
      REAL(ReKi)                                         :: HalfWidth   ! Retrieved from FF
      CHARACTER(1024)                                    :: FileName

!NOTE: I may need to revamp how data is passed to the lower modules. Might need to do that before going any further.


         ! Initialize ErrStat

      ErrStat = ErrID_None
      ErrMsg  = ""


print*, "Wind Type: ",InitData%WindFileType

!
!FIXME:
!         ! Define parameters here:
!
!      !ParamData%DT     = Interval             ! InflowWind does not dictate the time interval.
                                                ! It only responds to the current time.
!      !ParamData%       =
!
!
!FIXME: no states -- except maybe otherstates.
!         ! Define initial states here
!
!      !ContStates%      =
!      !DiscStates%      =
!      !ConstrStateGuess%=
!      !OtherStates%     =
!
!
!FIXME: I think there are no initial guesses
!         ! Define initial guess for the input here:
!
!      !InputGuess%      =
!
!
!FIXME: setup the output data matrix.
!         ! Define output initializations (set up mesh) here:
!      !OutData%        =


      ! check to see if we are already initialized

   IF ( ParamData%Initialized ) THEN
      CALL WrScr( ' Wind inflow has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
         ! Copy things into the ParamaterType -- InitData may not exist later and isn't accessable in some routines.
      ParamData%WindFileType = InitData%WindFileType
      ParamData%WindFileName = InitData%WindFileName
!FIXME: this is temporary and should be removed once the Wind modules are done.
      FileName = InitData%WindFileName
      CALL NWTC_Init()
      CALL DispNVD( IfW_ProgDesc )

   END IF

   !-------------------------------------------------------------------------------------------------
   ! Get default wind type, based on file name, if requested. Otherwise store what we are given for the type
   !-------------------------------------------------------------------------------------------------
   IF ( InitData%WindFileType == DEFAULT_Wind ) THEN
      CALL GetWindType( ParamData, ErrStat, ErrMsg )
   ELSE
      ParamData%WindFileType = InitData%WindFileType
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Check for coherent turbulence file (KH superimposed on a background wind file)
   ! Initialize the CTWind module and initialize the module of the other wind type.
   !-------------------------------------------------------------------------------------------------

   IF ( ParamData%WindFileType == CTP_Wind ) THEN

      CALL CT_Init(UnWind, ParamData%WindFileName, BackGrndValues, ErrStat)
      IF (ErrStat /= 0) THEN
!         CALL IfW_End( ParamData, ErrStat )
!FIXME: cannot call IfW_End here -- requires InitData to be INOUT. Not allowed by framework.
!         CALL IfW_End( InitData, ParamData, ContStates, DiscStates, ConstrStateGuess, OtherStates, &
!                       OutData, ErrStat, ErrMsg )
         ParamData%WindFileType = Undef_Wind
         ErrStat  = 1
         RETURN
      END IF

!FIXME: check this
      ParamData%WindFileName = BackGrndValues%WindFile
      ParamData%WindFileType = BackGrndValues%WindFileType
!      CT_Flag  = BackGrndValues%CoherentStr
      ParamData%CT_Flag  = BackGrndValues%CoherentStr    ! This might be wrong

   ELSE

!      CT_Flag  = .FALSE.
      ParamData%CT_Flag  = .FALSE.

   END IF

   !-------------------------------------------------------------------------------------------------
   ! Initialize based on the wind type
   !-------------------------------------------------------------------------------------------------

   SELECT CASE ( ParamData%WindFileType )

      CASE (HH_Wind)

         HHInitInfo%ReferenceHeight = InitData%ReferenceHeight
         HHInitInfo%Width           = InitData%Width

         CALL HH_Init( UnWind, ParamData%WindFileName, HHInitInfo, ErrStat )

!        IF (CT_Flag) CALL CT_SetRefVal(FileInfo%ReferenceHeight, 0.5*FileInfo%Width, ErrStat)
         IF (ErrStat == 0 .AND. ParamData%CT_Flag) CALL CT_SetRefVal(InitData%ReferenceHeight, REAL(0.0, ReKi), ErrStat)


      CASE (FF_Wind)

         CALL FF_Init( UnWind, ParamData%WindFileName, ErrStat )


            ! Set CT parameters
         IF ( ErrStat == 0 .AND. ParamData%CT_Flag ) THEN
            Height     = FF_GetValue('HubHeight', ErrStat)
            IF ( ErrStat /= 0 ) Height = InitData%ReferenceHeight

            HalfWidth  = 0.5*FF_GetValue('GridWidth', ErrStat)
            IF ( ErrStat /= 0 ) HalfWidth = 0

            CALL CT_SetRefVal(Height, HalfWidth, ErrStat)
         END IF


      CASE (UD_Wind)

         CALL UsrWnd_Init(ErrStat)


      CASE (FD_Wind)

         CALL FD_Init(UnWind, ParamData%WindFileName, InitData%ReferenceHeight, ErrStat)

      CASE (HAWC_Wind)

         CALL HW_Init( UnWind, ParamData%WindFileName, ErrStat )

      CASE DEFAULT

         CALL WrScr(' Error: Undefined wind type in WindInflow_Init()' )
         ErrStat = 1
         RETURN

   END SELECT


      ! check error status. If no error, set flag to indicate we are initialized.

   IF ( ErrStat /= 0 ) THEN
      ParamData%Initialized = .FALSE.
      ParamData%WindFileType    = Undef_Wind
      ErrStat               = 1         !FIXME: change the error status to the framework convention
!      CALL IfW_End( InitData, ParamData, ContStates, DiscStates, ConstrStateGuess, OtherStates, &
!                    OutData, ErrStat, ErrMsg )  ! Just in case something did get allocated
!FIXME: cannot call IfW_End here. The problem is that InitData might must be INOUT, but that isn't allowed here by the framework
   ELSE
      ParamData%Initialized = .TRUE.
   END IF

   RETURN

END SUBROUTINE IfW_Init
!====================================================================================================
!FIXME: this becomes part of InflowWind_CalcOutput
FUNCTION InflowWind_GetVelocity(ParamData, Time, InputPosition, ErrStat)
! Get the wind speed at a point in space and time
!----------------------------------------------------------------------------------------------------

      ! passed variables
   TYPE(IfW_ParameterType),               INTENT(IN   )  :: ParamData
   REAL(ReKi),       INTENT(IN)  :: Time
   REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
   INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise

      ! local variables
   TYPE(InflIntrpOut)            :: InflowWind_GetVelocity     ! U, V, W velocities
   TYPE(InflIntrpOut)            :: CTWindSpeed             ! U, V, W velocities to superimpose on background wind


   ErrStat = 0

   SELECT CASE ( ParamData%WindFileType )
      CASE (HH_Wind)
         InflowWind_GetVelocity = HH_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE (FF_Wind)
         InflowWind_GetVelocity = FF_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE (UD_Wind)
         InflowWind_GetVelocity = UsrWnd_GetWindSpeed( Time, InputPosition, ErrStat )

      CASE (FD_Wind)
         InflowWind_GetVelocity = FD_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE (HAWC_Wind)
         InflowWind_GetVelocity = HW_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in InflowWind_GetVelocity(). ' &
                   //'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1
         InflowWind_GetVelocity%Velocity(:) = 0.0

   END SELECT


   IF (ErrStat /= 0) THEN

      InflowWind_GetVelocity%Velocity(:) = 0.0

   ELSE

         ! Add coherent turbulence to background wind

      IF (ParamData%CT_Flag) THEN

         CTWindSpeed = CT_GetWindSpeed(Time, InputPosition, ErrStat)
         IF (ErrStat /=0 ) RETURN

         InflowWind_GetVelocity%Velocity(:) = InflowWind_GetVelocity%Velocity(:) + CTWindSpeed%Velocity(:)

      ENDIF

   ENDIF

END FUNCTION InflowWind_GetVelocity
!====================================================================================================
!FIXME: rename as per framework.
!SUBROUTINE IfW_End( ParamData, ErrStat )
SUBROUTINE IfW_End( InitData, ParamData, ContStates, DiscStates, ConstrStateGuess, OtherStates, &
                    OutData, ErrStat, ErrMsg )
! Clean up the allocated variables and close all open files.  Reset the initialization flag so
! that we have to reinitialize before calling the routines again.
!----------------------------------------------------------------------------------------------------
   USE WindFile_Types

         ! Initialization data and guesses

      TYPE( IfW_InitInputType ),          INTENT(INOUT)  :: InitData          ! Input data for initialization
      TYPE( Ifw_ParameterType ),          INTENT(INOUT)  :: ParamData         ! Parameters
      TYPE( IfW_ContinuousStateType ),    INTENT(INOUT)  :: ContStates        ! Continuous states
      TYPE( IfW_DiscreteStateType ),      INTENT(INOUT)  :: DiscStates        ! Discrete states
      TYPE( IfW_ConstraintStateType ),    INTENT(INOUT)  :: ConstrStateGuess  ! Guess of the constraint states
      TYPE( IfW_OtherStateType ),         INTENT(INOUT)  :: OtherStates       ! Other/optimization states
      TYPE( IfW_OutputType ),             INTENT(INOUT)  :: OutData           ! Output data


         ! Error Handling

      INTEGER( IntKi ),                   INTENT(  OUT)  :: ErrStat
      CHARACTER(*),                       INTENT(  OUT)  :: ErrMsg


      ! Close the wind file, if it happens to be open

   CLOSE( UnWind )


      ! End the sub-modules (deallocates their arrays and closes their files):

   SELECT CASE ( ParamData%WindFileType )

      CASE (HH_Wind)
         CALL HH_Terminate(     ErrStat )

      CASE (FF_Wind)
         CALL FF_Terminate(     ErrStat )

      CASE (UD_Wind)
         CALL UsrWnd_Terminate( ErrStat )

      CASE (FD_Wind)
         CALL FD_Terminate(     ErrStat )

      CASE (HAWC_Wind)
         CALL HW_Terminate(     ErrStat )

      CASE ( Undef_Wind )
         ! Do nothing

      CASE DEFAULT  ! keep this check to make sure that all new wind types have a terminate function
         CALL WrScr(' InflowWind: Undefined wind type in IfW_End().' )
         ErrStat = 1

   END SELECT

!   IF (CT_Flag) CALL CT_Terminate( ErrStat )
   CALL CT_Terminate( ErrStat )


      ! Reset the wind type so that the initialization routine must be called
   ParamData%WindFileType = Undef_Wind
!FIXME: reset the initialization flag.
   ParamData%CT_Flag  = .FALSE.


END SUBROUTINE IfW_End
!====================================================================================================
END MODULE InflowWind_Module



!**********************************************************************************************************************************
!
!  MODULE: IfW_Driver_Types  - This module contains types used by the InflowWind Driver program to store arguments passed in
!
!  The types listed here are used within the InflowWind Driver program to store the settings. These settings are read in as
!  command line arguments, then stored within these types.
!
!**********************************************************************************************************************************
!
!..................................................................................................................................
! LICENSING
! Copyright (C) 2012  National Renewable Energy Laboratory
!
!    This file is part of InflowWind.
!
!    InflowWind is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as
!    published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!
!    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
!    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License along with InflowWind.
!    If not, see <http://www.gnu.org/licenses/>.
!
!**********************************************************************************************************************************

MODULE Ifw_Driver_Types

   USE NWTC_Library
   USE WindFile_Types

   IMPLICIT NONE

      ! This contains flags to note if the settings were made.
   TYPE     :: IfW_Driver_ArgFlags
      LOGICAL                 :: WindFileType   = .FALSE.      ! specified a windfiletype
      LOGICAL                 :: Height         = .FALSE.      ! specified a height
      LOGICAL                 :: Width          = .FALSE.      ! specified a width
      LOGICAL                 :: Xrange         = .FALSE.      ! specified a range of x
      LOGICAL                 :: Yrange         = .FALSE.      ! specified a range of y
      LOGICAL                 :: Zrange         = .FALSE.      ! specified a range of z
      LOGICAL                 :: Trange         = .FALSE.      ! specified a range of time
      LOGICAL                 :: Xres           = .FALSE.      ! specified a resolution in x
      LOGICAL                 :: Yres           = .FALSE.      ! speficied a resolution in y
      LOGICAL                 :: Zres           = .FALSE.      ! specified a resolution in z
      LOGICAL                 :: Tres           = .FALSE.      ! specified a resolution in time
      LOGICAL                 :: ParaPrint      = .FALSE.      ! create a ParaView file?
      LOGICAL                 :: Summary        = .FALSE.      ! create a summary file?
      LOGICAL                 :: fft            = .FALSE.      ! do an FFT
      LOGICAL                 :: PointsFile     = .FALSE.      ! points file specified
   END TYPE    IfW_Driver_ArgFlags


      ! This contains all the settings (possible passed in arguments).
   TYPE     :: IfW_Driver_Args
      INTEGER                 :: WindFileType   = DEFAULT_WIND ! the kind of windfile     -- set default to simplify things later
      REAL( ReKi )            :: Height                        ! Reference height
      REAL( ReKi )            :: Width                         ! Reference width
      REAL( ReKi )            :: Xrange(1:2)                   ! range of x
      REAL( ReKi )            :: Yrange(1:2)                   ! range of y
      REAL( ReKi )            :: Zrange(1:2)                   ! range of z
      REAL( ReKi )            :: Trange(1:2)                   ! range of time
      REAL( ReKi )            :: Xres                          ! resolution of x
      REAL( ReKi )            :: Yres                          ! resolution of y
      REAL( ReKi )            :: Zres                          ! resolution of z
      REAL( ReKi )            :: Tres                          ! resolution of time
      REAL( ReKi )            :: fft(1:3)                      ! Coords to do an FFT
      CHARACTER(1024)         :: PointsFile                    ! Filename of points file
      CHARACTER(1024)         :: InputFile                     ! Filename of file to process
   END TYPE    IfW_Driver_Args


END MODULE IfW_Driver_Types
!**********************************************************************************************************************************
!
!  MODULE: IfW_Driver_Subs  - This module contains subroutines used by the InflowWind Driver program
!
!**********************************************************************************************************************************
!
!..................................................................................................................................
! LICENSING
! Copyright (C) 2012  National Renewable Energy Laboratory
!
!    This file is part of InflowWind.
!
!    InflowWind is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as
!    published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!
!    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
!    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License along with InflowWind.
!    If not, see <http://www.gnu.org/licenses/>.
!
!**********************************************************************************************************************************
MODULE Ifw_Driver_Subs

   USE NWTC_Library
   IMPLICIT NONE


CONTAINS
!-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
!-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
SUBROUTINE DispHelpText( ErrStat, ErrMsg )
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-!
      ! Print out help information  !
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-!

   USE NWTC_Library

   IMPLICIT NONE

      ! Error Handling
   INTEGER(IntKi),                     INTENT(  OUT)  :: ErrStat
   CHARACTER(1024),                    INTENT(  OUT)  :: ErrMsg


      !  Statement about usage
   CALL WrScr("")
   CALL WrScr("  Syntax:  InlowWind_Driver <filename> [options]")
   CALL WrScr("")
   CALL WrScr("       where:     <filename>     -- Name of wind file")
   CALL WrScr("     options:     "//SwChar//"type[<type>]  -- type of the file, where <type> is               [N/A]")
   CALL WrScr("                                    HH    -- HubHeight                                   ")
   CALL WrScr("                                    FF    -- Full Field                                  ")
   CALL WrScr("                                    UD    -- User Defined                                ")
   CALL WrScr("                                    FD    -- 4-dimensional (.les)                        ")
   CALL WrScr("                                    CTP   -- Coherent turbulence wind field on top of another")
   CALL WrScr("                                    HAWC  -- HAWC formatted file                         ")
   CALL WrScr("                  "//SwChar//"height[#]     -- height of the hub                         ")
   CALL WrScr("                  "//SwChar//"width[#]      -- width of the windfield                    ")
   CALL WrScr("                  "//SwChar//"x[#:#]        -- range of x (#'s are reals)                      [N/A]")
   CALL WrScr("                  "//SwChar//"y[#:#]        -- range of y                                      [N/A]")
   CALL WrScr("                  "//SwChar//"z[#:#]        -- range in z (ground = 0.0)                       [N/A]")
   CALL WrScr("                  "//SwChar//"t[#:#]        -- range of time                                   [N/A]")
   CALL WrScr("                  "//SwChar//"xres[#]       -- resolution in x                                 [N/A]")
   CALL WrScr("                  "//SwChar//"yres[#]       -- resolution in y                                 [N/A]")
   CALL WrScr("                  "//SwChar//"zres[#]       -- resolution in z                                 [N/A]")
   CALL WrScr("                  "//SwChar//"tres[#]       -- resolution in time                              [N/A]")
   CALL WrScr("                  "//SwChar//"paraprint     -- make an output file for ParaView                [N/A]")
   CALL WrScr("                  "//SwChar//"summary       -- summarize in  .sum file                         [N/A]")
   CALL WrScr("                  "//SwChar//"fft[X,Y,Z]    -- an fft over all t at X,Y,Z (outputs .fft file)  [N/A]")
   CALL WrScr("                  "//SwChar//"points[FILE]  -- calculates at x,y,z coordinates specified in a  [N/A]")
   CALL WrScr("                                    white space delimited FILE")
   CALL WrScr("                  "//SwChar//"help          -- print this help menu and exits")
   CALL WrScr("")
   CALL WrScr("   If the type is not specified, attempts are made to figure out what it is.")
   CALL WrScr("   Unspecified ranges and resolutions default to what is in the file.")
   CALL WrScr("   Features marked [N/A] have not been implimented in this version.")
!FIXME: Does the CTP get used with another? If so, specify in comment at end.
   CALL WrScr("")


END SUBROUTINE DispHelpText


!-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
SUBROUTINE RetrieveArgs( Settings, SettingsFlags, ErrStat, ErrMsg )
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-!
      ! Iterate through the input arguments !
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-!

   USE NWTC_Library
   USE IfW_Driver_Types

   IMPLICIT NONE

      ! Storing the arguments
   TYPE( IfW_Driver_ArgFlags ),        INTENT(  OUT)  :: SettingsFlags        ! Flags indicating which arguments were specified
   TYPE( IfW_Driver_Args ),            INTENT(  OUT)  :: Settings             ! Arguments passed in

      ! Error Handling
   INTEGER(IntKi),                     INTENT(  OUT)  :: ErrStat
   CHARACTER(1024),                    INTENT(  OUT)  :: ErrMsg

      ! Local variables
   INTEGER(IntKi)                                     :: i
   CHARACTER(1024)                                    :: arg
   INTEGER(IntKi)                                     :: InputArgs
   LOGICAL                                            :: FileNameGiven


      ! initialize some things
   FileNameGiven = .FALSE.
   ErrStat = ErrID_None


      ! Check how many arguments are passed in
   InputArgs = COMMAND_ARGUMENT_COUNT()

      ! exit if we don't have enough
   IF (InputArgs == 0) THEN
      ErrMsg   = "Insufficient Arguments."
      ErrStat  = ErrID_Fatal     ! Cannot continue
      RETURN
   ENDIF


      ! Loop through all the arguments, and store them
   DO i=1,InputArgs
      CALL get_command_argument(i, arg)

         ! Check to see if it is a control parameter or the filename
      IF ( INDEX( SwChar, arg(1:1) ) > 0 ) THEN

            ! check to see if we asked for help
         IF ( arg(2:5) == "help" ) THEN
            CALL DispHelpText( ErrStat, ErrMsg )
            CALL ProgExit(0)
         ENDIF

            ! Check the argument and put it where it belongs
            ! chop the SwChar off before passing the argument
         CALL ParseArg( Settings, SettingsFlags, arg(2:), ErrStat, ErrMsg )

         IF ( ErrStat == ErrID_Warn ) CALL ProgWarn( ErrMsg )
         IF ( ErrStat == ErrID_Fatal ) RETURN


      ELSE

            ! since there is no switch character, assume it is the filename, unless we already set one
         IF ( FileNameGiven ) THEN
            ErrMsg   = "Multiple input filenames given: "//TRIM(Settings%InputFile)//", "//TRIM(arg)
            ErrStat  = ErrID_Fatal
            RETURN
         ELSE
            Settings%InputFile = TRIM(arg)
            FileNameGiven = .TRUE.
         ENDIF

      ENDIF
   END DO


      ! Check the arguments passed in:
   IF ( .NOT. FileNameGiven ) THEN
      ErrMsg   = "No filename given for file to open."
      ErrStat  = ErrID_Fatal
      RETURN
   ENDIF


   !-------------------------------------------------------------------------------
   !-------------------------------------------------------------------------------
      CONTAINS


   !-------------------------------------------------------------------------------
   FUNCTION StringToReal( StringIn, ErrStat )
         !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-!
         ! Convert a string to a real number !
         !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-!

      IMPLICIT NONE

         ! Error Handling
      INTEGER(IntKi),                     INTENT(  OUT)  :: ErrStat

         ! Input
      CHARACTER(*),                       INTENT(IN   )  :: StringIn

         ! Returned value
      REAL(ReKi)                                         :: StringToReal

         ! Local Variables
      INTEGER(IntKi)                                     :: TempIO         ! Temporary variable to hold the error status

         read( StringIn, *, iostat=TempIO) StringToReal

            ! If that isn't a number, only warn since we can continue by skipping this value
         IF ( TempIO .ne. 0 ) ErrSTat  = ErrID_Warn

   END FUNCTION StringToReal



   !-------------------------------------------------------------------------------
   SUBROUTINE ParseArg( Settings, SettingsFlags, ThisArg, ErrStat, ErrMsg )
         !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-!
         ! Parse and store the input argument  !
         !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-!

      USE NWTC_Library
      USE IfW_Driver_Types
      USE WindFile_Types

      IMPLICIT NONE

         ! Storing the arguments
      TYPE( IfW_Driver_ArgFlags ),        INTENT(INOUT)  :: SettingsFlags        ! Flags indicating which arguments were specified
      TYPE( IfW_Driver_Args ),            INTENT(INOUT)  :: Settings             ! Arguments passed in

      CHARACTER(*),                       INTENT(IN   )  :: ThisArg              ! The current argument

         ! Error Handling
      INTEGER(IntKi),                     INTENT(  OUT)  :: ErrStat
      CHARACTER(1024),                    INTENT(  OUT)  :: ErrMsg


         ! local variables
      INTEGER(IntKi)                                     :: Delim1               ! where the [ is
      INTEGER(IntKi)                                     :: Delim2               ! where the ] is
      INTEGER(IntKi)                                     :: DelimSep             ! where the : is
      INTEGER(IntKi)                                     :: DelimSep2            ! where the : is
      INTEGER(IntKi)                                     :: DelimSep3            ! where the : is
      REAL(ReKi)                                         :: TempReal             ! temp variable to hold a real
      INTEGER(IntKi)                                     :: TempIO               ! temp variable to store the IO error



         ! Initialize some things
      ErrStat  = ErrID_None
      ErrMsg   = ""
      TempIO   = 0

         ! Get the delimiters -- returns 0 if there isn't one
      Delim1   = INDEX(ThisArg,'[')
      Delim2   = INDEX(ThisArg,']')
      DelimSep = INDEX(ThisArg,':')


         ! check that if there is an opening bracket, then there is a closing one
      IF ( (Delim1 > 0 ) .and. (Delim2 < Delim1) ) THEN
         ErrMsg   = "Syntax error in option: '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
         ErrStat  = ErrID_Warn
         RETURN
      ENDIF

         ! check that if there is a colon, then there are brackets
      IF ( (DelimSep > 0) .and. (Delim1 == 0) ) THEN
         ErrMsg   = "Syntax error in option: '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
         ErrStat  = ErrID_Warn
         RETURN
      ENDIF


         ! Now go through the full list of possible options. Store as appropriate

         ! "type[#]"
      IF    ( ThisArg(1:Delim1) == "type["      ) THEN
         SELECT CASE (ThisArg(Delim1+1:Delim2-1))
            CASE ('HH')    ! hub height
               SettingsFlags%WindFileType = .TRUE.
               Settings%WindFileType      = HH_Wind

            CASE ('FF')    ! full field
               SettingsFlags%WindFileType = .TRUE.
               Settings%WindFileType      = FF_Wind

            CASE ('UD')    ! User Defined
               SettingsFlags%WindFileType = .TRUE.
               Settings%WindFileType      = UD_Wind

            CASE ('FD')    ! Four dimen
               SettingsFlags%WindFileType = .TRUE.
               Settings%WindFileType      = FD_Wind

            CASE ('CTP')   ! coherent turbulence
               SettingsFlags%WindFileType = .TRUE.
               Settings%WindFileType      = CTP_Wind

            CASE ('HAWC')  ! HAWC compatible
               SettingsFlags%WindFileType = .TRUE.
               Settings%WindFileType      = HAWC_Wind

            CASE DEFAULT
               ErrMsg   = "Invalid wind type. Ignoring option: '"//SwChar//TRIM(ThisArg)//"'."
               ErrStat  = ErrID_Warn

         END SELECT



         ! "height[#]"
      ELSEIF( ThisArg(1:Delim1) == "height["    ) THEN
         TempReal = StringToReal( ThisArg(Delim1+1:Delim2-1), ErrStat )
         IF ( ErrStat == ErrID_Warn ) THEN
            ErrMsg   = "Invalid number in option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            SettingsFlags%Height = .FALSE.
            RETURN
         ELSEIF ( ErrStat == ErrID_None ) THEN
            SettingsFlags%Height = .TRUE.
            Settings%Height      = TempReal
         ELSE
            ErrMsg   = "Something failed in parsing option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            ErrStat  = ErrID_Fatal
            SettingsFlags%Height = .FALSE.
         ENDIF


         ! "width[#]"
      ELSEIF( ThisArg(1:Delim1) == "width["     ) THEN
         TempReal = StringToReal( ThisArg(Delim1+1:Delim2-1), ErrStat )
         IF ( ErrStat == ErrID_Warn ) THEN
            ErrMsg   = "Invalid number in option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            SettingsFlags%Width  = .FALSE.
            RETURN
         ELSEIF ( ErrStat == ErrID_None ) THEN
            SettingsFlags%Width  = .TRUE.
            Settings%Width       = TempReal
         ELSE
            ErrMsg   = "Something failed in parsing option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            ErrStat  = ErrID_Fatal
            SettingsFlags%Width  = .FALSE.
         ENDIF



         ! "x[#:#]"
      ELSEIF( ThisArg(1:Delim1) == "x["         ) THEN

            ! First Value
         TempReal = StringToReal( ThisArg(Delim1+1:DelimSep-1), ErrStat )
         IF ( ErrStat == ErrID_Warn ) THEN
            ErrMsg   = "Invalid number in option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            SettingsFlags%Xrange = .FALSE.
            RETURN
         ELSEIF ( ErrStat == ErrID_None ) THEN
            SettingsFlags%Xrange = .TRUE.
            Settings%Xrange(1)   = TempReal
         ELSE
            ErrMsg   = "Something failed in parsing option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            ErrStat  = ErrID_Fatal
            SettingsFlags%Xrange = .FALSE.
         ENDIF

            ! Second Value
         TempReal = StringToReal( ThisArg(DelimSep+1:Delim2-1), ErrStat )
         IF ( ErrStat == ErrID_Warn ) THEN
            ErrMsg   = "Invalid number in option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            SettingsFlags%Xrange = .FALSE.
            RETURN
         ELSEIF ( ErrStat == ErrID_None ) THEN
            SettingsFlags%Xrange = .TRUE.
            Settings%Xrange(2)   = TempReal
         ELSE
            ErrMsg   = "Something failed in parsing option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            ErrStat  = ErrID_Fatal
            SettingsFlags%Xrange = .FALSE.
         ENDIF

            ! Check the order of values
         IF ( Settings%Xrange(1) > Settings%Xrange(2) ) THEN
            ErrMsg   = "Unexpected order of values in option '"//SwChar//TRIM(ThisArg)//"'. Ingoring."
            ErrStat  = ErrID_Warn
            Settings%Xrange(1)   = 0.0
            Settings%Xrange(2)   = 0.0
            SettingsFlags%Xrange = .FALSE.
         ENDIF


         ! "y[#:#]"
      ELSEIF( ThisArg(1:Delim1) == "y["         ) THEN

            ! First Value
         TempReal = StringToReal( ThisArg(Delim1+1:DelimSep-1), ErrStat )
         IF ( ErrStat == ErrID_Warn ) THEN
            ErrMsg   = "Invalid number in option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            SettingsFlags%Yrange = .FALSE.
            RETURN
         ELSEIF ( ErrStat == ErrID_None ) THEN
            SettingsFlags%Yrange = .TRUE.
            Settings%Yrange(1)   = TempReal
         ELSE
            ErrMsg   = "Something failed in parsing option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            ErrStat  = ErrID_Fatal
            SettingsFlags%Yrange = .FALSE.
         ENDIF

            ! Second Value
         TempReal = StringToReal( ThisArg(DelimSep+1:Delim2-1), ErrStat )
         IF ( ErrStat == ErrID_Warn ) THEN
            ErrMsg   = "Invalid number in option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            SettingsFlags%Yrange = .FALSE.
            RETURN
         ELSEIF ( ErrStat == ErrID_None ) THEN
            SettingsFlags%Yrange = .TRUE.
            Settings%Yrange(2)   = TempReal
         ELSE
            ErrMsg   = "Something failed in parsing option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            ErrStat  = ErrID_Fatal
            SettingsFlags%Yrange = .FALSE.
         ENDIF

            ! Check the order of values
         IF ( Settings%Yrange(1) > Settings%Yrange(2) ) THEN
            ErrMsg   = "Unexpected order of values in option '"//SwChar//TRIM(ThisArg)//"'. Ingoring."
            ErrStat  = 1
            Settings%Yrange(1)   = 0.0
            Settings%Yrange(2)   = 0.0
            SettingsFlags%Yrange = .FALSE.
         ENDIF


         ! "z[#:#]"
      ELSEIF( ThisArg(1:Delim1) == "z["         ) THEN

            ! First Value
         TempReal = StringToReal( ThisArg(Delim1+1:DelimSep-1), ErrStat )
         IF ( ErrStat == ErrID_Warn ) THEN
            ErrMsg   = "Invalid number in option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            SettingsFlags%Zrange = .FALSE.
            RETURN
         ELSEIF ( ErrStat == ErrID_None ) THEN
            SettingsFlags%Zrange = .TRUE.
            Settings%Zrange(1)   = TempReal
         ELSE
            ErrMsg   = "Something failed in parsing option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            ErrStat  = ErrID_Fatal
            SettingsFlags%Zrange = .FALSE.
         ENDIF

            ! Second Value
         TempReal = StringToReal( ThisArg(DelimSep+1:Delim2-1), ErrStat )
         IF ( ErrStat == ErrID_Warn ) THEN
            ErrMsg   = "Invalid number in option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            SettingsFlags%Zrange = .FALSE.
            RETURN
         ELSEIF ( ErrStat == ErrID_None ) THEN
            SettingsFlags%Zrange = .TRUE.
            Settings%Zrange(2)   = TempReal
         ELSE
            ErrMsg   = "Something failed in parsing option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            ErrStat  = ErrID_Fatal
            SettingsFlags%Zrange = .FALSE.
         ENDIF

            ! Check the order of values
         IF ( Settings%Zrange(1) > Settings%Zrange(2) ) THEN
            ErrMsg   = "Unexpected order of values in option '"//SwChar//TRIM(ThisArg)//"'. Ingoring."
            ErrStat  = 1
            Settings%Zrange(1)   = 0.0
            Settings%Zrange(2)   = 0.0
            SettingsFlags%Zrange = .FALSE.
         ENDIF


         ! "t[#:#]"
      ELSEIF( ThisArg(1:Delim1) == "t["         ) THEN

            ! First Value
         TempReal = StringToReal( ThisArg(Delim1+1:DelimSep-1), ErrStat )
         IF ( ErrStat == ErrID_Warn ) THEN
            ErrMsg   = "Invalid number in option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            SettingsFlags%Trange = .FALSE.
            RETURN
         ELSEIF ( ErrStat == ErrID_None ) THEN
            SettingsFlags%Trange = .TRUE.
            Settings%Trange(1)   = TempReal
         ELSE
            ErrMsg   = "Something failed in parsing option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            ErrStat  = ErrID_Fatal
            SettingsFlags%Trange = .FALSE.
         ENDIF

            ! Second Value
         TempReal = StringToReal( ThisArg(DelimSep+1:Delim2-1), ErrStat )
         IF ( ErrStat == ErrID_Warn ) THEN
            ErrMsg   = "Invalid number in option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            SettingsFlags%Trange = .FALSE.
            RETURN
         ELSEIF ( ErrStat == ErrID_None ) THEN
            SettingsFlags%Trange = .TRUE.
            Settings%Trange(2)   = TempReal
         ELSE
            ErrMsg   = "Something failed in parsing option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            ErrStat  = ErrID_Fatal
            SettingsFlags%Trange = .FALSE.
         ENDIF

            ! Check the order of values
         IF ( Settings%Trange(1) > Settings%Trange(2) ) THEN
            ErrMsg   = "Unexpected order of values in option '"//SwChar//TRIM(ThisArg)//"'. Ingoring."
            Settings%Trange(1)   = 0.0
            Settings%Trange(2)   = 0.0
            ErrStat  = 1
            SettingsFlags%Trange = .FALSE.
         ENDIF


         ! "xres[#]"
      ELSEIF( ThisArg(1:Delim1) == "xres["      ) THEN
         TempReal = StringToReal( ThisArg(Delim1+1:Delim2-1), ErrStat )
         IF ( ErrStat == ErrID_Warn ) THEN
            ErrMsg   = "Invalid number in option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            SettingsFlags%Xres   = .FALSE.
            RETURN
         ELSEIF ( ErrStat == ErrID_None ) THEN
            SettingsFlags%Xres   = .TRUE.
            Settings%Xres        = abs(TempReal)
         ELSE
            ErrMsg   = "Something failed in parsing option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            ErrStat  = ErrID_Fatal
            SettingsFlags%Xres   = .FALSE.
         ENDIF

         ! "yres[#]"
      ELSEIF( ThisArg(1:Delim1) == "yres["      ) THEN
         TempReal = StringToReal( ThisArg(Delim1+1:Delim2-1), ErrStat )
         IF ( ErrStat == ErrID_Warn ) THEN
            ErrMsg   = "Invalid number in option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            SettingsFlags%Yres   = .FALSE.
            RETURN
         ELSEIF ( ErrStat == ErrID_None ) THEN
            SettingsFlags%Yres   = .TRUE.
            Settings%Yres        = abs(TempReal)
         ELSE
            ErrMsg   = "Something failed in parsing option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            ErrStat  = ErrID_Fatal
            SettingsFlags%Yres   = .FALSE.
         ENDIF

         ! "zres[#]"
      ELSEIF( ThisArg(1:Delim1) == "zres["      ) THEN
         TempReal = StringToReal( ThisArg(Delim1+1:Delim2-1), ErrStat )
         IF ( ErrStat == ErrID_Warn ) THEN
            ErrMsg   = "Invalid number in option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            SettingsFlags%Zres   = .FALSE.
            RETURN
         ELSEIF ( ErrStat == ErrID_None ) THEN
            SettingsFlags%Zres   = .TRUE.
            Settings%Zres        = abs(TempReal)
         ELSE
            ErrMsg   = "Something failed in parsing option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            ErrStat  = ErrID_Fatal
            SettingsFlags%Zres   = .FALSE.
         ENDIF

         ! "tres[#]"
      ELSEIF( ThisArg(1:Delim1) == "tres["      ) THEN
         TempReal = StringToReal( ThisArg(Delim1+1:Delim2-1), ErrStat )
         IF ( ErrStat == ErrID_Warn ) THEN
            ErrMsg   = "Invalid number in option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            SettingsFlags%Tres   = .FALSE.
            RETURN
         ELSEIF ( ErrStat == ErrID_None ) THEN
            SettingsFlags%Tres   = .TRUE.
            Settings%Tres        = abs(TempReal)
         ELSE
            ErrMsg   = "Something failed in parsing option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            ErrStat  = ErrID_Fatal
            SettingsFlags%Tres   = .FALSE.
         ENDIF

         ! "paraprint"
      ELSEIF( ThisArg(1:9)      == "paraprint"  ) THEN
         SettingsFlags%ParaPrint = .TRUE.
         ErrMsg   = "Feature not implimented. Ignoring option '"//SwChar//TRIM(ThisArg)//"'."
         ErrStat  = ErrID_Warn

         ! "summary"
      ELSEIF( ThisArg(1:8)      == "summary"    ) THEN
         SettingsFlags%Summary   = .TRUE.
         ErrMsg   = "Feature not implimented. Ignoring option '"//SwChar//TRIM(ThisArg)//"'."
         ErrStat  = ErrID_Warn

         ! "fft[X,Y,Z]"
      ELSEIF( ThisArg(1:Delim1) == "fft["       ) THEN
         DelimSep = INDEX(ThisArg,',')
         DelimSep2= INDEX(ThisArg(DelimSep+1:),',') + DelimSep

            ! First Value
         TempReal = StringToReal( ThisArg(Delim1+1:DelimSep-1), ErrStat )
         IF ( ErrStat == ErrID_Warn ) THEN
            ErrMsg   = "Invalid number in option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            SettingsFlags%fft    = .FALSE.
            RETURN
         ELSEIF ( ErrStat == ErrID_None ) THEN
            SettingsFlags%fft    = .TRUE.
            Settings%fft(1)      = TempReal
         ELSE
            ErrMsg   = "Something failed in parsing option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            SettingsFlags%fft    = .FALSE.
         ENDIF

            ! Second Value
         TempReal = StringToReal( ThisArg(DelimSep+1:DelimSep2-1), ErrStat )
         IF ( ErrStat == ErrID_Warn ) THEN
            ErrMsg   = "Invalid number in option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            SettingsFlags%fft    = .FALSE.
            RETURN
         ELSEIF ( ErrStat == ErrID_None ) THEN
            SettingsFlags%fft    = .TRUE.
            Settings%fft(2)      = TempReal
         ELSE
            ErrMsg   = "Something failed in parsing option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            ErrStat  = ErrID_Fatal
            SettingsFlags%fft    = .FALSE.
         ENDIF

            ! Third Value
         TempReal = StringToReal( ThisArg(DelimSep2+1:Delim2-1), ErrStat )
         IF ( ErrStat == ErrID_Warn ) THEN
            ErrMsg   = "Invalid number in option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            SettingsFlags%fft    = .FALSE.
            RETURN
         ELSEIF ( ErrStat == ErrID_None ) THEN
            SettingsFlags%fft    = .TRUE.
            Settings%fft(3)      = TempReal
         ELSE
            ErrMsg   = "Something failed in parsing option '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
            ErrStat  = ErrID_Fatal
            SettingsFlags%fft    = .FALSE.
         ENDIF

         ! "points[FILE]"
      ELSEIF( ThisArg(1:Delim1) == "points["    ) THEN
         SettingsFlags%PointsFile= .TRUE.
         Settings%PointsFile     = ThisArg(Delim1+1:Delim2-1)

      ELSE
         ErrMsg  = "Unrecognized option: '"//SwChar//TRIM(ThisArg)//"'. Ignoring."
         ErrStat = ErrID_Warn
      ENDIF

   END SUBROUTINE ParseArg
   !-------------------------------------------------------------------------------



END SUBROUTINE RetrieveArgs

!-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
!-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
END MODULE Ifw_Driver_Subs
!****************************************************************************
!
!  PROGRAM: InflowWind_Driver  - This program tests the inflow wind module
!
!****************************************************************************
!
!..................................................................................................................................
! LICENSING
! Copyright (C) 2012  National Renewable Energy Laboratory
!
!    This file is part of InflowWind.
!
!    InflowWind is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as
!    published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!
!    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
!    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License along with InflowWind.
!    If not, see <http://www.gnu.org/licenses/>.
!
!**********************************************************************************************************************************

PROGRAM InflowWind_Driver

!   USE NWTC_Library       !NOTE: Not sure why this doesn't need to be specified
   USE InflowWind_Module
   USE WindFile_Types      !NOTE: would we prefer not to need this????
   USE SharedInflowDefs
   USE IfW_Driver_Types    ! Contains types and routines for handling the input arguments
   USE IfW_Driver_Subs     ! Contains subroutines for the driver program

   IMPLICIT NONE

      ! Info on this code
   TYPE( ProgDesc ), PARAMETER                        :: ProgInfo = ProgDesc("InflowWind_Driver","v1.00.00a-adp","31-Dec-2012")


      ! Types needed here (from InflowWind module)
   TYPE( IfW_InitInputType )                          :: IfW_InitInputData       ! Data for initialization -- this is where the input info goes
   TYPE( IfW_InputType )                              :: IfW_InputData           ! input     -- contains xyz coords of interest
   TYPE( IfW_ParameterType )                          :: IfW_ParamData           ! Parameters
   TYPE( IfW_ContinuousStateType )                    :: IfW_ContStateData       ! Continous State Data  (not used here)
   TYPE( IfW_DiscreteStateType )                      :: IfW_DiscStateData       ! Discrete State Data   (not used here)
   TYPE( IfW_ConstraintStateType )                    :: IfW_ConstrStateData     ! Constraint State Data (not used here)
   TYPE( IfW_OtherStateType )                         :: IfW_OtherStateData      ! Other State Data      (might use at some point)
   TYPE( IfW_OutputType )                             :: IfW_OutputData          ! Output Data -- contains the velocities at xyz

      ! Error Handling
   INTEGER(IntKi)                                     :: ErrStat
   CHARACTER(1024)                                    :: ErrMsg



      ! Local variables for this code
   TYPE( IfW_Driver_ArgFlags )                        :: SettingsFlags        ! Flags indicating which arguments were specified
   TYPE( IfW_Driver_Args )                            :: Settings             ! Arguments passed in
   REAL( DbKi )                                       :: TimeStep             ! Initial timestep (the glue code ditcates this)
   REAL( DbKi )                                       :: Timer(1:2)           ! Keep track of how long this takes to run
   INTEGER( IntKi )                                   :: InputArgs            ! Number of arguments passed in
   LOGICAL                                            :: TempFileExist        ! Flag for inquiring file existence



   !--------------------------------------------------------------------------
   !-=-=- Initialize the Library -=-=-
   !--------------------------------------------------------------------------

   CALL NWTC_Init
   CALL DispNVD(ProgInfo)


!FIXME
      ! Set the beep to false. This is a temporary workaround since the beepcode on linux may be incorrectly set. This may also be an artifact of my current development environment.
   Beep = .FALSE.


   !--------------------------------------------------------------------------
   !-=-=- Setup the program -=-=-
   !--------------------------------------------------------------------------

      ! Start the timer
   CALL CPU_TIME( Timer(1) )



   !--------------------------------------------------------------------------
   !-=-=- Parse the command line inputs -=-=-
   !--------------------------------------------------------------------------

   CALL RetrieveArgs( Settings, SettingsFlags, ErrStat, ErrMsg )

   IF ( ErrStat == ErrID_Fatal ) CALL ProgAbort( ErrMsg )


      ! Set the input file name and verify it exists

   IfW_InitInputData%WindFileName      = Settings%InputFile

   INQUIRE( file=Settings%InputFile, exist=TempFileExist )
   IF ( TempFileExist .eqv. .FALSE. ) CALL ProgAbort( "Cannot find input file "//TRIM(Settings%InputFile))


      ! In the event things are not specified on the input line, use the following

   IfW_InitInputData%ReferenceHeight   = 80.                      ! meters  -- default
   IfW_InitInputData%Width             = 100.                     ! meters
   IfW_InitInputData%WindFileType      = DEFAULT_Wind             ! This must be preset before calling the initialization.
   TimeStep                            = 10                       !seconds


      ! If they are specified by input arguments, use the following

   IF ( SettingsFlags%Height )         IfW_InitInputData%ReferenceHeight = Settings%Height
   IF ( SettingsFlags%Width )          IfW_InitInputData%Width           = Settings%Width
   IF ( SettingsFlags%WindFileType )   IfW_InitInputData%WindFileType    = Settings%WindFileType
   IF ( SettingsFlags%Tres )           TimeStep                          = Settings%Tres



      ! Sanity check: if an input points file is specified, make sure it actually exists.

   IF ( SettingsFlags%PointsFile ) THEN
      INQUIRE( file=Settings%PointsFile, exist=TempFileExist )
      IF ( TempFileExist .eqv. .FALSE. ) CALL ProgAbort( "Cannot find the points file "//TRIM(Settings%InputFile))
   ENDIF



   !--------------------------------------------------------------------------
   !-=-=- Initialize the Module -=-=-
   !--------------------------------------------------------------------------
   !  Initialize the IfW module --> it will initialize all its pieces

   CALL IfW_Init( IfW_InitInputData, IfW_InputData, IfW_ParamData, &
                  IfW_ContStateData, IfW_DiscStateData, IfW_ConstrStateData, IfW_OtherStateData, &
                  IfW_OutputData, TimeStep, ErrStat, ErrMsg )


      ! Make sure no errors occured that give us reason to terminate now.

   IF ( ErrStat == ErrID_Severe ) CALL ProgAbort( ErrMsg )
   IF ( ErrStat == ErrID_Fatal )  CALL ProgAbort( ErrMsg )



   !--------------------------------------------------------------------------
   !-=-=- Other Setup -=-=-
   !--------------------------------------------------------------------------
   !  Setup any additional things
   !  -- reset bounds to reasonable level (can't do more than what actually exists in the file)
   !  -- setup the matrices for handling the data?





   !FIXME: check that the FFT file can be made


   !--------------------------------------------------------------------------
   !-=-=- Time stepping loop -=-=-
   !--------------------------------------------------------------------------
   !  Loop through the time
   !     -- send matrix of coordinates at each timestep --> ask for certain points at time T
   !     -- should get back a matrix of wind velocities at each coordinate
   !     -- Assemble the large matrix with all the small pieces

!FIXME: write this routine
!   CALL IfW_Calculate( )


   !--------------------------------------------------------------------------
   !-=-=- Calculate OtherStates -=-=-
   !--------------------------------------------------------------------------
   !  Iff we add in some averaging / TI / mean etc, it would be in OtherStates
   !     -- Test that here.




   !--------------------------------------------------------------------------
   !-=-=- Output results -=-=-
   !--------------------------------------------------------------------------
   !  ParaPrint         -- will create a ParaView file that can be looked at
   !  Write to screen   -- if ParaPrint isn't used


   !--------------------------------------------------------------------------
   !-=-=- We are done, so close everything down -=-=-
   !--------------------------------------------------------------------------

   CALL IfW_End(  IfW_InitInputData, IfW_ParamData, &
                  IfW_ContStateData, IfW_DiscStateData, IfW_ConstrStateData, IfW_OtherStateData, &
                  IfW_OutputData, ErrStat, ErrMsg )








END PROGRAM InflowWind_Driver




