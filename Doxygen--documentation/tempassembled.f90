!****************************************************************************
!
!  PROGRAM: InflowWind_Test  - This program tests the inflow wind module
!
!****************************************************************************

PROGRAM InflowWind_Test

   USE InflowWind
   USE SharedInflowDefs

   IMPLICIT NONE

   INTEGER ErrStat
   TYPE(InflInitInfo)  :: InitWindData         ! data to initialize the module; TYPE defined in InflowWindMod.f90

   REAL(ReKi)          :: InpPosition(3)
   TYPE(InflIntrpOut)  :: MyWindSpeed
   REAL(ReKi)          :: Time

   REAL(ReKi)          :: dt
   INTEGER             :: I


print*, "Test of flag CT_Flag: ",CT_Flag

   !-------------------------------------------------------------------------------------------------
   ! Send the data required for initialization
   !-------------------------------------------------------------------------------------------------

!      InitWindData%WindFileName     = "D:\DATA\Fortran\IVF Projects\AeroDyn\Update\Source\InflowWind\TestData\GPLLJ_DNS\InOut.wnd"
!      InitWindData%WindFileName     = "../TestRoutines/TestData/Periodic_Winds.wnd"    !! ff wind
      InitWindData%WindFileName     = "Test-Data/InOut.wnd"    !! ff wind
!      InitWindData%WindFileName     = "../Samples/Steady.wnd"  !! HH wind
!      InitWindData%WindFileName     = "../Samples/les.fdp"  !! 4 D -- points to some other files. -- not work
      InitWindData%ReferenceHeight  = 80.   ! meters
      InitWindData%Width            = 100.  ! meters

!     InitWindData%WindFileType     = FF_Wind
      InitWindData%WindFileType     = DEFAULT_Wind      ! let the module figure out what type of file it is...


      CALL InflowWind_Init( InitWindData, ErrStat )


      IF (errstat /=0) CALL ProgAbort('Error in Initialization routine')


   !-------------------------------------------------------------------------------------------------
   ! Get the wind speeds at various times and positions
   !-------------------------------------------------------------------------------------------------
      dt     = 0.05 ! seconds

      InpPosition(1) = 0.0                            ! longitudinal position front/back of tower
      InpPosition(2) = 0.0                            ! lateral position left/right of tower
      InpPosition(3) = InitWindData%ReferenceHeight   ! height relative to the ground

      DO I = 1,3 !time

         Time = 0.0 + (I-1)*dt

         MyWindSpeed = InflowWind_GetVelocity( Time, InpPosition, ErrStat )

         !IF (ErrStat /=0) CALL ProgAbort('Error in getting wind speed')

         WRITE(*,*) TRIM(Num2LStr(ErrStat)), ' V(t=', TRIM(Num2LStr(Time)), ') = ', MyWindSpeed

      END DO

   !-------------------------------------------------------------------------------------------------
   ! Clean up the variables and close files
   !-------------------------------------------------------------------------------------------------
    CALL InflowWind_Terminate( ErrStat )


END PROGRAM InflowWind_Test

!MODULARIZATION NOTES:
!  This file will eventually be replaced with an autogenerated one by the registry program
!  So, for now we will modify this as we develop, then setup the txt file for registry program to use
!     1) modify this to match new style
!     2) setup the InflowWind.txt file for the registry program
!     3) run the registry program to generate the InflowWind_Types.f90 file
!     4) verify that works correctly before removing this (compile with each and verify output)
!
!
!----------------------------------------------------------------------------------------------------
!FIXME: rename
MODULE SharedInflowDefs
! This module is used to define shared types and parameters that are used in the module InflowWind.
! 7 Oct 2009    B. Jonkman, NREL/NWTC
!----------------------------------------------------------------------------------------------------

   USE NWTC_Library                                               ! Precision module

   !-------------------------------------------------------------------------------------------------
   ! Shared types
   !-------------------------------------------------------------------------------------------------

!FIXME: Setup the standard types here.

!   TYPE, PUBLIC :: InflLoc
!      REAL(ReKi)                    :: Position(3)                ! X, Y, Z
!   END TYPE InflLoc


   TYPE, PUBLIC :: InflIntrpOut
      REAL(ReKi)                    :: Velocity(3)                ! U, V, W
   END TYPE InflIntrpOut

   !-------------------------------------------------------------------------------------------------
   ! Shared parameters, defining the wind types
   ! THEY MUST BE UNIQUE!
   !-------------------------------------------------------------------------------------------------

!FIXME: I'm not sure what to do with these
   INTEGER, PARAMETER, PUBLIC  :: DEFAULT_Wind = -1        ! Undetermined wind type; calls internal routine to guess what type of file it is.
   INTEGER, PARAMETER, PUBLIC  :: Undef_Wind   =  0        ! This is the code for an undefined WindType
   INTEGER, PARAMETER, PUBLIC  :: HH_Wind      =  1        ! Hub-Height wind file
   INTEGER, PARAMETER, PUBLIC  :: FF_Wind      =  2        ! Binary full-field wind file
   INTEGER, PARAMETER, PUBLIC  :: UD_Wind      =  3        ! User-defined wind
   INTEGER, PARAMETER, PUBLIC  :: FD_Wind      =  4        ! 4-dimensional wind (LES)
   INTEGER, PARAMETER, PUBLIC  :: CTP_Wind     =  5        ! Coherent turbulence wind field (superimpose KH billow on background wind)
   INTEGER, PARAMETER, PUBLIC  :: HAWC_Wind    =  6        ! Binary full-field wind file in HAWC format

!The following was moved. I don't know if it will get properly stored anymore.
   INTEGER, SAVE                  :: WindType = Undef_Wind  ! Wind Type Flag

!The following was moved. I don't know if it will get properly stored anymore.
   LOGICAL, SAVE                  :: CT_Flag  = .FALSE.     ! determines if coherent turbulence is used
END MODULE SharedInflowDefs
MODULE CTWind
! This module uses reads coherent turbulence parameter (CTP) files and processes the data in them
! to get coherent turbulence which is later superimposed on a background wind field (the super-
! positioning occurs elsewhere).  The turbulence in this module is part of the KH billow, which
! can be read using FDWind.  As a result, the scaling here should be similiar to FDWind.
!
! This module assumes that the origin, (0,0,0), is located at the tower centerline at ground level,
! and that all units are specified in the metric system (using meters and seconds).
! Data is shifted by half the grid width when used with FFWind.
!
!  Created 25-Sept-2009 by B. Jonkman, National Renewable Energy Laboratory
!     using subroutines and modules from AeroDyn v12.58
!
!----------------------------------------------------------------------------------------------------

   USE                     NWTC_Library
   USE                     SharedInflowDefs

   IMPLICIT                NONE
   PRIVATE
   
      
   INTEGER, PARAMETER           :: NumComps  = 3                              ! number of components
   
            ! CT_Wind
   REAL(ReKi)                   :: DelYCTgrid                                 ! The nondimensional distance between grid points in the y direction.
   REAL(ReKi)                   :: DelZCTgrid                                 ! The nondimensional distance between grid points in the z direction.
   REAL(ReKi)                   :: CTDistSc                                   ! Disturbance scale (ratio of wave height to rotor diameter).
   REAL(ReKi)                   :: CTOffset (NumComps)                        ! Offsets to convert integer data to actual wind speeds.
   REAL(ReKi)                   :: CTScale  (NumComps)                        ! Scaling factors to convert integer data to actual wind speeds.

   
   REAL(ReKi), ALLOCATABLE      :: CTvelU   (:,:,:)                         ! The y-z grid velocity data (U components) for the lower- and upper-bound time slices
   REAL(ReKi), ALLOCATABLE      :: CTvelV   (:,:,:)                         ! The y-z grid velocity data (V components) for the lower- and upper-bound time slices
   REAL(ReKi), ALLOCATABLE      :: CTvelW   (:,:,:)                         ! The y-z grid velocity data (W components) for the lower- and upper-bound time slices
   REAL(ReKi)                   :: CTLy                                       ! Fractional location of tower centerline from right (looking downwind) to left side of the dataset.
   REAL(ReKi)                   :: CTLz                                       ! Fractional location of hub height from bottom to top of dataset.
   REAL(ReKi)                   :: CTScaleVel                                 ! Scaling velocity, U0.  2*U0 is the difference in wind speed between the top and bottom of the wave.
   REAL(ReKi), ALLOCATABLE      :: Tdata    (:)                               ! The list of times for the CT-wind input files.  
   
   REAL(ReKi)                   :: CT_Zref                                    ! The reference height for the CT file (the bottom of the billow)
   REAL(ReKi)                   :: CTYHWid                                    ! The half the width of the background dataset, used to compute the CTwind time offset
   REAL(ReKi)                   :: CTYmax                                     ! The dimensional lateral width of the dataset.
   REAL(ReKi)                   :: CTYt                                       ! Distance of the tower from the right side of the dataset (looking downwind).
   REAL(ReKi)                   :: CTZmax                                     ! The dimensional vertical height of the dataset.
   REAL(ReKi)                   :: InvMCTWS                                   ! The multiplicative inverse of the mean hub height wind speed for the CT wind data

   INTEGER                      :: CT_DF_Y                                    ! The decimation factor for the CT wind data in the y direction.
   INTEGER                      :: CT_DF_Z                                    ! The decimation factor for the CT wind data in the z direction.
   INTEGER                      :: CTvel_files(2)                             ! Times for the CT wind files stored in CTvel arrays.

   INTEGER                      :: IndCT_hi                                   ! An index into the 3rd dimension of the CTvel arrays, indicating the upper time slice (allows us to avoid copying array)
   INTEGER                      :: IndCT_lo                                   ! An index into the 3rd dimension of the CTvel arrays, indicating the lower time slice (allows us to avoid copying array)
   
   INTEGER                      :: NumCTt                                     ! The number of CT wind grids, no more than one grid per time step.
   INTEGER                      :: NumCTy                                     ! The number of CT wind grid points in the y direction.
   INTEGER                      :: NumCTyD                                    ! The decimated number of CT wind grid points in the y direction.
   INTEGER                      :: NumCTyD1                                   ! The decimated number of CT wind grid points in the y direction minus 1.
   INTEGER                      :: NumCTz                                     ! The number of CT wind grid points in the z direction.
   INTEGER                      :: NumCTzD                                    ! The decimated number of CT wind grid points in the z direction.
   INTEGER                      :: NumCTzD1                                   ! The decimated number of CT wind grid points in the z direction minus 1.
   INTEGER, SAVE                :: TimeIndx  = 0                              ! Index into the time array
   INTEGER, ALLOCATABLE         :: TimeStpCT (:)                              ! The list of time steps from the original LE simulation, associated with the CT-wind times.

   INTEGER                      :: CTWindUnit                                 ! unit number used to read the wind files at each call to CT_GetWindSpeed()
   
   LOGICAL                      :: CTVertShft                                 ! Flag to indicate whether or not to shift the z values for the w component.

   CHARACTER(3)                 :: CText                                      ! The extension used for coherent turbulence data files. (usually "les" or "dns")
   CHARACTER(1024)              :: CTSpath                                    ! The path to the CT wind files.

   TYPE :: CTWindFiles
      CHARACTER(1024)           :: CTTSfile                                   ! The name of the file containing the time-step history of the wind files.
      CHARACTER(1024)           :: CTbackgr                                   ! The name of the background wind data
   END TYPE CTWindFiles


   TYPE, PUBLIC :: CT_Backgr
      CHARACTER(1024)           :: WindFile                                   ! The name of the background wind file
      INTEGER                   :: WindFileType                               ! The type of background wind file (currently only FF)
      LOGICAL                   :: CoherentStr                                ! If the coherent time step file is blank or doesn't exist, this is FALSE (use the background only)
   END TYPE CT_Backgr
            
   
   PUBLIC                       :: CT_Init
   PUBLIC                       :: CT_GetWindSpeed
   PUBLIC                       :: CT_SetRefVal
   PUBLIC                       :: CT_Terminate

CONTAINS
!====================================================================================================
SUBROUTINE CT_Init(UnWind, WindFile, BackGrndValues, ErrStat)
!  This subroutine is called at the beginning of a simulation.  It reads the CTP file to obtain
!  the name of the CTS file, the path locating the binary KH files, and decimation factors.
!  It returns the background wind file and type; it also returns a flag that determines if CT wind
!  files are ACTUALLY to be used (e.g., if the CTS file is blank or there is one line of zero in the
!  CTS time array).  
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: WindFile                     ! Name of the CTP (.ctp) wind file
   TYPE(CT_Backgr), INTENT(OUT)   :: BackGrndValues               ! output background values
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise


      ! Local Variables:
      
   TYPE(CTWindFiles)              :: CTP_files
   CHARACTER(3)                   :: CT_SC_ext                    ! extension of the scaling file
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( TimeIndx /= 0 ) THEN  
      CALL WrScr( ' CTWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Read the CTP file and set the background data info to be returned later
   !-------------------------------------------------------------------------------------------------
   
   CALL ReadCTP( UnWind, WindFile, CTP_files, ErrStat )
   IF (ErrStat /= 0) RETURN           
   
  
   BackGrndValues%WindFile     = CTP_files%CTbackgr
   BackGrndValues%WindFileType = FF_Wind             !bjj: perhaps we should check the wind type here
   
   !-------------------------------------------------------------------------------------------------
   ! Read the CTTS file to get the time step and file number arrays
   !-------------------------------------------------------------------------------------------------   
   CALL ReadCTTS( UnWind, CTP_files%CTTSfile, CT_SC_ext, ErrStat )

   IF (ErrStat == 0 .AND. NumCTt > 1) THEN    
      BackGrndValues%CoherentStr  = .TRUE.
      
      !-------------------------------------------------------------------------------------------------
      ! Read file containing scaling for the binary large-eddy files
      !-------------------------------------------------------------------------------------------------
      CALL ReadCTScales( UnWind, TRIM( CTSpath )//'\Scales.'//TRIM( CT_SC_ext ), ErrStat )
      IF (ErrStat /= 0) RETURN


      CTScale(:)  = CTScaleVel*CTScale(:)
      CTOffset(:) = CTScaleVel*CTOffset(:)

   ELSE              
      
      IF (ErrStat <= 0) THEN
         
            ! The file is missing, blank (or possibly incomplete), or has only 1 time step line (which  
            ! is zero); Go on without the CT file, using just the background

         CALL ProgWarn( ' Coherent turbulence wind file will be turned off.' )
         
         BackGrndValues%CoherentStr  = .FALSE.
         CALL CT_Terminate( ErrStat )          
         
      END IF

      RETURN
      
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Set some values that don't change during the run
   !-------------------------------------------------------------------------------------------------
      
   CTYHWid        = 0.0                                                    ! This value is used to perform a time shift (the equivalent distance of FFYHWid [approx. rotor radius])
   CT_Zref        = -1.0                                                   ! This value needs to be set after the corresponding background turbulence has been read (or the CTS file should be changed)

   NumCTyD        = ( NumCTy + CT_DF_Y - 1 )/CT_DF_Y                       ! The decimated number of CT wind grid points in the y direction.
   NumCTzD        = ( NumCTz + CT_DF_Z - 1 )/CT_DF_Z                       ! The decimated number of CT wind grid points in the z direction.
   NumCTyD1       = NumCTyD - 1                                            ! The decimated number of CT wind grid points in the y direction minus 1.
   NumCTzD1       = NumCTzD - 1                                            ! The decimated number of CT wind grid points in the z direction minus 1.

   CTYt           = CTYmax*CTLy                                            ! Distance of the tower from the right side of the dataset (looking downwind).
!   CTZt           = CTZmax*CTLz                                            ! Distance of the hub from the bottom of the dataset.
   DelYCTgrid     = 1.0/NumCTyD1                                           ! The nondimensional distance between grid points in the y direction.
   DelZCTgrid     = 1.0/NumCTzD1                                           ! The nondimensional distance between grid points in the z direction.
    

     
   !-------------------------------------------------------------------------------------------------
   ! Allocate the wind array and initialize it
   !-------------------------------------------------------------------------------------------------
   
   IF (.NOT. ALLOCATED(CTvelU) ) THEN
      ALLOCATE ( CTvelU(NumCTyD,NumCTzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the CTvelU array.' )
         RETURN
      END IF
   END IF   
   
   IF (.NOT. ALLOCATED(CTvelV) ) THEN
!      CALL AllocAry( CTvelV, NumCTyD, NumCTzD, 2, 'CTvelV', ErrStat ) !AllRAry3 AllocAry
      ALLOCATE ( CTvelV(NumCTyD,NumCTzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the CTvelV array.' )
         RETURN
      END IF
   END IF   
   
   IF (.NOT. ALLOCATED(CTvelW) ) THEN
!      CALL AllocAry( CTvelW, NumCTyD, NumCTzD, 2, 'CTvelW', ErrStat ) !AllRAry3 AllocAry
      ALLOCATE ( CTvelW(NumCTyD,NumCTzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the CTvelW array.' )
         RETURN
      END IF
   END IF   

   CTvelU(:,:,:) = 0.0                                                    ! the original velocity data      
   CTvelV(:,:,:) = 0.0                                                    ! the original velocity data      
   CTvelW(:,:,:) = 0.0                                                    ! the original velocity data      
      
   !-------------------------------------------------------------------------------------------------
   ! Initialize the arrays and set the initialization flag
   !-------------------------------------------------------------------------------------------------   
   CTvel_files(:) = 0                                                      ! the name of the files currently in the CTvel array
   CTWindUnit     = UnWind                                                 ! This unit is needed to open the binary files at each step
   TimeIndx       = 1
    
   RETURN

END SUBROUTINE CT_Init
!====================================================================================================
SUBROUTINE CT_SetRefVal(Height, HWidth, ErrStat)

   REAL(ReKi), INTENT(IN)           :: Height                                 ! a reference height (should be hub height)
   REAL(ReKi), INTENT(IN), OPTIONAL :: HWidth                                 ! a reference offset (should be half grid width [~rotor radius])
   INTEGER,    INTENT(OUT)          :: ErrStat                                ! returns 0 if no error; non-zero otherwise


   !-------------------------------------------------------------------------------------------------     
   ! Check that we've initialized everything first
   !-------------------------------------------------------------------------------------------------     
     
   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Initialialize the CTWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE IF ( CT_Zref >= 0 ) THEN
      CALL WrScr( ' Cannot reset the CTWind reference height in the middle of a simulation.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0         
   END IF      


   !-------------------------------------------------------------------------------------------------     
   ! Set the grid shift using the half-width
   !-------------------------------------------------------------------------------------------------     
   IF ( PRESENT( HWidth ) ) THEN
      CTYHWid = HWidth
        
      IF ( CTYHWid < 0 ) THEN
         CALL WrScr( ' Reference width in CTWind cannot be negative.')
         CTYHWid = 0
         ErrStat = 1
      END IF
   END IF
 
 
   !-------------------------------------------------------------------------------------------------     
   ! Set the reference height (bottom of the KH billow) using the input hub-height
   !-------------------------------------------------------------------------------------------------     
      ! CTZt = CTZmax*CTLz             ! the distance between the hub and the bottom of the dataset

   CT_Zref = Height - CTZmax*CTLz      ! the height of the bottom of the KH billow

   IF ( CT_Zref < 0 ) THEN
      CALL WrScr( ' Reference height in CTWind cannot be negative.')
      CT_Zref = 0
      ErrStat = 1
   END IF      

   
END SUBROUTINE CT_SetRefVal
!====================================================================================================
FUNCTION CT_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are are 
! requested.  It returns the velocities at the specified time and space that are superimposed on
! a background wind flow.  This function interpolates into the full-field CT wind arrays, performing
! a time shift based on the average windspeed. The modified time is used to decide which pair of time 
! slices to interpolate within and between. After finding the two time slices, it decides which four 
! grid points bound the (Y,Z) pair. It does a bilinear interpolation for (Y,Z) on each bounding time 
! slice, then linearly interpolates between the 2 time slices. This routine assumes that X is downwind, 
! Y is to the left when looking downwind and Z is up.  In the time (X) and Z directions, steady winds 
! are used when extrapolation is required.  The dataset is assumed to be periodic in the Y direction.
!----------------------------------------------------------------------------------------------------
 
      ! Passed variables:
      
   REAL(ReKi),        INTENT(IN) :: Time                                   ! the time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)                       ! the position (X,Y,Z)
   INTEGER,           INTENT(OUT):: ErrStat                                ! returns 0 if no error; non-zero otherwise
   TYPE(InflIntrpOut)            :: CT_GetWindSpeed                        ! the resultant wind speed
   
   
      ! Local Variables:

   REAL(ReKi)                    :: Iyz_th                                 ! Temporary interpolated value. (time hi, all y, all z)
   REAL(ReKi)                    :: Iyz_tl                                 ! Temporary interpolated value. (time lo, all y, all z)
   REAL(ReKi)                    :: Iyhz                                   ! Temporary interpolated value. (y hi, all z)
   REAL(ReKi)                    :: Iylz                                   ! Temporary interpolated value. (y lo, all z)
   REAL(ReKi)                    :: TimeShifted                            ! Shifted time (necessary because we're keeping x constant)
   REAL(ReKi)                    :: Tgrid                                  ! Fractional distance between time grids.
   REAL(ReKi)                    :: Ygrid                                  ! Fractional distance between grids in the y direction.
   REAL(ReKi)                    :: Ynorm                                  ! Nondimensional lateral distance of the analysis point from right side of dataset (looking downwind).
   REAL(ReKi)                    :: Zgrid(3)                               ! Fractional distance between grids in the z direction.
   REAL(ReKi)                    :: Znorm                                  ! Nondimensional vertical distance of the analysis point from bottom of dataset.

   INTEGER                       :: I
   INTEGER                       :: IYHi
   INTEGER                       :: IYLo
   INTEGER                       :: IZHi(3)
   INTEGER                       :: IZLo(3)


   !-------------------------------------------------------------------------------------------------     
   ! Check that we've initialized everything first
   !-------------------------------------------------------------------------------------------------     
     
   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Initialialize the CTWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE IF ( CT_Zref < 0 ) THEN
      CALL WrScr( ' Set the reference height in the CTWind module before calling CT_GetWindSpeed.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------     
   ! Perform the time shift. At time=0, a point half the grid width downstream will index into the zero 
   ! time slice.  CTYHWid is used to shift the CT wind the same as FF wind is shifted.
   ! This assumes that the coherent turbulence events are moving at MCTWS
   !-------------------------------------------------------------------------------------------------     

   TimeShifted = TIME + ( CTYHWid - InputPosition(1) )*InvMCTWS


   !-------------------------------------------------------------------------------------------------
   ! Find the bounding time slices:
   ! Linearly interpolate in time (or set to 0 before and/or after) 
   ! (compare with NWTC_Num.f90\InterpStpReal) 
   !-------------------------------------------------------------------------------------------------

      ! Let's check the limits first.

   IF ( TimeShifted <= Tdata(1) )  THEN
   
      TimeIndx = 1
      Tgrid    = 0.0
                     
!      CT_GetWindSpeed%Velocity(:) = 0.0
!      RETURN
                           
   ELSE IF ( TimeShifted >= Tdata(NumCTt) )  THEN
   
      TimeIndx = NumCTt - 1
      Tgrid    = 1.0

!      CT_GetWindSpeed%Velocity(:) = 0.0
!      RETURN
      
   ELSE
   
         ! Let's interpolate!

      TimeIndx = MAX( MIN( TimeIndx, NumCTt-1 ), 1 )


      DO 

         IF ( TimeShifted < Tdata(TimeIndx) )  THEN

            TimeIndx = TimeIndx - 1

         ELSE IF ( TimeShifted >= Tdata(TimeIndx+1) )  THEN

            TimeIndx = TimeIndx + 1

         ELSE
         
            Tgrid = MIN( MAX( ( TimeShifted - Tdata(TimeIndx) )/( Tdata(TimeIndx+1) - Tdata(TimeIndx) ), 0.0 ), 1.0 )
            EXIT

         END IF

      END DO
      
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Read the data at the two time steps, if necessary
   !-------------------------------------------------------------------------------------------------
     
   IF ( TimeStpCT(TimeIndx) == CTvel_files(2) ) THEN
      IndCT_lo = 2      
      IndCT_hi = 1
            
   ELSE
      IndCT_lo = 1
      IndCT_hi = 2 
        
      IF ( TimeStpCT(TimeIndx) /= CTvel_files(IndCT_lo) ) THEN         
         CTvel_files(IndCT_lo) = TimeStpCT(TimeIndx)
         CALL ReadCTData ( CTWindUnit, CTvel_files(IndCT_lo), IndCT_lo, ErrStat  )
      END IF
      
   END IF
   

   IF ( CTvel_files(IndCT_hi) /= TimeStpCT(TimeIndx+1) ) THEN
      
      CTvel_files(IndCT_hi) = TimeStpCT(TimeIndx+1)
      CALL ReadCTData ( CTWindUnit, CTvel_files(IndCT_hi), IndCT_hi, ErrStat  )

   END IF
         

   !-------------------------------------------------------------------------------------------------
   ! Calculate the y values;                   The lower-right corner is (1,1) when looking downwind.
   ! note that the KH data is periodic in this direction
   !-------------------------------------------------------------------------------------------------
   
   Ynorm = ( CTYt + InputPosition(2) )/CTYmax

      ! Ensure Ynorm is not negative.  The wave is periodic in y.

   IF ( Ynorm < 0.0 ) THEN
      Ynorm = 1.0 + MOD(Ynorm, 1.0)
   ENDIF

   Ygrid = MIN( MAX( MOD( Ynorm, DelYCTgrid ), 0.0 ), 1.0 )
   IYLo  = MAX( MOD( INT( Ynorm*NumCTyD1 ) + 1, NumCTyD1 ), 1 )
   IYHi =  MOD( IYLo, NumCTyD ) + 1


   !-------------------------------------------------------------------------------------------------
   ! Calculate the z values                   The lower-right corner is (1,1) when looking downwind.
   ! Note: the equivalent Znorm for the w-component may be shifted vertically by half the original
   ! grid spacing. (the K-H data staggers w differently than u & v).  We store IZLo, IZHi, and 
   ! Zgrid in an array to account for this difference.
   !-------------------------------------------------------------------------------------------------

   Znorm = MIN( MAX( ( InputPosition(3) - CT_Zref )/CTZmax, 0.0 ), 1.0 ) ! non-dimensional height (CT_Zref is the bottom of the billow)

      ! Find out fractionally how far we are between grids in time and between grid points in each direction.
      ! Limit values to avoid extrapolation.  We need this for interpolation later on.

   Zgrid(1:2)   = MIN( MAX( MOD( Znorm, DelZCTgrid ), 0.0 ), 1.0 )
   IZLo(1:2)    = MAX( INT( Znorm*NumCTzD1 ) + 1, 1 )            ! Make sure the lowest possible value is 1.

      ! If we are located at the upper end of the z dimension, decrement the index by one and set the grid coordinate to 1.

   IF ( IZLo(1) == NumCTzD )  THEN
      IZLo(1:2)  = NumCTzD1
      Zgrid(1:2) = 1.0
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Find the equivalent Znorm for the w-component, which may be shifted vertically by half 
   ! the original grid spacing. (This is necessary due to the fact that the K-H data staggers w 
   ! differently than u & v).  LES and DNS scale differently.
   !-------------------------------------------------------------------------------------------------

   IF ( CTVertShft )  THEN
      Znorm = MAX( Znorm - 0.5*DelZCTgrid/CT_DF_Z, 0.0 )
      
      Zgrid(3) = MIN( MAX( MOD( Znorm, DelZCTgrid ), 0.0 ), 1.0 )
      IZLo(3)  = MAX( INT( Znorm*NumCTzD1 ) + 1, 1 )       ! Make sure the lowest possible value is 1.


         ! If we are located at the upper end of the z dimension, decrement the index by one and set the grid coordinate to 1.

      IF ( IZLo(3) == NumCTzD )  THEN
         IZLo(3)  = NumCTzD1
         Zgrid(3) = 1.0
      ENDIF
                 
   ELSE
      IZLo(3) = IZLo(1)
      Zgrid(3)= Zgrid(1)          
   ENDIF

   IZHi(:) = IZLo(:) + 1
   
!bjj: old versions used Zgrid(3) = Zgrid(1) without regard to CTVertShft. It seemed wrong to me so I changed it.

   !-------------------------------------------------------------------------------------------------
   !  Interpolate for U component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

      I = 1
         ! linearaly interpolate in the lower time slice
      Iylz   = ( CTvelU(IYLo,IZHi(I),IndCT_lo) - CTvelU(IYLo,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelU(IYLo,IZLo(I),IndCT_lo)
      Iyhz   = ( CTvelU(IYHi,IZHi(I),IndCT_lo) - CTvelU(IYHi,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelU(IYHi,IZLo(I),IndCT_lo)     
      Iyz_tl = ( Iyhz - Iylz )*Ygrid + Iylz

         ! linearaly interpolate in the upper time slice
      Iylz   = ( CTvelU(IYLo,IZHi(I),IndCT_hi) - CTvelU(IYLo,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelU(IYLo,IZLo(I),IndCT_hi)
      Iyhz   = ( CTvelU(IYHi,IZHi(I),IndCT_hi) - CTvelU(IYHi,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelU(IYHi,IZLo(I),IndCT_hi)     
      Iyz_th = ( Iyhz - Iylz )*Ygrid + Iylz

      CT_GetWindSpeed%Velocity(I) = ( Iyz_th - Iyz_tl )*Tgrid + Iyz_tl


   !-------------------------------------------------------------------------------------------------
   !  Interpolate for V component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

      I = 2

         ! linearaly interpolate in the lower time slice
      Iylz   = ( CTvelV(IYLo,IZHi(I),IndCT_lo) - CTvelV(IYLo,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelV(IYLo,IZLo(I),IndCT_lo)
      Iyhz   = ( CTvelV(IYHi,IZHi(I),IndCT_lo) - CTvelV(IYHi,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelV(IYHi,IZLo(I),IndCT_lo)     
      Iyz_tl = ( Iyhz - Iylz )*Ygrid + Iylz

         ! linearaly interpolate in the upper time slice
      Iylz   = ( CTvelV(IYLo,IZHi(I),IndCT_hi) - CTvelV(IYLo,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelV(IYLo,IZLo(I),IndCT_hi)
      Iyhz   = ( CTvelV(IYHi,IZHi(I),IndCT_hi) - CTvelV(IYHi,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelV(IYHi,IZLo(I),IndCT_hi)     
      Iyz_th = ( Iyhz - Iylz )*Ygrid + Iylz

      CT_GetWindSpeed%Velocity(I) = ( Iyz_th - Iyz_tl )*Tgrid + Iyz_tl


   !-------------------------------------------------------------------------------------------------
   !  Interpolate for W component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

      I = 3

         ! linearaly interpolate in the lower time slice
      Iylz   = ( CTvelW(IYLo,IZHi(I),IndCT_lo) - CTvelW(IYLo,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelW(IYLo,IZLo(I),IndCT_lo)
      Iyhz   = ( CTvelW(IYHi,IZHi(I),IndCT_lo) - CTvelW(IYHi,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelW(IYHi,IZLo(I),IndCT_lo)     
      Iyz_tl = ( Iyhz - Iylz )*Ygrid + Iylz

         ! linearaly interpolate in the upper time slice
      Iylz   = ( CTvelW(IYLo,IZHi(I),IndCT_hi) - CTvelW(IYLo,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelW(IYLo,IZLo(I),IndCT_hi)
      Iyhz   = ( CTvelW(IYHi,IZHi(I),IndCT_hi) - CTvelW(IYHi,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelW(IYHi,IZLo(I),IndCT_hi)     
      Iyz_th = ( Iyhz - Iylz )*Ygrid + Iylz

      CT_GetWindSpeed%Velocity(I) = ( Iyz_th - Iyz_tl )*Tgrid + Iyz_tl


   RETURN

END FUNCTION CT_GetWindSpeed
!====================================================================================================
SUBROUTINE ReadCTData ( UnWind, CTFileNo, Itime, ErrStat )
!    This subroutine is used to read one time-step's worth of large-eddy
!    zero-mean wind data for each wind component from a file.
!----------------------------------------------------------------------------------------------------


      ! Passed variables.

   INTEGER,       INTENT(IN)     :: UnWind                                    ! The I/O unit of the input file
   INTEGER,       INTENT(IN)     :: CTFileNo                                  ! The number of the file to read
   INTEGER,       INTENT(IN)     :: Itime                                     ! The index of the time slice
   INTEGER,       INTENT(OUT)    :: ErrStat                                   ! returns 0 if no error; non-zero otherwise

      ! Local variables.

!   CHARACTER(1),PARAMETER        :: Comp(NumComps) = (/'u', 'v', 'w' /)       ! the wind components
   CHARACTER(5)                  :: CTnum                                     ! string equivalent of input variable CTFileNo
   CHARACTER(1024)               :: FileName                                  ! The name of the input data file
   
   
   IF ( CTFileNo == 0 ) THEN
   
      CTvelU(:,:,Itime) = 0.0
      CTvelV(:,:,Itime) = 0.0
      CTvelW(:,:,Itime) = 0.0
      
   ELSE
         ! Loop through the components

      WRITE( CTnum, '(I5.5)' ) CTFileNo


      FileName = TRIM( CTSpath )//'\u\u_16i_'//CTnum//'.'//TRIM( CText )
      CALL LoadCTData( UnWind, TRIM(FileName), Itime, 1, CTvelU, ErrStat )
      IF ( ErrStat /= 0 ) RETURN
      

      FileName = TRIM( CTSpath )//'\v\v_16i_'//CTnum//'.'//TRIM( CText )
      CALL LoadCTData( UnWind, TRIM(FileName), Itime, 2, CTvelV, ErrStat )
      IF ( ErrStat /= 0 ) RETURN
      
      
      FileName = TRIM( CTSpath )//'\w\w_16i_'//CTnum//'.'//TRIM( CText )
      CALL LoadCTData( UnWind, TRIM(FileName), Itime, 3, CTvelW, ErrStat )
      IF ( ErrStat /= 0 ) RETURN
      
   
   END IF

   RETURN
   
END SUBROUTINE ReadCTData
!====================================================================================================
SUBROUTINE LoadCTData( UnWind, FileName, ITime, IComp, Vel, ErrStat )
!  This function is used to read the input parameters for the coherent turbulence events, 
!  based on the large-eddy simulation.
!----------------------------------------------------------------------------------------------------

      ! Passed variables.

   INTEGER,       INTENT(IN)     :: UnWind                                    ! The I/O unit of the input file
   CHARACTER(*),  INTENT(IN)     :: FileName                                  ! The name of the file to open
   INTEGER,       INTENT(IN)     :: Itime                                     ! The index of the time slice
   INTEGER,       INTENT(IN)     :: IComp                                     ! The index of the component
   REAL(ReKi),    INTENT(INOUT)  :: Vel    (NumCTyD,NumCTzD,2)                ! returns the velocity array (don't use INTENT OUT!)  
   INTEGER,       INTENT(OUT)    :: ErrStat                                   ! returns 0 if no error; non-zero otherwise

   INTEGER(B2Ki)                 :: Com    (NumCTy)                           ! Temporary array to hold component's integer values for a given Z.
   INTEGER                       :: IY                                        ! A DO index for indexing the arrays in the y direction.
   INTEGER                       :: IYK                                       ! An index for the decimated arrays in the y direction.
   INTEGER                       :: IZ                                        ! A DO index for indexing the arrays in the z direction.
   INTEGER                       :: IZK                                       ! An index for the decimated arrays in the z direction.



   !-------------------------------------------------------------------------------------------------
   ! Open the input file
   !-------------------------------------------------------------------------------------------------

   CALL OpenUInBEFile( UnWind, TRIM(FileName), 2*NumCTy, ErrStat )
   IF (ErrStat /= 0) RETURN


   !-------------------------------------------------------------------------------------------------
   ! Read the data and fill the arrays
   !-------------------------------------------------------------------------------------------------
      
   IZK = 0                          ! the Z index into the array (necessary b/c of decimation factor)
   DO IZ=1,NumCTz,CT_DF_Z

      READ (UnWind,REC=IZ,IOSTAT=ErrStat)  Com

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Error reading record '//TRIM( Num2LStr( IZ ) )//' of the binary CT wind file, "' &
                           //TRIM( FileName )//'."')
         RETURN                           

      ENDIF

      IZK = IZK + 1
      IYK = 0                       ! the Y index into the array (necessary b/c of decimation factor)
      
      DO IY=1,NumCTy,CT_DF_Y
         IYK = IYK + 1
         Vel(IYK,IZK,ITime) = CTScale(IComp)*Com(IY) + CTOffset(IComp)
      ENDDO ! IY

   ENDDO ! IZ


   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
      CLOSE ( UnWind )

   RETURN


END SUBROUTINE LoadCTData
!====================================================================================================
SUBROUTINE ReadCTP( UnWind, FileName, CTPscaling, ErrStat )
!  This function is used to read the input parameters for the coherent turbulence events, 
!  based on the large-eddy simulation.
!----------------------------------------------------------------------------------------------------


      ! Passed variables.

   INTEGER,            INTENT(IN)  :: UnWind                                   ! The I/O unit of the input file
   CHARACTER(*),       INTENT(IN)  :: FileName                                 ! The name of the input data file
   TYPE(CTWindFiles),  INTENT(OUT) :: CTPscaling                               ! The file names contained in the CTP file
   INTEGER,            INTENT(OUT) :: ErrStat                                  ! returns 0 if no error; non-zero otherwise


      ! Local variables.
      
   CHARACTER(1024)                 :: HeaderLine                               ! The header text in the file
   CHARACTER(1024)                 :: TmpPath

   !-------------------------------------------------------------------------------------------------
   ! Open the CTP input file
   !-------------------------------------------------------------------------------------------------
   
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) RETURN


   !-------------------------------------------------------------------------------------------------
   ! Read the CTP input file
   !-------------------------------------------------------------------------------------------------
   CALL ReadStr( UnWind, TRIM( FileName ), HeaderLine, 'Header line', 'The header line in the CTP file', ErrStat )
   IF (ErrStat /= 0) RETURN   
   CALL WrScr ( ' Heading of the CT-wind-parameter file: "'//TRIM(HeaderLine)//'"' )


   CALL ReadCom( UnWind, TRIM( FileName ), 'parameter header line', ErrStat )
   IF (ErrStat /= 0) RETURN
   

   CALL ReadVar( UnWind, TRIM( FileName ), CTSpath,  'CTSpath',  & 
                  'Location (path) of the binary coherent turbulence dataset', ErrStat )
   IF (ErrStat /= 0) RETURN
                  

   CALL ReadVar( UnWind, TRIM( FileName ), CTPscaling%CTTSfile, 'CTTSfile', &
                  'File containing the time steps for the coherent turbulence events (.cts)', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   
   IF ( PathIsRelative( CTPscaling%CTTSfile ) ) THEN
      CALL GetPath( FileName, TmpPath ) 
      CTPscaling%CTTSfile = TRIM(TmpPath)//TRIM(CTPscaling%CTTSfile)
   END IF      

   CALL ReadVar( UnWind, TRIM( FileName ), CTPscaling%CTbackgr, 'CTbackgr', 'File containing the background wind', ErrStat )
   IF (ErrStat /= 0) RETURN

   IF ( PathIsRelative( CTPscaling%CTbackgr ) ) THEN
      CALL GetPath( FileName, TmpPath ) 
      CTPscaling%CTbackgr = TRIM(TmpPath)//TRIM(CTPscaling%CTbackgr)
   END IF      


   CALL ReadVar( UnWind, TRIM( FileName ), CT_DF_Y, 'CT_DF_Y', 'Decimation factor for wind data in the Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CT_DF_Z, 'CT_DF_Z', 'Decimation factor for wind data in the Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN

   
   !-------------------------------------------------------------------------------------------------
   ! Close the CTP input file
   !-------------------------------------------------------------------------------------------------
   
   CLOSE( UnWind )


END SUBROUTINE ReadCTP
!====================================================================================================
SUBROUTINE ReadCTTS ( UnWind, FileName, CT_SC_ext, ErrStat )
!  This subroutine is used to read the input parameters calculated in TurbSim for the scaling of 
!  coherent turbulence events.  It reads the .cts file and saves the time step and file number arrays.
!----------------------------------------------------------------------------------------------------


      ! Passed variables.

   INTEGER,            INTENT(IN)  :: UnWind                                   ! The I/O unit of the input file
   CHARACTER(*),       INTENT(IN)  :: FileName                                 ! The name of the input data file
   INTEGER,            INTENT(OUT) :: ErrStat                                  ! returns 0 if no error; -1 if the file is blank or can't be opened;                                                                               ! non-zero otherwise
   CHARACTER(3),       INTENT(OUT) :: CT_SC_ext                                ! The extension used for coherent turbulence scale files.(usually "les", "dns", or "dat")

      ! Local variables
   INTEGER                         :: IT                                       ! Loop counter

   !-------------------------------------------------------------------------------------------------
   ! Initialize variables
   !-------------------------------------------------------------------------------------------------

   NumCTt = 0

   !-------------------------------------------------------------------------------------------------
   ! Open the CTS input file
   !-------------------------------------------------------------------------------------------------
   
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) THEN
      ErrStat = -1
      RETURN
   END IF
   
   !-------------------------------------------------------------------------------------------------
   ! Read the header of the CTS input file
   !-------------------------------------------------------------------------------------------------
   
      ! Check to see if the first value is numeric (old) or the file type (new) and start again
      
   READ ( UnWind, *, IOSTAT=ErrStat ) CTScaleVel       
   REWIND( UnWind )  


   IF ( ErrStat /= 0 )  THEN   ! try again
            
      CALL ReadVar( UnWind, TRIM( FileName ), CText, 'CText', 'FileType ', ErrStat ) 
      IF ( ErrStat /= 0 ) THEN
         ErrStat = SIGN( 1, ErrStat)
         RETURN
      END IF
      CT_SC_ext = CText      
      
      CALL ReadVar( UnWind, TRIM( FileName ), CTScaleVel, 'CTScaleVel', ' ', ErrStat ) 
      IF ( ErrStat /= 0 ) RETURN
   ELSE  ! assume LES files
   
      CALL ReadVar( UnWind, TRIM( FileName ), CTScaleVel, 'CTScaleVel', ' ', ErrStat ) 

      CText     = 'les'
      CT_SC_ext = 'dat'
   END IF
   
   CALL ReadVar( UnWind, TRIM( FileName ), InvMCTWS, 'MeanCTWS', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   InvMCTWS = 1.0 / InvMCTWS
      

   CALL ReadVar( UnWind, TRIM( FileName ), CTYmax, 'CTYmax', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   

   CALL ReadVar( UnWind, TRIM( FileName ), CTZmax, 'CTZmax', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CTDistSc, 'CTDistSc', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CTLy, 'CTLy', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   
   
   CALL ReadVar( UnWind, TRIM( FileName ), CTLz, 'CTLz', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   
   
   CALL ReadVar( UnWind, TRIM( FileName ), NumCTt, 'NumCTt', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   !-------------------------------------------------------------------------------------------------
   ! Allocate space for the arrays
   !-------------------------------------------------------------------------------------------------

   IF (.NOT. ALLOCATED(Tdata) ) THEN
      ALLOCATE ( Tdata(NumCTt) , STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the Tdata array.' )
         RETURN
      END IF
   END IF

   IF (.NOT. ALLOCATED(TimeStpCT) ) THEN
      ALLOCATE ( TimeStpCT(NumCTt) , STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the TimeStpCT array.' )
         RETURN
      END IF
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Read the arrays from the CTS input file
   !-------------------------------------------------------------------------------------------------
   
   DO IT=1,NumCTt

      READ (UnWind,*,IOSTAT=ErrStat)  Tdata(IT), TimeStpCT(IT)

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error reading record '//TRIM( Num2LStr( IT ) )//' of the CT-wind time-steps file, "' &
                         //TRIM( FileName )//'."')

         NumCTt = IT - 1
         RETURN
      ENDIF

   ENDDO ! IT


   !-------------------------------------------------------------------------------------------------
   ! Close the CTS input file
   !-------------------------------------------------------------------------------------------------
   CLOSE( UnWind )


   RETURN
   
END SUBROUTINE ReadCTTS
!====================================================================================================
SUBROUTINE ReadCTScales ( UnWind, FileName, ErrStat )
!  This subroutine is used to read the input parameters for the coherent turbulence events, based
!  on the large-eddy simulation.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,            INTENT(IN)  :: UnWind                                   ! The I/O unit of the input file
   CHARACTER(*),       INTENT(IN)  :: FileName                                 ! The name of the input data file
   INTEGER,            INTENT(OUT) :: ErrStat                                  ! returns 0 if no error; non-zero otherwise


      ! Local variables
      
   INTEGER                         :: I                                        ! Array counter

   !-------------------------------------------------------------------------------------------------
   ! Open the file with the scales (les or dns)
   !-------------------------------------------------------------------------------------------------

   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) RETURN
   

   !-------------------------------------------------------------------------------------------------
   ! Read the file with the scales (les or dns)
   !-------------------------------------------------------------------------------------------------

   CALL ReadCom( UnWind, TRIM( FileName ), 'First line', ErrStat )
   IF (ErrStat /= 0) RETURN

   CALL ReadVar( UnWind, TRIM( FileName ), CTVertShft, 'CTVertShft', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN

   DO I = 1,3
      CALL ReadVar( UnWind, TRIM( FileName ), CTScale(I), 'CTScale('//TRIM(Num2LStr(I))//')', ' ', ErrStat ) 
      IF ( ErrStat /= 0 )  RETURN
   
      CALL ReadVar( UnWind, TRIM( FileName ), CTOffset(I), 'CTOffset('//TRIM(Num2LStr(I))//')', ' ', ErrStat ) 
      IF ( ErrStat /= 0 )  RETURN
   END DO !I

   CALL ReadVar( UnWind, TRIM( FileName ), NumCTy, 'NumCTy', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN

   CALL ReadVar( UnWind, TRIM( FileName ), NumCTz, 'NumCTz', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   !-------------------------------------------------------------------------------------------------
   ! Close the file with the scales (les or dns)
   !-------------------------------------------------------------------------------------------------
   
   CLOSE( UnWind )
   

   RETURN
   
END SUBROUTINE ReadCTScales
!====================================================================================================
SUBROUTINE CT_Terminate( ErrStat )
! This subroutine closes files, deallocates memory, and un-sets the initialization flag
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise


   CLOSE( CTWindUnit )
   
   ErrStat = 0

   IF ( ALLOCATED( CTvelU    ) )  DEALLOCATE( CTvelU,    STAT=ErrStat )
   IF ( ALLOCATED( CTvelV    ) )  DEALLOCATE( CTvelV,    STAT=ErrStat )
   IF ( ALLOCATED( CTvelW    ) )  DEALLOCATE( CTvelW,    STAT=ErrStat )
   IF ( ALLOCATED( Tdata     ) )  DEALLOCATE( Tdata,     STAT=ErrStat )
   IF ( ALLOCATED( TimeStpCT ) )  DEALLOCATE( TimeStpCT, STAT=ErrStat )

   TimeIndx = 0

END SUBROUTINE CT_Terminate
!====================================================================================================
END MODULE CTWind
MODULE FDWind
! This module reads and processes 4-dimensional wind fields.
! The subroutines were originally created by Marshall Buhl to read LES data provided by researchers
! at NCAR. It was later updated by Bonnie Jonkman to read DNS data provided by researchers at CoRA.
!
! Data are assumed to be in units of meters and seconds.
!
!  7 Oct 2009    B. Jonkman, NREL/NWTC using subroutines from AeroDyn 12.57
!----------------------------------------------------------------------------------------------------  

    USE                     NWTC_Library
    USE                     SharedInflowDefs

    IMPLICIT                NONE
   PRIVATE
  
      ! FD_Wind
      
   REAL(ReKi)                   :: DelXgrid                                   ! The nondimensional distance between grid points in the x direction.
   REAL(ReKi)                   :: DelYgrid                                   ! The nondimensional distance between grid points in the y direction.
   REAL(ReKi)                   :: DelZgrid                                   ! The nondimensional distance between grid points in the z direction.
   REAL(ReKi)                   :: FDper                                      ! Total time in dataset.
   REAL(ReKi)                   :: FDTime   (2)                               ! Times for the 4D wind files.
   REAL(ReKi), ALLOCATABLE      :: FDu      (:,:,:,:)                         ! The u-component array of 4D wind data.
   REAL(ReKi), ALLOCATABLE      :: FDv      (:,:,:,:)                         ! The v-component array of 4D wind data.
   REAL(ReKi), ALLOCATABLE      :: FDw      (:,:,:,:)                         ! The w-component array of 4D wind data.
   REAL(ReKi), ALLOCATABLE      :: FDuData  (:,:,:,:)                         ! The u-component array of all 4D wind data when used with advection.
   REAL(ReKi), ALLOCATABLE      :: FDvData  (:,:,:,:)                         ! The v-component array of all 4D wind data when used with advection.
   REAL(ReKi), ALLOCATABLE      :: FDwData  (:,:,:,:)                         ! The w-component array of all 4D wind data when used with advection.
   REAL(ReKi)                   :: Lx                                         ! Fractional location of tower centerline from upwind end to downwind end of the dataset.
   REAL(ReKi)                   :: Ly                                         ! Fractional location of tower centerline from right (looking downwind) to left side of the dataset.
   REAL(ReKi)                   :: Lz                                         ! Fractional location of hub height from bottom to top of dataset.
   REAL(ReKi)                   :: Offsets  (3)                               ! Offsets to convert integer data to actual wind speeds.
   REAL(ReKi), SAVE             :: PrevTime                                   ! The previous time this was called -- so we can go back in time if necessary
   REAL(ReKi)                   :: RotDiam                                    ! Rotor diameter.
   REAL(ReKi)                   :: ScalFact (3)                               ! Scaling factors to convert integer data to actual wind speeds.
   REAL(ReKi)                   :: ScaleVel                                   ! Scaling velocity, U0.  2*U0 is the difference in wind speed between the top and bottom of the wave.
   REAL(ReKi), ALLOCATABLE      :: Times4D  (:)                               ! The list of times for the 4D-wind input files.
   REAL(ReKi)                   :: Tm_max                                     ! The total nondimensional time of the dataset.
   REAL(ReKi)                   :: TSclFact                                   ! Scale factor for time (h/U0).
   REAL(ReKi)                   :: T_4D_En                                    ! Time at which the wave event ends.
   REAL(ReKi)                   :: T_4D_St                                    ! Time at which the wave event starts.
   REAL(ReKi)                   :: Xmax                                       ! The dimensional downwind length of the dataset.
   REAL(ReKi)                   :: Xt                                         ! Distance of the tower from the upwind end of the dataset.
   REAL(ReKi)                   :: Ymax                                       ! The dimensional lateral width of the dataset.
   REAL(ReKi)                   :: Yt                                         ! Distance of the tower from the right side of the dataset (looking downwind).
   REAL(ReKi)                   :: Zmax                                       ! The dimensional vertical height of the dataset.
   REAL(ReKi)                   :: Zt                                         ! Distance of the hub from the bottom of the dataset.
   REAL(ReKi)                   :: Zref                                       ! The reference height (hub height)

   INTEGER                      :: FD_DF_X                                    ! The decimation factor for the 4D wind data in the x direction.
   INTEGER                      :: FD_DF_Y                                    ! The decimation factor for the 4D wind data in the y direction.
   INTEGER                      :: FD_DF_Z                                    ! The decimation factor for the 4D wind data in the z direction.
   INTEGER                      :: FDFileNo                                   ! The 4D wind file number.
   INTEGER                      :: FDRecL                                     ! The length, in bytes, of the LE binary records.
   INTEGER                      :: Ind4DAdv                                   ! Index of the file to be used in advection
   INTEGER                      :: Ind4Dnew                                   ! Index of the newest 4D wind file.
   INTEGER                      :: Ind4Dold                                   ! Index of the older 4D wind file.
   INTEGER                      :: Num4Dt                                     ! The number of 4D wind grids, one grid per time step.
   INTEGER, PARAMETER           :: Num4DtD = 2                                ! The number of 4D wind grids stored in memory, normally 2
   INTEGER                      :: Num4Dx                                     ! The number of 4D wind grid points in the x direction.
   INTEGER                      :: Num4DxD                                    ! The decimated number of 4D wind grid points in the x direction.
   INTEGER                      :: Num4DxD1                                   ! The decimated number of 4D wind grid points in the x direction minus 1.
   INTEGER                      :: Num4Dy                                     ! The number of 4D wind grid points in the y direction.
   INTEGER                      :: Num4DyD                                    ! The decimated number of 4D wind grid points in the y direction.
   INTEGER                      :: Num4DyD1                                   ! The decimated number of 4D wind grid points in the y direction minus 1.
   INTEGER                      :: Num4Dz                                     ! The number of 4D wind grid points in the z direction.
   INTEGER                      :: Num4DzD                                    ! The decimated number of 4D wind grid points in the z direction.
   INTEGER                      :: Num4DzD1                                   ! The decimated number of 4D wind grid points in the z direction minus 1.
   INTEGER                      :: NumAdvect                                  ! Number of frozen timesteps to advect past the turbine
   INTEGER                      :: Shft4Dnew                                  ! Number of times the x-data needs to be shifted for advection
   INTEGER, ALLOCATABLE         :: Times4DIx (:)                              ! Index number of the 4D time files (used for advection)

   INTEGER                      :: FDUnit                                     ! Unit number for reading wind files

   LOGICAL                      :: Advect                                     ! Flag to indicate whether or not to advect a given data set or to just use the time step files 
   LOGICAL                      :: VertShft                                   ! Flag to indicate whether or not to shift the z values for the w component.

   LOGICAL, SAVE                :: Initialized = .FALSE.

   CHARACTER(5), ALLOCATABLE    :: AdvFiles (:)
   CHARACTER(1024)              :: FDSpath                                    ! The path to the 4D wind files.


   PUBLIC                       :: FD_Init
   PUBLIC                       :: FD_GetWindSpeed
   PUBLIC                       :: FD_Terminate
   PUBLIC                       :: FD_GetValue


CONTAINS
!====================================================================================================
SUBROUTINE FD_Init(UnWind, WindFile, RefHt, ErrStat)
!  This subroutine is called at the beginning of a simulation to initialize the module.  
!----------------------------------------------------------------------------------------------------

      ! Passed variables
      
   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: WindFile                     ! Name of the 4D wind parameter file (.fdp)
   REAL(ReKi),      INTENT(IN)    :: RefHt                        ! The reference height for the billow (should be hub height)
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors; non-zero otherwise

      ! Local variables

   CHARACTER(1024)                :: FDTSfile                     ! name of the 4D time step file
   REAL(ReKi)                     :: FDTimStp                     ! Average time step for 4D wind data.
   INTEGER                        :: IT
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' FDWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Set the reference height for the wind file (this takes the place of HH that was used earlier)
   !-------------------------------------------------------------------------------------------------

   ZRef = RefHt         
   
   !-------------------------------------------------------------------------------------------------
   ! Read the main 4D input file
   !-------------------------------------------------------------------------------------------------
   
   CALL ReadFDP( UnWind, WindFile, FDTSfile, ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   !-------------------------------------------------------------------------------------------------
   ! Get the times array, which must be scaled and shifted later using TSclFact and T_4D_St
   !-------------------------------------------------------------------------------------------------

   CALL Read4Dtimes ( UnWind, FDTSfile, ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   
   !-------------------------------------------------------------------------------------------------
   ! Calculate some values that don't change during the run.
   !-------------------------------------------------------------------------------------------------

   FDRecL      = 2*Num4Dx*Num4Dy                                           ! The length, in bytes, of the 4D binary records.
   Num4DxD     = ( Num4Dx + FD_DF_X - 1 )/FD_DF_X                          ! The decimated number of 4D wind grid points in the x direction.
   Num4DyD     = ( Num4Dy + FD_DF_Y - 1 )/FD_DF_Y                          ! The decimated number of 4D wind grid points in the y direction.
   Num4DzD     = ( Num4Dz + FD_DF_Z - 1 )/FD_DF_Z                          ! The decimated number of 4D wind grid points in the z direction.
   Num4DxD1    = Num4DxD - 1                                               ! The decimated number of 4D wind grid points in the x direction minus 1.
   Num4DyD1    = Num4DyD - 1                                               ! The decimated number of 4D wind grid points in the y direction minus 1.
   Num4DzD1    = Num4DzD - 1                                               ! The decimated number of 4D wind grid points in the z direction minus 1.

   Tm_max      = Times4D(Num4Dt)                                           ! Time of end of dataset.
   IF ( ADVECT ) THEN
      FDTimStp   = Xmax / ( ( Num4Dx - 1 )*( ScaleVel )*Num4Dt )           ! The timestep is calculated by the approximation dx/dt ~= U0 (divide by num4dt to get delta for a full timestep).
      FDper      = FDTimStp * Num4Dt                                       ! Total time in dataset. (We have periodic time, so multiply by number of time steps, without subtracting 1)
      TSclFact   = FDper / Tm_max                                          ! Equivalent scale factor for time.
   ELSE
      FDper       = TSclFact*Tm_max                                        ! Total time in dataset.
      FDTimStp    = FDper/( Num4Dt - 1 )                                   ! Average time step.
   ENDIF

   T_4D_En     = T_4D_St + FDper                                           ! Time for the end of the dataset.
   Xt          = Xmax*Lx                                                   ! Distance of the tower from the upwind end of the dataset.
   Yt          = Ymax*Ly                                                   ! Distance of the tower from the right side of the dataset (looking downwind).
   Zt          = Zmax*Lz                                                   ! Distance of the hub from the bottom of the dataset.
   DelXgrid    = 1.0/Num4DxD1                                              ! The nondimensional distance between grid points in the x direction.
   DelYgrid    = 1.0/Num4DyD1                                              ! The nondimensional distance between grid points in the y direction.
   DelZgrid    = 1.0/Num4DzD1                                              ! The nondimensional distance between grid points in the z direction.


   !-------------------------------------------------------------------------------------------------
   ! Scale and shift the times array using TSclFact and T_4D_St
   !-------------------------------------------------------------------------------------------------

   DO IT=1,Num4Dt
      
      Times4D(IT) = TSclFact*Times4D(IT) + T_4D_St

   ENDDO ! IT


   !-------------------------------------------------------------------------------------------------
   ! Allocate velocity arrays and fill Data arrays for advection (DNS files)
   !-------------------------------------------------------------------------------------------------

   IF (.NOT. ALLOCATED(FDu) ) THEN
!      CALL AllocAry ( FDu, Num4DxD, Num4DyD, Num4DzD, 2, 'U-component velocity array (FDu)', ErrStat)
      ALLOCATE ( FDu(Num4DxD,Num4DyD,Num4DzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the U-component velocity array (FDu) array.' )
         RETURN
      END IF
   END IF
   
   IF (.NOT. ALLOCATED(FDv) ) THEN
!      CALL AllocAry ( FDv, Num4DxD, Num4DyD, Num4DzD, 2, 'V-component velocity array (FDv)', ErrStat)
      ALLOCATE ( FDv(Num4DxD,Num4DyD,Num4DzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the V-component velocity array (FDv) array.' )
         RETURN
      END IF
   END IF

   IF (.NOT. ALLOCATED(FDw) ) THEN
!      CALL AllocAry ( FDw, Num4DxD, Num4DyD, Num4DzD, 2, 'W-component velocity array (FDw)', ErrStat)
      ALLOCATE ( FDw(Num4DxD,Num4DyD,Num4DzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the W-component velocity array (FDw) array.' )
         RETURN
      END IF
   END IF

   IF ( ADVECT ) THEN

      IF (.NOT. ALLOCATED(FDuData) ) THEN
!         CALL AllocAry ( FDuData, Num4DxD, Num4DyD, Num4DzD, Num4Dt, 'U-component velocity array (FDuData)', ErrStat)
         ALLOCATE ( FDuData(Num4DxD,Num4DyD,Num4DzD,Num4Dt), STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error allocating memory for the U-component velocity array (FDuData) array.' )
            RETURN
         END IF
      END IF

      IF (.NOT. ALLOCATED(FDvData) ) THEN
!         CALL AllocAry ( FDvData, Num4DxD, Num4DyD, Num4DzD, Num4Dt, 'V-component velocity array (FDvData)', ErrStat)
         ALLOCATE ( FDvData(Num4DxD,Num4DyD,Num4DzD,Num4Dt), STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error allocating memory for the V-component velocity array (FDvData) array.' )
            RETURN
         END IF
      END IF

      IF (.NOT. ALLOCATED(FDwData) ) THEN
!         CALL AllocAry ( FDwData, Num4DxD, Num4DyD, Num4DzD, Num4Dt, 'W-component velocity array (FDwData)', ErrStat)
         ALLOCATE ( FDwData(Num4DxD,Num4DyD,Num4DzD,Num4Dt), STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error allocating memory for the W-component velocity array (FDwData) array.' )
            RETURN
         END IF
      END IF

      CALL ReadAll4DData(UnWind, ErrStat) !This needs AdvFiles(:), which was is read in ReadFDP()
      IF ( ErrStat /= 0 ) RETURN

   ENDIF

     
   !-------------------------------------------------------------------------------------------------
   ! Determine the first file needed for this simulation.
   !-------------------------------------------------------------------------------------------------
   Ind4Dold  = 1                                                           ! Put the old stuff in the first part of the array.
   Ind4Dnew  = 2                                                           ! Put the new stuff in the second part of the array.

   Shft4Dnew = 0


   IF ( T_4D_St >= 0.0 )  THEN
      FDFileNo = 1
   ELSE
      FDFileNo = Num4Dt
      DO IT=1,Num4Dt
         IF ( Times4D(IT) > 0.0 )  THEN
            FDFileNo = IT - 1
            EXIT
         END IF
      END DO ! IT
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Open, read, and close the first set of files.
   !-------------------------------------------------------------------------------------------------
   FDTime(Ind4Dold) = Times4D(FDFileNo)                                 ! Set the time for this file.

   IF ( ADVECT ) THEN
      CALL Load4DData(Ind4Dold)     ! load data stored in FDuData, FDvData, and FDwData arrays
   ELSE
      CALL LoadLESData( UnWind, FDFileNo, Ind4Dold, ErrStat )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Open, read, and close the second set of files.
   !-------------------------------------------------------------------------------------------------
   FDFileNo  = FDFileNo + 1


   IF ( ADVECT ) THEN
      FDFileNo = MOD(FDFileNo-1,Num4Dt) + 1

      IF (FDFileNo == 1) THEN
         Shft4Dnew = Shft4Dnew + 1

         IF (Ind4DAdv <= NumAdvect) THEN                             ! Ind4DAdv was set in ReadFDP
            IF ( MOD( Shft4Dnew, Num4Dx ) == 0 ) THEN
               CALL ReadAll4DData(UnWind, ErrStat)
               IF ( ErrStat /= 0 ) RETURN
            END IF
         END IF

      ENDIF

      FDTime(Ind4Dnew) = Times4D(FDFileNo) + Shft4Dnew*FDPer         ! Set the time for this file.

      CALL Load4DData( Ind4Dnew )    ! shift the data

   ELSE   
      FDTime(Ind4Dnew) = Times4D(FDFileNo)                                           ! Set the time for this file.

      CALL LoadLESData( UnWind, FDFileNo, Ind4Dnew, ErrStat )
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Set the initialization flag
   !-------------------------------------------------------------------------------------------------
   FDUnit      = UnWind
   PrevTime    = 0.0
   
   Initialized = .TRUE.
   
   RETURN

END SUBROUTINE FD_Init
!====================================================================================================
SUBROUTINE ReadFDP ( UnWind, FileName, FDTSfile, ErrStat )
!  This subroutine is used to read the input parameters for the large-eddy simulation.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: FileName                     ! Then name of the LE data file.
   CHARACTER(*),    INTENT(OUT)   :: FDTSfile                     ! The name of the file containing the time-step history of the wind files.
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise


      ! Local variables

   CHARACTER(1024)                :: HeaderLine
   CHARACTER(1),PARAMETER         :: Comp(3) = (/'U', 'V', 'W' /) ! the wind components

   REAL(ReKi)                     :: CoefTE                       ! Coefficient of thermal expansion.
   REAL(ReKi)                     :: DistScal                     ! Disturbance scale (ratio of wave height to rotor diameter) from input file.
   REAL(ReKi)                     :: Grav                         ! Gravitational acceleration.
   REAL(ReKi)                     :: LenScale                     ! Length scale (h).
   REAL(ReKi)                     :: Ri                           ! Richardson number.
   REAL(ReKi)                     :: Ubot                         ! Steady u-component wind speed at the bottom of the wave.
   REAL(ReKi)                     :: Zm_maxo                      ! The nondimensional vertical height of the untrimmed dataset.

   REAL(ReKi)                     :: Xm_max                       ! The nondimensional downwind length of the dataset.
   REAL(ReKi)                     :: Ym_max                       ! The nondimensional lateral width of the dataset.
   REAL(ReKi)                     :: Zm_max                       ! The nondimensional vertical height of the dataset.

   INTEGER                        :: I

   !-------------------------------------------------------------------------------------------------
   ! Open the 4D parameter file for reading
   !-------------------------------------------------------------------------------------------------
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) RETURN   


   !-------------------------------------------------------------------------------------------------
   ! Read the 4D parameter input file
   !-------------------------------------------------------------------------------------------------

      !..............................................................................................
      ! Read the 4D wind parameters specific to this turbine simulation.  
      !..............................................................................................

   CALL ReadStr( UnWind, TRIM( FileName ), HeaderLine, 'Header line', 'The header line in the FTP file', ErrStat )
   IF (ErrStat /= 0) RETURN   
   CALL WrScr ( ' Heading of the 4D-wind-parameter file: "'//TRIM(HeaderLine)//'"' )


   CALL ReadCom( UnWind, TRIM( FileName ), 'Header line', ErrStat )
   IF (ErrStat /= 0) RETURN
      

   CALL ReadVar( UnWind, TRIM( FileName ), FDSpath,  'FDSpath', 'Location (path) of the binary dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FDTSfile,  'FDTSfile', & 
                                  'Name of the file containing the time-step history of the wind files', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ubot,  'Ubot', 'Steady u-component wind speed at the bottom of the wave', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), DistScal,  'DistScal', 'Disturbance scale', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Lx,  'Lx', &
                            'Fractional location of tower centerline from upwind end to downwind end of the dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ly,  'Ly', &
                 'Fractional location of tower centerline from right (looking downwind) to left side of the dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Lz,  'Lz', &
                                          'Fractional location of hub height from bottom to top of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), T_4D_St,  'T_4D_St', 'Time at which the wave event starts', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), ScaleVel,  'ScaleVel', &
                 'Scaling velocity, U0: half the difference in wind speed between the top and bottom of the billow.', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), RotDiam,  'RotDiam', 'Rotor diameter', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FD_DF_X,  'FD_DF_X', 'Decimation factor in X direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FD_DF_Y,  'FD_DF_Y', 'Decimation factor in Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FD_DF_Z,  'FD_DF_Z', 'Decimation factor in Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadCom( UnWind, TRIM( FileName ), 'blank line', ErrStat )
   IF (ErrStat /= 0) RETURN

      !..............................................................................................
      ! Read the 4D wind parameters specific to the K-H billow simulation being used.  
      !..............................................................................................

   CALL ReadCom( UnWind, TRIM( FileName ), 'LES parameters specific to the K-H billow simulation being used', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), VertShft,  'VertShft', & 
                           'Flag to indicate whether or not to shift the z values for the w component', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Xm_max,  'Xm_max', & 
                           'Maximum nondimensional downwind distance from center of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ym_max,  'Ym_max', & 
                           'Maximum nondimensional lateral distance from center of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Zm_max,  'Zm_max', & 
                           'Maximum nondimensional vertical distance from center of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Zm_maxo,  'Zm_maxo', & 
                 'Maximum nondimensional vertical distance from center of untrimmed dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   DO I = 1,3

      CALL ReadVar( UnWind, TRIM( FileName ), ScalFact(I),  Comp(I)//'Scl', & 
                    Comp(I)//'-component scale factor for converting from integers to reals', ErrStat )
      IF (ErrStat /= 0) RETURN
      ScalFact(I) = ScalFact(I) * ScaleVel


      CALL ReadVar( UnWind, TRIM( FileName ), Offsets(I), Comp(I)//'Off', & 
                    Comp(I)//'-component offset for converting from integers to reals', ErrStat )
      IF (ErrStat /= 0) RETURN
      Offsets(I) = Offsets(I) * ScaleVel
      
   END DO   
   Offsets (1) = Offsets (1) + ScaleVel + Ubot                           ! u-component offset to convert integer data to actual wind speeds.


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dt, 'Num4Dt', 'The number of LE grids, one grid per time step', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dx, 'Num4Dx', 'The number of LE grid points in the x direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dy, 'Num4Dy', 'The number of LE grid points in the y direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dz, 'Num4Dz', 'The number of LE grid points in the z direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ri, 'Ri', 'Richardson number', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CoefTE, 'CoefTE', 'Coefficient of thermal expansion', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Grav, 'Grav', 'Gravitational acceleration', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Advect, 'Advect', 'Advection flag', ErrStat )
   
   IF (ErrStat /= 0) THEN
   
      Advect   = .FALSE.
      Ind4DAdv = 0
      ErrStat  = 0
      CALL WrScr( ' Advection will not be used.')
      
   ELSE
   
      IF (Advect) THEN
         IF ( FD_DF_X /= 1 ) THEN
            CALL WrScr( ' FD_DF_X must be 1 when using advection. ' )
            FD_DF_X = 1            
         ENDIF

         CALL ReadVar( UnWind, TRIM( FileName ), NumAdvect, 'NumAdvect', 'Number of 4D files for advection', ErrStat )
         IF (ErrStat /= 0) RETURN
         

         IF ( NumAdvect < 1 ) THEN
            CALL WrScr( ' NumAdvect in 4D-wind-parameter file, "'//TRIM( FileName )//'," must be at least 1.' )
            ErrStat = 1
            RETURN
         ENDIF

         IF ( .NOT. ALLOCATED( AdvFiles ) ) THEN
!            CALL AllocAry( AdvFiles, NumAdvect, 'AdvFiles array', ErrStat )
            ALLOCATE ( AdvFiles(NumAdvect), STAT=ErrStat )

            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error allocating memory for the AdvFiles array.' )
               RETURN
            END IF
         ENDIF

         CALL ReadAryLines( UnWind, TRIM( FileName ), AdvFiles, NumAdvect, 'AdvFiles', 'Advection file names', ErrStat )
         IF (ErrStat /= 0) RETURN
         Ind4DAdv = 1
         
      ELSE
         Ind4DAdv = 0
      ENDIF !Advect == .TRUE.
   
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Close the 4D parameter input file
   !-------------------------------------------------------------------------------------------------
   CLOSE ( UnWind )
   
   !-------------------------------------------------------------------------------------------------
   ! Close the 4D parameter input file
   !-------------------------------------------------------------------------------------------------

   LenScale    = RotDiam*DistScal/Zm_max                             ! Length scale (h).
   Xmax        = Xm_max*LenScale                                     ! The dimensional length of the dataset.
   Ymax        = Ym_max*LenScale                                     ! The dimensional width of the dataset
   Zmax        = Zm_max*LenScale                                     ! The dimensional vertical height of the dataset.
   TSclFact    = LenScale/ScaleVel                                   ! Scale factor for time (h/U0).

   

   RETURN

END SUBROUTINE ReadFDP
!====================================================================================================
SUBROUTINE Read4Dtimes ( UnWind, FileName, ErrStat )
!  This subroutine is used to read the time array for the 4D data.  The times in the file are 
!  non-dimensional and non-uniformly spaced. They are scaled using TSclFact to obtain units of seconds
!  and T_4D_St is added to allow the billow to start at non-zero time.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: FileName                     ! Then name of the LE data file.
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise


      ! Local variables

   INTEGER                        :: I                            ! Loop counter

   !-------------------------------------------------------------------------------------------------
   ! Allocate arrays to store the data in
   !-------------------------------------------------------------------------------------------------
   
   IF (.NOT. ALLOCATED( Times4D) ) THEN
!      CALL AllocAry( Times4D, Num4Dt, '4D time array', ErrStat)
      ALLOCATE ( Times4D(Num4Dt), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the Times4D array.' )
         RETURN
      END IF
   END IF
      
   IF (.NOT. ALLOCATED( Times4DIx) ) THEN
!      CALL AllocAry( Times4DIx, Num4Dt, '4D time array', ErrStat)
      ALLOCATE ( Times4DIx(Num4Dt), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the Times4DIx array.' )
         RETURN
      END IF
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Open the 4D times file
   !-------------------------------------------------------------------------------------------------
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   !-------------------------------------------------------------------------------------------------
   ! Read the 4D times file
   !-------------------------------------------------------------------------------------------------
   CALL ReadCom( UnWind, TRIM( FileName ), 'first line', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   DO I=1,Num4Dt

      READ (UnWind,*,IOSTAT=ErrStat)  Times4DIx(I), Times4D(I)

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Error reading line '//TRIM( Num2LStr( I+1 ) )// &
                        ' of the 4D-wind time-steps file, "'//TRIM( FileName )//'."')
         RETURN                        

      ENDIF
      
   ENDDO ! I

   
   !-------------------------------------------------------------------------------------------------
   ! Close the 4D times file
   !-------------------------------------------------------------------------------------------------
   
   CLOSE ( UnWind )  
   
   RETURN     
   
END SUBROUTINE Read4Dtimes
!====================================================================================================
SUBROUTINE ReadAll4DData(UnWind, ErrStat)
! This subroutine reads the data into one array to be accessed later when ADVECT=.TRUE. Since there 
! are just a few time steps, we'll load them into memory to (hopefully) save I/O time.
!----------------------------------------------------------------------------------------------------

   INTEGER, INTENT(IN)        :: UnWind
   INTEGER, INTENT(OUT)       :: ErrStat                            ! 
   INTEGER                    :: IT

   CHARACTER(1)               :: FDNum
   CHARACTER(20)              :: DNSFileName                        ! String containing part of the current file name.


   DO IT = 1,Num4Dt

      WRITE(FDNum,'(I1.1)') Times4DIx(IT)
      DNSFileName = TRIM(AdvFiles(Ind4DAdv))//'_'//TRIM(FDNum)//'.dns'

      CALL Read4DData ( UnWind, TRIM( FDSpath )//'\u\u_16i_'//TRIM(DNSFileName), FDuData, IT, ScalFact(1), Offsets(1), ErrStat )
      IF ( ErrStat /= 0 ) RETURN

      CALL Read4DData ( UnWind, TRIM( FDSpath )//'\v\v_16i_'//TRIM(DNSFileName), FDvData, IT, ScalFact(2), Offsets(2), ErrStat )
      IF ( ErrStat /= 0 ) RETURN

      CALL Read4DData ( UnWind, TRIM( FDSpath )//'\w\w_16i_'//TRIM(DNSFileName), FDwData, IT, ScalFact(3), Offsets(3), ErrStat )
      IF ( ErrStat /= 0 ) RETURN

   ENDDO ! IT

   Ind4DAdv = Ind4DAdv + 1

   RETURN

END SUBROUTINE ReadAll4DData
!====================================================================================================
SUBROUTINE LoadLESData( UnWind, FileNo, Indx, ErrStat )
! This subroutine reads binary data from the U, V, and W files and stores them in the arrays FDu,
! FDv, and FDw (by calling Read4DData).
!----------------------------------------------------------------------------------------------------
      ! Passed variables

   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,         INTENT(IN)    :: FileNo                       ! current file number to read
   INTEGER,         INTENT(IN)    :: Indx                         ! index into the data arrays
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise
   
      ! local variables
   CHARACTER(5)                   :: FDNum
   CHARACTER(20)                  :: LESFileName                  ! String containing part of the current file name.      
   
      
      ! get the file name for the file number
      
   WRITE(FDNum,'(I5.5)', IOStat=ErrStat) FileNo
   IF ( ErrStat /= 0 ) RETURN
   
   LESFileName = TRIM(FDNum)//'.les'


      ! set the paths and read the data for each component
      
   CALL Read4DData ( UnWind, TRIM( FDSpath )//'\u\u_16i_'//TRIM(LESFileName), FDu, Indx, ScalFact(1), Offsets(1), ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   CALL Read4DData ( UnWind, TRIM( FDSpath )//'\v\v_16i_'//TRIM(LESFileName), FDv, Indx, ScalFact(2), Offsets(2), ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   CALL Read4DData ( UnWind, TRIM( FDSpath )//'\w\w_16i_'//TRIM(LESFileName), FDw, Indx, ScalFact(3), Offsets(3), ErrStat )


END SUBROUTINE LoadLESData
!====================================================================================================
SUBROUTINE Read4DData ( UnWind, FileName, Comp, Indx4, Scale, Offset,  ErrStat)
! This subroutine is used to read one time-step's worth of large-eddy wind data for one component 
! from a file.
!----------------------------------------------------------------------------------------------------

      ! Passed variables
      
   INTEGER,     INTENT(IN)    :: UnWind               ! The I/O unit of the LE file.
   CHARACTER(*),INTENT(IN)    :: FileName             ! Then name of the LE data file.

   REAL(ReKi),  INTENT(INOUT) :: Comp (:,:,:,:)       ! The velocity array [do NOT make this INTENT(OUT): other parts of the array may become undefined]
   INTEGER,     INTENT(IN)    :: Indx4                ! The index of the 4th dimension of Comp, which is to be read.
   REAL(ReKi),  INTENT(IN)    :: Scale                ! The scale factor for converting from intergers to non-normalized reals.
   REAL(ReKi),  INTENT(IN)    :: Offset               ! The offset for converting from intergers to non-normalized reals.

   INTEGER,     INTENT(OUT)   :: ErrStat              ! The returned status of a READ.
      
      ! Local variables

   INTEGER                    :: IX                   ! A DO index for indexing the arrays in the x direction.
   INTEGER                    :: IXK                  ! An index for the decimated arrays in the x direction.
   INTEGER                    :: IY                   ! A DO index for indexing the arrays in the y direction.
   INTEGER                    :: IYK                  ! An index for the decimated arrays in the y direction.
   INTEGER                    :: IZ                   ! A DO index for indexing the arrays in the z direction.
   INTEGER                    :: IZK                  ! An index for the decimated arrays in the z direction.

   INTEGER(B2Ki)              :: Com (Num4Dx,Num4Dy)  ! Temporary array to hold component's integer values for a given Z.


   !-------------------------------------------------------------------------------------------------
   ! Open the binary input file
   !-------------------------------------------------------------------------------------------------
   CALL OpenUInBEFile( UnWind, TRIM( FileName ), FDRecL, ErrStat )
   IF ( ErrStat /= 0 ) RETURN


   !-------------------------------------------------------------------------------------------------
   ! Read the input file
   !-------------------------------------------------------------------------------------------------

   IZK = 0
   DO IZ=1,Num4Dz,FD_DF_Z

      READ (UnWind,REC=IZ,IOSTAT=ErrStat)  Com

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Error reading record '//TRIM( Num2LStr( IZ ) )// & 
                                            ' of the binary 4D wind file, "'//TRIM( FileName )//'".')
         RETURN

      ENDIF

      IZK = IZK + 1                                ! IZK = ( IZ - 1 + FD_DF_Z )/FD_DF_Z
      IYK = 0
      
      DO IY=1,Num4Dy,FD_DF_Y
         
         IYK = IYK + 1                             ! IYK = ( IY - 1 + FD_DF_Y )/FD_DF_Y
         
         DO IX=1,Num4Dx,FD_DF_X
         
               ! shift the x-index, if necessary, to perform Advection
               
            !IXK = ( IX + FD_DF_X - 1 )/FD_DF_X
            IXK = ( MOD(IX+Shft4Dnew-1,Num4Dx) + FD_DF_X )/FD_DF_X
         
            Comp(IXK,IYK,IZK,Indx4) = Scale*Com(IX,IY) + Offset
         
         ENDDO ! IX
         
      ENDDO ! IY

   ENDDO ! IZ


   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
   CLOSE ( UnWind )

   RETURN

END SUBROUTINE Read4DData
!====================================================================================================
SUBROUTINE Load4DData( InpIndx )
! This subroutine takes the data from the storage array (used when ADVECT=.TRUE., shifts it if necessary, 
! and loads it into the array for the time slice indexed by InpIndx.
!----------------------------------------------------------------------------------------------------

   INTEGER, INTENT(IN) :: InpIndx

   INTEGER             :: IX
   INTEGER             :: IXK


   DO IX=1,Num4Dx,FD_DF_X

         ! shift the x-index, if necessary, to perform Advection
      IXK = ( MOD(IX+Shft4Dnew-1,Num4Dx) + FD_DF_X )/FD_DF_X

      FDu(IXK,:,:,InpIndx) = FDuData(IX,:,:,FDFileNo)
      FDv(IXK,:,:,InpIndx) = FDvData(IX,:,:,FDFileNo)
      FDw(IXK,:,:,InpIndx) = FDwData(IX,:,:,FDFileNo)

   ENDDO ! IX


   RETURN

END SUBROUTINE Load4DData
!====================================================================================================
FUNCTION FD_GetValue(RVarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the RVarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------

   CHARACTER(*),   INTENT(IN)    :: RVarName
   INTEGER,        INTENT(OUT)   :: ErrStat
   REAL(ReKi)                    :: FD_GetValue

   
   CHARACTER(20)                 :: VarNameUC
   

   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FDWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = RVarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
            
      CASE ('ROTDIAM' )
         FD_GetValue = RotDiam         
         
      CASE DEFAULT
         CALL WrScr( ' Invalid variable name in FD_GetRValue().' )
         ErrStat = 1
         
   END SELECT

END FUNCTION FD_GetValue
!====================================================================================================
FUNCTION FD_GetWindSpeed(Time, InputPosition, ErrStat)
! This function is used to interpolate into the 4D wind arrays.  It receives X, Y, Z and TIME from the 
! calling routine.  The time since the start of the 4D data is used to decide which pair of time slices 
! to interpolate within and between.  After finding the two time slices, it decides which eight grid 
! points bound the (X,Y,Z) pair. It does a trilinear interpolation for each time slice. Linear 
! interpolation is then used to interpolate between time slices.  This routine assumes that X is 
! downwind, Y is to the left when looking downwind and Z is up.  It also assumes that no 
! extrapolation will be needed except in time and the Z direction.  In those cases, the appropriate
! steady winds are used.
!----------------------------------------------------------------------------------------------------

      ! Passed variables:
      
   REAL(ReKi),        INTENT(IN) :: Time                                   ! the time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)                       ! structure that contains the position
   INTEGER,           INTENT(OUT):: ErrStat                                ! returns 0 if no error; non-zero otherwise
   TYPE(InflIntrpOut)            :: FD_GetWindSpeed                        ! the resultant wind speed


      ! Local Variables:

   REAL(ReKi)                 :: Ixhyz                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Ixlyz                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Ixyzo                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Iyhz                                      ! Temporary interpolated value.
   REAL(ReKi)                 :: Iylz                                      ! Temporary interpolated value.
   REAL(ReKi)                 :: Ixyzn                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Tgrid                                     ! Fractional distance between time grids.
   REAL(ReKi)                 :: Xgrid                                     ! Fractional distance between grids in the x direction.
   REAL(ReKi)                 :: Xnorm                                     ! Nondimensional downwind distance of the analysis point from upwind end of dataset.
   REAL(ReKi)                 :: Ygrid                                     ! Fractional distance between grids in the y direction.
   REAL(ReKi)                 :: Ynorm                                     ! Nondimensional lateral distance of the analysis point from right side of dataset (looking downwind).
   REAL(ReKi)                 :: Zgrid                                     ! Fractional distance between grids in the z direction.
   REAL(ReKi)                 :: Zgrid_w                                   ! Fractional distance between grids in the z direction for the w component.
   REAL(ReKi)                 :: Znorm                                     ! Nondimensional vertical distance of the analysis point from bottom of dataset.
   REAL(ReKi)                 :: Znorm_w                                   ! Nondimensional vertical distance of the analysis point from bottom of dataset for the w component.

   INTEGER                    :: IT                                        ! Index for do loop
   INTEGER                    :: IXHI                                      ! Index for the more-positive x value.
   INTEGER                    :: IXLO                                      ! Index for the more-negative x value.
   INTEGER                    :: IYHI                                      ! Index for the more-positive y value.
   INTEGER                    :: IYLO                                      ! Index for the more-negative y value.
   INTEGER                    :: IZHI                                      ! Index for the more-positive z value.
   INTEGER                    :: IZHI_w                                    ! Index for the more-positive z value for the w component.
   INTEGER                    :: IZLO                                      ! Index for the more-negative z value.
   INTEGER                    :: IZLO_w                                    ! Index for the more-negative z value for the w component.

   !-------------------------------------------------------------------------------------------------     
   ! Check that we've initialized everything first
   !-------------------------------------------------------------------------------------------------     
     
   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FDWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE 
      ErrStat = 0   
   END IF      

   !-------------------------------------------------------------------------------------------------     
   ! If the TIME is greater than the time for the last file read, read another set of files until we straddle the current time.
   ! Stick with the last file if we've exhausted the data.
   ! We're assuming here that the simulation time step is smaller than the wind-file time step.
   !-------------------------------------------------------------------------------------------------     

   IF ( Time < PrevTime .AND. Time < FDTime(Ind4Dold) ) THEN  ! bjj: GET THE CORRECT TIME if we're going backward!
     
      !----------------------------------------------------------------------------------------------
      ! Determine the first file needed for this simulation.
      !----------------------------------------------------------------------------------------------
      Ind4Dold  = 1                                                           ! Put the old stuff in the first part of the array.
      Ind4Dnew  = 2                                                           ! Put the new stuff in the second part of the array.
      
      FDFileNo  = Num4Dt
      DO IT=1,Num4Dt
         IF ( Times4D(IT) > Time )  THEN
            FDFileNo = IT - 1
            EXIT
         END IF
      END DO ! IT
         
      !----------------------------------------------------------------------------------------------
      ! Open, read, and close the first set of files.
      !----------------------------------------------------------------------------------------------
      FDTime(Ind4Dold) = Times4D(FDFileNo)                                 ! Set the time for this file.

      IF ( ADVECT ) THEN
         CALL Load4DData(Ind4Dold)     ! load data stored in FDuData, FDvData, and FDwData arrays
      ELSE
         CALL LoadLESData( FDUnit, FDFileNo, Ind4Dold, ErrStat )
      END IF
            
      !----------------------------------------------------------------------------------------------
      ! Open, read, and close the second set of files.
      !----------------------------------------------------------------------------------------------
      FDFileNo  = MIN(FDFileNo + 1, Num4Dt)
      Shft4Dnew = 0
      
      IF ( ADVECT ) THEN
         FDFileNo = MOD(FDFileNo-1,Num4Dt) + 1

         IF (FDFileNo == 1) THEN
            Shft4Dnew = Shft4Dnew + 1

            IF (Ind4DAdv <= NumAdvect) THEN                             ! Ind4DAdv was set in ReadFDP
               IF ( MOD( Shft4Dnew, Num4Dx ) == 0 ) THEN
                  CALL ReadAll4DData(FDUnit, ErrStat)
                  IF ( ErrStat /= 0 ) RETURN
               END IF
            END IF

         ENDIF

         FDTime(Ind4Dnew) = Times4D(FDFileNo) + Shft4Dnew*FDPer         ! Set the time for this file.

         CALL Load4DData( Ind4Dnew )    ! shift the data

      ELSE   
         FDTime(Ind4Dnew) = Times4D(FDFileNo)                                           ! Set the time for this file.
!
         CALL LoadLESData( FDUnit, FDFileNo, Ind4Dnew, ErrStat )
      ENDIF
                     
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Move forward in time
   !-------------------------------------------------------------------------------------------------

   DO WHILE ( Time > FDTime(Ind4Dnew) .AND. ( Time < T_4D_En .OR. ADVECT ) )

      Ind4Dnew         = Ind4Dold                                          ! Reverse array indices (1 or 2).
      Ind4Dold         = 3 - Ind4Dnew
      FDFileNo         = FDFileNo + 1                                      ! Increment file number.


      IF ( ADVECT ) THEN
         FDFileNo = MOD(FDFileNo-1,Num4Dt) + 1

         IF (FDFileNo == 1) THEN
               Shft4Dnew = Shft4Dnew + 1

               IF (Ind4DAdv <= NumAdvect) THEN
                  IF ( MOD( Shft4Dnew, Num4Dx ) == 0 ) THEN
                     CALL ReadAll4DData(FDUnit, ErrStat)
                     IF ( ErrStat /= 0 ) RETURN
                  END IF                  
               ENDIF

         ENDIF

         FDTime(Ind4Dnew) = Times4D(FDFileNo) + Shft4Dnew*FDPer

         CALL Load4DData( Ind4Dnew )  ! shift the data
      ELSE
         FDTime(Ind4Dnew) = Times4D(FDFileNo)

         CALL LoadLESData( FDUnit, FDFileNo, Ind4Dnew, ErrStat )
      ENDIF

   ENDDO


   !.................................................................................................
   ! Find the bounding rows, columns, and planes for the X,Y,Z position.  The near, lower-right  
   ! corner is (1,1,1) when looking downwind. Make sure the lowest possible value is 1.
   !.................................................................................................


   !-------------------------------------------------------------------------------------------------
   ! get values of Time for interpolation. Linear interpolation; Nearest-neighbor extrapolation.
   !-------------------------------------------------------------------------------------------------

      ! Find out fractionally how far we are between grids in time and between grid points in each direction.
      !  Limit values to avoid extrapolation.  We need this for interpolation later on.

   Tgrid = MIN( MAX( ( Time - FDTime(Ind4Dold) )/( FDTime(Ind4Dnew) - FDTime(Ind4Dold) ), 0.0 ), 1.0 )


   !-------------------------------------------------------------------------------------------------
   ! get values of X for interpolation. Grid is periodic in X.
   !-------------------------------------------------------------------------------------------------
   Xnorm = ( Xt + InputPosition(1) )/Xmax

   DO WHILE ( Xnorm < 0.0 )   ! Ensure Xnorm is not negative.  The wave is periodic in x.
      Xnorm = Xnorm + 1.0
   ENDDO

   Xgrid = MIN( MAX( MOD( Xnorm, DelXgrid ), 0.0 ), 1.0 )
   IXLo  = MAX( MOD( INT( Xnorm*Num4DxD1 ) + 1, Num4DxD1 ), 1 )
   IXHi  = MOD( IXLo, Num4DxD ) + 1

   !-------------------------------------------------------------------------------------------------
   ! get values of Y for interpolation. Grid is periodic in Y.
   !-------------------------------------------------------------------------------------------------
   Ynorm = ( Yt + InputPosition(2) )/Ymax

   DO WHILE ( Ynorm < 0.0 )  ! Ensure Ynorm is not negative.  The wave is periodic in y.
      Ynorm = Ynorm + 1.0
   ENDDO

   Ygrid = MIN( MAX( MOD( Ynorm, DelYgrid ), 0.0 ), 1.0 )
   IYLo  = MAX( MOD( INT( Ynorm*Num4DyD1 ) + 1, Num4DyD1 ), 1 )
   IYHi  = MOD( IYLo, Num4DyD ) + 1

   !-------------------------------------------------------------------------------------------------
   ! get values of Z for interpolation.  Linear interpolation; Nearest-neighbor extrapolation.  
   !-------------------------------------------------------------------------------------------------
   Znorm = MIN( MAX( ( Zt + InputPosition(3) - ZRef )/Zmax, 0.0 ), 1.0 ) !bjj: define ZRef

   Zgrid = MIN( MAX( MOD( Znorm, DelZgrid ), 0.0 ), 1.0 )
   IZLo  = MAX( INT( Znorm*Num4DzD1 ) + 1, 1 )

      ! If we are located at the upper end of the z dimension, decrement the index by one and set the grid coordinate to 1.

   IF ( IZLo == Num4DzD )  THEN
      IZLo  = Num4DzD1
      Zgrid = 1.0
   ENDIF
   IZHi = IZLo + 1

      !..............................................................................................
      ! Find the equivalent Znorm (Znorm_w) for the w-component, which may be shifted vertically
      ! by half the original grid spacing.
      !..............................................................................................

   IF ( VertShft ) THEN
      Znorm_w = MAX( Znorm - 0.5*DelZgrid/FD_DF_Z, 0.0 )
   ELSE
      Znorm_w = Znorm
   ENDIF

   Zgrid_w = MIN( MAX( MOD( Znorm_w, DelZgrid ), 0.0 ), 1.0 )
   IZLo_w  = MAX( INT( Znorm_w*Num4DzD1 ) + 1, 1 )

   IF ( IZLo_w == Num4DzD )  THEN
      IZLo_w  = Num4DzD1
      Zgrid_w = 1.0
   ENDIF

   IZHi_w = IZLo_w + 1


   !-------------------------------------------------------------------------------------------------
   ! Interpolate for u component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

   Iylz  = ( FDu(IXLo,IYLo,IZHi,Ind4Dold) - FDu(IXLo,IYLo,IZLo,Ind4Dold) )*Zgrid + FDu(IXLo,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDu(IXLo,IYHi,IZHi,Ind4Dold) - FDu(IXLo,IYHi,IZLo,Ind4Dold) )*Zgrid + FDu(IXLo,IYHi,IZLo,Ind4Dold)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDu(IXHi,IYLo,IZHi,Ind4Dold) - FDu(IXHi,IYLo,IZLo,Ind4Dold) )*Zgrid + FDu(IXHi,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDu(IXHi,IYHi,IZHi,Ind4Dold) - FDu(IXHi,IYHi,IZLo,Ind4Dold) )*Zgrid + FDu(IXHi,IYHi,IZLo,Ind4Dold)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzo = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   Iylz  = ( FDu(IXLo,IYLo,IZHi,Ind4Dnew) - FDu(IXLo,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDu(IXLo,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDu(IXLo,IYHi,IZHi,Ind4Dnew) - FDu(IXLo,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDu(IXLo,IYHi,IZLo,Ind4Dnew)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDu(IXHi,IYLo,IZHi,Ind4Dnew) - FDu(IXHi,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDu(IXHi,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDu(IXHi,IYHi,IZHi,Ind4Dnew) - FDu(IXHi,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDu(IXHi,IYHi,IZLo,Ind4Dnew)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzn = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   FD_GetWindSpeed%Velocity(1) = ( Ixyzn - Ixyzo )*Tgrid + Ixyzo

   !-------------------------------------------------------------------------------------------------
   ! Interpolate for v component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

   Iylz  = ( FDv(IXLo,IYLo,IZHi,Ind4Dold) - FDv(IXLo,IYLo,IZLo,Ind4Dold) )*Zgrid + FDv(IXLo,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDv(IXLo,IYHi,IZHi,Ind4Dold) - FDv(IXLo,IYHi,IZLo,Ind4Dold) )*Zgrid + FDv(IXLo,IYHi,IZLo,Ind4Dold)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDv(IXHi,IYLo,IZHi,Ind4Dold) - FDv(IXHi,IYLo,IZLo,Ind4Dold) )*Zgrid + FDv(IXHi,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDv(IXHi,IYHi,IZHi,Ind4Dold) - FDv(IXHi,IYHi,IZLo,Ind4Dold) )*Zgrid + FDv(IXHi,IYHi,IZLo,Ind4Dold)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzo = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   Iylz  = ( FDv(IXLo,IYLo,IZHi,Ind4Dnew) - FDv(IXLo,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDv(IXLo,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDv(IXLo,IYHi,IZHi,Ind4Dnew) - FDv(IXLo,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDv(IXLo,IYHi,IZLo,Ind4Dnew)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDv(IXHi,IYLo,IZHi,Ind4Dnew) - FDv(IXHi,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDv(IXHi,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDv(IXHi,IYHi,IZHi,Ind4Dnew) - FDv(IXHi,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDv(IXHi,IYHi,IZLo,Ind4Dnew)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzn = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   FD_GetWindSpeed%Velocity(2) = ( Ixyzn - Ixyzo )*Tgrid + Ixyzo

   !-------------------------------------------------------------------------------------------------
   ! Interpolate for w component of wind within the grid.
   !-------------------------------------------------------------------------------------------------
   !bjj: should Zgrid actually be Zgrid_w here?  I changed it so that it's consistent
   
   Iylz  = ( FDw(IXLo,IYLo,IZHi_w,Ind4Dold) - FDw(IXLo,IYLo,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXLo,IYLo,IZLo_w,Ind4Dold)
   Iyhz  = ( FDw(IXLo,IYHi,IZHi_w,Ind4Dold) - FDw(IXLo,IYHi,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXLo,IYHi,IZLo_w,Ind4Dold)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDw(IXHi,IYLo,IZHi_w,Ind4Dold) - FDw(IXHi,IYLo,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXHi,IYLo,IZLo_w,Ind4Dold)
   Iyhz  = ( FDw(IXHi,IYHi,IZHi_w,Ind4Dold) - FDw(IXHi,IYHi,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXHi,IYHi,IZLo_w,Ind4Dold)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzo = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   Iylz  = ( FDw(IXLo,IYLo,IZHi_w,Ind4Dnew) - FDw(IXLo,IYLo,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXLo,IYLo,IZLo_w,Ind4Dnew)
   Iyhz  = ( FDw(IXLo,IYHi,IZHi_w,Ind4Dnew) - FDw(IXLo,IYHi,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXLo,IYHi,IZLo_w,Ind4Dnew)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDw(IXHi,IYLo,IZHi_w,Ind4Dnew) - FDw(IXHi,IYLo,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXHi,IYLo,IZLo_w,Ind4Dnew)
   Iyhz  = ( FDw(IXHi,IYHi,IZHi_w,Ind4Dnew) - FDw(IXHi,IYHi,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXHi,IYHi,IZLo_w,Ind4Dnew)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzn = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   FD_GetWindSpeed%Velocity(3) = ( Ixyzn - Ixyzo )*Tgrid + Ixyzo


   !-------------------------------------------------------------------------------------------------
   ! Set the previous time here to compare with later...
   !-------------------------------------------------------------------------------------------------
   PrevTime = Time

   RETURN
   
END FUNCTION FD_GetWindSpeed
!====================================================================================================
SUBROUTINE FD_Terminate( ErrStat )
! This subroutine deallocates arrays, closes files, and un-sets the initialization flag.
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise


   CLOSE( FDunit )

   ErrStat = 0

   IF ( ALLOCATED( FDu       ) )   DEALLOCATE( FDu,       STAT=ErrStat )
   IF ( ALLOCATED( FDv       ) )   DEALLOCATE( FDv,       STAT=ErrStat )
   IF ( ALLOCATED( FDw       ) )   DEALLOCATE( FDw,       STAT=ErrStat )
   IF ( ALLOCATED( FDuData   ) )   DEALLOCATE( FDuData,   STAT=ErrStat )  
   IF ( ALLOCATED( FDvData   ) )   DEALLOCATE( FDvData,   STAT=ErrStat )
   IF ( ALLOCATED( FDwData   ) )   DEALLOCATE( FDwData,   STAT=ErrStat )
   IF ( ALLOCATED( Times4D   ) )   DEALLOCATE( Times4D,   STAT=ErrStat )
   IF ( ALLOCATED( Times4DIx ) )   DEALLOCATE( Times4DIx, STAT=ErrStat )
   IF ( ALLOCATED( AdvFiles  ) )   DEALLOCATE( AdvFiles,  STAT=ErrStat )

   Initialized = .FALSE.

END SUBROUTINE FD_Terminate
!====================================================================================================
END MODULE FDWind
MODULE FFWind
!
!  This module uses full-field binary wind files to determine the wind inflow.
!  This module assumes that the origin, (0,0,0), is located at the tower centerline at ground level,
!  and that all units are specified in the metric system (using meters and seconds).
!  Data is shifted by half the grid width to account for turbine yaw (so that data in the X 
!  direction actually starts at -1*FFYHWid meters).
!
!  Created 25-Sept-2009 by B. Jonkman, National Renewable Energy Laboratory
!     using subroutines and modules from AeroDyn v12.58
!
!----------------------------------------------------------------------------------------------------

   USE      NWTC_Library
   USE      SharedInflowDefs

   IMPLICIT NONE

   PRIVATE                                                        ! By default, everything in FFWind is private (methods, data, types, etc.)
   
      ! former FF_Wind module
      
   REAL(ReKi), ALLOCATABLE          :: FFData  (:,:,:,:)          ! Array of FF data
   REAL(ReKi), ALLOCATABLE          :: FFtower (:,:,:)            ! Array of data along the tower, below the FF array

   REAL(ReKi)                       :: FFDTime                    ! delta time
   REAL(ReKi)                       :: FFRate                     ! data rate in Hz (1/FFDTime)
   REAL(ReKi)                       :: FFYHWid                    ! half the grid width
   REAL(ReKi)                       :: FFZHWid                    ! half the grid height
   REAL(ReKi)                       :: RefHt                      ! the reference (hub) height of the grid in meters 
   REAL(ReKi)                       :: GridBase                   ! the height of the bottom of the grid in meters
   REAL(ReKi)                       :: InitXPosition              ! the initial x location of the wind file (distance the FF file will be offset)
   REAL(ReKi)                       :: InvFFYD                    ! reciprocal of delta y
   REAL(ReKi)                       :: InvFFZD                    ! reciprocal of delta z
   REAL(ReKi)                       :: InvMFFWS                   ! reciprocal of the mean wind speed (MeanFFWS)
   REAL(ReKi)                       :: MeanFFWS                   ! the mean wind speed (as defined in the FF file), not necessarially the mean of the portion of the wind used
   REAL(ReKi)                       :: TotalTime                  ! the total time in the simulation

   INTEGER                          :: NFFComp                    ! number of wind components
   INTEGER                          :: NFFSteps                   ! number of time steps in the FF array
   INTEGER                          :: NYGrids                    ! number of points in the lateral (y) direction of the grids
   INTEGER                          :: NZGrids                    ! number of points in the vertical (z) direction of the grids
   INTEGER                          :: NTGrids                    ! number of points in the vertical (z) direction on the tower (below the grids)
         
   LOGICAL, SAVE                    :: Initialized = .FALSE.      ! flag that determines if the module has been initialized
   LOGICAL                          :: Periodic    = .FALSE.      ! flag that determines if the wind is periodic


   INTERFACE FF_GetValue
      MODULE PROCEDURE FF_GetRValue                               ! routine to return scalar real values 
   END INTERFACE


   PUBLIC                           :: FF_Init                    ! initialization subroutine to read the FF grids
   PUBLIC                           :: FF_GetWindSpeed            ! interpolation function that returns velocities at specified time and space
   PUBLIC                           :: FF_GetValue                ! interface to return requested values
   PUBLIC                           :: FF_Terminate               ! subroutine that deallocates memory stored in the FFWind module

CONTAINS
!====================================================================================================
SUBROUTINE FF_Init ( UnWind, BinFile, ErrStat )
!  This routine is used read the full-field turbulence data.
!  09/25/97 - Created by M. Buhl from GETFILES in ViewWind.
!  09/23/09 - modified by B. Jonkman: this subroutine was split into several subroutines (was ReadFF)
!----------------------------------------------------------------------------------------------------

   IMPLICIT                       NONE


      ! Passed Variables:
      
   INTEGER,      INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered
   
   CHARACTER(*), INTENT(IN)    :: BinFile                      ! Name of the binary FF wind file

      ! Local Variables:

   REAL(ReKi)                  :: TI      (3)                  ! turbulence intensities of the wind components as defined in the FF file, not necessarially the actual TI
   REAL(ReKi)                  :: BinTI   (3)                  ! turbulence intensities of the wind components as defined in the FF binary file, not necessarially the actual TI
   REAL(ReKi)                  :: UBar
   REAL(ReKi)                  :: ZCenter
   
   INTEGER(B2Ki)               :: Dum_Int2
   INTEGER                     :: DumInt
   INTEGER                     :: I
   LOGICAL                     :: CWise
   LOGICAL                     :: Exists
   CHARACTER( 1028 )           :: SumFile                      ! length is LEN(BinFile) + the 4-character extension.
   CHARACTER( 1028 )           :: TwrFile                      ! length is LEN(BinFile) + the 4-character extension.


      !----------------------------------------------------------------------------------------------
      ! Check that the module hasn't already been initialized.
      !----------------------------------------------------------------------------------------------   
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' FFWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF   


      !----------------------------------------------------------------------------------------------
      ! Open the binary file, read its "header" (first 2-byte integer) to determine what format
      ! binary file it is, and close it.
      !----------------------------------------------------------------------------------------------

   CALL OpenBInpFile (UnWind, TRIM(BinFile), ErrStat)
   IF (ErrStat /= 0) RETURN
      
   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2
   CLOSE( UnWind )
   
   IF (ErrStat /= 0) THEN
      CALL WrScr( ' Error reading first binary integer from file "'//TRIM(BinFile)//'."' )
      RETURN
   END IF
   
      !----------------------------------------------------------------------------------------------
      ! Read the files to get the required FF data.
      !----------------------------------------------------------------------------------------------   
   DumInt = Dum_Int2  ! change to default INTEGER, instead of INT(2) to compare in SELECT below
    
   SELECT CASE (DumInt)  
   
      CASE ( 7, 8 )                                                    ! TurbSim binary format
         
         CALL Read_TurbSim_FF(UnWind, TRIM(BinFile), ErrStat)
         
      CASE ( -1, -2, -3, -99 )                                         ! Bladed-style binary format
      
         !...........................................................................................
         ! Create full-field summary file name from binary file root name.  Also get tower file
         ! name.
         !...........................................................................................

            CALL GetRoot(BinFile, SumFile)
            
            TwrFile = TRIM(SumFile)//'.twr'
            SumFile = TRIM(SumFile)//'.sum'
      
         !...........................................................................................
         ! Read the summary file to get necessary scaling information
         !...........................................................................................
   
            CALL Read_Summary_FF (UnWind, TRIM(SumFile), CWise, ZCenter, TI, ErrStat ) 
            IF (ErrStat /= 0) RETURN
            
            UBar = MeanFFWS      ! temporary storage .... this is our only check to see if the summary and binary files "match"

         !...........................................................................................
         ! Open the binary file and read its header
         !...........................................................................................
         
            CALL OpenBInpFile (UnWind, TRIM(BinFile), ErrStat)

            IF (ErrStat /= 0) RETURN

            IF ( Dum_Int2 == -99 ) THEN                                       ! Newer-style BLADED format
               CALL Read_Bladed_FF_Header1 (UnWind, BinTI, ErrStat)    
               
                  ! If the TIs are also in the binary file (BinTI > 0), 
                  ! use those numbers instead of ones from the summary file
                  
               DO I =1,NFFComp                  
                  IF ( BinTI(I) > 0 ) TI(I) = BinTI(I)
               END DO
               
            ELSE
               CALL Read_Bladed_FF_Header0 (UnWind, ErrStat)                  ! Older-style BLADED format
            END IF

            IF (ErrStat /= 0) RETURN

         !...........................................................................................
         ! Let's see if the summary and binary FF wind files go together before continuing.
         !...........................................................................................
               
            IF ( ABS( UBar - MeanFFWS ) > 0.1 )  THEN
               CALL WrScr( ' Error: Incompatible mean hub-height wind speeds in FF wind files. '//&
                           '(Check that the .sum and .wnd files were generated together.)' )
               ErrStat = 1
               RETURN
            ENDIF

         !...........................................................................................
         ! Calculate the height of the bottom of the grid
         !...........................................................................................

            GridBase = ZCenter - FFZHWid         ! the location, in meters, of the bottom of the grid

         !...........................................................................................
         ! Read the binary grids (converted to m/s) and close the file
         !...........................................................................................

            CALL Read_Bladed_Grids( UnWind, CWise, TI, ErrStat) 
            CLOSE ( UnWind )
                           
            IF ( ErrStat /= 0 ) RETURN
   
         !...........................................................................................
         ! Read the tower points file
         !...........................................................................................
   
            INQUIRE ( FILE=TRIM(TwrFile) , EXIST=Exists )

            IF (  Exists )  THEN  
               CALL Read_FF_Tower( UnWind, TRIM(TwrFile), ErrStat  )
            ELSE
               NTgrids = 0            
            END IF                        

                               
      CASE DEFAULT
         
         CALL WrScr( ' Error: Unrecognized binary wind file type.' )
         ErrStat = 1
         RETURN
                  
   END SELECT


   IF (Periodic) THEN
      InitXPosition = 0                ! start at the hub
      TotalTime     = NFFSteps*FFDTime
   ELSE
      InitXPosition = FFYHWid          ! start half the grid with ahead of the turbine
      TotalTime     = (NFFSteps-1)*FFDTime      
   END IF
      
   Initialized = .TRUE.
   
   RETURN
   
END SUBROUTINE FF_Init
!====================================================================================================
SUBROUTINE Read_Bladed_FF_Header0 (UnWind, ErrStat)
!   Reads the binary headers from the turbulence files of the old Bladed variety.  Note that
!   because of the normalization, neither NZGrids or NYGrids are larger than 32 points.
!   21-Sep-2009 - B. Jonkman, NREL/NWTC.
!----------------------------------------------------------------------------------------------------


   IMPLICIT                      NONE


      ! Passed Variables:
      
   INTEGER,   INTENT(IN)      :: UnWind
   INTEGER,   INTENT(OUT)     :: ErrStat

      ! Local Variables:

   REAL(ReKi)                 :: FFXDelt
   REAL(ReKi)                 :: FFYDelt
   REAL(ReKi)                 :: FFZDelt

   INTEGER(B2Ki)              :: Dum_Int2

   INTEGER                    :: I

   !-------------------------------------------------------------------------------------------------
   ! Read the header (file has just been opened)
   !-------------------------------------------------------------------------------------------------

   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! -NFFC (file ID)

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading number of wind components from binary FF file.' )
         RETURN
      END IF
      NFFComp = -1*Dum_Int2
         

   READ (UnWind, IOSTAT=ErrStat) Dum_Int2                                                    ! delta z (mm)
    
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dz from binary FF file.' )
         RETURN
      END IF
      FFZDelt = 0.001*Dum_Int2
      InvFFZD = 1.0/FFZDelt


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! delta y (mm)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dy from binary FF file.' )
         RETURN
      END IF
      FFYDelt = 0.001*Dum_Int2
      InvFFYD = 1.0/FFYDelt


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! delta x (mm)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dx from binary FF file.' )
         RETURN
      END IF
      FFXDelt = 0.001*Dum_Int2


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! half the number of time steps
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading number of time steps from binary FF file.' )
         RETURN
      END IF
      NFFSteps = 2*Dum_Int2


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! 10 times the mean full-field wind speed
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading mean full-field wind speed from binary FF file.' )
         RETURN
      END IF
      MeanFFWS = 0.1*Dum_Int2
      InvMFFWS = 1.0/MeanFFWS
      FFDTime  = FFXDelt/MeanFFWS
      FFRate   = 1.0/FFDTime

      
   DO I = 1,5   
   
      READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                ! unused variables: zLu, yLu, xLu, dummy, random seed

         IF (ErrStat /= 0) THEN
            CALL WrScr( ' Error reading 2-byte integers from binary FF file.' )
            RETURN
         END IF
         
   END DO


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! 1000*nz

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading nz from binary FF file.' )
         RETURN
      END IF
      NZGrids  = Dum_Int2/1000
      FFZHWid  = 0.5*FFZDelt*( NZGrids - 1 )    ! half the vertical size of the grid


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! 1000*ny
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading ny from binary FF file.' )
         RETURN
      END IF   
      NYGrids  = Dum_Int2/1000
      FFYHWid  = 0.5*FFYDelt*( NYGrids - 1 )


   IF (NFFComp == 3) THEN
   
      DO I=1,6
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                             ! unused variables: zLv, yLv, xLv, zLw, yLw, xLw
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 2-byte length scales from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I
      
   END IF !NFFComp


   RETURN
   
END SUBROUTINE Read_Bladed_FF_Header0
!====================================================================================================
SUBROUTINE Read_Bladed_FF_Header1 (UnWind, TI, ErrStat)
!   Reads the binary headers from the turbulence files of the new Bladed variety.
!   16-May-2002 - Windward Engineering.
!   21-Sep-2009 - B. Jonkman, NREL.  updated to trap errors and add extra parameters for MANN model
!----------------------------------------------------------------------------------------------------


   IMPLICIT                      NONE


      ! Passed Variables:
      
   INTEGER,   INTENT(IN)      :: UnWind
   REAL(ReKi), INTENT(OUT)    :: TI(3)
   INTEGER,   INTENT(OUT)     :: ErrStat

      ! Local Variables:

   REAL(ReKi)                 :: FFXDelt
   REAL(ReKi)                 :: FFYDelt
   REAL(ReKi)                 :: FFZDelt

   REAL(SiKi)                 :: Dum_Real4
   INTEGER(B2Ki)              :: Dum_Int2
   INTEGER(B4Ki)              :: Dum_Int4

   INTEGER                    :: I
   INTEGER                    :: TurbType


   TI(:) = -1                                                                                !Initialize to -1 (not all models contain TI)

   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! -99 (file ID)

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading integer from binary FF file.' )
         RETURN
      END IF

   
   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! turbulence type

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading turbulence type from binary FF file.' )
         RETURN
      END IF
      TurbType = Dum_Int2


   SELECT CASE (TurbType)
      CASE(1, 2) 
         !----------------------------------------
         !1-component Von Karman (1) or Kaimal (2)
         !----------------------------------------
            NFFComp = 1
                  
      CASE(3, 5) 
         !----------------------------------------
         !3-component Von Karman (3) or IEC-2 
         ! Kaimal (5)
         !----------------------------------------
            NFFComp = 3
         
      CASE(4) 
         !----------------------------------------
         !improved Von Karman
         !----------------------------------------
      
            READ (UnWind, IOSTAT=ErrStat) Dum_Int4                                           ! number of components (should be 3)
            
               IF (ErrStat /= 0) THEN           
                  CALL WrScr( ' Error reading number of components from binary FF file.' )
                  RETURN
               END IF
               NFFComp = Dum_Int4
            
            READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                          ! Latitude (deg)
            
               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading latitude from binary FF file.' )  
                  RETURN
               END IF

            READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                          ! Roughness length (m)

               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading roughness length from binary FF file.' )
                  RETURN
               END IF
            
            READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                          ! Reference height (m) = Z(1) + GridHeight / 2.0

               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading reference height from binary FF file.' )
                  RETURN
               END IF
            
            
            DO I = 1,3
               READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                       ! TI(u, v, w) (%)
               
                  IF (ErrStat /= 0) THEN
                     CALL WrScr( ' Error reading TI('//'TRIM(Num2LStr(I))'//') from binary FF file.' )
                     RETURN
                  END IF
                  TI(I) = Dum_Real4                                                          ! This overwrites the TI read in the summary file
                  
            END DO !I            
                             
                  
      CASE (7, 8)
         !----------------------------------------
         ! General Kaimal (7) or  Mann model (8)
         !----------------------------------------
      
            READ (UnWind, IOSTAT=ErrStat) Dum_Int4                                           ! number of bytes in header
            
               IF (ErrStat /= 0) THEN           
                  CALL WrScr( ' Error reading number of header records from binary FF file.' )
                  RETURN
               END IF

            READ (UnWind, IOSTAT=ErrStat) Dum_Int4                                           ! number of components
            
               IF (ErrStat /= 0) THEN           
                  CALL WrScr( ' Error reading number of data from binary FF file.' )
                  RETURN
               END IF
               NFFComp = Dum_Int4

                                  
      CASE DEFAULT
      
         CALL ProgWarn( ' AeroDyn does not recognize the full-field turbulence file type ='//TRIM(Num2LStr(TurbType))//'.' )
                  
   END SELECT !TurbType


   READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                                   ! delta z (m)
    
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dz from binary FF file.' )
         RETURN
      END IF
      FFZDelt = Dum_Real4
      InvFFZD = 1.0/FFZDelt


   READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                                  ! delta y (m)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dy from binary FF file.' )
         RETURN
      END IF
      FFYDelt = Dum_Real4
      InvFFYD = 1.0/FFYDelt

   READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                                  ! delta x (m)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dx from binary FF file.' )
         RETURN
      END IF
      FFXDelt = Dum_Real4


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                   ! half the number of time steps
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading number of time steps from binary FF file.' )
         RETURN
      END IF
      NFFSteps = 2*Dum_Int4


   READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                                  ! mean full-field wind speed
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading mean full-field wind speed from binary FF file.' )
         RETURN
      END IF
      MeanFFWS = Dum_Real4
      InvMFFWS = 1.0/MeanFFWS
      FFDTime  = FFXDelt/MeanFFWS
      FFRate   = 1.0/FFDTime

      
   DO I = 1,3   
   
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                               ! unused variables: zLu, yLu, xLu

         IF (ErrStat /= 0) THEN
            CALL WrScr( ' Error reading 4-byte length scales from binary FF file.' )
            RETURN
         END IF
         
   END DO
   
   
   DO I = 1,2
   
      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                ! unused variables: dummy, random seed
      
         IF (ErrStat /= 0) THEN
            CALL WrScr( ' Error reading 4-byte integers from binary FF file.' )
            RETURN
         END IF
         
   END DO


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                   ! nz

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading nz from binary FF file.' )
         RETURN
      END IF
      NZGrids  = Dum_Int4
      FFZHWid  = 0.5*FFZDelt*( NZGrids - 1 )    ! half the vertical size of the grid


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                   ! ny
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading ny from binary FF file.' )
         RETURN
      END IF   
      NYGrids  = Dum_Int4
      FFYHWid  = 0.5*FFYDelt*( NYGrids - 1 )


   IF (NFFComp == 3) THEN
   
      DO I=1,6
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables: zLv, yLv, xLv, zLw, yLw, xLw
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte length scales from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I
      
   END IF !NFFComp



   IF ( TurbType == 7 ) THEN     ! General Kaimal model
   
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variable: coherence decay constant
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading coherence decay constant from binary FF file.' )
               RETURN
            END IF

         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables: coherence scale parameter in m
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading coherence scale parameter from binary FF file.' )
               RETURN
            END IF
         
   ELSE IF ( TurbType == 8 ) THEN     ! Mann model
      
      DO I=1,2
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables: shear parameter (gamma), scale length
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,4
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,3
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,2
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,3
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,2
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I


   END IF !TurbType


   RETURN
   
END SUBROUTINE Read_Bladed_FF_Header1
!====================================================================================================
SUBROUTINE Read_Bladed_Grids ( UnWind, CWise, TI, ErrStat )
! This subroutine continues reading UnWind, starting after the headers have been read.
! It reads the grids and converts the data to un-normalized wind speeds in m/s.
!----------------------------------------------------------------------------------------------------

   INTEGER,     INTENT(IN)    :: UnWind
   LOGICAL,     INTENT(IN)    :: CWise
   REAL(ReKi),  INTENT(IN)    :: TI      (3)                  ! turbulence intensities of the wind components as defined in the FF file, not necessarially the actual TI
   INTEGER,     INTENT(OUT)   :: ErrStat

   REAL(ReKi), PARAMETER      :: FF_Offset(3) = (/ 1.0, 0.0, 0.0 /)  ! used for "un-normalizing" the data

   INTEGER                    :: CFirst
   INTEGER                    :: CLast
   INTEGER                    :: CStep
   INTEGER(B2Ki)              :: Dum_Int2
   INTEGER                    :: I
   INTEGER                    :: IC
   INTEGER                    :: IR
   INTEGER                    :: IT
   
   INTEGER                    :: TmpNumSteps


   !-------------------------------------------------------------------------------------------------
   ! Generate an informative message.
   !-------------------------------------------------------------------------------------------------
      
   CALL WrScr1( ' Reading a '//TRIM( Num2LStr(NYGrids) )//'x'//TRIM( Num2LStr(NZGrids) )//  &
            ' grid ('//TRIM( Num2LStr(FFYHWid*2) )//' m wide, '// &
            TRIM( Num2LStr(GridBase) )//' m to '//TRIM( Num2LStr(GridBase+FFZHWid*2) )//&
            ' m above ground) with a characterstic wind speed of '//TRIM( Num2LStr(MeanFFWS) )//' m/s. ' )

   !-------------------------------------------------------------------------------------------------
   ! Allocate space for the FF array 
   !-------------------------------------------------------------------------------------------------

   TmpNumSteps = NFFSteps + 1       ! add another step, just in case there is an odd number of steps.

!bjj: should we reorganize this FFData array so we access the data faster?
   
   IF ( .NOT. ALLOCATED( FFData ) ) THEN
      ALLOCATE ( FFData(NZGrids,NYGrids,NFFComp,TmpNumSteps),STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Cannot allocate the full-field wind data array.' )
         RETURN

      ENDIF
      
   ELSE
      IF (SIZE(FFDATA,1) /= NZGrids .OR. SIZE(FFDATA,2) /= NYGrids .OR. &
          SIZE(FFDATA,3) /= NFFComp .OR. SIZE(FFDATA,3) /= TmpNumSteps ) THEN
          
            ! Let's make the array the correct size (we should never get here, but you never know)
            
         DEALLOCATE( FFData )
          
         ALLOCATE ( FFData(NZGrids,NYGrids,NFFComp,TmpNumSteps),STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN

            CALL WrScr( ' Cannot allocate the full-field wind data array.' )
            RETURN

         END IF ! Error
          
      END IF !Incorrect size
   END IF ! allocated

   !-------------------------------------------------------------------------------------------------
   ! Initialize the data and set column indexing to account for direction of turbine rotation (CWise)
   !-------------------------------------------------------------------------------------------------
   
   FFData(:,:,:,:) = 0.0                        ! we may have only one component
   
   IF ( CWise )  THEN
      CFirst    = NYGrids
      CLast     = 1
      CStep     = -1
   ELSE
      CFirst    = 1
      CLast     = NYGrids
      CStep     = 1
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Loop through all the time steps, reading the data and converting to m/s
   !-------------------------------------------------------------------------------------------------
!bjj: should we reorganize this FFData array so we access the data faster?
  
   NFFSteps = TmpNumSteps
  
TIME_LOOP:  DO IT=1,TmpNumSteps     ! time (add 1 to see if there is an odd number of grids)
   
      DO IR=1,NZGrids               ! the rows (vertical)
      
         DO IC=CFirst,CLast,CStep   ! the columns (lateral)
         
            DO I=1,NFFComp          ! wind components (U, V, W)
            
               READ (UnWind,IOStat=ErrStat)  Dum_Int2
               IF (ErrStat /= 0) THEN
                  IF ( IT == TmpNumSteps ) THEN ! There really were an even number of steps
                     NFFSteps = TmpNumSteps - 1
                     ErrStat  = 0
                     EXIT TIME_LOOP       
                  ELSE               
                     CALL WrScr( ' Error reading binary data file. ic = '//TRIM(Num2LStr(ic))// &
                                    ', ir = '//TRIM(Num2LStr(ir))//', it = '//TRIM(Num2LStr(it))// &
                                    ', nffsteps = '//TRIM(Num2LStr(nffsteps)) )
                     ErrStat = 1
                     RETURN
                  END IF
               ELSE               
                  FFData(IR,IC,I,IT) = MeanFFWS*(FF_Offset(I)+0.00001*TI(I)*Dum_Int2) 
               END IF
               
            END DO !I

         END DO !IC

      END DO !IR

   END DO TIME_LOOP !IT
   
   IF ( Periodic ) THEN
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data (period of '//TRIM( Num2LStr( FFDTime*NFFSteps ) )//' seconds).' )
   ELSE                     
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data ('//TRIM( Num2LStr( FFDTime*( NFFSteps - 1 ) ) )//' seconds).' )
   END IF

END SUBROUTINE Read_Bladed_Grids
!====================================================================================================
SUBROUTINE Read_Summary_FF ( UnWind, FileName, CWise, ZCenter, TI, ErrStat )
! This subroutine reads the text summary file to get normalizing parameters, the location of the
! grid, and the direction the grid was written to the binary file
!----------------------------------------------------------------------------------------------------

   INTEGER,     INTENT(IN)    :: UnWind         ! unit number for the file to open
   CHARACTER(*),INTENT(IN)    :: FileName       ! name of the summary file
   LOGICAL,     INTENT(OUT)   :: CWise          ! rotation (for reading the order of the binary data)
   REAL(ReKi),  INTENT(OUT)   :: ZCenter        ! the height at the center of the grid
   REAL(ReKi),  INTENT(OUT)   :: TI      (3)    ! turbulence intensities of the wind components as defined in the FF file, not necessarially the actual TI
   INTEGER,     INTENT(OUT)   :: ErrStat        ! returns 0 if no error encountered in the subroutine
   
   REAL(ReKi)                 :: ZGOffset       ! The vertical offset of the turbine on rectangular grid (allows turbulence not centered on turbine hub)

   
   INTEGER, PARAMETER         :: NumStrings = 6 ! number of strings to be looking for in the file

   INTEGER                    :: FirstIndx      ! The first character of a line where data is located
   INTEGER                    :: I              ! A loop counter
   INTEGER                    :: LastIndx       ! The last  character of a line where data is located
   INTEGER                    :: LineCount      ! Number of lines that have been read in the file
   INTEGER                    :: Status         ! Status from I/O calls
   
   LOGICAL                    :: StrNeeded(NumStrings)   ! if the string has been found
   
   CHARACTER(1024)            :: LINE           ! temporary storage for reading a line from the file
   
      !----------------------------------------------------------------------------------------------
      ! Initialize some variables
      !----------------------------------------------------------------------------------------------

   ErrStat      = 0
   LineCount    = 0
   StrNeeded(:) = .TRUE.
   ZGOffset     = 0.0
   RefHt        = 0.0
   Periodic     = .FALSE.
   
      !----------------------------------------------------------------------------------------------
      ! Open summary file.
      !----------------------------------------------------------------------------------------------
      
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat) 


      !----------------------------------------------------------------------------------------------
      ! Read the summary file.
      !----------------------------------------------------------------------------------------------

   DO WHILE ( ( ErrStat == 0 ) .AND. StrNeeded(NumStrings) )

      LineCount = LineCount + 1

      READ ( UnWind, '(A)', IOSTAT=ErrStat ) LINE
      IF ( ErrStat /= 0 ) THEN
      
         IF ( StrNeeded(NumStrings-1) ) THEN  ! the "HEIGHT OFFSET" StrNeeded(NumStrings) parameter is not necessary.  We'll assume it's zero if we didn't find it.
            CALL WrScr( ' Error reading line #'//TRIM(Num2LStr(LineCount))//' of the summary file, "'//TRIM(FileName)//'"' )
            CALL WrScr( 'Could not find all of the required parameters.' )
            ErrStat = NumStrings+1
            RETURN
         ELSE           
            EXIT
         ENDIF
         
      END IF
      
      CALL Conv2UC ( LINE )
            

      IF ( StrNeeded(1) ) THEN
      
         !-------------------------------------------------------------------------------------------
         ! #1: Get the rotation direction, using the string "CLOCKWISE" 
         !-------------------------------------------------------------------------------------------
            
         IF ( INDEX( LINE, 'CLOCKWISE' ) > 0 ) THEN
            
            READ (LINE, *, IOSTAT = Status)  CWise          ! Look for True/False values

            IF ( Status /= 0 ) THEN                         ! Look for Yes/No values instead

               LINE = ADJUSTL ( LINE )                      ! Remove leading spaces from input line

               SELECT CASE (LINE(1:1) )
                  CASE ('Y')
                     CWise = .TRUE.
                  CASE ('N')
                     CWise = .FALSE.
                  CASE DEFAULT                  
                     CALL WrScr( ' Error reading rotation direction (CLOCKWISE) from FF summary file.' )
                     ErrStat = 1
                     RETURN
               END SELECT
               
            END IF ! Status /= 0
            StrNeeded(1) = .FALSE.
            
         END IF   ! INDEX for "CLOCKWISE"
         
      ELSEIF ( StrNeeded(2) ) THEN
      
         !-------------------------------------------------------------------------------------------
         ! #2: Get the hub height, using the strings "HUB HEIGHT" or "ZHUB"
         !-------------------------------------------------------------------------------------------

         IF ( INDEX( LINE, 'HUB HEIGHT' ) > 0 .OR. INDEX( LINE, 'ZHUB' ) > 0 ) THEN
         
            READ (LINE, *, IOSTAT = Status) RefHt
         
            IF ( Status /= 0 ) THEN
               CALL WrScr( ' Error reading hub height from FF summary file.' )
               ErrStat = 2
               RETURN
            END IF ! Status /= 0
            StrNeeded(2) = .FALSE.
                  
         END IF !INDEX for "HUB HEIGHT" or "ZHUB"
         
         
!      ELSEIF ( StrNeeded(3) ) THEN
!
!         !-------------------------------------------------------------------------------------------
!         ! #3: Get the grid width (& height, if available), using the strings "GRID WIDTH" or "RDIAM"
!         !    If GRID HEIGHT is specified, use it, too. -- THIS IS UNNECESSARY AS IT'S STORED IN THE BINARY FILE
!         !-------------------------------------------------------------------------------------------         

      ELSEIF ( StrNeeded(4) ) THEN
      
         !-------------------------------------------------------------------------------------------
         ! #4: Get the mean wind speed "UBAR" and turbulence intensities from following lines for 
         !     scaling Bladed-style FF binary files
         !-------------------------------------------------------------------------------------------         

         IF ( INDEX( LINE, 'UBAR') > 0 ) THEN

            FirstIndx = INDEX( LINE, '=' ) + 1        ! Look for the equal siqn to find the number we're looking for

            READ ( LINE( FirstIndx:LEN(LINE) ), *, IOSTAT=Status ) MeanFFWS

            IF ( Status /= 0 ) THEN
               CALL WrScr( ' Error reading UBar binary data normalizing parameter from FF summary file.' )
               ErrStat = 4
               RETURN
            END IF ! Status /= 0      

            DO I = 1,3

               LineCount = LineCount + 1

               READ ( UnWind, '(A)', IOSTAT=Status ) LINE
               IF ( Status /= 0 ) THEN
                  CALL WrScr( ' Error reading line #'//TRIM(Num2LStr(LineCount))//' of the summary file, "'//TRIM(FileName)//'"' )
                  CALL WrScr( 'Could not find all of the required parameters.' )
                  ErrStat = Status
                  RETURN
               END IF

               FirstIndx = INDEX( LINE, '=' ) + 1     ! Read the number between the = and % signs
               LastIndx  = INDEX( LINE, '%' ) - 1

               IF ( LastIndx <= FirstIndx ) LastIndx = LEN( LINE )   ! If there's no % sign, read to the end of the line

               READ ( LINE( FirstIndx:LastIndx ), *, IOSTAT=Status ) TI(I)
               IF ( Status /= 0 ) THEN
                  CALL WrScr( ' Error reading TI('//TRIM(Num2LStr(I))//') binary data normalizing parameter from FF summary file.' )
                  ErrStat = 4
                  RETURN
               END IF ! Status /= 0      

            END DO !I

            StrNeeded(4) = .FALSE.            

          END IF
      
      ELSEIF ( StrNeeded(5) ) THEN
         
         !-------------------------------------------------------------------------------------------
         ! #5: Get the grid "HEIGHT OFFSET", if it exists (in TurbSim). Otherwise, assume it's zero 
         !           ZGOffset = HH - GridBase - FFZHWid
         !-------------------------------------------------------------------------------------------         
         IF ( INDEX( LINE, 'HEIGHT OFFSET' ) > 0  ) THEN
         
            FirstIndx = INDEX ( LINE, '=' ) + 1

            READ ( LINE( FirstIndx:LEN(LINE) ), *, IOSTAT=Status ) ZGOffset            
                  
            IF ( Status /= 0 ) THEN
               CALL WrScr( ' Error reading height offset from FF summary file.' )
               ErrStat = 5
               RETURN
            END IF ! Status /= 0
                  
            StrNeeded(5) = .FALSE.
            
         END IF !INDEX for "HEIGHT OFFSET"

      ELSEIF ( StrNeeded(6) ) THEN
         
         !-------------------------------------------------------------------------------------------
         ! #5: Get the grid "PERIODIC", if it exists (in TurbSim). Otherwise, assume it's  
         !        not a periodic file
         !-------------------------------------------------------------------------------------------         
         IF ( INDEX( LINE, 'PERIODIC' ) > 0  ) THEN
         
            Periodic     = .TRUE.                  
            StrNeeded(6) = .FALSE.
            
         END IF !INDEX for "PERIODIC"
         
      END IF ! StrNeeded
      
      
   END DO !WHILE

   ErrStat = 0    ! We made it to the end of the file
   
   !-------------------------------------------------------------------------------------------------
   ! Close the summary file
   !-------------------------------------------------------------------------------------------------         
   
   CLOSE ( UnWind )


   !-------------------------------------------------------------------------------------------------
   ! Calculate the height of the grid center
   !-------------------------------------------------------------------------------------------------         

    ZCenter  = RefHt - ZGOffset


END SUBROUTINE Read_Summary_FF
!====================================================================================================
SUBROUTINE Read_TurbSim_FF(UnWind,WindFile, ErrStat)
! This subroutine reads the binary TurbSim-format FF file (.bts).  It fills the FFData array with
! velocity data for the grids and fills the FFtower array with velocities at points on the tower 
! (if data exists).
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,      INTENT(IN)   :: UnWind            ! unit number for the wind file
   CHARACTER(*), INTENT(IN)   :: WindFile          ! name of the binary TurbSim file
   INTEGER,      INTENT(OUT)  :: ErrStat           ! error status return value (0=no error; non-zero is error)

      ! Local Variables:

   REAL(SiKi)                 :: Dum_Real4         ! dummy 4-byte real number
   INTEGER(B1Ki)              :: Dum_Int1          ! dummy 1-byte integer
   INTEGER(B2Ki)              :: Dum_Int2          ! dummy 2-byte integer
   INTEGER(B4Ki)              :: Dum_Int4          ! dummy 4-byte integer

   INTEGER                    :: IC                ! loop counter for wind components
   INTEGER                    :: IT                ! loop counter for time
   INTEGER                    :: IY                ! loop counter for y
   INTEGER                    :: IZ                ! loop counter for z
   INTEGER                    :: NChar             ! number of characters in the description string
   
   REAL(SiKi)                 :: Vslope(3)         ! slope  for "un-normalizing" data
   REAL(SiKi)                 :: Voffset(3)        ! offset for "un-normalizing" data
            
   CHARACTER(1024)            :: DescStr           ! description string contained in the file


   NFFComp = 3                                              ! this file contains 3 wind components
         
   !-------------------------------------------------------------------------------------------------
   ! Open the file
   !-------------------------------------------------------------------------------------------------

   CALL OpenBInpFile (UnWind, TRIM(WindFile), ErrStat)
   IF (ErrStat /= 0) RETURN
      
   !-------------------------------------------------------------------------------------------------
   ! Read the header information
   !-------------------------------------------------------------------------------------------------
      READ (UnWind, IOSTAT=ErrStat)  Dum_Int2               ! the file identifier, INT(2)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the file identifier in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF         
         Periodic = Dum_Int2 == INT( 8, B2Ki) ! the number 7 is used for non-periodic wind files; 8 is periodic wind


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4               ! the number of grid points vertically, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of z grid points in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NZgrids = Dum_Int4       

     
      READ (UnWind, IOSTAT=ErrStat) Dum_Int4                ! the number of grid points laterally, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of y grid points in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NYgrids = Dum_Int4


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4               ! the number of tower points, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of tower points in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NTgrids = Dum_Int4
         

      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4               ! the number of time steps, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of time steps in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NFFSteps = Dum_Int4


      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! grid spacing in vertical direction (dz), REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dz in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         InvFFZD = 1.0/Dum_Real4                            ! 1/dz
         FFZHWid = 0.5*(NZgrids-1)*Dum_Real4                ! half the grid height


      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! grid spacing in lateral direction (dy), REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dy in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         InvFFYD = 1.0 / Dum_Real4                          ! 1/dy
         FFYHWid = 0.5*(NYgrids-1)*Dum_Real4                ! half grid grid width


      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! grid spacing in time (dt), REAL(4), in m/s
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dt in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         FFDTime = Dum_Real4
         FFRate  = 1.0/FFDTime
                  
                  
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! the mean wind speed at hub height, REAL(4), in m/s
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading mean wind speed in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         MeanFFWS = Dum_Real4
         InvMFFWS = 1.0 / MeanFFWS
         
         
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! height of the hub, REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading zHub in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         RefHt = Dum_Real4
         
         
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! height of the bottom of the grid, REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading GridBase in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         GridBase = Dum_Real4

 !        ZGOffset = RefHt - GridBase  - FFZHWid
         
         
      !----------------------------------------------------------------------------------------------
      ! Read the binary scaling factors
      !----------------------------------------------------------------------------------------------         
         
         DO IC = 1,NFFComp         
            READ (UnWind, IOSTAT=ErrStat)  Vslope(IC)       ! the IC-component slope for scaling, REAL(4)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr ( ' Error reading Vslope('//Num2LStr(IC)//') in the FF binary file "'//TRIM( WindFile )//'."' )
                  RETURN
               ENDIF


            READ (UnWind, IOSTAT=ErrStat)  Voffset(IC)      ! the IC-component offset for scaling, REAL(4)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr ( ' Error reading Voffset('//Num2LStr(IC)//') in the FF binary file "'//TRIM( WindFile )//'."' )
                  RETURN
               ENDIF
               
         END DO !IC


      !----------------------------------------------------------------------------------------------
      ! Read the description string: "Generated by TurbSim (vx.xx, dd-mmm-yyyy) on dd-mmm-yyyy at hh:mm:ss."
      !----------------------------------------------------------------------------------------------

         READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                ! the number of characters in the description string, max 200, INT(4)
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error reading NCHAR in the FF binary file "'//TRIM( WindFile )//'."' )
               RETURN
            ENDIF
            nchar = Dum_Int4
            
         DescStr = ''                                       ! Initialize the description string
         
         DO IC=1,nchar

            READ (UnWind, IOSTAT=ErrStat) Dum_Int1          ! the ASCII integer representation of the character, INT(1)
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error reading description line in the FF binary file "'//TRIM( WindFile )//'."' )
               RETURN
            ENDIF
            
            IF ( LEN(DescStr) >= IC ) THEN
               DescStr(IC:IC) = ACHAR( Dum_Int1 )              ! converted ASCII characters
            ELSE
               CALL WrScr ( ' Description string too long.' )
               EXIT
            END IF

         ENDDO !IC


   !-------------------------------------------------------------------------------------------------
   ! Get the grid and tower velocities
   !-------------------------------------------------------------------------------------------------

   CALL WrScr1( ' Reading a '//TRIM( Num2LStr(NYGrids) )//'x'//TRIM( Num2LStr(NZGrids) )//  &
            ' grid ('//TRIM( Num2LStr(FFYHWid*2) )//' m wide, '// &
            TRIM( Num2LStr(GridBase) )//' m to '//TRIM( Num2LStr(GridBase+FFZHWid*2) )//&
            ' m above ground) with a characterstic wind speed of '//TRIM( Num2LStr(MeanFFWS) )//' m/s. '//TRIM(DescStr) )
               
               
   !----------------------------------------------------------------------------------------------
   ! Allocate arrays for the FF grid as well as the tower points, if they exist
   !----------------------------------------------------------------------------------------------
            
      IF ( .NOT. ALLOCATED( FFData ) ) THEN
         ALLOCATE ( FFData(NZGrids,NYGrids,NFFComp,NFFSteps), STAT=ErrStat )
               
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr( ' Cannot allocate the full-field wind data array.' )
            RETURN
         ENDIF         
      ENDIF
         
     
      IF ( NTgrids > 0 ) THEN
      
         IF ( .NOT. ALLOCATED( FFtower ) ) THEN
            ALLOCATE( FFtower( NFFComp, NTgrids, NFFSteps ), STAT=ErrStat )
            
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Cannot allocate the tower wind data array.' )
               RETURN
            ENDIF            
         ENDIF
         
      ENDIF         
      
   !-------------------------------------------------------------------------------------------------
   ! Read the 16-bit data and scale it to 32-bit reals
   !-------------------------------------------------------------------------------------------------
               
      ! Loop through time.

      DO IT=1,NFFSteps
      
         !...........................................................................................
         ! Read grid data at this time step.
         !...........................................................................................

         DO IZ=1,NZgrids
            ! Zgrid(IZ) = Z1 + (IZ-1)*dz                 ! Vertical location of grid data point, in m relative to ground

            DO IY=1,NYgrids
               ! Ygrid(IY) = -0.5*(ny-1)*dy + (IY-1)*dy  ! Horizontal location of grid data point, in m relative to tower centerline
            
               DO IC=1,NFFComp                           ! number of wind components (U, V, W)

                  READ (UnWind, IOSTAT=ErrStat)  Dum_Int2      ! normalized wind-component, INT(2)
                  IF ( ErrStat /= 0 )  THEN
                     CALL WrScr ( ' Error reading grid wind components in the FF binary file "'//TRIM( WindFile )//'."' )
                     RETURN
                  ENDIF
                  
                  FFData(IZ,IY,IC,IT) = ( Dum_Int2 - Voffset(IC) ) / VSlope(IC)

               ENDDO !IC

            ENDDO !IY
            
         ENDDO ! IZ


         !...........................................................................................
         ! Read the tower data at this time step.
         !...........................................................................................
            
         DO IZ=1,NTgrids         ! If NTgrids<1, there are no tower points & FFtower is not allocated

            ! Ytower     = 0               ! Lateral location of the tower data point, in m relative to tower centerline
            ! Ztower(IZ) = Z1 - (IZ-1)*dz  ! Vertical location of tower data point, in m relative to ground

            DO IC=1,NFFComp   ! number of wind components

               READ (UnWind, IOSTAT=ErrStat)  Dum_Int2      ! normalized wind-component, INT(2)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr ( ' Error reading tower wind components in the FF binary file "'//TRIM( WindFile )//'."' )
                  RETURN
               ENDIF
               
               FFtower(IC,IZ,IT) = ( Dum_Int2 - Voffset(IC) ) / VSlope(IC)  ! wind-component scaled to m/s

            ENDDO !IC

         ENDDO ! IZ


      ENDDO ! IT

   !-------------------------------------------------------------------------------------------------
   ! close the file and return
   !-------------------------------------------------------------------------------------------------
   
   CLOSE ( UnWind )


   IF ( Periodic ) THEN
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data (period of '//TRIM( Num2LStr( FFDTime*( NFFSteps ) ) )//' seconds).' )
   ELSE
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data ('//TRIM( Num2LStr( FFDTime*( NFFSteps - 1 ) ) )//' seconds).' )
   END IF                  

   RETURN

END SUBROUTINE READ_TurbSim_FF
!====================================================================================================
SUBROUTINE Read_FF_Tower( UnWind, WindFile, ErrStat )
! This subroutine reads the binary tower file that corresponds with the Bladed-style FF binary file.
! The FF grid must be read before this subroutine is called! (many checks are made to ensure the
! files belong together)
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,      INTENT(IN)   :: UnWind            ! unit number for the wind file
   CHARACTER(*), INTENT(IN)   :: WindFile          ! name of the binary TurbSim file
   INTEGER,      INTENT(OUT)  :: ErrStat           ! error status return value (0=no error; non-zero is error)

      ! Local Variables:

   REAL(SiKi)                 :: Dum_Real4         ! dummy 4-byte real number
   INTEGER(B2Ki)              :: Dum_Int2          ! dummy 2-byte integer
   INTEGER(B4Ki)              :: Dum_Int4          ! dummy 4-byte integer

   INTEGER                    :: IC                ! loop counter for wind components
   INTEGER                    :: IT                ! loop counter for time
   INTEGER                    :: IZ                ! loop counter for z
   
   REAL(ReKi), PARAMETER      :: TOL = 1E-4        ! tolerence for wind file comparisons

   REAL(ReKi), PARAMETER      :: FF_Offset(3) = (/ 1.0, 0.0, 0.0 /)  ! used for "un-normalizing" the data
   REAL(SiKi)                 :: TI       (3)      ! scaling values for "un-normalizing the data" [approx. turbulence intensities of the wind components]

   !-------------------------------------------------------------------------------------------------
   ! 
   !-------------------------------------------------------------------------------------------------

   NTgrids = 0

   IF ( NFFComp /= 3 ) THEN
      CALL WrScr( ' Error: Tower binary files require 3 wind components.' )
      ErrStat = 1
      RETURN
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Open the file
   !-------------------------------------------------------------------------------------------------

   CALL OpenBInpFile (UnWind, TRIM(WindFile), ErrStat)
   IF (ErrStat /= 0) THEN
      ErrStat = -1
      RETURN
   END IF
      
   !-------------------------------------------------------------------------------------------------
   ! Read the header information and check that it's compatible with the FF Bladed-style binary
   ! parameters already read.
   !-------------------------------------------------------------------------------------------------
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! dz, in meters [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dz in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( ABS(Dum_Real4*InvFFZD-1) > TOL ) THEN
            CALL WrScr ( ' Resolution in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF
         
         
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! dx, in meters [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dx in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         
         IF ( ABS(Dum_Real4*InvMFFWS/FFDTime-1) > TOL ) THEN
            CALL WrScr ( ' Time resolution in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF
         

      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! Zmax, in meters [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading GridBase in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( ABS(Dum_Real4/GridBase-1) > TOL ) THEN
            CALL WrScr ( ' Height in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                  ! NumOutSteps [4-byte INTEGER]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading NumOutSteps in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( Dum_Int4 /= NFFSteps ) THEN
            CALL WrScr ( ' Number of time steps in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                  ! NumZ      [4-byte INTEGER]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading NumZ in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NTgrids = Dum_Int4
         

      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! UHub      [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading UHub in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( ABS(Dum_Real4*InvMFFWS - 1) > TOL ) THEN
            CALL WrScr ( ' Mean wind speed in the FF binary file does not match the tower file.' )
            ErrStat = 1
            NTgrids = 0
            RETURN
         END IF


      DO IC=1,3
         READ (UnWind, IOSTAT=ErrStat)  TI(IC)               ! TI(u), TI(v), TI(w)  [4-byte REAL]
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error reading TI('//TRIM(Num2LStr(IC))//') in the binary tower file "' &
                               //TRIM( WindFile )//'."' )
               NTgrids = 0                               
               RETURN
            ENDIF
      END DO      

   !----------------------------------------------------------------------------------------------
   ! Allocate arrays for the tower points
   !----------------------------------------------------------------------------------------------        
     
      IF ( NTgrids > 0 ) THEN
      
         IF ( .NOT. ALLOCATED( FFtower ) ) THEN
!            CALL AllocAry( FFtower, NFFComp, NTgrids, NFFSteps, 'tower wind data', ErrStat )            
            ALLOCATE ( FFtower(NFFComp,NTgrids,NFFSteps), STAT=ErrStat )

            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error allocating memory for the tower wind data array.' )
               NTgrids = 0
               RETURN
            END IF

         ELSE
            ! Check sizes here!
         ENDIF
         
      ENDIF         
      
   !-------------------------------------------------------------------------------------------------
   ! Read the 16-bit time-series data and scale it to 32-bit reals
   !-------------------------------------------------------------------------------------------------
               
      ! Loop through time.

      DO IT=1,NFFSteps

         DO IZ=1,NTgrids         ! If NTgrids<1, there are no tower points & FFtower is not allocated

            ! Ytower     = 0               ! Lateral location of the tower data point, in m relative to tower centerline
            ! Ztower(IZ) = Z1 - (IZ-1)*dz  ! Vertical location of tower data point, in m relative to ground

            DO IC=1,NFFComp   ! number of wind components

               READ (UnWind, IOSTAT=ErrStat)  Dum_Int2      ! normalized wind-component, INT(2)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr( ' Error reading binary tower data file. it = '//TRIM(Num2LStr(it))// &
                                 ', nffsteps = '//TRIM(Num2LStr(nffsteps)) )
                  ErrStat = 1  
                  NTgrids = 0            
                  RETURN
               ENDIF
               
               FFtower(IC,IZ,IT) = MeanFFWS*(FF_Offset(IC)+0.00001*TI(IC)*Dum_Int2)   ! wind-component scaled to m/s

            ENDDO !IC

         ENDDO ! IZ


      ENDDO ! IT   

   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
   CLOSE ( UnWind )


   CALL WrScr ( ' Processed '//TRIM( Num2LStr(NFFSteps) )//' time steps of '//TRIM( Num2LStr(NTgrids) )//'x1 tower data grids.')


   RETURN

END SUBROUTINE Read_FF_Tower
!====================================================================================================
FUNCTION FF_GetRValue(RVarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the RVarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------

   CHARACTER(*),   INTENT(IN)    :: RVarName
   INTEGER,        INTENT(OUT)   :: ErrStat
   REAL(ReKi)                    :: FF_GetRValue

   
   CHARACTER(20)                 :: VarNameUC
   

   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FFWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = RVarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
   
      CASE ('HUBHEIGHT', 'REFHEIGHT' )
         FF_GetRValue = RefHt
         
      CASE ('GRIDWIDTH', 'FFYWID' )
         FF_GetRValue = FFYHWid*2

      CASE ('GRIDHEIGHT', 'FFZWID' )
         FF_GetRValue = FFZHWid*2
         
      CASE ('MEANFFWS' )
         FF_GetRValue = MeanFFWS         
         
      CASE DEFAULT
         CALL WrScr( ' Invalid variable name in FF_GetRValue().' )
         ErrStat = 1
         
   END SELECT

END FUNCTION FF_GetRValue
!====================================================================================================
FUNCTION FF_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are are 
! requested.  It determines if the point is on the FF grid or tower points and calls the
! corresponding interpolation routine, which returns the velocities at the specified time and space.
!----------------------------------------------------------------------------------------------------
   
   REAL(ReKi),        INTENT(IN) :: Time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)
   INTEGER,           INTENT(OUT):: ErrStat
   TYPE(InflIntrpOut)            :: FF_GetWindSpeed
   
   REAL(ReKi), PARAMETER         :: TOL = 1E-3
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   
   
   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FFWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      

   
   !-------------------------------------------------------------------------------------------------
   ! Find out if the location is on the grid on on tower points; interpolate and return the value.
   !-------------------------------------------------------------------------------------------------   

    FF_GetWindSpeed%Velocity = FF_Interp(Time,InputPosition, ErrStat)


!   IF ( InputPosition(3) >= GridBase - TOL ) THEN  
!   
!         ! Get the velocities interpolated on the FF grid
!      
!      FF_GetWindSpeed%Velocity = FF_Interp(Time,InputPosition, ErrStat)
!      
!   ELSE
!   
!         ! Get the velocities interpolated below the FF grid, on the tower points
!
!      IF ( NTgrids < 1 ) THEN
!      
!         CALL WrScr( ' Error: FF interpolation height is below the grid and no tower points have been defined.' )
!         ErrStat = 1
!         RETURN
!         
!      ELSE
!      
!         FF_GetWindSpeed%Velocity = FF_TowerInterp(Time,InputInfo%Position, ErrStat)
!         
!      END IF   ! NTgrids < 1
!      
!   
!   END IF      ! InputInfo%Position(3)>= GridBase


END FUNCTION FF_GetWindSpeed
!====================================================================================================
FUNCTION FF_Interp(Time, Position, ErrStat)
!    This function is used to interpolate into the full-field wind array or tower array if it has   
!    been defined and is necessary for the given inputs.  It receives X, Y, Z and
!    TIME from the calling routine.  It then computes a time shift due to a nonzero X based upon 
!    the average windspeed.  The modified time is used to decide which pair of time slices to interpolate
!    within and between.  After finding the two time slices, it decides which four grid points bound the 
!    (Y,Z) pair.  It does a bilinear interpolation for each time slice. Linear interpolation is then used 
!    to interpolate between time slices.  This routine assumes that X is downwind, Y is to the left when  
!    looking downwind and Z is up.  It also assumes that no extrapolation will be needed.
!    
!    If tower points are used, it assumes the velocity at the ground is 0.  It interpolates between
!    heights and between time slices, but ignores the Y input.
!
!    11/07/94 - Created by M. Buhl from the original TURBINT.
!    09/25/97 - Modified by M. Buhl to use f90 constructs and new variable names.  Renamed to FF_Interp.
!    09/23/09 - Modified by B. Jonkman to use arguments instead of modules to determine time and position.  
!               Height is now relative to the ground
!
!----------------------------------------------------------------------------------------------------

   IMPLICIT                      NONE

   REAL(ReKi),      INTENT(IN) :: Position(3)       ! takes the place of XGrnd, YGrnd, ZGrnd
   REAL(ReKi),      INTENT(IN) :: Time
   REAL(ReKi)                  :: FF_Interp(3)      ! The U, V, W velocities

   INTEGER,         INTENT(OUT):: ErrStat

      ! Local Variables:

   REAL(ReKi)                  :: TimeShifted
   REAL(ReKi),PARAMETER        :: Tol = 1.0E-3      ! a tolerance for determining if two reals are the same (for extrapolation)
   REAL(ReKi)                  :: W_YH_Z
   REAL(ReKi)                  :: W_YH_ZH
   REAL(ReKi)                  :: W_YH_ZL
   REAL(ReKi)                  :: W_YL_Z
   REAL(ReKi)                  :: W_YL_ZH
   REAL(ReKi)                  :: W_YL_ZL
   REAL(ReKi)                  :: Wnd      (2)
   REAL(ReKi)                  :: T
   REAL(ReKi)                  :: TGRID
   REAL(ReKi)                  :: Y
   REAL(ReKi)                  :: YGRID
   REAL(ReKi)                  :: Z
   REAL(ReKi)                  :: ZGRID

   INTEGER                    :: IDIM
   INTEGER                    :: IG
   INTEGER                    :: IT
   INTEGER                    :: ITHI
   INTEGER                    :: ITLO
   INTEGER                    :: IYHI
   INTEGER                    :: IYLO
   INTEGER                    :: IZHI
   INTEGER                    :: IZLO
   
   LOGICAL                    :: OnGrid
   
   !-------------------------------------------------------------------------------------------------
   ! Initialize variables
   !-------------------------------------------------------------------------------------------------

   FF_Interp(:)          = 0.0                         ! the output velocities (in case NFFComp /= 3)
   Wnd(:)                = 0.0                         ! just in case we're on an end point

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding time slices.
   !-------------------------------------------------------------------------------------------------

   ! Perform the time shift.  At time=0, a point half the grid width downstream (FFYHWid) will index into the zero time slice.  
   ! If we did not do this, any point downstream of the tower at the beginning of the run would index outside of the array.   
   ! This all assumes the grid width is at least as large as the rotor.  If it isn't, then the interpolation will not work.


   TimeShifted = TIME + ( InitXPosition - Position(1) )*InvMFFWS    ! in distance, X: InputInfo%Position(1) - InitXPosition - TIME*MeanFFWS
      

   IF ( Periodic ) THEN ! translate TimeShifted to ( 0 <= TimeShifted < TotalTime )

      TimeShifted = MODULO( TimeShifted, TotalTime )
   
      TGRID = TimeShifted*FFRate
      ITLO  = INT( TGRID )             ! convert REAL to INTEGER (add 1 later because our grids start at 1, not 0) 
      T     = TGRID - ITLO             ! a value between 0 and 1 that indicates a relative location between ITLO and ITHI   
      
      ITLO = ITLO + 1
      IF ( ITLO == NFFSteps ) THEN
         ITHI = 1
      ELSE
         ITHI = ITLO + 1
      END IF
      
      
   ELSE
   
      TGRID = TimeShifted*FFRate
      ITLO  = INT( TGRID )             ! convert REAL to INTEGER (add 1 later because our grids start at 1, not 0) 
      T     = TGRID - ITLO             ! a value between 0 and 1 that indicates a relative location between ITLO and ITHI   
   
      ITLO = ITLO + 1                  ! add one since our grids start at 1, not 0 
      ITHI = ITLO + 1   

      IF ( ITLO >= NFFSteps .OR. ITLO < 1 ) THEN
         IF ( ITLO == NFFSteps  ) THEN
            ITHI = ITLO   
            IF ( T <= TOL ) THEN ! we're on the last point
               T = 0.0
            ELSE  ! We'll extrapolate one dt past the last value in the file
               ITLO = ITHI - 1
            END IF         
         ELSE                 
            CALL WrScr( ' Error: FF wind array was exhausted at '//TRIM( Num2LStr( REAL( TIME,   ReKi ) ) )// & 
                           ' seconds (trying to access data at '//TRIM( Num2LStr( REAL( TimeShifted, ReKi ) ) )//' seconds).'  )
            ErrStat = 1   
            RETURN
         END IF
      ENDIF

   END IF


   !-------------------------------------------------------------------------------------------------
   ! Find the bounding rows for the Z position. [The lower-left corner is (1,1) when looking upwind.]
   !-------------------------------------------------------------------------------------------------

   ZGRID = ( Position(3) - GridBase )*InvFFZD

   IF (ZGRID > -1*TOL) THEN
      OnGrid = .TRUE.
      
      IZLO = INT( ZGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
      IZHI = IZLO + 1

      Z = ZGRID - ( IZLO - 1 )            ! a value between 0 and 1 that indicates a relative location between IZLO and IZHI

      IF ( IZLO < 1 ) THEN
         IF ( IZLO == 0 .AND. Z >= 1.0-TOL ) THEN
            Z    = 0.0 
            IZLO = 1
         ELSE
            CALL WrScr( ' Error: FF wind array boundaries violated. Grid too small in Z direction (Z='//&
                        TRIM(Num2LStr(Position(3)))//' m is below the grid).' )
            ErrStat = 1   
            RETURN
         END IF
      ELSEIF ( IZLO >= NZGrids ) THEN
         IF ( IZLO == NZGrids .AND. Z <= TOL ) THEN
            Z    = 0.0
            IZHI = IZLO                   ! We're right on the last point, which is still okay
         ELSE      
            CALL WrScr( ' Error: FF wind array boundaries violated. Grid too small in Z direction (Z='//&
                        TRIM(Num2LStr(Position(3)))//' m is above the grid).' )
            ErrStat = 3   
            RETURN
         END IF         
      ENDIF

   ELSE
   
      OnGrid = .FALSE.  ! this is on the tower
      
      IF ( NTGrids < 1 ) THEN
         CALL WrScr ( ' Error: FF wind array boundaries violated. Grid too small in Z direction '// &
                       '(height (Z='//TRIM(Num2LStr(Position(3)))//' m) is below the grid and no tower points are defined).' )
         ErrStat = 1
         RETURN
      END IF

      IZLO = INT( -1.0*ZGRID ) + 1            ! convert REAL to INTEGER, then add one since our grids start at 1, not 0      
      

      IF ( IZLO >= NTGrids ) THEN  !our dz is the difference between the bottom tower point and the ground
         IZLO = NTGrids
         
         Z    = 1.0 - Position(3) / (GridBase - (IZLO-1)/InvFFZD) !check that this isn't 0         
      ELSE
         Z    = ABS(ZGRID) - (IZLO - 1)
      END IF
      IZHI = IZLO + 1
            
   END IF


   IF ( OnGrid ) THEN      ! The tower points don't use this

      !-------------------------------------------------------------------------------------------------
      ! Find the bounding columns for the Y position. [The lower-left corner is (1,1) when looking upwind.]
      !-------------------------------------------------------------------------------------------------

         YGRID = ( Position(2) + FFYHWid )*InvFFYD    ! really, it's (Position(2) - -1.0*FFYHWid)

         IYLO = INT( YGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
         IYHI = IYLO + 1

         Y    = YGRID - ( IYLO - 1 )         ! a value between 0 and 1 that indicates a relative location between IYLO and IYHI
         
         IF ( IYLO >= NYGrids .OR. IYLO < 1 ) THEN
            IF ( IYLO == 0 .AND. Y >= 1.0-TOL ) THEN
               Y    = 0.0 
               IYLO = 1
            ELSE IF ( IYLO == NYGrids .AND. Y <= TOL ) THEN
               Y    = 0.0
               IYHI = IYLO                   ! We're right on the last point, which is still okay      
            ELSE
               CALL WrScr( ' Error FF wind array boundaries violated: Grid too small in Y direction. Y=' &
                             //TRIM(Num2LStr(Position(2)))//'; Y boundaries = ['//TRIM(Num2LStr(-1.0*FFYHWid)) &
                             //', '//TRIM(Num2LStr(FFYHWid))//']' )
               ErrStat = 2   
               RETURN
            END IF
         ENDIF

      !-------------------------------------------------------------------------------------------------
      ! Interpolate on the grid 
      !-------------------------------------------------------------------------------------------------

      DO IDIM=1,NFFComp       ! all the components

         IT = ITLO            ! Start using the ITLO slice
   
         DO IG=1,2            ! repeat for 2 time slices (by changing the value of IT. note that we can't loop from IXLO to IXHI because they could be NFFSteps and 1 respectively)

            !-------------------------------------------------------------------------------------------
            ! Get the wind velocity values for the four corners of the grid for this time.
            !-------------------------------------------------------------------------------------------

            W_YL_ZL = FFData( IZLO, IYLO, IDIM, IT )
            W_YL_ZH = FFData( IZHI, IYLO, IDIM, IT )
            W_YH_ZL = FFData( IZLO, IYHI, IDIM, IT )
            W_YH_ZH = FFData( IZHI, IYHI, IDIM, IT )


            !-------------------------------------------------------------------------------------------
            ! Interpolate within the grid for this time.
            !-------------------------------------------------------------------------------------------

            W_YL_Z  = ( W_YL_ZH - W_YL_ZL )*Z + W_YL_ZL
            W_YH_Z  = ( W_YH_ZH - W_YH_ZL )*Z + W_YH_ZL
            Wnd(IG) = ( W_YH_Z  - W_YL_Z  )*Y + W_YL_Z

            IT = ITHI            ! repeat for the using the ITHI slice

         END DO !IG

         !----------------------------------------------------------------------------------------------
         ! Interpolate between the two times.
         !----------------------------------------------------------------------------------------------
         
         FF_Interp(IDIM) = ( Wnd(2) - Wnd(1) ) * T + Wnd(1)    ! interpolated velocity
         
      END DO !IDIM

   ELSE
   
   !-------------------------------------------------------------------------------------------------
   ! Interpolate on the tower array
   !-------------------------------------------------------------------------------------------------
      
      DO IDIM=1,NFFComp    ! all the components

         IT = ITLO            ! Start using the ITLO slice

         DO IG=1,2            ! repeat for 2 time slices (by changing the value of IT. note that we can't loop from IXLO to IXHI because they could be NFFSteps and 1 respectively)

            !-------------------------------------------------------------------------------------------
            ! Get the wind velocity values for the two corners of the grid for this time.
            !-------------------------------------------------------------------------------------------

            W_YH_ZL = FFTower( IDIM, IZLO, IT )
            
            IF ( IZHI > NTGrids ) THEN
               W_YH_ZH = 0.0
            ELSE
               W_YH_ZH = FFTower( IDIM, IZHI, IT )
            END IF


            !-------------------------------------------------------------------------------------------
            ! Interpolate within the grid for this time.
            !-------------------------------------------------------------------------------------------

            Wnd(IG) = ( W_YH_ZH - W_YH_ZL )*Z + W_YH_ZL

            IT = ITHI            ! repeat for the using the ITHI slice

         END DO !IG

         !----------------------------------------------------------------------------------------------
         ! Interpolate between the two times.
         !----------------------------------------------------------------------------------------------
         
         FF_Interp(IDIM) = ( Wnd(2) - Wnd(1) ) * T + Wnd(1)    ! interpolated velocity
         
      END DO !IDIM
   
   END IF ! OnGrid

   RETURN
   
END FUNCTION FF_Interp
!====================================================================================================
SUBROUTINE FF_Terminate( ErrStat )
!  This subroutine cleans up any data that is still allocated.  The (possibly) open files are 
!  closed in InflowWindMod.
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   ErrStat = 0

   IF ( ALLOCATED( FFData  ) )   DEALLOCATE( FFData,  STAT=ErrStat )   
   IF ( ALLOCATED( FFTower ) )   DEALLOCATE( FFTower, STAT=ErrStat )   
   
   Initialized = .FALSE.


END SUBROUTINE FF_Terminate
!====================================================================================================
END MODULE FFWind

MODULE HAWCWind
!
!  This module uses full-field binary wind files to determine the wind inflow.
!  This module assumes that the origin, (0,0,0), is located at the tower centerline at ground level,
!  and that all units are specified in the metric system (using meters and seconds).
!  Data is assumed periodic in the X direction (and thus not shifted like FFWind files are).
!
!  Created 25-June-2010 by B. Jonkman, National Renewable Energy Laboratory
!     using subroutines and modules from AeroDyn v12.58
!
!----------------------------------------------------------------------------------------------------

   USE      NWTC_Library
   USE      SharedInflowDefs

   IMPLICIT NONE

   PRIVATE                                                        ! By default, everything in HAWCWind is private (methods, data, types, etc.)
   
      
   REAL(ReKi), ALLOCATABLE          :: WindData  (:,:,:,:)        ! Array of FF data for all 3 wind components

   REAL(ReKi)                       :: deltaXInv                  ! multiplicative inverse of delta X
   REAL(ReKi)                       :: deltaYInv                  ! multiplicative inverse of delta Y
   REAL(ReKi)                       :: deltaZInv                  ! multiplicative inverse of delta Z

   INTEGER, PARAMETER               :: NC = 3                     ! number of wind components
   INTEGER                          :: NX                         ! number of points in the X direction
   INTEGER                          :: NY                         ! number of points in the Y direction
   INTEGER                          :: NZ                         ! number of points in the Z direction

   REAL(ReKi)                       :: GridBase                   ! the height of the bottom of the grid (Z direction) in meters
   REAL(ReKi)                       :: LengthX                    ! the grid length in the X direction (distance between point 1 and the next point 1 [because it is periodic])
   REAL(ReKi)                       :: LengthYHalf                ! half the grid width
   REAL(ReKi)                       :: RefHt                      ! the reference (hub) height of the grid in meters 
   REAL(ReKi)                       :: URef                       ! the mean wind speed in m/s at height RefHt meters (as defined in the input file)

         
   LOGICAL, SAVE                    :: Initialized = .FALSE.      ! flag that determines if the module has been initialized


   PUBLIC                           :: HW_Init                    ! initialization subroutine to read the FF grids
   PUBLIC                           :: HW_GetWindSpeed            ! interpolation function that returns velocities at specified time and space
   PUBLIC                           :: HW_GetValue                ! interface to return requested values
   PUBLIC                           :: HW_Terminate               ! subroutine that deallocates memory stored in the FFWind module

CONTAINS
!====================================================================================================
SUBROUTINE HW_Init ( UnWind, InpFileName, ErrStat )
!  This routine is used read the full-field turbulence data stored in HAWC format.
!----------------------------------------------------------------------------------------------------

   IMPLICIT                       NONE


      ! Passed Variables:
      
   INTEGER,      INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered
   
   CHARACTER(*), INTENT(IN)    :: InpFileName                  ! Name of the input text file

      ! Local Variables:

   REAL(SiKi)                  :: DumReal                      ! real variable to temporarially store values read from binary file

   REAL(ReKi)                  :: dx
   REAL(ReKi)                  :: dy
   REAL(ReKi)                  :: dz
   REAL(ReKi)                  :: PLExp                        ! Power law exponent, for the PL mean wind profile type
   REAL(ReKi)                  :: U                            ! The mean wind speed
   REAL(ReKi)                  :: Z                            ! The height above ground/sea level
   REAL(ReKi)                  :: Z0                           ! Surface layer roughness length in meters, used for LOG profile type
    
  
   INTEGER                     :: IC                           ! Loop counter for the number of wind components
   INTEGER                     :: IX                           ! Loop counter for the number of grid points in the X direction
   INTEGER                     :: IY                           ! Loop counter for the number of grid points in the Y direction
   INTEGER                     :: IZ                           ! Loop counter for the number of grid points in the Z direction

   CHARACTER( 1024 )           :: DataFiles ( 3 )              ! Names of the files containing the 3 wind components   
   CHARACTER(3)                :: WindProfileType              ! character code of mean wind profile type


   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' HAWCWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF   

! bjj: this (reading the file) should perhaps be in a subroutine...

   !-------------------------------------------------------------------------------------------------
   ! Open the text file 
   !-------------------------------------------------------------------------------------------------

   CALL OpenFInpFile ( UnWind, TRIM(InpFileName), ErrStat )
   IF (ErrStat /= 0) RETURN

   
   !-------------------------------------------------------------------------------------------------
   ! Read some header information in the text file 
   !-------------------------------------------------------------------------------------------------
   
   CALL ReadCom( UnWind, InpFileName, 'Header 1', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Header 2', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Header 3', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Header 4', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Parameters for HAWC-format binary files', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   
   !-------------------------------------------------------------------------------------------------
   ! Read file names and scaling info from the file
   !-------------------------------------------------------------------------------------------------

   CALL ReadVar( UnWind, InpFileName, DataFiles(1), 'FileName_u', 'Name of the u-component binary file', ErrStat )
   IF (ErrStat /= 0) RETURN

   CALL ReadVar( UnWind, InpFileName, DataFiles(2), 'FileName_v', 'Name of the v-component binary file', ErrStat )
   IF (ErrStat /= 0) RETURN

   CALL ReadVar( UnWind, InpFileName, DataFiles(3), 'FileName_w', 'Name of the w-component binary file', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, InpFileName, NX, 'nx', 'Number of grid points in the X direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( NX < 1 ) THEN
      CALL WrScr ( ' HAWCWind error reading "nx": number of grid points in the X direction must be at least 1.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, NY, 'ny', 'Number of grid points in the Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( NY < 1 ) THEN
      CALL WrScr ( ' HAWCWind error reading "ny": number of grid points in the Y direction must be at least 1.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, NZ, 'nz', 'Number of grid points in the Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( NZ < 1 ) THEN
      CALL WrScr ( ' HAWCWind error reading "nz": number of grid points in the Z direction must be at least 1.')
      ErrStat = 1
      RETURN
   END IF
   

   CALL ReadVar( UnWind, InpFileName, dx, 'dx', 'Distance between two points in the X direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( DX < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "dx": the grid spacing in the X direction must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, dy, 'dy', 'Distance between two points in the Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( DY < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "dy": the grid spacing in the Y direction must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, dz, 'dz', 'Distance between two points in the Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( DZ < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "dz": the grid spacing in the Z direction must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, RefHt, 'RefHt', 'Grid reference height', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( RefHt < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "RefHt": the grid reference height must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF

 
   !-------------------------------------------------------------------------------------------------
   ! Read the section to determine the mean wind profile
   !-------------------------------------------------------------------------------------------------
 
   CALL ReadCom( UnWind, InpFileName, 'mean wind profile parameters (added to HAWC-format files)', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, InpFileName, WindProfileType, 'WindProfileType', 'Wind profile type', ErrStat )
   IF (ErrStat /= 0) RETURN

    
   CALL ReadVar( UnWind, InpFileName, URef, 'URef', 'Reference wind speed', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( URef < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error: the reference wind speed, URef, must not be negative.' )
      ErrStat = 1
      RETURN   
   END IF

    
   CALL ReadVar( UnWind, InpFileName, PLExp, 'PLExp', 'Power law exponent', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, InpFileName, Z0, 'Z0', 'Surface roughness length', ErrStat )   
   IF (ErrStat /= 0) RETURN  
   
   IF ( Z0 <= EPSILON(Z0) ) THEN
      CALL WrScr ( ' HAWCWind error: the surface roughness length, Z0, must be greater than zero.' )
      ErrStat = 1
      RETURN   
   END IF
   
   !-------------------------------------------------------------------------------------------------
   ! Close the file.
   !-------------------------------------------------------------------------------------------------

   CLOSE ( UnWind )


   !-------------------------------------------------------------------------------------------------
   ! Set some internal module parameters based on input file values
   !-------------------------------------------------------------------------------------------------

   LengthX     = dx*nx !(nx-1)   !because the turbulence box is periodic in the X direction, we need to consider the length between point 1 and the next point 1 (instead of between points 1 and nx)
   LengthYHalf = 0.5*dy*(ny-1)
   GridBase    = RefHt - 0.5*(nz-1)*dz

   IF ( GridBase <= 0.0 ) THEN
      CALL WrScr( ' HAWCWind error: the bottom of the grid is located at a height of '//&
                      TRIM( Num2LStr(GridBase) )//' meters, which is below the ground.' )
      ErrStat = 1
      RETURN
   END IF 


   deltaXInv   = 1.0 / dx
   deltaYInv   = 1.0 / dy
   deltaZInv   = 1.0 / dz
   
   
   !-------------------------------------------------------------------------------------------------
   ! Allocate space for the wind arrays.
   !-------------------------------------------------------------------------------------------------

   IF (.NOT. ALLOCATED(WindData) ) THEN
      ALLOCATE( WindData( NZ, NY, NX, NC ), STAT=ErrStat )
      IF ( ErrStat /= 0 ) THEN
         CALL WrScr ( " Error allocating space for HAWCWind's WindData array." )
         RETURN
      END IF
   END IF
      

   !-------------------------------------------------------------------------------------------------
   ! Read the 3 files containg the turbulent wind speeds.
   !-------------------------------------------------------------------------------------------------
!bjj: check these indices... they do not seem to be very consistant between the WAsP IEC Turbulence
!     simulator and documentation of OC3 file formats... the current implementation is from the 
!     OC3/Kenneth Thompson documentation.

      ! The array must be filled so that x(i) < x(i+1), y(i) < y(i+1), and z(i) < z(i+1)
      ! Also, note that the time axis is the negative x axis.

   DO IC = 1,NC
   
      CALL OpenBInpFile ( UnWind, DataFiles(IC), ErrStat )
   
      DO IX = NX,1,-1                  ! Time is the opposite of X ....
         DO IY = NY,1,-1
            DO IZ = 1,NZ 
            
               READ( UnWind, IOSTAT=ErrStat ) DumReal
               
               WindData( IZ, IY, IX, IC ) = DumReal    ! possible type conversion here
               
               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading binary data from "'//TRIM(DataFiles(IC))//'".' )
                  CALL WrScr( ' I/O error '//TRIM(Num2LStr(ErrStat))//' occurred at IZ='//TRIM(Num2LStr(IZ))//&
                                                   ', IY='//TRIM(Num2LStr(IY))//', IX='//TRIM(Num2LStr(IX))//'.' )
                  CLOSE ( UnWind )
                  RETURN
               END IF
                              
            END DO
         END DO
      END DO
      
      CLOSE ( UnWind )
      
   END DO

   
   !-------------------------------------------------------------------------------------------------
   ! Add the mean wind speed to the u component.
   !-------------------------------------------------------------------------------------------------

   CALL Conv2UC( WindProfileType )
                 
   
   IF ( RefHt > 0.0 ) THEN
   
      DO IZ = 1,NZ

         Z = GridBase  + ( IZ - 1 )*dz
         
         SELECT CASE ( TRIM(WindProfileType) )
   
            CASE ( 'PL' )         
               U = URef*( Z / RefHt )**PLExp      ! [IEC 61400-1 6.3.1.2 (10)]
      
            CASE ( 'LOG' )
            
               IF ( Z /= Z0 ) THEN
                  U = URef*( LOG( Z / Z0 ) )/( LOG( RefHt / Z0 ) )
               ELSE
                  U = 0.0
               ENDIF
            
            CASE DEFAULT
            
               CALL WrScr( ' Invalid wind profile type in HAWCWind.' )
               ErrStat = 1
               RETURN
      
         END SELECT
   
         WindData( IZ, :, :, 1 ) = WindData( IZ, :, :, 1 ) + U
            

      END DO ! IZ
   END IF ! RefHt
   
   
   !-------------------------------------------------------------------------------------------------
   ! Set initialized flag and return
   !-------------------------------------------------------------------------------------------------
   
   Initialized = .TRUE.

   RETURN
   
END SUBROUTINE HW_Init
!====================================================================================================
FUNCTION HW_GetValue(RVarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the RVarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------

   CHARACTER(*),   INTENT(IN)    :: RVarName
   INTEGER,        INTENT(OUT)   :: ErrStat
   REAL(ReKi)                    :: HW_GetValue

   
   CHARACTER(20)                 :: VarNameUC
   

   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the HAWCWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = RVarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
   
      CASE ( 'REFHEIGHT' )
         HW_GetValue = RefHt
         
      CASE ('GRIDWIDTH' )
         HW_GetValue = LengthYHalf*2

      CASE ('GRIDHEIGHT' )
         HW_GetValue = NZ/deltaZInv
         
      CASE ('UREF' )
         HW_GetValue = URef        
         
      CASE DEFAULT
         CALL WrScr( ' HAWCWind error: invalid variable name in HW_GetRValue().' )
         ErrStat = 1
         
   END SELECT

END FUNCTION HW_GetValue
!!====================================================================================================
FUNCTION HW_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are are 
! requested.  It determines if the point is on the FF grid or tower points and calls the
! corresponding interpolation routine, which returns the velocities at the specified time and space.
!----------------------------------------------------------------------------------------------------
   
   REAL(ReKi),        INTENT(IN) :: Time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)
   INTEGER,           INTENT(OUT):: ErrStat
   TYPE(InflIntrpOut)            :: HW_GetWindSpeed
     
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   
   
   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FFWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      

   
   !-------------------------------------------------------------------------------------------------
   ! interpolate and return the value.
   !-------------------------------------------------------------------------------------------------   

    HW_GetWindSpeed%Velocity = HW_LinearInterp(Time,InputPosition, ErrStat)


END FUNCTION HW_GetWindSpeed
!====================================================================================================
FUNCTION HW_LinearInterp(Time, Position, ErrStat)
!    This function is used to interpolate into the full-field wind array for the given inputs. It receives 
!    X, Y, Z and TIME from the calling routine.  It then computes a time shift in the X axis based upon 
!    the average windspeed.  The modified position is used to decide which pair of X grids to interpolate
!    within and between.  After finding the two X slices, it decides which four grid points bound the 
!    (Y,Z) pair.  It does a bilinear interpolation for each X slice. Linear interpolation is then used 
!    to interpolate between the X slices.  This routine assumes that X is downwind, Y is to the left when  
!    looking downwind and Z is up.  It also assumes that no extrapolation will be needed.
!    
!    If tower points are used, it assumes the velocity at the ground is 0.  It interpolates between
!    heights and between time slices, but ignores the Y input.
!
!    09/23/09 - Modified by B. Jonkman to use arguments instead of modules to determine time and position.  
!               Height is now relative to the ground
!
!----------------------------------------------------------------------------------------------------

   IMPLICIT                      NONE

   REAL(ReKi),      INTENT(IN) :: Position(3)       ! takes the place of XGrnd, YGrnd, ZGrnd
   REAL(ReKi),      INTENT(IN) :: Time
   REAL(ReKi)                  :: HW_LinearInterp(3)      ! The U, V, W velocities

   INTEGER,         INTENT(OUT):: ErrStat

      ! Local Variables:

   REAL(ReKi)                  :: ShiftedXPosition
   REAL(ReKi),PARAMETER        :: Tol = 1.0E-3      ! a tolerance for determining if two reals are the same (for extrapolation)
   REAL(ReKi)                  :: W_YH_Z
   REAL(ReKi)                  :: W_YH_ZH
   REAL(ReKi)                  :: W_YH_ZL
   REAL(ReKi)                  :: W_YL_Z
   REAL(ReKi)                  :: W_YL_ZH
   REAL(ReKi)                  :: W_YL_ZL
   REAL(ReKi)                  :: Wnd      (2)
   REAL(ReKi)                  :: X                 ! a value between 0 and 1 that indicates a relative location between IXLO and IXHI
   REAL(ReKi)                  :: XGRID             ! the position in the X direction relative to the first grid point
   REAL(ReKi)                  :: Y                 ! a value between 0 and 1 that indicates a relative location between IYLO and IYHI
   REAL(ReKi)                  :: YGRID             ! the position in the Y direction relative to the first grid point
   REAL(ReKi)                  :: Z                 ! a value between 0 and 1 that indicates a relative location between IZLO and IZHI
   REAL(ReKi)                  :: ZGRID             ! the position in the Z direction relative to the first grid point             

   INTEGER                     :: IC                ! loop counter for number of grid points
   INTEGER                     :: IG                ! loop counter for X grids
   INTEGER                     :: IX                ! variable to store IXLO and IXHI while looping
   INTEGER                     :: IXHI              ! high index into the array in the X dimension
   INTEGER                     :: IXLO              ! low  index into the array in the X dimension
   INTEGER                     :: IYHI              ! high index into the array in the Y dimension
   INTEGER                     :: IYLO              ! low  index into the array in the Y dimension
   INTEGER                     :: IZHI              ! high index into the array in the Z dimension
   INTEGER                     :: IZLO              ! low  index into the array in the Z dimension
   
   
   !-------------------------------------------------------------------------------------------------
   ! Initialize variables
   !-------------------------------------------------------------------------------------------------

   HW_LinearInterp(:)    = 0.0                         ! the output velocities (in case NFFComp /= 3)
   Wnd(:)                = 0.0                         ! just in case we're on an end point

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding X slices.
   !-------------------------------------------------------------------------------------------------

! bjj: should we shift by MIN(YHalfWid,FFZHWid)?
         
         ! Assume Taylor's Frozen Turbulence Hypothesis applies: u(X,Y,Z,t) = u( X-U*t, Y, Z, 0)

   ShiftedXPosition = Position(1) - TIME*URef      !this puts the first X grid point at the undeflected tower centerline

   
      ! The wind file is periodic so we'll translate this position to ( 0 <= ShiftedXPosition < LengthX )
   
   ShiftedXPosition = MODULO( ShiftedXPosition, LengthX )
    
   XGrid            = ShiftedXPosition*deltaXInv
   
   IXLO = INT( XGrid ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
   
   IF ( IXLO == NX ) THEN
      IXHI = 1
   ELSE
      IXHI = IXLO + 1
      
! BJJ: assuming LengthX and NX have been correctly defined, this cannot happen:      
!      IF ( IXLO > NX .OR. IXLO < 1 ) THEN
!            CALL WrScr( ' HAWCWind error: wind array was exhausted at '//TRIM( Num2LStr( REAL( TIME,   ReKi ) ) )//' seconds '//& 
!                        '(trying to access X data at '//TRIM( Num2LStr( REAL( ShiftedXPosition, ReKi ) ) )//' m).'  )
!            ErrStat = 1   
!            RETURN
!      ENDIF
      
   END IF
   
   X = XGrid - ( IXLO - 1 )         ! a value between 0 and 1 that indicates a relative location between IXLO and IXHI

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding rows for the Z position. [The lower-left corner is (1,1) when looking upwind.]
   !-------------------------------------------------------------------------------------------------

   ZGRID = ( Position(3) - GridBase )*deltaZInv

     
   IZLO = INT( ZGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
   IZHI = IZLO + 1

   Z = ZGRID - ( IZLO - 1 )            ! a value between 0 and 1 that indicates a relative location between IZLO and IZHI

   IF ( IZLO < 1 ) THEN
      IF ( IZLO == 0 .AND. Z >= 1.0-TOL ) THEN
         Z    = 0.0 
         IZLO = 1
      ELSE
         CALL WrScr( ' HAWCWind error: wind array boundaries violated. Grid too small in Z direction (Z='//&
                     TRIM(Num2LStr(Position(3)))//' m is below the grid).' )
         ErrStat = 1   
         RETURN
      END IF
   ELSEIF ( IZLO >= NZ ) THEN
      IF ( IZLO == NZ .AND. Z <= TOL ) THEN
         Z    = 0.0
         IZHI = IZLO                   ! We're right on the last point, which is still okay
      ELSE      
         CALL WrScr( ' HAWCWind error: wind array boundaries violated. Grid too small in Z direction (Z='//&
                     TRIM(Num2LStr(Position(3)))//' m is above the grid).' )
         ErrStat = 3   
         RETURN
      END IF         
   ENDIF
   

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding columns for the Y position. [The lower-left corner is (1,1) when looking upwind.]
   !-------------------------------------------------------------------------------------------------

   YGRID = ( Position(2) + LengthYHalf )*deltaYInv    ! really, it's (Position(2) - -1.0*YHalfWid)

   IYLO = INT( YGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
   IYHI = IYLO + 1

   Y    = YGRID - ( IYLO - 1 )         ! a value between 0 and 1 that indicates a relative location between IYLO and IYHI
   
   IF ( IYLO >= NY .OR. IYLO < 1 ) THEN
      IF ( IYLO == 0 .AND. Y >= 1.0-TOL ) THEN
         Y    = 0.0 
         IYLO = 1
      ELSE IF ( IYLO == NY .AND. Y <= TOL ) THEN
         Y    = 0.0
         IYHI = IYLO                   ! We're right on the last point, which is still okay      
      ELSE
         CALL WrScr( ' HAWCWind error: wind array boundaries violated: Grid too small in Y direction. Y=' &
                        //TRIM(Num2LStr(Position(2)))//'; Y boundaries = ['//TRIM(Num2LStr(-1.0*LengthYHalf)) &
                        //', '//TRIM(Num2LStr(LengthYHalf))//']' )
         ErrStat = 2   
         RETURN
      END IF
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Interpolate on the Y-Z grid for each X (time) slice
   !-------------------------------------------------------------------------------------------------

   DO IC=1,NC            ! all the components

      IX = IXLO          ! start using the first time (X) slice

      DO IG = 1,2        ! repeat for 2 time slices (by changing the value of IX. note that we can't loop from IXLO to IXHI because they could be NX and 1 respectively)

         !-------------------------------------------------------------------------------------------
         ! Get the wind velocity values for the four corners of the grid for this time.
         !-------------------------------------------------------------------------------------------

         W_YL_ZL = WindData( IZLO, IYLO, IX, IC )
         W_YL_ZH = WindData( IZHI, IYLO, IX, IC )
         W_YH_ZL = WindData( IZLO, IYHI, IX, IC )
         W_YH_ZH = WindData( IZHI, IYHI, IX, IC )


         !-------------------------------------------------------------------------------------------
         ! Interpolate within the grid for this time.
         !-------------------------------------------------------------------------------------------

         W_YL_Z  = ( W_YL_ZH - W_YL_ZL )*Z + W_YL_ZL
         W_YH_Z  = ( W_YH_ZH - W_YH_ZL )*Z + W_YH_ZL
         Wnd(IG) = ( W_YH_Z  - W_YL_Z  )*Y + W_YL_Z

         IX = IXHI  ! repeat for the second time (X) slice

      END DO !IX

      !----------------------------------------------------------------------------------------------
      ! Interpolate between the two times.
      !----------------------------------------------------------------------------------------------
      
      HW_LinearInterp( IC ) = ( Wnd(2) - Wnd(1) ) * X + Wnd(1)    ! interpolated velocity
      
   END DO !IDIM


   RETURN
   
END FUNCTION HW_LinearInterp
!====================================================================================================
SUBROUTINE HW_Terminate( ErrStat )
!  This subroutine cleans up any data that is still allocated.  The (possibly) open files are 
!  closed in InflowWindMod.
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   ErrStat = 0

   IF ( ALLOCATED( WindData  ) )   DEALLOCATE( WindData,  STAT=ErrStat )   
   
   Initialized = .FALSE.


END SUBROUTINE HW_Terminate
!====================================================================================================
END MODULE HAWCWind
MODULE HHWind
! This module contains all the data and procedures that define hub-height wind files. This could 
! more accurately be called a point wind file since the wind speed at any point is calculated by 
! shear applied to the point where wind is defined.  It is basically uniform wind over the rotor disk.
! The entire file is read on initialization, then the columns that make up the wind file are
! interpolated to the time requested, and wind is calculated based on the location in space.
!
! the file contains header information (rows that contain "!"), followed by numeric data stored in
! 8 columns:   (1) Time                                  [s]
!              (2) Horizontal wind speed       (V)       [m/s]
!              (3) Wind direction              (Delta)   [deg]
!              (4) Vertical wind speed         (VZ)      [m/s]
!              (5) Horizontal linear shear     (HLinShr) [-]
!              (6) Vertical power-law shear    (VShr)    [-]
!              (7) Vertical linear shear       (VLinShr) [-]
!              (8) Gust (horizontal) velocity  (VGust)   [m/s]
!
! The horizontal wind speed at (X, Y, Z) is then calculated using the interpolated columns by
!   Vh = V * ( Z/RefHt ) ** VShr                                        ! power-law wind shear
!      + V * HLinShr/RefWid * ( Y * COS(Delta) + X * SIN(Delta) )       ! horizontal linear shear
!      + V * VLinShr/RefWid * ( Z-RefHt )                               ! vertical linear shear
!      + VGust                                                          ! gust speed
!----------------------------------------------------------------------------------------------------

   USE                     NWTC_Library
   USE                     SharedInflowDefs
   
   IMPLICIT                NONE
   PRIVATE

      
   REAL(ReKi), ALLOCATABLE      :: Tdata  (:)                              ! Time array from the HH wind file
   REAL(ReKi), ALLOCATABLE      :: DELTA  (:)                              ! HH Wind direction (angle)
   REAL(ReKi), ALLOCATABLE      :: V      (:)                              ! HH horizontal wind speed
   REAL(ReKi), ALLOCATABLE      :: VZ     (:)                              ! wind, including tower shadow, along the Z axis
   REAL(ReKi), ALLOCATABLE      :: HSHR   (:)                              ! HH Horizontal linear shear
   REAL(ReKi), ALLOCATABLE      :: VSHR   (:)                              ! HH vertical shear exponent
   REAL(ReKi), ALLOCATABLE      :: VLINSHR(:)                              ! HH vertical linear shear
   REAL(ReKi), ALLOCATABLE      :: VGUST  (:)                              ! HH wind gust

   REAL(ReKi)                   :: LinearizeDels(7)                        ! The delta values for linearization -- perhaps at some point, this could be T/F and we determine the deltas by sqrt(eps) or something similar
   REAL(ReKi)                   :: RefHt                                   ! reference height; was HH (hub height); used to center the wind
   REAL(ReKi)                   :: RefWid                                  ! reference width; was 2*R (=rotor diameter); used to scale the linear shear
   
   INTEGER                      :: NumDataLines
   INTEGER, SAVE                :: TimeIndx = 0                            ! An index into the Tdata array (to allow us faster searching, starting search from previous one)

   LOGICAL, SAVE                :: Linearize = .FALSE.                     ! If this is TRUE, we are linearizing
   
   TYPE, PUBLIC                 :: HH_Info
      REAL(ReKi)                :: ReferenceHeight
      REAL(ReKi)                :: Width
   END TYPE HH_Info
      
   PUBLIC                       :: HH_Init
   PUBLIC                       :: HH_GetWindSpeed
   PUBLIC                       :: HH_Terminate
   PUBLIC                       :: HH_SetLinearizeDels
   PUBLIC                       :: HH_Get_ADhack_WindSpeed                  ! REMOVE THIS!!!!

CONTAINS
!====================================================================================================
SUBROUTINE HH_Init(UnWind, WindFile, WindInfo, ErrStat)
! A subroutine to initialize the HHWind module.  It reads the HH file and stores the data in an
! array to use later.  It requires an initial reference height (hub height) and width (rotor diameter),
! both in meters, which are used to define the volume where wind velocities will be calculated.  This
! information is necessary because of the way the shears are defined.
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,      INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered
   TYPE(HH_Info),INTENT(IN)    :: WindInfo                     ! Additional information needed to initialize this wind type
   
   CHARACTER(*), INTENT(IN)    :: WindFile                     ! Name of the text HH wind file

      ! local variables
            
   INTEGER, PARAMETER          :: NumCols = 8                  ! Number of columns in the HH file
   REAL(ReKi)                  :: TmpData(NumCols)             ! Temp variable for reading all columns from a line 
   REAL(ReKi)                  :: DelDiff                      ! Temp variable for storing the direction difference

   INTEGER                     :: I
   INTEGER                     :: NumComments
   INTEGER                     :: ILine                        ! Counts the line number in the file
   INTEGER, PARAMETER          :: MaxTries = 100
   CHARACTER(1024)             :: Line                         ! Temp variable for reading whole line from file

    
   !-------------------------------------------------------------------------------------------------
   ! Check that it's not already initialized
   !-------------------------------------------------------------------------------------------------
      
   IF ( TimeIndx /= 0 ) THEN  
      CALL WrScr( ' HHWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
      
      LinearizeDels(:) = 0.0
      Linearize        = .FALSE.
   END IF   

  
   !-------------------------------------------------------------------------------------------------
   ! Open the file for reading
   !-------------------------------------------------------------------------------------------------
   CALL OpenFInpFile (UnWind, TRIM(WindFile), ErrStat)
   
   IF ( ErrStat /= 0 ) RETURN

   !-------------------------------------------------------------------------------------------------
   ! Find the number of comment lines
   !-------------------------------------------------------------------------------------------------
   LINE = '!'                          ! Initialize the line for the DO WHILE LOOP
   NumComments = -1
   
   DO WHILE (INDEX( LINE, '!' ) > 0 ) ! Lines containing "!" are treated as comment lines
      NumComments = NumComments + 1
      
      READ(UnWind,'( A )',IOSTAT=ErrStat) LINE
            
      IF ( ErrStat /=0 ) THEN
         CALL WrScr ( ' Error reading from HH wind file on line '//TRIM(Num2LStr(NumComments))//'.' )
         RETURN
      END IF
      
   END DO !WHILE
   
   !-------------------------------------------------------------------------------------------------
   ! Find the number of data lines
   !-------------------------------------------------------------------------------------------------
   NumDataLines = 0
   
   READ(LINE,*,IOSTAT=ErrStat) ( TmpData(I), I=1,NumCols )

   DO WHILE (ErrStat == 0)  ! read the rest of the file (until an error occurs)
      NumDataLines = NumDataLines + 1               
      
      READ(UnWind,*,IOSTAT=ErrStat) ( TmpData(I), I=1,NumCols )

   END DO !WHILE


   IF (NumDataLines < 1) THEN
      CALL WrScr ( ' Error reading data from HH wind file on line '//TRIM(Num2LStr(NumDataLines+NumComments))//'.' )
      RETURN
   ELSE
      CALL WrScr ( ' Reading '//TRIM(Num2LStr(NumDataLines))//' lines of data from the HH wind file.' )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Allocate arrays for the HH data
   !-------------------------------------------------------------------------------------------------
   ! BJJ note: If the subroutine AllocAry() is called, the CVF compiler with A2AD does not work
   !   properly.  The arrays are not properly read even though they've been allocated.
   !-------------------------------------------------------------------------------------------------
   
   IF (.NOT. ALLOCATED(Tdata) ) THEN
      ALLOCATE ( Tdata(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH time array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(V) ) THEN
      ALLOCATE ( V(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH horizontal wind speed array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(Delta) ) THEN
      ALLOCATE ( Delta(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH wind direction array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VZ) ) THEN
      ALLOCATE ( VZ(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH vertical wind speed array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(HShr) ) THEN
      ALLOCATE ( HShr(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH horizontal linear shear array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VShr) ) THEN
      ALLOCATE ( VShr(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH vertical power-law shear exponent array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VLinShr) ) THEN
      ALLOCATE ( VLinShr(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH vertical linear shear array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VGust) ) THEN
      ALLOCATE ( VGust(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH gust velocity array.' )
         RETURN
      END IF   
   END IF
   

   !-------------------------------------------------------------------------------------------------
   ! Rewind the file (to the beginning) and skip the comment lines
   !-------------------------------------------------------------------------------------------------
   REWIND( UnWind )
   
   DO I=1,NumComments
      CALL ReadCom( UnWind, TRIM(WindFile), 'Header line #'//TRIM(Num2LStr(I)), ErrStat )
      IF ( ErrStat /= 0 ) RETURN
   END DO !I


   !-------------------------------------------------------------------------------------------------
   ! Read the data arrays
   !-------------------------------------------------------------------------------------------------

   DO I=1,NumDataLines
         
      CALL ReadAry( UnWind, TRIM(WindFile), TmpData(1:NumCols), NumCols, 'TmpData', & 
                'Data from HH line '//TRIM(Num2LStr(NumComments+I)), ErrStat )
      IF (ErrStat /= 0) RETURN
                 
      Tdata(  I) = TmpData(1)
      V(      I) = TmpData(2)
      Delta(  I) = TmpData(3)*D2R 
      VZ(     I) = TmpData(4)
      HShr(   I) = TmpData(5)
      VShr(   I) = TmpData(6)
      VLinSHR(I) = TmpData(7)
      VGust(  I) = TmpData(8)           
      
   END DO !I


   !-------------------------------------------------------------------------------------------------
   ! Make sure the wind direction isn't jumping more than 180 degrees between any 2 consecutive
   ! input times.  (Avoids interpolation errors with modular arithemetic.)
   !-------------------------------------------------------------------------------------------------

   DO I=2,NumDataLines
   
      ILine = 1
      
      DO WHILE ( ILine < MaxTries )
     
         DelDiff = ( Delta(I) - Delta(I-1) )

         IF ( ABS( DelDiff ) < Pi ) EXIT  ! exit inner loop

         Delta(I) = Delta(I) - SIGN( TwoPi, DelDiff )
         
         ILine = ILine + 1

      END DO
      
      IF ( ILine >= MaxTries ) THEN
         CALL WrScr( ' Error calculating wind direction from HH file. Delta(' &
               // TRIM(Num2LStr(I  )) // ') = ' // TRIM(Num2LStr(Delta(I))) // '; Delta(' & 
               // TRIM(Num2LStr(I+1)) // ') = ' // TRIM(Num2LStr(Delta(I+1))) )
         ErrStat = 1
      END IF
           

   END DO !I


   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
   
   CLOSE( UnWind )
   

   !-------------------------------------------------------------------------------------------------
   ! Print warnings and messages
   !-------------------------------------------------------------------------------------------------
!   CALL WrScr ( ' Processed '//TRIM( Num2LStr( NumDataLines ) )//' records of HH data' )
   
   
   IF ( Tdata(1) > 0.0 ) THEN
      CALL ProgWarn( 'The hub-height wind file : "'//TRIM(ADJUSTL(WindFile))//'" starts at a time '// & 
                     'greater than zero. Interpolation errors may result.')
   ENDIF
   
   IF ( NumDataLines == 1 ) THEN
      CALL WrScr( ' Only 1 line in HH wind file. Steady, hub-height horizontal wind speed = '//TRIM(Num2LStr(V(1)))//' m/s.' )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Set the initial index into the time array (it indicates that we've initialized the module, too)
   ! and initialize the spatial scaling for the wind calculations
   !-------------------------------------------------------------------------------------------------
   TimeIndx = 1            

   RefHt  = WindInfo%ReferenceHeight
   RefWid = WindInfo%Width   


   RETURN
     
END SUBROUTINE HH_Init
!====================================================================================================
FUNCTION HH_GetWindSpeed(Time, InputPosition, ErrStat)
! This subroutine linearly interpolates the columns in the HH input file to get the values for 
! the requested time, then uses the interpolated values to calclate the wind speed at a point
! in space represented by InputPosition.
!----------------------------------------------------------------------------------------------------

   REAL(ReKi),        INTENT(IN) :: Time                 ! time from the start of the simulation
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)     ! input information: positions X,Y,Z
   INTEGER,           INTENT(OUT):: ErrStat              ! error status
   TYPE(InflIntrpOut)            :: HH_GetWindSpeed      ! return velocities (U,V,W)
   
   REAL(ReKi)                    :: CosDelta             ! cosine of Delta_tmp
   REAL(ReKi)                    :: Delta_tmp            ! interpolated Delta   at input TIME
   REAL(ReKi)                    :: HShr_tmp             ! interpolated HShr    at input TIME
   REAL(ReKi)                    :: P                    ! temporary storage for slope (in time) used in linear interpolation
   REAL(ReKi)                    :: SinDelta             ! sine of Delta_tmp
   REAL(ReKi)                    :: V_tmp                ! interpolated V       at input TIME
   REAL(ReKi)                    :: VGust_tmp            ! interpolated VGust   at input TIME
   REAL(ReKi)                    :: VLinShr_tmp          ! interpolated VLinShr at input TIME
   REAL(ReKi)                    :: VShr_tmp             ! interpolated VShr    at input TIME
   REAL(ReKi)                    :: VZ_tmp               ! interpolated VZ      at input TIME
   REAL(ReKi)                    :: V1                   ! temporary storage for horizontal velocity
   

   !-------------------------------------------------------------------------------------------------
   ! verify the module was initialized first
   !-------------------------------------------------------------------------------------------------

   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Error: Call HH_Init() before getting wind speed.')
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
      
   !-------------------------------------------------------------------------------------------------
   ! Linearly interpolate in time (or used nearest-neighbor to extrapolate) 
   ! (compare with NWTC_Num.f90\InterpStpReal)
   !-------------------------------------------------------------------------------------------------

    IF ( Linearize ) THEN  !get the perturbed wind speed

      TimeIndx      = 1
      V_tmp         = V      (1) + LinearizeDels(1)
      Delta_tmp     = Delta  (1) + LinearizeDels(2)
      VZ_tmp        = VZ     (1) + LinearizeDels(3)
      HShr_tmp      = HShr   (1) + LinearizeDels(4)
      VShr_tmp      = VShr   (1) + LinearizeDels(5)
      VLinShr_tmp   = VLinShr(1) + LinearizeDels(6)
      VGust_tmp     = VGust  (1) + LinearizeDels(7)

      ! Let's check the limits.
   ELSE IF ( Time <= Tdata(1) .OR. NumDataLines == 1 )  THEN
   
      TimeIndx      = 1
      V_tmp         = V      (1)
      Delta_tmp     = Delta  (1)
      VZ_tmp        = VZ     (1)
      HShr_tmp      = HShr   (1)
      VShr_tmp      = VShr   (1)
      VLinShr_tmp   = VLinShr(1)
      VGust_tmp     = VGust  (1)   
         
   ELSE IF ( Time >= Tdata(NumDataLines) )  THEN
   
      TimeIndx      = NumDataLines - 1
      V_tmp         = V      (NumDataLines)
      Delta_tmp     = Delta  (NumDataLines)
      VZ_tmp        = VZ     (NumDataLines)
      HShr_tmp      = HShr   (NumDataLines)
      VShr_tmp      = VShr   (NumDataLines)
      VLinShr_tmp   = VLinShr(NumDataLines)
      VGust_tmp     = VGust  (NumDataLines)
      
   ELSE
   
         ! Let's interpolate!

      TimeIndx = MAX( MIN( TimeIndx, NumDataLines-1 ), 1 )

      DO

         IF ( Time < Tdata(TimeIndx) )  THEN

            TimeIndx = TimeIndx - 1

         ELSE IF ( Time >= Tdata(TimeIndx+1) )  THEN

            TimeIndx = TimeIndx + 1

         ELSE
            P           = ( Time - Tdata(TimeIndx) )/( Tdata(TimeIndx+1) - Tdata(TimeIndx) )
            V_tmp       = ( V(      TimeIndx+1) - V(      TimeIndx) )*P + V(      TimeIndx)
            Delta_tmp   = ( Delta(  TimeIndx+1) - Delta(  TimeIndx) )*P + Delta(  TimeIndx)
            VZ_tmp      = ( VZ(     TimeIndx+1) - VZ(     TimeIndx) )*P + VZ(     TimeIndx)
            HShr_tmp    = ( HShr(   TimeIndx+1) - HShr(   TimeIndx) )*P + HShr(   TimeIndx)
            VShr_tmp    = ( VShr(   TimeIndx+1) - VShr(   TimeIndx) )*P + VShr(   TimeIndx)
            VLinShr_tmp = ( VLinShr(TimeIndx+1) - VLinShr(TimeIndx) )*P + VLinShr(TimeIndx)
            VGust_tmp   = ( VGust(  TimeIndx+1) - VGust(  TimeIndx) )*P + VGust(  TimeIndx)
            EXIT

         END IF

      END DO
      
   END IF

   
   !-------------------------------------------------------------------------------------------------
   ! calculate the wind speed at this time
   !-------------------------------------------------------------------------------------------------
   
   CosDelta = COS( Delta_tmp )
   SinDelta = SIN( Delta_tmp )
   
   V1 = V_tmp * ( ( InputPosition(3)/RefHt ) ** VShr_tmp &                                  ! power-law wind shear
        + ( HShr_tmp   * ( InputPosition(2) * CosDelta + InputPosition(1) * SinDelta ) &    ! horizontal linear shear
        +  VLinShr_tmp * ( InputPosition(3)-RefHt ) )/RefWid  ) &                           ! vertical linear shear
        + VGUST_tmp                                                                         ! gust speed
   
   HH_GetWindSpeed%Velocity(1) =  V1 * CosDelta
   HH_GetWindSpeed%Velocity(2) = -V1 * SinDelta
   HH_GetWindSpeed%Velocity(3) =  VZ_tmp      


   RETURN

END FUNCTION HH_GetWindSpeed
!====================================================================================================
FUNCTION HH_Get_ADHack_WindSpeed(Time, InputPosition, ErrStat)
! This subroutine linearly interpolates the columns in the HH input file to get the values for 
! the requested time, then uses the interpolated values to calclate the wind speed at a point
! in space represented by InputPosition. THIS FUNCTION SHOULD BE REMOVED!!!!! (used for DISK VEL ONLY)
!----------------------------------------------------------------------------------------------------

   REAL(ReKi),        INTENT(IN) :: Time                 ! time from the start of the simulation
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)     ! input information: positions X,Y,Z   -   NOT USED HERE!!!
   INTEGER,           INTENT(OUT):: ErrStat              ! error status
   TYPE(InflIntrpOut)            :: HH_Get_ADHack_WindSpeed      ! return velocities (U,V,W)
   
   REAL(ReKi)                    :: Delta_tmp            ! interpolated Delta   at input TIME
   REAL(ReKi)                    :: P                    ! temporary storage for slope (in time) used in linear interpolation
   REAL(ReKi)                    :: V_tmp                ! interpolated V       at input TIME
   REAL(ReKi)                    :: VZ_tmp               ! interpolated VZ      at input TIME
   

   !-------------------------------------------------------------------------------------------------
   ! verify the module was initialized first
   !-------------------------------------------------------------------------------------------------

   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Error: Call HH_Init() before getting wind speed.')
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
      
   !-------------------------------------------------------------------------------------------------
   ! Linearly interpolate in time (or use nearest-neighbor to extrapolate) 
   ! (compare with NWTC_Num.f90\InterpStpReal)
   !-------------------------------------------------------------------------------------------------

     ! Let's check the limits.

   IF ( Time <= Tdata(1) .OR. NumDataLines == 1)  THEN
   
      TimeIndx      = 1
      V_tmp         = V      (1)
      Delta_tmp     = Delta  (1)
      VZ_tmp        = VZ     (1)
         
   ELSE IF ( Time >= Tdata(NumDataLines) )  THEN
   
      TimeIndx      = NumDataLines - 1
      V_tmp         = V      (NumDataLines)
      Delta_tmp     = Delta  (NumDataLines)
      VZ_tmp        = VZ     (NumDataLines)
      
   ELSE
   
         ! Let's interpolate!

      TimeIndx = MAX( MIN( TimeIndx, NumDataLines-1 ), 1 )

      DO

         IF ( Time < Tdata(TimeIndx) )  THEN

            TimeIndx = TimeIndx - 1

         ELSE IF ( Time >= Tdata(TimeIndx+1) )  THEN

            TimeIndx = TimeIndx + 1

         ELSE
            P           = ( Time - Tdata(TimeIndx) )/( Tdata(TimeIndx+1) - Tdata(TimeIndx) )
            V_tmp       = ( V(      TimeIndx+1) - V(      TimeIndx) )*P + V(      TimeIndx)
            Delta_tmp   = ( Delta(  TimeIndx+1) - Delta(  TimeIndx) )*P + Delta(  TimeIndx)
            VZ_tmp      = ( VZ(     TimeIndx+1) - VZ(     TimeIndx) )*P + VZ(     TimeIndx)
            EXIT

         END IF

      END DO
      
   END IF
   
   !-------------------------------------------------------------------------------------------------
   ! calculate the wind speed at this time
   !-------------------------------------------------------------------------------------------------
      
   HH_Get_ADHack_WindSpeed%Velocity(1) =  V_tmp * COS( Delta_tmp )
   HH_Get_ADHack_WindSpeed%Velocity(2) = -V_tmp * SIN( Delta_tmp )
   HH_Get_ADHack_WindSpeed%Velocity(3) =  VZ_tmp      


   RETURN

END FUNCTION HH_Get_ADHack_WindSpeed
!====================================================================================================
SUBROUTINE HH_SetLinearizeDels( Perturbations, ErrStat )
! This subroutine sets the perturbation values for the linearization scheme.
!----------------------------------------------------------------------------------------------------

   REAL(ReKi),       INTENT(IN)  :: Perturbations(7)     ! purturbations for each of the 7 input parameters
   INTEGER,          INTENT(OUT) :: ErrStat              ! time from the start of the simulation

   !-------------------------------------------------------------------------------------------------
   ! verify the module was initialized first
   !-------------------------------------------------------------------------------------------------

   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Error: Call HH_Init() before getting wind speed.')
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF

   Linearize = .TRUE.
   LinearizeDels(:) = Perturbations(:)

   RETURN

END SUBROUTINE HH_SetLinearizeDels
!====================================================================================================
SUBROUTINE HH_Terminate(ErrStat)

   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered

   INTEGER                     :: SumErrs
   
   SumErrs = 0

   IF ( ALLOCATED(Tdata  ) ) DEALLOCATE( Tdata,   STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(DELTA  ) ) DEALLOCATE( DELTA,   STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(V      ) ) DEALLOCATE( V,       STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VZ     ) ) DEALLOCATE( VZ,      STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(HSHR   ) ) DEALLOCATE( HSHR,    STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VSHR   ) ) DEALLOCATE( VSHR,    STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VGUST  ) ) DEALLOCATE( VGUST,   STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VLINSHR) ) DEALLOCATE( VLINSHR, STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)

   ErrStat  = SumErrs
   TimeIndx = 0            
   
END SUBROUTINE HH_Terminate   
!====================================================================================================
END MODULE HHWind
MODULE UserWind
!  The purpose of this module is to allow user-defined wind.  
!----------------------------------------------------------------------------------------------------

   USE                           NWTC_Library
   USE                           SharedInflowDefs

   IMPLICIT                      NONE
   PRIVATE
    
    
      ! define variables for UserWind here
      
   LOGICAL, SAVE              :: Initialized = .FALSE.         ! This variable indicates if the initialization routine has been run
   
   REAL(ReKi)                 :: UWmeanU                       ! Possibly instantaneous, disk-averaged wind speeds.
   REAL(ReKi)                 :: UWmeanV                       !
   REAL(ReKi)                 :: UWmeanW                       !   
   

      ! allow the initialization and termination routines to be public (called from outside)

   PUBLIC                     :: UsrWnd_Init
   PUBLIC                     :: UsrWnd_Terminate
   PUBLIC                     :: UsrWnd_GetValue
   PUBLIC                     :: UsrWnd_GetWindSpeed

CONTAINS
!====================================================================================================
SUBROUTINE UsrWnd_Init(ErrStat)
!  This subroutine is called at the beginning of
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' UserWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Perform any initialization steps here (read input files, etc.)
   !-------------------------------------------------------------------------------------------------
   
   CALL WrScr( '***** NOTE: User-defined wind employed *****' )


      ! Set the disk-average wind vector.
   
   UWmeanU = 10.0
   UWmeanV =  0.0
   UWmeanW =  0.0

   
   !-------------------------------------------------------------------------------------------------
   ! Set the initialization flag
   !-------------------------------------------------------------------------------------------------
   
   Initialized = .TRUE.
   
   RETURN

END SUBROUTINE UsrWnd_Init
!====================================================================================================
FUNCTION UsrWnd_GetValue(VarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the VarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------
   
   CHARACTER(*),   INTENT(IN)    :: VarName
   INTEGER,        INTENT(OUT)   :: ErrStat           ! return 0 if no errors; non-zero otherwise
   REAL(ReKi)                    :: UsrWnd_GetValue

   
   CHARACTER(20)                 :: VarNameUC         ! upper-case VarName
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN   
      CALL WrScr( 'Initialize UserWind before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = VarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
   
      CASE ('MEANU' )
         UsrWnd_GetValue = UWmeanU
         
      CASE ('MEANV' )
         UsrWnd_GetValue = UWmeanV

      CASE ('MEANW' )
         UsrWnd_GetValue = UWmeanW
         
      CASE DEFAULT
         CALL WrScr( ' Invalid variable name in UsrWnd_GetValue().' )
         ErrStat = 1
         
   END SELECT
      
   

END FUNCTION UsrWnd_GetValue
!====================================================================================================
FUNCTION UsrWnd_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are 
! requested. It returns the velocities at the specified time and space.
!----------------------------------------------------------------------------------------------------
   
   REAL(ReKi),        INTENT(IN) :: Time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)        ! X,Y,Z (z is 0 at ground level)
   INTEGER,           INTENT(OUT):: ErrStat                 ! return 0 if no errors; non-zero otherwise
   TYPE(InflIntrpOut)            :: UsrWnd_GetWindSpeed
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   
   IF ( .NOT. Initialized ) THEN   
      CALL WrScr( 'Initialize UserWind before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Calculate the wind speed at this time and position.
   !-------------------------------------------------------------------------------------------------   
   !     Time
   !     X = InputPosition(1)           ! relative to the undeflected tower centerline (positive downwind)
   !     Y = InputPosition(2)           ! relative to the undeflected tower centerline (positive left when looking downwind)
   !     Z = InputPosition(3)           ! relative to the ground (0 is ground level)
   !-------------------------------------------------------------------------------------------------

      ! We'll test this with steady winds for now.

   UsrWnd_GetWindSpeed%Velocity(1) = 10.0    ! U velocity (along positive X)
   UsrWnd_GetWindSpeed%Velocity(2) =  0.0    ! V velocity (along positive Y)
   UsrWnd_GetWindSpeed%Velocity(3) =  0.0    ! V velocity (along positive Z)
   

END FUNCTION UsrWnd_GetWindSpeed
!====================================================================================================
SUBROUTINE UsrWnd_Terminate(ErrStat)
!  This subroutine is called at the end of program execution (including after fatal errors occur).  
!  It should close any files that could be open and deallocate any arrays that have been allocated.
!----------------------------------------------------------------------------------------------------
      
   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   ErrStat = 0

   !-------------------------------------------------------------------------------------------------
   ! Close files
   !-------------------------------------------------------------------------------------------------
      
      
   !-------------------------------------------------------------------------------------------------
   ! Deallocate arrays
   !-------------------------------------------------------------------------------------------------

      
   !-------------------------------------------------------------------------------------------------
   ! Set the initialization flag
   !-------------------------------------------------------------------------------------------------
   
   Initialized = .FALSE.

END SUBROUTINE UsrWnd_Terminate
!====================================================================================================
END MODULE UserWind
MODULE InflowWind_Subs
! This module is used to read and process the (undisturbed) inflow winds.  It must be initialized
! using InflowWind_Init() with the name of the file, the file type, and possibly reference height and
! width (depending on the type of wind file being used).  This module calls appropriate routines
! in the wind modules so that the type of wind becomes seamless to the user.  InflowWind_Terminate()
! should be called when the program has finshed.
!
! Data are assumed to be in units of meters and seconds.  Z is measured from the ground (NOT the hub!).
!
!  7 Oct 2009    Initial Release with AeroDyn 13.00.00      B. Jonkman, NREL/NWTC
! 14 Nov 2011    v1.00.01b-bjj                              B. Jonkman
!  1 Aug 2012    v1.01.00a-bjj                              B. Jonkman
! 10 Aug 2012    v1.01.00b-bjj                              B. Jonkman
!----------------------------------------------------------------------------------------------------

   USE                              NWTC_Library
   USE                              SharedInflowDefs

   !-------------------------------------------------------------------------------------------------
   ! The included wind modules
   !-------------------------------------------------------------------------------------------------

   USE                              FFWind               ! full-field binary wind files
   USE                              HHWind               ! hub-height text wind files
   USE                              FDWind               ! 4-D binary wind files
   USE                              CTWind               ! coherent turbulence from KH billow - binary file superimposed on another wind type
   USE                              UserWind             ! user-defined wind module
   USE                              HAWCWind             ! full-field binary wind files in HAWC format


   IMPLICIT                         NONE


CONTAINS
!====================================================================================================
!FIXME: this becomes part of InflowWind_CalcOutput
FUNCTION InflowWind_GetVelocity(Time, InputPosition, ErrStat)
! Get the wind speed at a point in space and time
!----------------------------------------------------------------------------------------------------

      ! passed variables
   REAL(ReKi),       INTENT(IN)  :: Time
   REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
   INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise

      ! local variables
   TYPE(InflIntrpOut)            :: InflowWind_GetVelocity     ! U, V, W velocities
   TYPE(InflIntrpOut)            :: CTWindSpeed             ! U, V, W velocities to superimpose on background wind


   ErrStat = 0

   SELECT CASE ( WindType )
      CASE (HH_Wind)
         InflowWind_GetVelocity = HH_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE (FF_Wind)
         InflowWind_GetVelocity = FF_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE (UD_Wind)
         InflowWind_GetVelocity = UsrWnd_GetWindSpeed( Time, InputPosition, ErrStat )

      CASE (FD_Wind)
         InflowWind_GetVelocity = FD_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE (HAWC_Wind)
         InflowWind_GetVelocity = HW_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in InflowWind_GetVelocity(). ' &
                   //'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1
         InflowWind_GetVelocity%Velocity(:) = 0.0

   END SELECT


   IF (ErrStat /= 0) THEN

      InflowWind_GetVelocity%Velocity(:) = 0.0

   ELSE

         ! Add coherent turbulence to background wind

      IF (CT_Flag) THEN

         CTWindSpeed = CT_GetWindSpeed(Time, InputPosition, ErrStat)
         IF (ErrStat /=0 ) RETURN

         InflowWind_GetVelocity%Velocity(:) = InflowWind_GetVelocity%Velocity(:) + CTWindSpeed%Velocity(:)

      ENDIF

   ENDIF

END FUNCTION InflowWind_GetVelocity
!====================================================================================================
!FIXME: move to subroutines
!!    !====================================================================================================
FUNCTION GetWindType( FileName, ErrStat )
!  This subroutine checks the file FileName to see what kind of wind file we are using.  Used when
!  the wind file type is unknown.
!----------------------------------------------------------------------------------------------------


   IMPLICIT             NONE


      ! Passed Variables:

   CHARACTER(*),INTENT(INOUT) :: FileName
   INTEGER, INTENT(OUT)       :: ErrStat

      ! Function definition
   INTEGER                    :: GetWindType

      ! Local Variables:

   INTEGER                    :: IND
   LOGICAL                    :: Exists

   CHARACTER(  3)             :: FileNameEnd
   CHARACTER(  8)             :: WndFilNam

   CHARACTER(1024)            :: FileRoot


   ErrStat = 0

   !-------------------------------------------------------------------------------------------------
   ! Check for user-defined wind file first; file starts with "USERWIND"
   !-------------------------------------------------------------------------------------------------

   WndFilNam = FileName
   CALL Conv2UC( WndFilNam )

   IF ( WndFilNam == 'USERWIND' )  THEN

      CALL WrScr1( ' Detected user-defined wind file.' )
      GetWindType = UD_Wind

      RETURN
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Get the file extension (or at least what we expect the extension to be)
   !-------------------------------------------------------------------------------------------------
   CALL GetRoot ( FileName, FileRoot )                      ! Get the root name

   IND = LEN_TRIM( FileRoot ) + 1
   IF ( IND < LEN_TRIM( FileName ) ) THEN
      FileNameEnd = FileName(IND+1:)                        ! Get the extenstion, starting at first character past (may not be the whole "extension")
      CALL Conv2UC (FileNameEnd)
   ELSE
      FileNameEnd = ""
      IND = 0
   END IF


   !-------------------------------------------------------------------------------------------------
   ! If there was no '.' in the file name, assume FF, and add a .wnd extension
   !-------------------------------------------------------------------------------------------------
   IF ( IND == 0 ) THEN
      CALL WrScr1(' No file extension found. Assuming '//TRIM(FileName)// &
                  ' is a binary FF wind file with a ".wnd" extension.')
      GetWindType = FF_Wind
      FileName = TRIM(FileName)//'.wnd'
      RETURN
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Base the file type on the extension
   !-------------------------------------------------------------------------------------------------
   SELECT CASE ( TRIM(FileNameEnd) )
      CASE ('WND')

            ! If a summary file exists, assume FF; otherwise, assume HH file.

         INQUIRE ( FILE=FileName(1:IND)//'sum' , EXIST=Exists )
         IF (Exists) THEN
            CALL WrScr1(' Assuming '//TRIM(FileName)//' is a binary FF wind file.')
            GetWindType = FF_Wind
         ELSE
            CALL WrScr1(' Assuming '//TRIM(FileName)//' is a formatted HH wind file.')
            GetWindType = HH_Wind
         END IF

      CASE ('BTS')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a binary FF wind file.')
         GetWindType = FF_Wind

      CASE ('CTP')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a coherent turbulence wind file.')
         GetWindType = CTP_Wind

      CASE ('FDP')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a binary 4-dimensional wind file.')
         GetWindType = FD_Wind

      CASE ('HWC')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' contains full-field wind parameters in HAWC format.')
         GetWindType = HAWC_Wind

      CASE DEFAULT
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a formatted HH wind file.')
         GetWindType = HH_Wind

   END SELECT


RETURN
END FUNCTION GetWindType
!====================================================================================================
!FIXME: move to subroutines.
SUBROUTINE InflowWind_LinearizePerturbation( LinPerturbations, ErrStat )
! This function is used in FAST's linearization scheme.  It should be fixed at some point.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,    INTENT(OUT)    :: ErrStat

   REAL(ReKi), INTENT(IN)     :: LinPerturbations(7)

      ! Local variables


   ErrStat = 0

   SELECT CASE ( WindType )
      CASE (HH_Wind)

         CALL HH_SetLinearizeDels( LinPerturbations, ErrStat )

      CASE ( FF_Wind, UD_Wind, FD_Wind, HAWC_Wind )

         CALL WrScr( ' Error: Linearization is valid only with HH wind files.' )
         ErrStat = 1

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in InflowWind_LinearizePerturbation(). '// &
                     'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1

   END SELECT


END SUBROUTINE InflowWind_LinearizePerturbation
!====================================================================================================
!FIXME: move to subroutines.
FUNCTION InflowWind_ADhack_diskVel( Time, InpPosition, ErrStat )
! This function should be deleted ASAP.  It's purpose is to reproduce results of AeroDyn 12.57;
! when a consensus on the definition of "average velocity" is determined, this function will be
! removed.  InpPosition(2) should be the rotor radius; InpPosition(3) should be hub height
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   REAL(ReKi), INTENT(IN)     :: Time
   REAL(ReKi), INTENT(IN)     :: InpPosition(3)
   INTEGER, INTENT(OUT)       :: ErrStat

      ! Function definition
   REAL(ReKi)                 :: InflowWind_ADhack_diskVel(3)

      ! Local variables
   TYPE(InflIntrpOut)         :: NewVelocity             ! U, V, W velocities
   REAL(ReKi)                 :: Position(3)
   INTEGER                    :: IY
   INTEGER                    :: IZ


   ErrStat = 0

   SELECT CASE ( WindType )
      CASE (HH_Wind)

!      VXGBAR =  V * COS( DELTA )
!      VYGBAR = -V * SIN( DELTA )
!      VZGBAR =  VZ

         Position    = (/ REAL(0.0, ReKi), REAL(0.0, ReKi), InpPosition(3) /)
         NewVelocity = HH_Get_ADHack_WindSpeed(Time, Position, ErrStat)

         InflowWind_ADhack_diskVel(:) = NewVelocity%Velocity(:)


      CASE (FF_Wind)
!      VXGBAR = MeanFFWS
!      VYGBAR = 0.0
!      VZGBAR = 0.0

         InflowWind_ADhack_diskVel(1)   = FF_GetValue('MEANFFWS', ErrStat)
         InflowWind_ADhack_diskVel(2:3) = 0.0

      CASE (UD_Wind)
!      VXGBAR = UWmeanU
!      VYGBAR = UWmeanV
!      VZGBAR = UWmeanW

         InflowWind_ADhack_diskVel(1)   = UsrWnd_GetValue('MEANU', ErrStat)
         IF (ErrStat /= 0) RETURN
         InflowWind_ADhack_diskVel(2)   = UsrWnd_GetValue('MEANV', ErrStat)
         IF (ErrStat /= 0) RETURN
         InflowWind_ADhack_diskVel(3)   = UsrWnd_GetValue('MEANW', ErrStat)

      CASE (FD_Wind)
!      XGrnd = 0.0
!      YGrnd = 0.5*RotDiam
!      ZGrnd = 0.5*RotDiam
!      CALL FD_Interp
!      VXGBAR = FDWind( 1 )
!      VYGBAR = FDWind( 2 )
!      VZGBAR = FDWind( 3 )
!
!      XGrnd =  0.0
!      YGrnd = -0.5*RotDiam
!      ZGrnd =  0.5*RotDiam
!      CALL FD_Interp
!      VXGBAR = VXGBAR + FDWind( 1 )
!      VYGBAR = VYGBAR + FDWind( 2 )
!      VZGBAR = VZGBAR + FDWind( 3 )
!
!      XGrnd =  0.0
!      YGrnd = -0.5*RotDiam
!      ZGrnd = -0.5*RotDiam
!      CALL FD_Interp
!      VXGBAR = VXGBAR + FDWind( 1 )
!      VYGBAR = VYGBAR + FDWind( 2 )
!      VZGBAR = VZGBAR + FDWind( 3 )
!
!      XGrnd =  0.0
!      YGrnd =  0.5*RotDiam
!      ZGrnd = -0.5*RotDiam
!      CALL FD_Interp
!      VXGBAR = 0.25*( VXGBAR + FDWind( 1 ) )
!      VYGBAR = 0.25*( VYGBAR + FDWind( 2 ) )
!      VZGBAR = 0.25*( VZGBAR + FDWind( 3 ) )


         Position(1) = 0.0
         InflowWind_ADhack_diskVel(:) = 0.0

         DO IY = -1,1,2
            Position(2)  =  IY*FD_GetValue('RotDiam',ErrStat)

            DO IZ = -1,1,2
               Position(3)  = IZ*InpPosition(2) + InpPosition(3)

               NewVelocity = InflowWind_GetVelocity(Time, Position, ErrStat)
               InflowWind_ADhack_diskVel(:) = InflowWind_ADhack_diskVel(:) + NewVelocity%Velocity(:)
            END DO
         END DO
         InflowWind_ADhack_diskVel(:) = 0.25*InflowWind_ADhack_diskVel(:)

      CASE (HAWC_Wind)
         InflowWind_ADhack_diskVel(1)   = HW_GetValue('UREF', ErrStat)
         InflowWind_ADhack_diskVel(2:3) = 0.0

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in InflowWind_ADhack_diskVel(). '// &
                    'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1

   END SELECT

   RETURN

END FUNCTION InflowWind_ADhack_diskVel
!====================================================================================================
!FIXME: move to subroutines.
FUNCTION InflowWind_ADhack_DIcheck( ErrStat )
! This function should be deleted ASAP.  It's purpose is to reproduce results of AeroDyn 12.57;
! it performs a wind speed check for the dynamic inflow initialization
! it returns MFFWS for the FF wind files; for all others, a sufficiently large number is used ( > 8 m/s)
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER, INTENT(OUT)       :: ErrStat

      ! Function definition
   REAL(ReKi)                 :: InflowWind_ADhack_DIcheck


   ErrStat = 0

   SELECT CASE ( WindType )
      CASE (HH_Wind, UD_Wind, FD_Wind )

         InflowWind_ADhack_DIcheck = 50  ! just return something greater than 8 m/s

      CASE (FF_Wind)

         InflowWind_ADhack_DIcheck = FF_GetValue('MEANFFWS', ErrStat)

      CASE (HAWC_Wind)

         InflowWind_ADhack_DIcheck = HW_GetValue('UREF', ErrStat)

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in InflowWind_ADhack_DIcheck(). '// &
                    'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1

   END SELECT

   RETURN

END FUNCTION InflowWind_ADhack_DIcheck
!====================================================================================================
END MODULE InflowWind_Subs





!!----Remove this functionality for now. Might put it back in sometime after the conversion to the new framework ----
!FIXME: Move these to subroutines.
!!    FUNCTION InflowWind_GetMean(StartTime, EndTime, delta_time, InputPosition,  ErrStat )
!!    !  This function returns the mean wind speed
!!    !----------------------------------------------------------------------------------------------------
!!
!!          ! passed variables
!!       REAL(ReKi),       INTENT(IN)  :: StartTime
!!       REAL(ReKi),       INTENT(IN)  :: EndTime
!!       REAL(ReKi),       INTENT(IN)  :: delta_time
!!       REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
!!       INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise
!!
!!          ! function definition
!!       REAL(ReKi)                    :: InflowWind_GetMean(3)      ! MEAN U, V, W
!!
!!          ! local variables
!!       REAL(ReKi)                    :: Time
!!       REAL(DbKi)                    :: SumVel(3)
!!       INTEGER                       :: I
!!       INTEGER                       :: Nt
!!
!!       TYPE(InflIntrpOut)            :: NewVelocity             ! U, V, W velocities
!!
!!
!!       Nt = (EndTime - StartTime) / delta_time
!!
!!       SumVel(:) = 0.0
!!       ErrStat   = 0
!!
!!
!!       DO I=1,Nt
!!
!!          Time = StartTime + (I-1)*delta_time
!!
!!          NewVelocity = InflowWind_GetVelocity(Time, InputPosition, ErrStat)
!!          IF ( ErrStat /= 0 ) THEN
!!             InflowWind_GetMean(:) = SumVel(:) / REAL(I-1, ReKi)
!!             RETURN
!!          ELSE
!!             SumVel(:) = SumVel(:) + NewVelocity%Velocity(:)
!!          END IF
!!
!!       END DO
!!
!!       InflowWind_GetMean(:) = SumVel(:) / REAL(Nt, ReKi)
!!
!!
!!    END FUNCTION InflowWind_GetMean
!!    !====================================================================================================
!!    FUNCTION InflowWind_GetStdDev(StartTime, EndTime, delta_time, InputPosition,  ErrStat )
!!    !  This function returns the mean wind speed (mean, std, TI, etc)
!!    !----------------------------------------------------------------------------------------------------
!!
!!          ! passed variables
!!       REAL(ReKi),       INTENT(IN)  :: StartTime
!!       REAL(ReKi),       INTENT(IN)  :: EndTime
!!       REAL(ReKi),       INTENT(IN)  :: delta_time
!!       REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
!!       INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise
!!
!!          ! function definition
!!       REAL(ReKi)                    :: InflowWind_GetStdDev(3)    ! STD U, V, W
!!
!!          ! local variables
!!       REAL(ReKi)                    :: Time
!!       REAL(ReKi), ALLOCATABLE       :: Velocity(:,:)
!!       REAL(DbKi)                    :: SumAry(3)
!!       REAL(DbKi)                    :: MeanVel(3)
!!       INTEGER                       :: I
!!       INTEGER                       :: Nt
!!
!!       TYPE(InflIntrpOut)            :: NewVelocity             ! U, V, W velocities
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Initialize
!!       !-------------------------------------------------------------------------------------------------
!!
!!       InflowWind_GetStdDev(:) = 0.0
!!
!!       Nt = (EndTime - StartTime) / delta_time
!!
!!       IF ( Nt < 2 ) RETURN    ! StdDev is 0
!!
!!
!!       IF (.NOT. ALLOCATED(Velocity)) THEN
!!    !      CALL AllocAry( Velocity, 3, Nt, 'StdDev velocity', ErrStat)
!!          ALLOCATE ( Velocity(3, Nt), STAT=ErrStat )
!!
!!          IF ( ErrStat /= 0 )  THEN
!!             CALL WrScr ( ' Error allocating memory for the StdDev velocity array.' )
!!             RETURN
!!          END IF
!!       END IF
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the mean, storing the velocity for later
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          Time = StartTime + (I-1)*delta_time
!!
!!          NewVelocity = InflowWind_GetVelocity(Time, InputPosition, ErrStat)
!!          IF ( ErrStat /= 0 ) RETURN
!!          Velocity(:,I) = NewVelocity%Velocity(:)
!!          SumAry(:)     = SumAry(:) + NewVelocity%Velocity(:)
!!
!!       END DO
!!
!!       MeanVel(:) = SumAry(:) / REAL(Nt, ReKi)
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the standard deviation
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          SumAry(:) = SumAry(:) + ( Velocity(:,I) - MeanVel(:) )**2
!!
!!       END DO ! I
!!
!!       InflowWind_GetStdDev(:) = SQRT( SumAry(:) / ( Nt - 1 ) )
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Deallocate
!!       !-------------------------------------------------------------------------------------------------
!!       IF ( ALLOCATED(Velocity) ) DEALLOCATE( Velocity )
!!
!!
!!    END FUNCTION InflowWind_GetStdDev
!!    !====================================================================================================
!!    FUNCTION InflowWind_GetTI(StartTime, EndTime, delta_time, InputPosition,  ErrStat )
!!    !  This function returns the TI of the wind speed.  It's basically a copy of InflowWind_GetStdDev,
!!    !  except the return value is divided by the mean U-component wind speed.
!!    !----------------------------------------------------------------------------------------------------
!!
!!          ! passed variables
!!       REAL(ReKi),       INTENT(IN)  :: StartTime
!!       REAL(ReKi),       INTENT(IN)  :: EndTime
!!       REAL(ReKi),       INTENT(IN)  :: delta_time
!!       REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
!!       INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise
!!
!!          ! function definition
!!       REAL(ReKi)                    :: InflowWind_GetTI(3)        ! TI U, V, W
!!
!!          ! local variables
!!       REAL(ReKi)                    :: Time
!!       REAL(ReKi), ALLOCATABLE       :: Velocity(:,:)
!!       REAL(DbKi)                    :: SumAry(3)
!!       REAL(DbKi)                    :: MeanVel(3)
!!       INTEGER                       :: I
!!       INTEGER                       :: Nt
!!
!!       TYPE(InflIntrpOut)            :: NewVelocity             ! U, V, W velocities
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Initialize
!!       !-------------------------------------------------------------------------------------------------
!!
!!       InflowWind_GetTI(:) = 0.0
!!
!!       Nt = (EndTime - StartTime) / delta_time
!!
!!       IF ( Nt < 2 ) RETURN    ! StdDev is 0
!!
!!
!!       IF (.NOT. ALLOCATED(Velocity)) THEN
!!    !      CALL AllocAry( Velocity, 3, Nt, 'TI velocity', ErrStat)
!!          ALLOCATE ( Velocity(3, Nt), STAT=ErrStat )
!!
!!          IF ( ErrStat /= 0 )  THEN
!!             CALL WrScr ( ' Error allocating memory for the TI velocity array.' )
!!             RETURN
!!          END IF
!!       END IF
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the mean, storing the velocity for later
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          Time = StartTime + (I-1)*delta_time
!!
!!          NewVelocity = InflowWind_GetVelocity(Time, InputPosition, ErrStat)
!!          IF ( ErrStat /= 0 ) RETURN
!!          Velocity(:,I) = NewVelocity%Velocity(:)
!!          SumAry(:)     = SumAry(:) + NewVelocity%Velocity(:)
!!
!!       END DO
!!
!!       MeanVel(:) = SumAry(:) / REAL(Nt, ReKi)
!!
!!       IF ( ABS(MeanVel(1)) <= EPSILON(MeanVel(1)) ) THEN
!!          CALL WrScr( ' Wind speed is small in InflowWind_GetTI(). TI is undefined.' )
!!          ErrStat = 1
!!          RETURN
!!       END IF
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the standard deviation
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          SumAry(:) = SumAry(:) + ( Velocity(:,I) - MeanVel(:) )**2
!!
!!       END DO ! I
!!
!!       InflowWind_GetTI(:) = SQRT( SumAry(:) / ( Nt - 1 ) ) / MeanVel(1)
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Deallocate
!!       !-------------------------------------------------------------------------------------------------
!!       IF ( ALLOCATED(Velocity) ) DEALLOCATE( Velocity )
!!
!!
!!    END FUNCTION InflowWind_GetTI
MODULE InflowWind
! This module is used to read and process the (undisturbed) inflow winds.  It must be initialized
! using InflowWind_Init() with the name of the file, the file type, and possibly reference height and
! width (depending on the type of wind file being used).  This module calls appropriate routines
! in the wind modules so that the type of wind becomes seamless to the user.  InflowWind_Terminate()
! should be called when the program has finshed.
!
! Data are assumed to be in units of meters and seconds.  Z is measured from the ground (NOT the hub!).
!
!  7 Oct 2009    Initial Release with AeroDyn 13.00.00      B. Jonkman, NREL/NWTC
! 14 Nov 2011    v1.00.01b-bjj                              B. Jonkman
!  1 Aug 2012    v1.01.00a-bjj                              B. Jonkman
! 10 Aug 2012    v1.01.00b-bjj                              B. Jonkman
!----------------------------------------------------------------------------------------------------

   USE                              NWTC_Library
   USE                              SharedInflowDefs

   !-------------------------------------------------------------------------------------------------
   ! The included wind modules
   !-------------------------------------------------------------------------------------------------

   USE                              FFWind               ! full-field binary wind files
   USE                              HHWind               ! hub-height text wind files
   USE                              FDWind               ! 4-D binary wind files
   USE                              CTWind               ! coherent turbulence from KH billow - binary file superimposed on another wind type
   USE                              UserWind             ! user-defined wind module
   USE                              HAWCWind             ! full-field binary wind files in HAWC format


   !-------------------------------------------------------------------------------------------------
   ! The subroutines
   !-------------------------------------------------------------------------------------------------

   USE                              InflowWind_Subs      ! all the subroutines live here now.


   IMPLICIT                         NONE
   PRIVATE

   !-------------------------------------------------------------------------------------------------
   ! Private internal variables
   !-------------------------------------------------------------------------------------------------

!FIXME: handle this differently -- should be allocated by the library function to get an open unit number
! store as parameter in parametertype
   INTEGER                        :: UnWind   = 91          ! The unit number used for wind inflow files


   !-------------------------------------------------------------------------------------------------
   ! Definitions of public types and routines
   !-------------------------------------------------------------------------------------------------
!FIXME: move to types
   TYPE, PUBLIC :: InflInitInfo
      CHARACTER(1024)             :: WindFileName
      INTEGER                     :: WindFileType
      REAL(ReKi)                  :: ReferenceHeight        ! reference height for HH and/or 4D winds (was hub height), in meters
      REAL(ReKi)                  :: Width                  ! width of the HH file (was 2*R), in meters
   END TYPE InflInitInfo

   PUBLIC                         :: InflowWind_Init           ! Initialization subroutine

!FIXME: should not be public anymore
   PUBLIC                         :: InflowWind_GetVelocity    ! function to get wind speed at point in space and time

   PUBLIC                         :: InflowWind_Terminate      ! subroutine to clean up

!FIXME: not public anymore. may not exist when done.
!   PUBLIC                         :: InflowWind_ADhack_diskVel ! used to keep old AeroDyn functionality--remove soon!
!   PUBLIC                         :: InflowWind_ADhack_DIcheck ! used to keep old AeroDyn functionality--remove soon!

!FIXME: not public anymore.
!   PUBLIC                         :: InflowWind_LinearizePerturbation !used for linearization; should be modified
!!----Removed during conversion to new framework: may put back in as part of OtherStates
!!       PUBLIC                         :: InflowWind_GetMean        ! function to get the mean wind speed at a point in space
!!       PUBLIC                         :: InflowWind_GetStdDev      ! function to calculate standard deviation at a point in space
!!       PUBLIC                         :: InflowWind_GetTI          ! function to get TI at a point in space

!FIXME: tie this to a type as well. Change to ProgDesc type
   CHARACTER(99),PARAMETER        :: InflowWindVer = 'InflowWind (v1.01.00b-bjj, 10-Aug-2012)'

CONTAINS
!====================================================================================================
!FIXME: change naming to new standard. InflowWind_Init or IfW_Init
SUBROUTINE InflowWind_Init( FileInfo, ErrStat )
!  Open and read the wind files, allocating space for necessary variables
!
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   TYPE(InflInitInfo), INTENT(IN)   :: FileInfo
   INTEGER,            INTENT(OUT)  :: ErrStat

      ! Local variables

   TYPE(HH_Info)                    :: HHInitInfo
   TYPE(CT_Backgr)                  :: BackGrndValues

   REAL(ReKi)                       :: Height
   REAL(ReKi)                       :: HalfWidth
   CHARACTER(1024)                  :: FileName

!FIXME: not sure if want to track it this way or not.
   IF ( WindType /= Undef_Wind ) THEN
      CALL WrScr( ' Wind inflow has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      WindType = FileInfo%WindFileType
      FileName = FileInfo%WindFileName
      CALL NWTC_Init()
      CALL WrScr1( ' Using '//TRIM( InflowWindVer ) )

   END IF

   !-------------------------------------------------------------------------------------------------
   ! Get default wind type, based on file name, if requested
   !-------------------------------------------------------------------------------------------------
   IF ( FileInfo%WindFileType == DEFAULT_Wind ) THEN
      WindType = GetWindType( FileName, ErrStat )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Check for coherent turbulence file (KH superimposed on a background wind file)
   ! Initialize the CTWind module and initialize the module of the other wind type.
   !-------------------------------------------------------------------------------------------------

   IF ( WindType == CTP_Wind ) THEN

      CALL CT_Init(UnWind, FileName, BackGrndValues, ErrStat)
      IF (ErrStat /= 0) THEN
         CALL InflowWind_Terminate( ErrStat )
         WindType = Undef_Wind
         ErrStat  = 1
         RETURN
      END IF

      FileName = BackGrndValues%WindFile
      WindType = BackGrndValues%WindFileType
      CT_Flag  = BackGrndValues%CoherentStr

   ELSE

      CT_Flag  = .FALSE.

   END IF


   !-------------------------------------------------------------------------------------------------
   ! Initialize based on the wind type
   !-------------------------------------------------------------------------------------------------

   SELECT CASE ( WindType )

      CASE (HH_Wind)

         HHInitInfo%ReferenceHeight = FileInfo%ReferenceHeight
         HHInitInfo%Width           = FileInfo%Width

         CALL HH_Init( UnWind, FileName, HHInitInfo, ErrStat )

!        IF (CT_Flag) CALL CT_SetRefVal(FileInfo%ReferenceHeight, 0.5*FileInfo%Width, ErrStat)
         IF (ErrStat == 0 .AND. CT_Flag) CALL CT_SetRefVal(FileInfo%ReferenceHeight, REAL(0.0, ReKi), ErrStat)


      CASE (FF_Wind)

         CALL FF_Init( UnWind, FileName, ErrStat )


            ! Set CT parameters

         IF ( ErrStat == 0 .AND. CT_Flag ) THEN
            Height     = FF_GetValue('HubHeight', ErrStat)
            IF ( ErrStat /= 0 ) Height = FileInfo%ReferenceHeight

            HalfWidth  = 0.5*FF_GetValue('GridWidth', ErrStat)
            IF ( ErrStat /= 0 ) HalfWidth = 0

            CALL CT_SetRefVal(Height, HalfWidth, ErrStat)
         END IF


      CASE (UD_Wind)

         CALL UsrWnd_Init(ErrStat)


      CASE (FD_Wind)

         CALL FD_Init(UnWind, FileName, FileInfo%ReferenceHeight, ErrStat)

      CASE (HAWC_Wind)

         CALL HW_Init( UnWind, FileName, ErrStat )

      CASE DEFAULT

         CALL WrScr(' Error: Undefined wind type in WindInflow_Init()' )
         ErrStat = 1
         RETURN

   END SELECT

   IF ( ErrStat /= 0 ) THEN
      CALL InflowWind_Terminate( ErrStat )  !Just in case we've allocated something
      WindType = Undef_Wind
      ErrStat  = 1
   END IF

   RETURN

END SUBROUTINE InflowWind_Init
!====================================================================================================
!FIXME: rename as per framework.
SUBROUTINE InflowWind_Terminate( ErrStat )
! Clean up the allocated variables and close all open files.  Reset the initialization flag so
! that we have to reinitialize before calling the routines again.
!----------------------------------------------------------------------------------------------------

   INTEGER, INTENT(OUT)       :: ErrStat     !bjj: do we care if there's an error on cleanup?


      ! Close the wind file, if it happens to be open

   CLOSE( UnWind )


      ! End the sub-modules (deallocates their arrays and closes their files):

   SELECT CASE ( WindType )

      CASE (HH_Wind)
         CALL HH_Terminate(     ErrStat )

      CASE (FF_Wind)
         CALL FF_Terminate(     ErrStat )

      CASE (UD_Wind)
         CALL UsrWnd_Terminate( ErrStat )

      CASE (FD_Wind)
         CALL FD_Terminate(     ErrStat )

      CASE (HAWC_Wind)
         CALL HW_Terminate(     ErrStat )

      CASE ( Undef_Wind )
         ! Do nothing

      CASE DEFAULT  ! keep this check to make sure that all new wind types have a terminate function
         CALL WrScr(' Undefined wind type in InflowWind_Terminate().' )
         ErrStat = 1

   END SELECT

!   IF (CT_Flag) CALL CT_Terminate( ErrStat )
   CALL CT_Terminate( ErrStat )


      ! Reset the wind type so that the initialization routine must be called
  WindType = Undef_Wind
   CT_Flag  = .FALSE.


END SUBROUTINE InflowWind_Terminate
!====================================================================================================
END MODULE InflowWind



