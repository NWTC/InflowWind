!****************************************************************************
!
!  PROGRAM: InflowWind_Test  - This program tests the inflow wind module
!
!****************************************************************************

PROGRAM InflowWind_Test
    
   USE InflowWind
   USE SharedInflowDefns
          
   IMPLICIT NONE
    
   INTEGER ErrStat
   TYPE(InflInitInfo)  :: InitWindData         ! data to initialize the module; TYPE defined in InflowWindMod.f90
    
   REAL(ReKi)          :: InpPosition(3)
   TYPE(InflIntrpOut)  :: MyWindSpeed
   REAL(ReKi)          :: Time

   REAL(ReKi)          :: dt
   INTEGER             :: I


   !-------------------------------------------------------------------------------------------------
   ! Send the data required for initialization
   !-------------------------------------------------------------------------------------------------
    
!      InitWindData%WindFileName     = "D:\DATA\Fortran\IVF Projects\AeroDyn\Update\Source\InflowWind\TestData\GPLLJ_DNS\InOut.wnd"
!      InitWindData%WindFileName     = "../TestRoutines/TestData/Periodic_Winds.wnd"    !! ff wind
!      InitWindData%WindFileName     = "Test-Data/InOut.wnd"    !! ff wind
!      InitWindData%WindFileName     = "../Samples/Steady.wnd"  !! HH wind
      InitWindData%WindFileName     = "../Samples/les.fdp"  !! 4 D -- points to some other files.
      InitWindData%ReferenceHeight  = 80.   ! meters
      InitWindData%Width            = 100.  ! meters

!     InitWindData%WindFileType     = FF_Wind  
      InitWindData%WindFileType     = DEFAULT_Wind      ! let the module figure out what type of file it is...
      

      CALL WindInf_Init( InitWindData, ErrStat )    


      IF (errstat /=0) CALL ProgAbort('Error in Initialization routine')
      
   
   !-------------------------------------------------------------------------------------------------
   ! Get the wind speeds at various times and positions
   !-------------------------------------------------------------------------------------------------
      dt     = 0.05 ! seconds   
   
      InpPosition(1) = 0.0                            ! longitudinal position front/back of tower
      InpPosition(2) = 0.0                            ! lateral position left/right of tower
      InpPosition(3) = InitWindData%ReferenceHeight   ! height relative to the ground
    
      DO I = 1,3 !time
          
         Time = 0.0 + (I-1)*dt
          
         MyWindSpeed = WindInf_GetVelocity( Time, InpPosition, ErrStat )
         
         !IF (ErrStat /=0) CALL ProgAbort('Error in getting wind speed')
            
         WRITE(*,*) TRIM(Num2LStr(ErrStat)), ' V(t=', TRIM(Num2LStr(Time)), ') = ', MyWindSpeed

      END DO
    
   !-------------------------------------------------------------------------------------------------
   ! Clean up the variables and close files
   !-------------------------------------------------------------------------------------------------
    CALL WindInf_Terminate( ErrStat )


END PROGRAM InflowWind_Test

!=======================================================================
MODULE Precision


   ! This module stores constants to specify the KIND of variables.

IMPLICIT                           NONE

   ! These values should not vary from DoubPrec.f90:
   
INTEGER, PARAMETER              :: B1Ki     = SELECTED_INT_KIND(  2 )           ! Kind for one-byte whole numbers
INTEGER, PARAMETER              :: B2Ki     = SELECTED_INT_KIND(  4 )           ! Kind for two-byte whole numbers
INTEGER, PARAMETER              :: B4Ki     = SELECTED_INT_KIND(  9 )           ! Kind for four-byte whole numbers
INTEGER, PARAMETER              :: B8Ki     = SELECTED_INT_KIND( 18 )           ! Kind for eight-byte whole numbers

INTEGER, PARAMETER              :: QuKi     = SELECTED_REAL_KIND( 20, 500 )     ! Kind for 16-byte, floating-point numbers
INTEGER, PARAMETER              :: R8Ki     = SELECTED_REAL_KIND( 14, 300 )     ! Kind for eight-byte floating-point numbers
INTEGER, PARAMETER              :: SiKi     = SELECTED_REAL_KIND(  6,  30 )     ! Kind for four-byte, floating-point numbers


      ! The default kinds for reals and integers:
      
INTEGER, PARAMETER              :: IntKi    = B4Ki                              ! Default kind for integers
INTEGER, PARAMETER              :: ReKi     = SiKi                              ! Default kind for floating-point numbers
INTEGER, PARAMETER              :: DbKi     = R8Ki                              ! Default kind for double floating-point numbers


      ! The number of bytes in the default variables

INTEGER(IntKi), PARAMETER       :: BytesPerReKi  = 4                            ! Number of bytes per ReKi number     - use SIZEOF()           
INTEGER(IntKi), PARAMETER       :: BytesPerDbKi  = 8                            ! Number of bytes per DbKi number     - use SIZEOF()          
INTEGER(IntKi), PARAMETER       :: BytesPerIntKi = 4                            ! Number of bytes per IntKi number    - use SIZEOF()           


END MODULE Precision
MODULE SysSubs


   ! This module contains routines with system-specific logic and references.
   ! It also contains standard (but not system-specific) routines it uses.

   ! SysGnu.f90 is specifically for the GNU Fortran (gfortran) compiler on Linux. This should also work for gfortran on MAC.


   ! It contains the following routines:

   !     FUNCTION    COMMAND_ARGUMENT_COUNT()
   !     SUBROUTINE  FileSize ( FileName, Size )
   !     SUBROUTINE  FindLine ( Str , MaxLen , StrEnd )
   !     SUBROUTINE  FlushOut ( Unit )
   !     SUBROUTINE  Get_Arg ( Arg_Num , Arg , Error )                                      ! Please use GET_COMMAND_ARGUMENT() instead.
   !     SUBROUTINE  Get_Arg_Num ( Arg_Num )                                                ! Please use COMMAND_ARGUMENT_COUNT() instead.
   !     SUBROUTINE  GET_COMMAND ( Command, Length, Status )
   !     SUBROUTINE  GET_COMMAND_ARGUMENT ( Number, Value, Length, Status )
   !     SUBROUTINE  GET_CWD( DirName, Status )
   !     FUNCTION    Get_Env( EnvVar )                                                      ! Please use GET_ENVIRONMENT_VARIABLE() instead.
   !     FUNCTION    GET_ENVIRONMENT_VARIABLE( Name, Value, Length, Status, Trim_Name )
   !     FUNCTION    Is_NaN( DblNum )                                                       ! Please use IEEE_IS_NAN() instead
   !     SUBROUTINE  OpenBinFile ( Un, OutFile, RecLen, Error )
   !     SUBROUTINE  OpenBinInpFile( Un, InFile, Error )
   !     SUBROUTINE  OpenCon
   !     SUBROUTINE  OpenUnfInpBEFile ( Un, InFile, RecLen, Error )
   !     SUBROUTINE  ProgExit ( StatCode )
   !     SUBROUTINE  UsrAlarm
   !     FUNCTION    UserTime()                                                             ! Removed: Replace by F95 intrinsic, CPU_TIME().
   !     SUBROUTINE  WrNR ( Str )
   !     SUBROUTINE  WrOver ( Str )
   !     SUBROUTINE  WrScr ( Str )




   USE                             Precision

   IMPLICIT                        NONE


!=======================================================================


   INTEGER                      :: ConRecL  = 120                               ! The record length for console output.
   INTEGER                      :: CU       = 6 !7                                 ! The I/O unit for the console.
   INTEGER                      :: NL_Len   = 2                                 ! The number of characters used for a new line.

   CHARACTER(10)                :: Endian   = 'BIG_ENDIAN'                      ! The internal format of numbers.
   CHARACTER( 1)                :: PathSep  = '\'                               ! The path separater.
   CHARACTER( 1)                :: SwChar   = '/'                               ! The switch character for command-line options.
!20110512 jm changed from 'BINARY' to 'UNFORMATTED' because 'BINARY' is not
!standard and caused problems in OPEN statements in NWTC_iO.f90 that use
!this definition
   CHARACTER(11)                :: UnfForm  = 'UNFORMATTED'                     ! The string to specify unformatted I/O files.


CONTAINS

!=======================================================================
   FUNCTION COMMAND_ARGUMENT_COUNT()


      ! This routine returns the number of argumenta entered on the command line..

      ! Note: This routine will be available intrinsically in Fortran 2000.


      ! Function declaration.

   INTEGER                      :: COMMAND_ARGUMENT_COUNT                       ! This function.  The command line.



      ! Determine the mumber of arguments.  Load the program name into the result.

   COMMAND_ARGUMENT_COUNT = IArgC()


   RETURN
   END FUNCTION COMMAND_ARGUMENT_COUNT ! ()
!=======================================================================
   SUBROUTINE FileSize ( FileName, Size )


      ! This routine calls the routine Stat to obtain the file size
      ! corresponding to a file name or returns -1 on error.

      ! mlb: WARNING!!!
      ! The standard version of the routine uses the file unit instead of file name.
      ! We need fix the routines that call this one.


      ! Argument declarations:

   INTEGER, INTENT(OUT)         :: Size

   CHARACTER(*), INTENT(IN)     :: FileName


      ! Intrinsic declarations:

   INTEGER(KIND=1)              :: Stat


      ! Local declarations:

   INTEGER                      :: StatArray(12)
   INTEGER                      :: Status



   Status = Stat( FileName, StatArray )

   IF ( Status /= 0 ) THEN
     Size = -1
   ELSE
     Size = StatArray(8)
   END IF


   RETURN
   END SUBROUTINE FileSize ! ( FileName, Size )
!=======================================================================
   SUBROUTINE FindLine ( Str , MaxLen , StrEnd )


      ! This routine finds one line of text with a maximum length of MaxLen from the Str.
      ! It tries to break the line at a blank.

      ! This routine isn't system specific, but it is called by WrScr(), which is, so it must be here.


   IMPLICIT                        NONE


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: MaxLen                                       ! The maximum length of the string.
   INTEGER, INTENT(OUT)         :: StrEnd                                       ! The location of the end of the string.

   CHARACTER(*), INTENT(IN)     :: Str                                          ! The string to search.


      ! Local declarations:

   INTEGER         IC



   StrEnd = MaxLen

   IF ( LEN_TRIM( Str ) > MaxLen )  THEN

      IC = INDEX( Str(1:MaxLen), ' ', BACK = .TRUE. ) ! Find the last space in the line

      IF ( IC > 1 ) THEN ! We don't want to return just one character that's a space, or do we?

         StrEnd = IC-1    ! StrEnd > 0
         DO WHILE ( Str(StrEnd:StrEnd) == ' ' )
            StrEnd = StrEnd - 1
            IF ( StrEnd <= 0 ) THEN  ! This occurs if everything before IC is a space
               StrEnd = IC
               EXIT
            ENDIF
         ENDDO

      ENDIF ! IC > 1

   ENDIF ! LEN_TRIM( Str ) > MaxLen


   RETURN
   END SUBROUTINE FindLine ! ( Str , MaxLen , StrEnd )
!=======================================================================
   SUBROUTINE FlushOut ( Unit )


      ! This subroutine flushes the buffer on the specified Unit.
      ! It is especially useful when printing "running..." type messages.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: Unit                                         ! The unit number of the file being flushed.



  ! CALL FLUSH ( Unit )


   RETURN
   END SUBROUTINE FlushOut ! ( Unit )
!=======================================================================
   SUBROUTINE Get_Arg ( Arg_Num , Arg , Error )


      ! This routine gets Arg_Num'th argument from the command line.

   ! Note: The functionality in this routine was replaced by GET_COMMAND_ARGUMENT(), which is available intrinsically in Fortran 2000.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Arg_Num                                      ! The argument number to get.

   LOGICAL, INTENT(OUT)         :: Error                                        ! The Error flag returned to the calling program.

   CHARACTER(*), INTENT(OUT)    :: Arg                                          ! The argument string returned to the calling program.


      ! Local declarations.

   INTEGER                      :: Status                                       ! The status of the attempt to get an argument.



   CALL GETARG ( Arg_Num, Arg )  !20110512 jm remove 3rd arg for Linux port

   IF ( LEN_TRIM( Arg ) > 0 )  THEN
      Error = .FALSE.
   ELSE
      Error = .TRUE.
   END IF


   RETURN
   END SUBROUTINE Get_Arg ! ( Arg_Num , Arg , Error )
!=======================================================================
   SUBROUTINE Get_Arg_Num ( Arg_Num )


      ! This routine gets the number of command line arguments.

   ! Note: The functionality in this routine was replaced by COMMAND_ARGUMENT_COUNT(), which will be available intrinsically in Fortran 2000.


      ! Argument declarations.

   INTEGER, INTENT(OUT)         :: Arg_Num                                      ! The argument to get from the command line.



   Arg_Num = IARGC()


   RETURN
   END SUBROUTINE Get_Arg_Num ! ( Arg_Num )
!=======================================================================
   SUBROUTINE GET_COMMAND ( Command, Length, Status )


      ! This routine returns the string associated with the full command line.
      ! It tries as best it can to mimic the Fortran 2000 intrinsic subroutine by the same name.


      ! Argument declarations.

   INTEGER, OPTIONAL, INTENT(OUT)      :: Length                                ! The length of the value of the environment variable.
   INTEGER, OPTIONAL, INTENT(OUT)      :: Status                                ! The status indication what happened.

   CHARACTER(*), OPTIONAL, INTENT(OUT) :: Command                               ! The command line.


      ! Local parameter declarations.

   INTEGER, PARAMETER                  :: MaxLen = 500                          ! The maximum length permitted for an environment variable value.


      ! Local declarations.

   INTEGER                             :: CallStat                              ! Status of the call.
   INTEGER                             :: IArg                                  ! Argument index.

   CHARACTER(MaxLen)                   :: Arg                                   ! The current argument.
   CHARACTER(MaxLen)                   :: ReturnVal                             ! The value that will be returned.



      ! Initialize the result with the program name.

   CALL GETARG ( 0, ReturnVal )  !20110512 jm remove 3rd arg for Linux port


      ! Loop through all the arguments and build the total command line.

   DO IArg=1,IArgC()
      CALL GETARG ( IArg, Arg )  !20110512 jm remove 3rd arg for Linux port
      ReturnVal = TRIM( ReturnVal )//' '//TRIM( Arg )
   END DO ! IArg


      ! When asking the OS about the variable, trim the name unless Trim_Name is false.

   IF ( PRESENT( Command ) )  Command = ReturnVal
   IF ( PRESENT( Length  ) )  Length  = LEN_TRIM( ReturnVal )
   IF ( PRESENT( Status  ) )  Status  = 0


   RETURN
   END SUBROUTINE GET_COMMAND ! ( Command, Length, Status )
!=======================================================================
   SUBROUTINE GET_COMMAND_ARGUMENT ( Number, Value, Length, Status )


      ! This routine returns the string associated with the Numberth command-line argument.
      ! It tries as best it can to mimic the Fortran 2000 intrinsic function by the same name.


      ! Argument declarations.

   INTEGER, OPTIONAL, INTENT(OUT)      :: Length                                ! The length of the value of the environment variable.
   INTEGER, INTENT(IN)                 :: Number                                ! The number of the argument desired.
   INTEGER, OPTIONAL, INTENT(OUT)      :: Status                                ! The status indication what happened.

   CHARACTER(*), OPTIONAL, INTENT(OUT) :: Value                                 ! The command line argument.


      ! Local parameter declarations.

   INTEGER, PARAMETER                  :: MaxLen = 500                          ! The maximum length permitted for an environment variable value.


      ! Local declarations.

   INTEGER                             :: CallStat                              ! The status of the intrinsic call.

   CHARACTER(MaxLen)                   :: ReturnVal                             ! The value that will be returned.



      ! Get the argument.

   CALL GETARG ( Number, ReturnVal )  !20110512 jm remove 3rd arg for Linux port


      ! Load up the return values.

   IF ( PRESENT( Value  ) )  Value  = ReturnVal
   IF ( PRESENT( Length ) )  Length = LEN_TRIM( ReturnVal )
   IF ( PRESENT( Status ) )  Status = CallStat


   RETURN
   END SUBROUTINE GET_COMMAND_ARGUMENT ! ( Number, Value, Length, Status )
!=======================================================================
!bjj note: this subroutine is not tested for this compiler
   SUBROUTINE Get_CWD ( DirName, Status )


      ! This routine retrieves the path of the current working directory.


   IMPLICIT                        NONE


      ! Passed variables.

   CHARACTER(*), INTENT(OUT)    :: DirName                                         ! A CHARACTER string containing the path of the current working directory.
   INTEGER,      INTENT(OUT)    :: Status                                          ! Status returned by the call to a portability routine.


   Status = GETCWD ( DirName )

   RETURN
   END SUBROUTINE Get_CWD
!=======================================================================
   FUNCTION Get_Env( EnvVar )


      ! This routine returns the string associated with the EnvVar environment variable in the OS.
      ! It returns the null string of the variable is not found.

   ! Note: The functionality in this routine was replaced by GET_ENVIRONMENT_VARIABLE(), which will be available intrinsically in Fortran 2000.


      ! Function declaration.

   CHARACTER(500)               :: Get_Env                                      ! This function.  The value of the environment variable.


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: EnvVar                                       ! The environment variable to look up.



   CALL GetEnv ( EnvVar, Get_Env )


   RETURN
   END FUNCTION Get_Env ! ( EnvVar )
!=======================================================================
   FUNCTION GET_ENVIRONMENT_VARIABLE( Name, Value, Length, Status, Trim_Name )


      ! This routine returns the string associated with the Name environment variable in the OS.
      ! It tries as best it can to mimic the Fortran 2000 intrinsic function by the same name.


      ! Argument declarations.

   INTEGER, OPTIONAL, INTENT(OUT)      :: Length                                ! The length of the value of the environment variable.
   INTEGER, OPTIONAL, INTENT(OUT)      :: Status                                ! The status indication what happened.

   LOGICAL, OPTIONAL, INTENT(IN)       :: Trim_Name                             ! Treat trailing blanks in Name as significant if true.

   CHARACTER(*), INTENT(IN)            :: Name                                  ! The environment variable to look up.
   CHARACTER(*), OPTIONAL, INTENT(OUT) :: Value                                 ! The found value of the environment variable, Name.


      ! Local parameter declarations.

   INTEGER, PARAMETER                  :: MaxLen = 500                          ! The maximum length permitted for an environment variable value.


      ! Function declaration.

   CHARACTER(MaxLen)                   :: GET_ENVIRONMENT_VARIABLE              ! This function.  The value of the environment variable.


      ! Local declarations.

   CHARACTER(MaxLen)                   :: ReturnVal                             ! The value that will be returned.



      ! When asking the OS about the variable, trim the name unless Trim_Name is false.

   IF ( PRESENT( Trim_Name ) )  THEN
      IF ( Trim_Name )  THEN
         CALL GetEnv ( TRIM( Name ), ReturnVal )
      ELSE
         CALL GetEnv ( Name, ReturnVal )
      END IF
   ELSE
      CALL GetEnv ( TRIM( Name ), ReturnVal )
   END IF

   IF ( PRESENT( Value ) )  Value = ReturnVal

   IF ( PRESENT( Length ) )  Length = LEN_TRIM( ReturnVal )


      ! If requested, set the status of the OS request.

      ! Because the VF-specific GetEnv() is less capable than the Fortran 2000 intrinsic, we can't distinguish
      ! between a variable whose value is all blanks and one that is not set.

   IF ( PRESENT( Status ) )  THEN
      IF ( LEN_TRIM( ReturnVal ) == 0 )  THEN
         Status = 1
      ELSE
         Status = 0
      END IF
   END IF

   GET_ENVIRONMENT_VARIABLE = ReturnVal


   RETURN
   END FUNCTION GET_ENVIRONMENT_VARIABLE ! ( Name, Value, Length, Status, Trim_Name )
!=======================================================================
   FUNCTION Is_NaN( DblNum )


      ! This routine determines if a REAL(DbKi) variable holds a proper number.
      ! BJJ: this routine is used in CRUNCH.
      ! Note that IsNaN does not exist in earlier versions of gfortran (e.g., 4.2.1), 
      ! but does exist in version 4.4. It should be replaced with the standard 
      ! IEEE_IS_NAN when gfortran implements it.


      ! Argument declarations.

   REAL(DbKi), INTENT(IN)       :: DblNum


      ! Function declaration.

   LOGICAL                      :: Is_Nan



   Is_NaN = IsNaN( DblNum )


   RETURN
   END FUNCTION Is_NaN ! ( DblNum )
!=======================================================================
   SUBROUTINE OpenBinFile ( Un, OutFile, RecLen, Error )


      ! This routine opens a binary output file.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the output file.
   INTEGER, INTENT(IN)          :: RecLen                                       ! Length of binary record.

   LOGICAL, INTENT(OUT)         :: Error                                        ! Flag to indicate the open failed.

   CHARACTER(*), INTENT(IN)     :: OutFile                                      ! Name of the output file.


      ! Local declarations.

   INTEGER                      :: IOS                                          ! I/O status of OPEN.



      ! Open output file.  Make sure it worked.

!20110512 jm Change ACCESS from Sequential to F03std 'stream' to avoid reading/writing record block control words
   OPEN( Un, FILE=TRIM( OutFile ), STATUS='UNKNOWN', FORM='UNFORMATTED' , ACCESS='STREAM', IOSTAT=IOS )

   IF ( IOS /= 0 )  THEN
      Error = .TRUE.
   ELSE
      Error = .FALSE.
   END IF


   RETURN
   END SUBROUTINE OpenBinFile ! ( Un, OutFile, RecLen, Error )
!=======================================================================
   SUBROUTINE OpenBinInpFile ( Un, InFile, Error )


      ! This routine opens a binary input file.

   IMPLICIT                        NONE



      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the input file.

   CHARACTER(*), INTENT(IN)     :: InFile                                       ! Name of the input file.

   LOGICAL, INTENT(OUT)         :: Error                                        ! Flag to indicate the open failed.


      ! Local declarations.

   INTEGER                      :: IOS                                          ! I/O status of OPEN.

      ! NOTE: Do not explicitly declare the precision of this variable [as in
      !       LOGICAL(1)] so that the statements using this variable work with
      !       any compiler:


      ! Open input file.  Make sure it worked.

!20110512 jm Change ACCESS from Sequential to F03std 'stream' to avoid reading/writing record block control words
   OPEN( Un, FILE=TRIM( InFile ), STATUS='OLD', FORM='UNFORMATTED', ACCESS='STREAM', IOSTAT=IOS, ACTION='READ' )

   IF ( IOS /= 0 )  THEN
      Error = .TRUE.
   ELSE
      Error = .FALSE.
   END IF


   RETURN
   END SUBROUTINE OpenBinInpFile
!=======================================================================
 SUBROUTINE OpenCon


      ! This routine opens the console for standard output.



   OPEN ( CU , FILE='/dev/stdout' , STATUS='OLD' )

   CALL FlushOut ( CU )


   RETURN
   END SUBROUTINE OpenCon
!=======================================================================
   SUBROUTINE OpenUnfInpBEFile ( Un, InFile, RecLen, Error )


      ! This routine opens a binary input file with data stored in Big Endian format (created on a UNIX machine.)
      ! Data are stored in RecLen-byte records.

   IMPLICIT                        NONE



      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the input file.

   CHARACTER(*), INTENT(IN)     :: InFile                                       ! Name of the input file.

   INTEGER, INTENT(IN)          :: RecLen                                       ! Size of records in the input file, in bytes.

   LOGICAL, INTENT(OUT)         :: Error                                        ! Flag to indicate the open failed.


      ! Local declarations.

   INTEGER                      :: IOS                                          ! I/O status of OPEN.



      ! Open input file.  Make sure it worked.

   ! The non-standard CONVERT keyword allows us to read UNIX binary files, whose bytes are in reverse order (i.e., stored in BIG ENDIAN format).

   ! NOTE: using RecLen in bytes requires using the /assume:byterecl compiler option!

   OPEN ( Un, FILE=TRIM( InFile ), STATUS='OLD', FORM='UNFORMATTED', ACCESS='DIRECT', RECL=RecLen, IOSTAT=IOS, &
                   ACTION='READ'  )                                              ! Use this for UNIX systems.
!                  ACTION='READ', CONVERT='BIG_ENDIAN' )                         ! Use this for PC systems.


   IF ( IOS /= 0 )  THEN
      Error = .TRUE.
   ELSE
      Error = .FALSE.
   END IF


   RETURN
   END SUBROUTINE OpenUnfInpBEFile
!=======================================================================
   SUBROUTINE ProgExit ( StatCode )


      ! This routine stops the program.  If the compiler supports the EXIT routine,
      ! pass the program status to it.  Otherwise, do a STOP.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: StatCode                                      ! The status code to pass to the OS.



   CALL EXIT ( StatCode )

!   IF ( StatCode == 0 ) THEN
!      STOP 0
!   ELSE
!      IF ( StatCode < 0 ) THEN
!         CALL WrScr( 'Invalid STOP code.' )
!      END IF
!
!      STOP 1
!   END IF


   RETURN
   END SUBROUTINE ProgExit ! ( StatCode )
!=======================================================================
   SUBROUTINE UsrAlarm


      ! This routine generates an alarm to warn the user that something went wrong.



   CALL WrOver ( CHAR( 7 ) )


   RETURN
   END SUBROUTINE UsrAlarm
!=======================================================================
!   FUNCTION UserTime()
!
!
!      ! This function returns the user CPU time.
!
!      ! The functionality of this routine was replaced by the F95 intrinsic, CPU_TIME().
!
!
!      ! Passed variables.
!
!   REAL(4)                      :: UserTime                                        ! User CPU time.
!
!
!      ! Local variables.
!
!   REAL(4)                      :: TimeAry (2)                                     ! TimeAry(1): User CPU time, TimeAry(2): System CPU time.
!   REAL(4)                      :: TotTime                                         ! User CPU time plus system CPU time.
!
!
!
!
!   TotTime  = DTIME( TimeAry )
!   UserTime = TimeAry(1)
!
!
!   RETURN
!   END FUNCTION UserTime
!=======================================================================
   SUBROUTINE WrNR ( Str )


      ! This routine writes out a string to the screen without following it with a new line.


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: Str                                          ! The string to write to the screen.



   WRITE (CU,'(1X,A)',ADVANCE='NO')  Str


   RETURN
   END SUBROUTINE WrNR ! ( Str )
!=======================================================================
   SUBROUTINE WrOver ( Str )


      ! This routine writes out a string that overwrites the previous line


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: Str                                          ! The string to write to the screen.



   WRITE (CU,'(''+'',A)')  Str


   RETURN
   END SUBROUTINE WrOver ! ( Str )
!=======================================================================
   SUBROUTINE WrScr ( Str )


      ! This routine writes out a string to the screen.


   IMPLICIT                        NONE


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: Str                                          ! The string to write to the screen.


      ! Local declarations.

   INTEGER                      :: Beg                                          ! The beginning of the next line of text.
   INTEGER                      :: Indent                                       ! The amunt to be indented.
   INTEGER                      :: LStr                                         ! The length of the remaining portion of the string.
   INTEGER                      :: MaxLen                                       ! Maximum number of columns to be written to the screen.

   CHARACTER(10)                :: Frm                                          ! Format specifier for the output.



      ! Find the amount of indent.  Create format.

   MaxLen = 98
   Indent = LEN_TRIM( Str ) - LEN_TRIM( ADJUSTL( Str ) )
   Indent = MIN( Indent, MaxLen-2 )                                              ! at least 2 characters per line
   MaxLen = MaxLen - Indent

   IF ( Indent > 0 )  THEN
      Frm    = '(1X,  X,A)'
      WRITE (Frm(5:6),'(I2)')  Indent
   ELSE
      Frm    = '(1X,A)'
   END IF



   !  Break long messages into multiple lines.

   Beg  = Indent + 1
   LStr = LEN_TRIM( Str(Beg:) )

   DO WHILE ( Lstr > MaxLen )

      CALL FindLine ( Str(Beg:) , MaxLen , LStr )

      WRITE (CU,Frm)  TRIM( ADJUSTL( Str(Beg:Beg+LStr-1) ) )

      Beg = Beg + LStr


         ! If we have a space at the beginning of the string, let's get rid of it

      DO WHILE ( Beg < LEN_TRIM( Str ) .AND. Str(Beg:Beg) == ' ' )
         Beg = Beg + 1
      ENDDO

      LStr = LEN_TRIM( Str(Beg:) )

   ENDDO

   IF ( LStr > 0 ) THEN
      WRITE (CU,Frm)  TRIM( ADJUSTL( Str(Beg:Beg+LStr-1) ) )
   ELSE
      WRITE (CU,'()')
   END IF


   RETURN
   END SUBROUTINE WrScr ! ( Str )
!=======================================================================

END MODULE SysSubs
MODULE NWTC_IO


   ! This module contains I/O-related variables and routines with non-system-specific logic.


   ! It contains the following routines:

   !     SUBROUTINE CheckArgs     ( InputFile [, ErrStat] )
   !     SUBROUTINE CheckIOS      ( IOS, Fil, Variable, VarType [, TrapErrors] )
   !     SUBROUTINE CloseEcho     ( )
   !     SUBROUTINE Conv2UC       ( Str )
   !     FUNCTION   CountWords    ( Line )
   !     FUNCTION   CurDate       ( )
   !     FUNCTION   CurTime       ( )
   !     SUBROUTINE DispNVD       ( )
   !     FUNCTION   Flt2LStr      ( FltNum )
   !     SUBROUTINE GetNewUnit    ( UnIn )
   !     SUBROUTINE GetPath       ( GivenFil, PathName )
   !     SUBROUTINE GetRoot       ( GivenFil, RootName )
   !     SUBROUTINE GetTokens     ( Line, NumTok, Tokens, Error )
   !     SUBROUTINE GetWords      ( Line, Words, NumWords )
   !     FUNCTION   GetNVD        ( ProgDesc )
   !     FUNCTION   Int2LStr      ( Intgr )
   !     SUBROUTINE NameOFile     ( InArg, OutExten, OutFile )
   !     SUBROUTINE NormStop      ( )
   !     FUNCTION   Num2LStr      ( Num )                                                             ! Generic interface for Int2LStr, R2LStr4, R2LStr8, R2LStr16
   !     SUBROUTINE OpenBin       ( Un, OutFile, RecLen [, ErrStat] )
   !     SUBROUTINE OpenBInpFile  ( Un, InFile [, ErrStat] )
   !     SUBROUTINE OpenEcho      ( Un, InFile [, ErrStat] )
   !     SUBROUTINE OpenFInpFile  ( Un, InFile [, ErrStat] )
   !     SUBROUTINE OpenFOutFile  ( Un, OutFile [, ErrStat] )
   !     SUBROUTINE OpenFUnkFile  ( Un, OutFile, FailAbt, Failed, Exists [, ErrStat] )
   !     SUBROUTINE OpenUInfile   ( Un, InFile [, ErrStat] )
   !     SUBROUTINE OpenUInBEFile ( Un, InFile, RecLen [, ErrStat] )
   !     SUBROUTINE OpenUOutfile  ( Un, OutFile [, ErrStat] )
   !     FUNCTION   PathIsRelative( GivenFil )
   !     SUBROUTINE PremEOF       ( Fil , Variable [, TrapErrors] )
   !     SUBROUTINE ProgAbort     ( Message [, TrapErrors] )
   !     SUBROUTINE ProgWarn      ( Message )
   !     SUBROUTINE ReadAry       ( UnIn, Fil, Ary, AryLen, AryName, AryDescr [, ErrStat] )           ! Generic interface for ReadCAry, ReadIAry, ReadLAry, and ReadRAry.
   !     SUBROUTINE ReadAryLines  ( UnIn, Fil, Ary, AryLen, AryName, AryDescr [, ErrStat] )           ! Generic interface for ReadCAryLines, ReadRAryLines4, ReadRAryLines8, and ReadRAryLines16.
   !     SUBROUTINE ReadCAry      ( UnIn, Fil, CharAry, AryLen, AryName, AryDescr [, ErrStat] )
   !     SUBROUTINE ReadCAryLines ( UnIn, Fil, CharAry, AryLen, AryName, AryDescr [, ErrStat] )
   !     SUBROUTINE ReadCom       ( UnIn, Fil, ComName [, ErrStat] )
   !     SUBROUTINE ReadCVar      ( UnIn, Fil, CharVar, VarName, VarDescr [, ErrStat] )
   !     SUBROUTINE ReadFASTbin   ( UnIn, FASTdata [, ErrLev, ErrMsg] )                               ! Read a FAST binary output file.
   !     SUBROUTINE ReadIAry      ( UnIn, Fil, IntAry, AryLen, AryName, AryDescr [, ErrStat] )
   !     SUBROUTINE ReadIVar      ( UnIn, Fil, IntVar, VarName, VarDescr [, ErrStat] )
   !     SUBROUTINE ReadLAry      ( UnIn, Fil, LogAry, AryLen, AryName, AryDescr [, ErrStat] )
   !     SUBROUTINE ReadLVar      ( UnIn, Fil, LogVar, VarName, VarDescr [, ErrStat] )
   !     SUBROUTINE ReadNum       ( UnIn, Fil, Word, VarName, ErrStat )
   !     SUBROUTINE ReadOutputList( UnIn, Fil, CharAry, AryLenRead, AryName, AryDescr, ErrStat )
   !     SUBROUTINE ReadRAry      ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
   !     SUBROUTINE ReadRAryLines ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
   !     SUBROUTINE ReadRVar      ( UnIn, Fil, RealVar, VarName, VarDescr [, ErrStat] )
   !     SUBROUTINE ReadStr       ( UnIn, Fil, CharVar, VarName, VarDescr [, ErrStat] )
   !     SUBROUTINE ReadVar       ( UnIn, Fil, Var, VarName, VarDescr [, ErrStat] )                   ! Generic interface for ReadCVar, ReadIVar, ReadLVar, and ReadRVar.
   !     SUBROUTINE WaitTime      ( WaitSecs )
   !     SUBROUTINE WrPr          ( Str )
   !     SUBROUTINE WrFileNR      ( Unit, Str )
   !     SUBROUTINE WrML          ( Str )
   !     SUBROUTINE WrScr1        ( Str )


   USE                             SysSubs

   IMPLICIT  NONE

!=======================================================================

   TYPE, PUBLIC :: ProgDesc
      CHARACTER(24)              :: Name
      CHARACTER(99)              :: Ver
      CHARACTER(24)              :: Date
   END TYPE ProgDesc

   TYPE, PUBLIC :: FASTdataType                                                  ! The derived type for holding FAST binary output data.
      CHARACTER(1024)            :: File                                         ! The name of the binary input file containing FAST output.
      CHARACTER(1024)            :: Descr                                        ! The file descriptor stored in the FAST binary output file.
      INTEGER(B4Ki)              :: NumChans                                     ! The number of channels of FAST output data (including time).
      INTEGER(B4Ki)              :: NumRecs                                      ! The number of records of FAST output data.
      REAL(R8Ki)                 :: TimeStep                                     ! The time step.
      CHARACTER(20), ALLOCATABLE :: ChanNames(:)                                 ! The channel names.
      CHARACTER(20), ALLOCATABLE :: ChanUnits(:)                                 ! The channel units.
      REAL(ReKi)   , ALLOCATABLE :: Data(:,:)                                    ! The channel data.  Time is stored in the first column.
   END TYPE FASTdataType

   INTEGER(IntKi), PARAMETER     :: ErrID_None   = 0
   INTEGER(IntKi), PARAMETER     :: ErrID_Info   = 1
   INTEGER(IntKi), PARAMETER     :: ErrID_Warn   = 2
   INTEGER(IntKi), PARAMETER     :: ErrID_Severe = 3
   INTEGER(IntKi), PARAMETER     :: ErrID_Fatal  = 4

   INTEGER(IntKi)                :: AbortErrLev  = ErrID_Fatal

      ! Global I/O-related variables.

   INTEGER(IntKi), PARAMETER     :: FlgType  = 1                                 ! Switch for telling if a variable is a flag.
   INTEGER(IntKi), PARAMETER     :: NumType  = 2                                 ! Switch for telling if a variable is a number.
   INTEGER(IntKi), PARAMETER     :: StrType  = 3                                 ! Switch for telling if a variable is a string.
   INTEGER                       :: UnEc     = 19                                ! I/O unit number for the echo file.

   LOGICAL                       :: Beep     = .TRUE.                            ! Flag that specifies whether or not to beep for error messages and program terminations.
   LOGICAL                       :: Echo     = .FALSE.                           ! Flag that specifies whether or not to produce an echo file.

   TYPE(ProgDesc), PARAMETER     :: NWTC_Ver = ProgDesc( 'NWTC Subroutine Library', 'v1.06.00b-bjj', '07-Dec-2012')       ! The name, version, and date of the NWTC Subroutine Library.
   CHARACTER(20)                 :: ProgName = ' '                               ! The name of the calling program.
   CHARACTER(99)                 :: ProgVer                                      ! The version (including date) of the calling program.
   CHARACTER(1), PARAMETER       :: Tab      = CHAR( 9 )                         ! The tab character.


!=======================================================================

      ! Create interface for a generic AllocAry that actually uses specific routines.

   INTERFACE AllocAry
      MODULE PROCEDURE AllCAry1
      MODULE PROCEDURE AllCAry2
      MODULE PROCEDURE AllCAry3
   !   MODULE PROCEDURE AllCAry4                               Not yet coded.
      MODULE PROCEDURE AllIAry1
      MODULE PROCEDURE AllIAry2
      MODULE PROCEDURE AllIAry3
   !   MODULE PROCEDURE AllIAry4                               Not yet coded.
      MODULE PROCEDURE AllLAry1
      MODULE PROCEDURE AllLAry2
      MODULE PROCEDURE AllLAry3
   !   MODULE PROCEDURE AllLAry4                               Not yet coded.
      MODULE PROCEDURE AllRAry1
      MODULE PROCEDURE AllRAry2
      MODULE PROCEDURE AllRAry3
      MODULE PROCEDURE AllRAry4
   END INTERFACE


      ! Create interface for a generic ReadVar that actually uses specific routines.

   INTERFACE ReadVar
      MODULE PROCEDURE ReadCVar
      MODULE PROCEDURE ReadIVar
      MODULE PROCEDURE ReadLVar
      MODULE PROCEDURE ReadR4Var     ! 4-byte real
      MODULE PROCEDURE ReadR8Var     ! 8-byte real
      MODULE PROCEDURE ReadR16Var    ! 16-byte real
   END INTERFACE


      ! Create interface for a generic ReadAry that actually uses specific routines.

   INTERFACE ReadAry
      MODULE PROCEDURE ReadCAry
      MODULE PROCEDURE ReadIAry
      MODULE PROCEDURE ReadLAry
      MODULE PROCEDURE ReadRAry ! replace with routines for 4-, 8-, and 16-byte reals
   END INTERFACE


   INTERFACE ReadAryLines
      MODULE PROCEDURE ReadCAryLines
      MODULE PROCEDURE ReadRAryLines4
      MODULE PROCEDURE ReadRAryLines8
      MODULE PROCEDURE ReadRAryLines16
!     MODULE PROCEDURE ReadIAryLines         ! Not coded yet
!     MODULE PROCEDURE ReadLAryLines         ! Not coded yet
   END INTERFACE


      ! Create interface for a generic Num2LStr that actually uses specific routines.

   INTERFACE Num2LStr
      MODULE PROCEDURE Int2LStr        ! default integers
      MODULE PROCEDURE R2LStr4         ! 4-byte  reals
      MODULE PROCEDURE R2LStr8         ! 8-byte  reals
      MODULE PROCEDURE R2LStr16        ! 16-byte reals
   END INTERFACE


      ! Create interface for DispNVD so that we can pass in the name of the program

   INTERFACE DispNVD
      MODULE PROCEDURE DispNVD0        ! No arguments.
      MODULE PROCEDURE DispNVD1        ! Single argument of TYPE ProgDesc
      MODULE PROCEDURE DispNVD2        ! Two arguments of TYPE character
   END INTERFACE


CONTAINS

!=======================================================================
   SUBROUTINE AdjRealStr( NumStr )

      ! This routine adjusts strings created from real numbers (4, 8, or 16-byte)
      ! It removes leading spaces and trailing zeros. It is intended to be called
      ! from routines R2LStr4, R2LStr8, and R2LStr16.

   CHARACTER(*), INTENT(INOUT) :: NumStr       ! String representing a real number (e.g., from R2LStr4)

         ! Local declarations.

   INTEGER                      :: IC          ! Character index.


   NumStr = ADJUSTL( NumStr )


      ! Replace trailing zeros and possibly the decimal point with blanks.
      ! Stop trimming once we find the decimal point or a nonzero.


      ! Don't remove (important!) trailing zeros if they are in the exponent:

   IF (INDEX( NumStr, "E" ) > 0 ) RETURN
   IF (INDEX( NumStr, "e" ) > 0 ) RETURN

      ! These are not in the exponent

   DO IC=LEN_TRIM( NumStr ),1,-1

      IF ( NumStr(IC:IC) == '.' )  THEN
         NumStr(IC:IC) = ' '
         RETURN
      ELSE IF ( NumStr(IC:IC) /= '0' )  THEN
         RETURN
      END IF

      NumStr(IC:IC) = ' '

   END DO ! IC


   END SUBROUTINE AdjRealStr
!=======================================================================
   SUBROUTINE AllCAry1 ( Ary, AryDim, Descr, ErrStat )

      ! This routine allocates a 1-D CHARACTER array.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryDim                                      ! The size of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error


   CHARACTER(*), ALLOCATABLE    :: Ary    (:)                                 ! Array to be allocated
   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim) , STAT=Sttus )


   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus

   RETURN
   END SUBROUTINE AllCAry1 ! ( Ary, AryDim, Descr )
!=======================================================================
   SUBROUTINE AllCAry2 (  Ary, AryDim1, AryDim2, Descr, ErrStat )

      ! This routine allocates a 2-D CHARACTER array.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), ALLOCATABLE    :: Ary    (:,:)                                ! Array to be allocated
   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllCAry2 ! (  Ary, AryDim1, AryDim2, Descr )
!=======================================================================
   SUBROUTINE AllCAry3 (  Ary, AryDim1, AryDim2, AryDim3, Descr, ErrStat )


      ! This routine allocates a 3-D CHARACTER array.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim3                                     ! The size of the third dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error


   CHARACTER(*), ALLOCATABLE    :: Ary    (:,:,:)                              ! Array to be allocated
   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2,AryDim3) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllCAry3 ! (  Ary, AryDim1, AryDim2, AryDim3, Descr )
!=======================================================================
   SUBROUTINE AllIAry1 ( Ary, AryDim, Descr, ErrStat )


      ! This routine allocates a 1-D INTEGER array.


      ! Argument declarations.

   INTEGER, ALLOCATABLE         :: Ary    (:)                                  ! Array to be allocated
   INTEGER, INTENT(IN)          :: AryDim                                      ! The size of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus

   RETURN
   END SUBROUTINE AllIAry1 ! ( Ary, AryDim, Descr )
!=======================================================================
   SUBROUTINE AllIAry2 (  Ary, AryDim1, AryDim2, Descr, ErrStat )


      ! This routine allocates a 2-D INTEGER array.


      ! Argument declarations.

   INTEGER, ALLOCATABLE         :: Ary    (:,:)                                ! Array to be allocated
   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus

   RETURN
   END SUBROUTINE AllIAry2 ! (  Ary, AryDim1, AryDim2, Descr )
!=======================================================================
   SUBROUTINE AllIAry3 (  Ary, AryDim1, AryDim2, AryDim3, Descr, ErrStat )


      ! This routine allocates a 3-D INTEGER array.


      ! Argument declarations.

   INTEGER, ALLOCATABLE         :: Ary    (:,:,:)                              ! Array to be allocated
   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim3                                     ! The size of the third dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2,AryDim3) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllIAry3 ! (  Ary, AryDim1, AryDim2, AryDim3, Descr )
!=======================================================================
   SUBROUTINE AllLAry1 ( Ary, AryDim, Descr, ErrStat )


      ! This routine allocates a 1-D LOGICAL array.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryDim                                      ! The size of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   LOGICAL, ALLOCATABLE         :: Ary    (:)                                  ! Array to be allocated

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllLAry1 ! ( Ary, AryDim, Descr )
!=======================================================================
   SUBROUTINE AllLAry2 (  Ary, AryDim1, AryDim2, Descr, ErrStat )


      ! This routine allocates a 2-D LOGICAL array.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   LOGICAL, ALLOCATABLE         :: Ary    (:,:)                                ! Array to be allocated

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllLAry2 ! (  Ary, AryDim1, AryDim2, Descr )
!=======================================================================
   SUBROUTINE AllLAry3 (  Ary, AryDim1, AryDim2, AryDim3, Descr, ErrStat )


      ! This routine allocates a 3-D LOGICAL array.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim3                                     ! The size of the third dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   LOGICAL, ALLOCATABLE         :: Ary    (:,:,:)                              ! Array to be allocated

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2,AryDim3) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllLAry3 ! (  Ary, AryDim1, AryDim2, AryDim3, Descr )
!=======================================================================
   SUBROUTINE AllRAry1 ( Ary, AryDim, Descr, ErrStat )


      ! This routine allocates a 1-D REAL array.


      ! Argument declarations.

   REAL(ReKi), ALLOCATABLE      :: Ary    (:)                                  ! Array to be allocated

   INTEGER, INTENT(IN)          :: AryDim                                      ! The size of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllRAry1 ! ( Ary, AryDim, Descr )
!=======================================================================
   SUBROUTINE AllRAry2 (  Ary, AryDim1, AryDim2, Descr, ErrStat )


      ! This routine allocates a 2-D REAL array.


      ! Argument declarations.

   REAL(ReKi), ALLOCATABLE      :: Ary    (:,:)                                ! Array to be allocated

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllRAry2 ! (  Ary, AryDim1, AryDim2, Descr )
!=======================================================================
   SUBROUTINE AllRAry3 (  Ary, AryDim1, AryDim2, AryDim3, Descr, ErrStat )


      ! This routine allocates a 3-D REAL array.


      ! Argument declarations.

   REAL(ReKi), ALLOCATABLE      :: Ary    (:,:,:)                              ! Array to be allocated

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim3                                     ! The size of the third dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2,AryDim3) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
  END SUBROUTINE AllRAry3 ! (  Ary, AryDim1, AryDim2, AryDim3, Descr )
!=======================================================================
   SUBROUTINE AllRAry4 (  Ary, AryDim1, AryDim2, AryDim3, AryDim4, Descr, ErrStat )


      ! This routine allocates a 4-D REAL array.


      ! Argument declarations.

   REAL(ReKi), ALLOCATABLE      :: Ary    (:,:,:,:)                            ! Array to be allocated

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim3                                     ! The size of the third dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim4                                     ! The size of the fourth dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2,AryDim3,AryDim4) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
  END SUBROUTINE AllRAry4 ! (  Ary, AryDim1, AryDim2, AryDim3, AryDim4, Descr )
!=======================================================================
!bjj: shouldn't this come after the next subroutine, alphabetically?
   SUBROUTINE CheckIOS ( IOS, Fil, Variable, VarType, TrapErrors )


      ! This routine checks the I/O status and prints either an end-of-file or
      ! an invalid-input message, and then aborts the program.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: IOS                                          ! I/O status.
   INTEGER, INTENT(IN)          :: VarType                                      ! Type of variable.

   LOGICAL, INTENT(IN), OPTIONAL:: TrapErrors                                   ! Determines if the program should abort or return to calling function
   LOGICAL                      :: TrapThisError                                ! The local version of TrapErrors

   CHARACTER(*), INTENT(IN)     :: Fil                                          ! Name of input file.
   CHARACTER(*), INTENT(IN)     :: Variable                                     ! Variable name.


   IF ( PRESENT( TrapErrors ) ) THEN
      TrapThisError = TrapErrors
   ELSE
      TrapThisError = .FALSE.
   END IF


   IF ( IOS < 0 )  THEN

      CALL PremEOF ( TRIM( Fil ), Variable, TrapThisError )

   ELSE IF ( IOS > 0 )  THEN

      SELECTCASE ( VarType )

      CASE ( NumType )
         CALL WrScr1 ( ' Invalid numerical input for file "'//TRIM( Fil )//'".' )
      CASE ( FlgType )
         CALL WrScr1 ( ' Invalid logical input for file "'//TRIM( Fil )//'".' )
      CASE ( StrType )
         CALL WrScr1 ( ' Invalid character input for file "'//TRIM( Fil )//'".' )
      ENDSELECT

      CALL ProgAbort  ( ' The error occurred while trying to read '//TRIM( Variable )//'.', TrapThisError )

   END IF


   RETURN
   END SUBROUTINE CheckIOS ! ( IOS, Fil, Variable, VarType )
!=======================================================================
   SUBROUTINE CheckArgs ( InputFile, ErrStat )


      ! This subroutine is used to check for command-line arguments.


      ! Argument declarations:
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                      ! Error status; if present, program does not abort on error
!bjj: I made this INOUT instead of OUT so that a default input name can be used
!bjj: MLB requests no default InputFile names be allowed; generate error when there is InputFile listed
!Thus, change to
! CALL WrScr1   ( '    '//TRIM( ProgName )//' ['//SwChar//'h] <InputFile>' )
! and add error when NumArg == 0

   CHARACTER(*), INTENT(INOUT)  :: InputFile                                    ! The name of the input file specified on the command line.


      ! Local declarations:

   INTEGER                      :: IArg                                         ! The argument number.
   INTEGER                      :: NumArg                                       ! The number of arguments on the command line.

   LOGICAL                      :: Error                                        ! Flag indicating if there was an error getting an argument.

   CHARACTER(LEN(InputFile))    :: Arg                                          ! A command-line argument.




      ! Find out how many arguments were entered on the command line.

   CALL Get_Arg_Num ( NumArg )


      ! Parse them.

   IF ( NumArg .GT. 0 )  THEN

      DO IArg=1,NumArg

         CALL Get_Arg ( IArg , Arg , Error )

         IF ( Error )  THEN
            CALL ProgAbort ( ' Error getting command-line argument #'//TRIM( Int2LStr( IArg ) )//'.', PRESENT(ErrStat) )
            IF ( PRESENT(ErrStat) ) THEN
               ErrStat = 1
               RETURN
            END IF
         END IF

         IF ( Arg(1:1) == SwChar )  THEN

            CALL WrScr1   ( ' Syntax is:' )
            CALL WrScr1   ( '    '//TRIM( ProgName )//' ['//SwChar//'h] [<InputFile>]' )
            CALL WrScr1   ( ' where:' )
            CALL WrScr1   ( '    '//SwChar//'h generates this help message.' )
            CALL WrScr    ( '    <InputFile> is the name of the primary input file ['//TRIM( InputFile )//'].' )
            CALL WrScr    ( ' ')

            IF ( INDEX( 'Hh?', Arg(2:2)  ) > 0 )  THEN
               IF ( PRESENT(ErrStat) ) THEN
                  ErrStat = -1
                  RETURN
               ELSE
                  CALL ProgExit ( 1 )
               END IF
            ELSE
               CALL ProgAbort ( ' Invalid command-line switch "'//SwChar//TRIM( Arg(2:) )//'".', PRESENT(ErrStat) )
               IF ( PRESENT(ErrStat) ) THEN
                  ErrStat = 1
                  RETURN
               END IF
            END IF

         ELSE
            InputFile = Arg
         END IF

      END DO

   END IF

   IF ( PRESENT( ErrStat ) ) ErrStat = 0

   RETURN
   END SUBROUTINE CheckArgs
!=======================================================================
   SUBROUTINE CloseEcho( )

      ! This subroutine closes the echo file and sets Echo to false

      CLOSE ( UnEc )

      Echo  = .FALSE.

   END SUBROUTINE CloseEcho
!=======================================================================
   SUBROUTINE Conv2UC ( Str )


      ! This routine converts all the text in a string to upper case.


      ! Argument declarations.

   CHARACTER(*), INTENT(INOUT)  :: Str                                          ! The string to be converted to UC.


      ! Local declarations.

   INTEGER                      :: IC                                           ! Character index



   DO IC=1,LEN_TRIM( Str )

      IF ( ( Str(IC:IC) >= 'a' ).AND.( Str(IC:IC) <= 'z' ) )  THEN
         Str(IC:IC) = CHAR( ICHAR( Str(IC:IC) ) - 32 )
      ELSE
         Str(IC:IC) = Str(IC:IC)
      END IF

   END DO ! IC


   RETURN
   END SUBROUTINE Conv2UC !  ( Str )
!=======================================================================
   FUNCTION CountWords ( Line )


      ! This subroutine is used to count the number of "words" in a line of text.
      ! It uses spaces, tabs, commas, semicolons, single quotes, and double quotes ("whitespace")
      !  as word separators.


      ! Function declaration.

   INTEGER                      :: CountWords                                   ! This function.


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: Line                                         ! Count the words in this text string.


      ! Local declarations.

   INTEGER                      :: Ch                                           ! Character position.
   INTEGER                      :: NextWhite                                    ! Position of the next white space.



      ! Let's initialize the number of columns and the character pointer.

   CountWords = 0


      ! Let's make sure we have text on this line.

   IF ( LEN_TRIM( Line ) == 0 )  RETURN


      ! Count words separated by any combination of spaces, tabs, commas,
      ! semicolons, single quotes, and double quotes ("whitespace").

   Ch = 0

   DO

      NextWhite = SCAN( Line(Ch+1:) , ' ,;''"'//Tab )
      Ch        = Ch + NextWhite

      IF ( NextWhite > 1 )  THEN
         CountWords = CountWords + 1
      ELSE IF ( NextWhite == 1 )  THEN
         CYCLE
      ELSE
         EXIT
      END IF

   END DO


   RETURN
   END FUNCTION CountWords ! ( Line )
!=======================================================================
   FUNCTION CurDate( )


      ! This function returns a character string encoded with the date in the form dd-mmm-ccyy.


      ! Function declaration.

   CHARACTER(11)                :: CurDate                                      ! This function


      ! Local declarations.

   CHARACTER(8)                 :: CDate                                        ! String to hold the returned value from the DATE_AND_TIME subroutine call.



   !  Call the system date function.

   CALL DATE_AND_TIME ( CDate )


   !  Parse out the day.

   CurDate(1:3) = CDate(7:8)//'-'


   !  Parse out the month.

   SELECT CASE ( CDate(5:6) )
      CASE ( '01' )
         CurDate(4:6) = 'Jan'
      CASE ( '02' )
         CurDate(4:6) = 'Feb'
      CASE ( '03' )
         CurDate(4:6) = 'Mar'
      CASE ( '04' )
         CurDate(4:6) = 'Apr'
      CASE ( '05' )
         CurDate(4:6) = 'May'
      CASE ( '06' )
         CurDate(4:6) = 'Jun'
      CASE ( '07' )
         CurDate(4:6) = 'Jul'
      CASE ( '08' )
         CurDate(4:6) = 'Aug'
      CASE ( '09' )
         CurDate(4:6) = 'Sep'
      CASE ( '10' )
         CurDate(4:6) = 'Oct'
      CASE ( '11' )
         CurDate(4:6) = 'Nov'
      CASE ( '12' )
         CurDate(4:6) = 'Dec'
   END SELECT


   !  Parse out the year.

   CurDate(7:11) = '-'//CDate(1:4)


   RETURN
   END FUNCTION CurDate ! ()
!=======================================================================
   FUNCTION CurTime( )


      ! This function returns a character string encoded with the time in the form "hh:mm:ss".


      ! Function declaration.

   CHARACTER(8)                 :: CurTime                                      ! This function.


      ! Local declarations.

   CHARACTER(10)                :: CTime                                        ! String to hold the returned value from the DATE_AND_TIME subroutine call.



   CALL DATE_AND_TIME ( TIME=CTime )

   CurTime = CTime(1:2)//':'//CTime(3:4)//':'//CTime(5:6)


   RETURN
   END FUNCTION CurTime ! ()
!=======================================================================
   SUBROUTINE DispNVD0


      ! This routine displays the name of the program, its version, and its release date.


      ! Print out program name, version, and date.

   CALL WrScr1 ( ' Running '//TRIM( ProgName )//' '//Trim( ProgVer )//'.' )


   RETURN
   END SUBROUTINE DispNVD0
!=======================================================================
   SUBROUTINE DispNVD1( ProgInfo )


      ! This routine displays the name of the program, its version, and its release date.


   IMPLICIT NONE
   TYPE( ProgDesc ), INTENT(IN)        :: ProgInfo    ! Contains the name and version info


      ! Print out program name, version, and date.

   CALL WrScr1 ( ' Running '//TRIM( GetNVD( ProgInfo ) )//'.' )


   RETURN
   END SUBROUTINE DispNVD1
!=======================================================================
   SUBROUTINE DispNVD2( Name, Ver )


      ! This routine displays the name of the program, its version, and its release date passed in as strings
      ! This routine is depricated and for legacy purposes only. Please don't use for any new code (Dec-2012)

   IMPLICIT NONE
   CHARACTER(*),  INTENT(IN)           :: Name     ! String containing the name of the program using the library
   CHARACTER(*),  INTENT(IN)           :: Ver      ! String containing the version and date info


      ! Print out program name, version, and date.

   CALL WrScr1 ( ' Running '//TRIM( Name )//' ('//Trim( Ver )//').' )


   RETURN
   END SUBROUTINE DispNVD2
!=======================================================================
   FUNCTION Flt2LStr ( FltNum )


      ! This function converts a floating point number to a left-aligned
      ! string.  It eliminates trailing zeroes and even the decimal
      ! point if it is not a fraction.
      ! This function remains here only for backward compatibility. New
      ! code should use Num2LStr instead.


      ! Function declaration.

   CHARACTER(15)                :: Flt2LStr                                        ! This function.


      ! Argument declarations.

   REAL(ReKi), INTENT(IN)       :: FltNum                                          ! The floating-point number to convert.



      ! Return a 0 if that's what we have.

   IF ( FltNum == 0.0 )  THEN
      Flt2LStr = '0'
      RETURN
   END IF


      ! Write the number into the string using G format and left justify it.

   WRITE (Flt2LStr,'(1PG15.5)')  FltNum

   CALL AdjRealStr( Flt2LStr )

   RETURN
   END FUNCTION Flt2LStr !  ( FltNum )
!=======================================================================
   SUBROUTINE GetNewUnit ( UnIn )

      ! This routine returns a unit number not currently in use.


      ! Argument declarations.

   INTEGER, INTENT(OUT)         :: UnIn                                         ! Logical unit for the file.


      ! Local declarations.

   INTEGER, SAVE                :: Un   = 10                                    ! Unit number; saved between calls (and a GLOBAL) variable
   LOGICAL                      :: Opened                                       ! Flag indicating whether or not a file is opened.



      ! See if unit is connected to an open file. Check the next largest number until it is not opened.

   DO

      INQUIRE ( UNIT=Un , OPENED=Opened )

      IF ( .NOT. Opened )  EXIT
      Un = Un + 1

!      IF ( Un > 99 ) Un = 10                                                     !some systems don't like unit numbers > 99, but we also don't want an infinite loop

   END DO

   UnIn = Un

   RETURN
   END SUBROUTINE GetNewUnit !  ( UnIn )
!=======================================================================
   FUNCTION GetNVD ( ProgInfo )
   
      ! This function converts the three strings contained in the ProgDesc
      ! data type into a single string listing the program name,
      ! version, and release date.
   
   
      ! Argument declarations.
      
   TYPE( ProgDesc ), INTENT(IN)        :: ProgInfo    ! Contains the name and version info
   
   
      ! Function delcaration
      
   CHARACTER(200)                      :: GetNVD      ! A single string containing the name, date, and version info
   
      
      ! Print all the version info into a nice string:
   
      GetNVD = TRIM( ProgInfo%Name )//' ('//Trim( ProgInfo%Ver )//', '//Trim( ProgInfo%Date )//')'

   END FUNCTION GetNVD 
!=======================================================================

   SUBROUTINE GetPath ( GivenFil, PathName )


      ! Let's parse the path name from the name of the given file.
      ! We'll count everything before (and including) the last "\" or "/".


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: GivenFil                                     ! The name of the given file.
   CHARACTER(*), INTENT(OUT)    :: PathName                                     ! The path name of the given file.


      ! Local declarations.

   INTEGER                      :: I                                            ! DO index for character position.


      ! Look for path separators

   I = INDEX( GivenFil, '\', BACK=.TRUE. )
   I = MAX( I, INDEX( GivenFil, '/', BACK=.TRUE. ) )

   IF ( I == 0 ) THEN
      ! we don't have a path specified, return '.'
      PathName = '.'//PathSep
   ELSE
      PathName = GivenFil(:I)
   END IF


   RETURN
   END SUBROUTINE GetPath ! ( GivenFil, PathName )
!=======================================================================
   SUBROUTINE GetRoot ( GivenFil, RootName )


      ! Let's parse the root file name from the name of the given file.
      ! We'll count everything after the last period as the extension.


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: GivenFil                                     ! The name of the given file.
   CHARACTER(*), INTENT(OUT)    :: RootName                                     ! The parsed root name of the given file.


      ! Local declarations.

   INTEGER                      :: I                                            ! DO index for character position.



      ! Deal with a couple of special cases.

   IF ( ( TRIM( GivenFil ) == "." ) .OR. (  TRIM( GivenFil ) == ".." ) )  THEN
      RootName = TRIM( GivenFil )
      RETURN
   END IF


      ! More-normal cases.

   DO I=LEN_TRIM( GivenFil ),1,-1


      IF ( GivenFil(I:I) == '.' )  THEN


         IF ( I < LEN_TRIM( GivenFil ) ) THEN                   ! Make sure the index I is okay
            IF ( INDEX( '\/', GivenFil(I+1:I+1)) == 0 ) THEN    ! Make sure we don't have the RootName in a different directory
               RootName = GivenFil(:I-1)
            ELSE
               RootName = GivenFil                              ! This does not have a file extension
            END IF
         ELSE
            IF ( I == 1 ) THEN
               RootName = ''
            ELSE
               RootName = GivenFil(:I-1)
            END IF
         END IF

         RETURN

      END IF
   END DO ! I

   RootName =  GivenFil


   RETURN
   END SUBROUTINE GetRoot ! ( GivenFil, RootName )
!=======================================================================
   SUBROUTINE GetTokens ( Line, NumTok, Tokens, Error )


      ! This routine will parse Line for NumTok "tokens" and return them in the Tokens array.
      ! THis routine differs from GetWords() in that it uses only spaces as token separators.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: NumTok                                       ! The number of "words" to look for.

   LOGICAL, INTENT(OUT)         :: Error                                        ! Error flag to indicate an insuffient number of tokens were found.

   CHARACTER(*), INTENT(INOUT)  :: Line                                         ! The string to search.
   CHARACTER(*), INTENT(OUT)    :: Tokens  (NumTok)                             ! The tokens that were found.


      ! Local declarations.

   INTEGER                      :: IT                                           ! Token index.
   INTEGER                      :: NextBlank                                    ! The location of the next blank character.



   NextBlank = 0

   DO IT=1,NumTok

      Line      = ADJUSTL( Line(NextBlank+1:) )
      NextBlank = INDEX  ( Line , ' ' )

      IF ( NextBlank == 0 )  THEN
        Error = .TRUE.
        RETURN
      END IF

      Tokens(IT) = Line(1:NextBlank-1)

   END DO ! IT

   Error = .FALSE.


   RETURN
   END SUBROUTINE GetTokens ! ( Line, NumTok, Tokens, Error )
!=======================================================================
   SUBROUTINE GetWords ( Line, Words, NumWords )


      ! This subroutine is used to get NumWords "words" from a line of text.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: NumWords                                     ! The number of words to look for.

   CHARACTER(*), INTENT(IN)     :: Line                                         ! The string to search.
   CHARACTER(*), INTENT(OUT)    :: Words(NumWords)                              ! The array of found words.


      ! Local declarations.

   INTEGER                      :: Ch                                           ! Character position within the string.
   INTEGER                      :: IW                                           ! Word index.
   INTEGER                      :: NextWhite                                    ! The location of the next whitespace in the string.



      ! Let's prefill the array with blanks.

   DO IW=1,NumWords
      Words(IW) = ' '
   END DO ! IW


      ! Let's make sure we have text on this line.

   IF ( LEN_TRIM( Line ) == 0 )  RETURN


      ! Parse words separated by any combination of spaces, tabs, commas,
      ! semicolons, single quotes, and double quotes ("whitespace").

   Ch = 0
   IW = 0

   DO

      NextWhite = SCAN( Line(Ch+1:) , ' ,;''"'//Tab )

      IF ( NextWhite > 1 )  THEN

         IW        = IW + 1
         Words(IW) = Line(Ch+1:Ch+NextWhite-1)

         IF ( IW == NumWords )  EXIT

         Ch = Ch + NextWhite

      ELSE IF ( NextWhite == 1 )  THEN

         Ch = Ch + 1

         CYCLE

      ELSE

         EXIT

      END IF

   END DO


   RETURN
   END SUBROUTINE GetWords ! ( Line, Words, NumWords )
!======================================================================= 
   FUNCTION Int2LStr ( Intgr )


      ! This function returns a left-adjusted string representing the passed integer.



   CHARACTER(11)                :: Int2LStr                                     ! This function.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Intgr                                        ! The integer to convert to a left-justified string.



   WRITE (Int2LStr,'(I11)')  Intgr

   Int2Lstr = ADJUSTL( Int2LStr )


   RETURN
   END FUNCTION Int2LStr ! ( Intgr )
!=======================================================================
   SUBROUTINE NameOFile ( InArg, OutExten, OutFile, ErrStat )


      ! Get the name of the input file from the InArgth command-line argument.
      ! Remove the extension if there is one, and append OutExten to the end.


      ! Argument declarations.

   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                     ! Error status; if present, program does not abort on error
   INTEGER, INTENT(IN)          :: InArg                                        ! The number of the command-line argument that should hold the input file name.

   CHARACTER(*), INTENT(IN)     :: OutExten                                     ! The requested extension for the output file.
   CHARACTER(*), INTENT(OUT)    :: OutFile                                      ! The name of the output file.


      ! Local declarations.

   CHARACTER(100)               :: InFile                                       ! The name of the input file.
   CHARACTER(100)               :: RootName                                     ! The root name of the input file.



      ! See if the command line has enough arguments.

   IF ( InArg > COMMAND_ARGUMENT_COUNT() )  THEN
      CALL ProgAbort ( 'Insufficient arguments on the command line (at least '//&
                         TRIM( Int2LStr( InArg ) )//' were expected).', PRESENT(ErrStat) )
      IF ( PRESENT( ErrStat ) ) ErrStat = 1
      RETURN
   END IF


      ! Get the root of the input file name (strip off the extension).

   CALL GET_COMMAND_ARGUMENT( InArg, InFile )
   CALL GetRoot ( TRIM( InFile ), RootName )

   OutFile = TRIM( RootName )//'.'//OutExten

   IF ( PRESENT( ErrStat ) ) ErrStat = 0

   RETURN
   END SUBROUTINE NameOFile ! ( InArg, OutExten, OutFile [, ErrStat])
!=======================================================================
   SUBROUTINE NormStop


      ! This routine performs a normal termination of the program.


   CALL WrScr1   ( ' '//TRIM( ProgName )//' terminated normally.' )
   CALL WrScr    ( '' )
   CALL ProgExit ( 0 )


   END SUBROUTINE NormStop
!=======================================================================
   SUBROUTINE OpenBin ( Un, OutFile, RecLen, ErrStat )

      ! This routine opens a binary output file.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the output file.
   INTEGER, INTENT(IN)          :: RecLen                                       ! Length of binary record.
   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                     ! Error status; if present, program does not abort on error


   CHARACTER(*), INTENT(IN)     :: OutFile                                      ! Name of the output file.


      ! Local declarations.

   LOGICAL                      :: Error                                        ! Flag to indicate the open failed.


      ! Open output file.  Make sure it worked.

   CALL OpenBinFile ( Un, OutFile, RecLen, Error )

   IF ( Error )  THEN
      CALL ProgAbort ( ' Cannot open file "'//TRIM( OutFile )// &
                       '".  Another program may have locked it for writing.', PRESENT(ErrStat) )
      IF ( PRESENT(ErrStat) ) ErrStat = 1
      RETURN
   ELSE
      IF ( PRESENT(ErrStat) ) ErrStat = 0
   ENDIF


   RETURN
   END SUBROUTINE OpenBin ! ( Un, OutFile, RecLen [, ErrStat] )
!=======================================================================
   SUBROUTINE OpenBInpFile ( Un, InFile, ErrStat )


      ! This routine opens a binary input file.

   IMPLICIT                        NONE



      ! Argument declarations.

   INTEGER, INTENT(IN)            :: Un                                          ! Logical unit for the input file.
   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)       :: InFile                                      ! Name of the input file.


      ! Local declarations.

      ! NOTE: Do not explicitly declare the precision of this variable [as in
      !       LOGICAL(1)] so that the statements using this variable work with
      !       any compiler:
   LOGICAL                      :: Exists                                       ! Flag indicating whether or not a file Exists.
   LOGICAL                      :: Error                                        ! Flag to indicate the open failed.



      ! See if input file Exists.

   INQUIRE ( FILE=TRIM( InFile ) , EXIST=Exists )

   IF ( .NOT. Exists )  THEN
      CALL ProgAbort ( ' The input file, "'//TRIM( InFile )//'", was not found.', PRESENT( ErrStat) )
      IF ( PRESENT( ErrStat) ) ErrStat = -1
      RETURN
   END IF


      ! Open input file.  Make sure it worked.

   CALL OpenBinInpFile ( Un, InFile, Error )

   IF ( Error )  THEN

      CALL ProgAbort ( ' Cannot open file "'//TRIM( InFile )//'".  Another program may have locked it.', PRESENT( ErrStat ) )
      IF ( PRESENT( ErrStat) ) ErrStat = 1
      RETURN

   ELSE

      IF ( PRESENT( ErrStat) ) ErrStat = 0

   END IF


   RETURN
   END SUBROUTINE OpenBInpFile
!=======================================================================
   SUBROUTINE OpenEcho ( Un, OutFile, ErrStat )


      ! This routine opens a formatted output file for the echo file.


      ! Argument declarations.

   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                   ! Error status; if present, program does not abort on error
   INTEGER, INTENT(IN)            :: Un                                        ! Logical unit for the input file.

   CHARACTER(*), INTENT(IN)       :: OutFile                                   ! Name of the input file.




   UnEc = Un

   IF ( PRESENT(ErrStat) ) THEN

      CALL OpenFOutFile( UnEc, OutFile, ErrStat )

   ELSE

      CALL OpenFOutFile( UnEc, OutFile )

   ENDIF

   Echo = .TRUE.

   RETURN
   END SUBROUTINE OpenEcho ! ( Un, OutFile [, ErrStat]  )
!=======================================================================
   SUBROUTINE OpenFInpFile ( Un, InFile, ErrStat )


      ! This routine opens a formatted input file.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                      ! Error status; if present, program does not abort on error
   CHARACTER(*), INTENT(IN)     :: InFile                                       ! Name of the input file.


      ! Local declarations.

   INTEGER                      :: IOS                                          ! I/O status of OPEN.

   LOGICAL                      :: Exists                                       ! Flag indicating whether or not a file Exists.



      ! See if input file Exists.

   INQUIRE ( FILE=TRIM( InFile ) , EXIST=Exists )

   IF ( .NOT. Exists )  THEN
      CALL ProgAbort ( ' The input file, "'//TRIM( InFile )//'", was not found.', PRESENT(ErrStat) )
      IF (PRESENT(ErrStat)) ErrStat = -1
      RETURN
   END IF


      ! Open input file.  Make sure it worked.

   OPEN( Un, FILE=TRIM( InFile ), STATUS='OLD', FORM='FORMATTED', IOSTAT=IOS, ACTION='READ' )

   IF ( IOS /= 0 )  THEN
      CALL ProgAbort ( ' Cannot open file "'//TRIM( InFile ) &
                      //'".  Another program like MS Excel may have locked it for writing.',PRESENT(ErrStat)  )
      IF (PRESENT(ErrStat)) ErrStat = 1
      RETURN
   ELSE
      IF (PRESENT(ErrStat)) ErrStat = 0
   END IF


   RETURN
   END SUBROUTINE OpenFInpFile ! ( Un, InFile [, ErrStat] )
!=======================================================================
   SUBROUTINE OpenFOutFile ( Un, OutFile, ErrStat )


      ! This routine opens a formatted output file.


      ! Argument declarations.

   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                    ! Error status; if present, program does not abort on error
   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the output file.

   CHARACTER(*), INTENT(IN)     :: OutFile                                      ! Name of the output file.


      ! Local declarations.

   INTEGER                      :: IOS                                          ! I/O status of OPEN.



      ! Open output file.  Make sure it worked.

   OPEN( Un, FILE=TRIM( OutFile ), STATUS='UNKNOWN', FORM='FORMATTED', IOSTAT=IOS, ACTION="WRITE" )



   IF ( PRESENT(ErrStat) ) ErrStat = IOS

   IF ( IOS /= 0 )  CALL ProgAbort( ' Cannot open file "'//TRIM( OutFile )// &
                                    '".  Another program like MS Excel may have locked it for writing.', PRESENT(ErrStat) )


   RETURN
   END SUBROUTINE OpenFOutFile ! ( Un, OutFile [, ErrStat] )
!=======================================================================
   SUBROUTINE OpenFUnkFile ( Un, OutFile, FailAbt, Failed, Exists, ErrStat )


      ! This routine opens a formatted output file and returns a flag telling if it already existed.


      ! Argument declarations.

   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                    ! Error status; if present, program does not abort on error
   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the output file.

   LOGICAL, INTENT(OUT)         :: Exists                                       ! Flag that indicates if the file already existedo.
   LOGICAL, INTENT(IN)          :: FailAbt                                      ! Flag that tells this routine to abort if the open fails.
   LOGICAL, INTENT(OUT)         :: Failed                                       ! Flag that indicates if the open failed.

   CHARACTER(*), INTENT(IN)     :: OutFile                                      ! Name of the output file.


      ! Local declarations.

   INTEGER                      :: IOS                                          ! I/O status of OPEN.



      ! Check to see if the file already exists.

   INQUIRE ( FILE=TRIM( OutFile ) , EXIST=Exists )

!bjj: should we be checking something here?


      ! Open output file.  Make sure it worked.

   OPEN( Un, FILE=TRIM( OutFile ), STATUS='UNKNOWN', FORM='FORMATTED', IOSTAT=IOS )

   IF ( PRESENT(ErrStat) ) ErrStat = IOS

   IF ( IOS /= 0 )  THEN
      Failed = .TRUE.
      IF ( FailAbt )  CALL ProgAbort ( ' Cannot open file "'//TRIM( OutFile ) &
                                 //'".  Another program like MS Excel may have locked it for writing.', PRESENT(ErrStat) )
   ELSE
      Failed = .FALSE.
   END IF


   RETURN
   END SUBROUTINE OpenFUnkFile ! ( Un, OutFile, FailAbt, Failed, Exists [,ErrStat] )
!=======================================================================
   SUBROUTINE OpenUInfile ( Un, InFile, ErrStat )


      !  This routine opens an unformatted input file.


      ! Argument declarations.

   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                    ! Error status; if present, program does not abort on error
   INTEGER, INTENT(IN)         ::  Un                                           ! Logical unit for the input file

   CHARACTER(*), INTENT(IN)    ::  InFile                                       ! Name of the input file


      ! Local declarations.

   INTEGER                     ::  IOS                                          ! Returned input/output status.

   LOGICAL                      :: Exists                                       ! Flag indicating whether or not a file Exists.



      ! See if input file Exists.

   INQUIRE ( FILE=TRIM( InFile ) , EXIST=Exists )

   IF ( .NOT. Exists )  THEN
      CALL ProgAbort ( ' The input file, "'//TRIM( InFile )//'", was not found.', PRESENT(ErrStat) )
      IF ( PRESENT(ErrStat) ) ErrStat = -1
      RETURN
   END IF


      ! Open the file.

   OPEN ( Un, FILE=TRIM( InFile ), STATUS='UNKNOWN', FORM=UnfForm, ACCESS='SEQUENTIAL', IOSTAT=IOS, ACTION='READ' )

   IF ( PRESENT(ErrStat) ) ErrStat = IOS

   IF ( IOS /= 0 )  CALL ProgAbort( ' Cannot open file "'//TRIM( InFile )// &
                                    '".  Another program may have locked it for writing.', PRESENT(ErrStat) )



   RETURN
   END SUBROUTINE OpenUInfile ! ( Un, InFile [,ErrStat] )
!=======================================================================
SUBROUTINE OpenUInBEFile( Un, InFile, RecLen, ErrStat )

      !  This routine opens an unformatted input file of RecLen-byte data records
      !  stored in Big Endian format.


      ! Argument declarations.

   INTEGER, INTENT(IN)           ::  Un                                         ! Logical unit for the input file
   CHARACTER(*), INTENT(IN)      ::  InFile                                     ! Name of the input file
   INTEGER, INTENT(IN)           ::  RecLen                                     ! The input file's record length in bytes
   INTEGER, INTENT(OUT),OPTIONAL ::  ErrStat                                    ! Error status; if present, program does not abort on error



      ! Local declarations.

   LOGICAL                       :: Exists                                       ! Flag to indicate if a file exists
   LOGICAL                       :: Error                                        ! Flag to indicate the open failed



      ! See if input file Exists.

   INQUIRE ( FILE=TRIM( InFile ) , EXIST=Exists )

   IF ( .NOT. Exists )  THEN
      CALL ProgAbort ( ' The input file, "'//TRIM( InFile )//'", was not found.', PRESENT(ErrStat) )
      IF ( PRESENT(ErrStat) ) ErrStat = -1
      RETURN
   END IF


      ! Open the file.

   CALL OpenUnfInpBEFile ( Un, InFile, RecLen, Error )

   IF ( Error )  THEN

      CALL ProgAbort ( ' Cannot open file "'//TRIM( InFile )//'".  Another program may have locked it.', PRESENT( ErrStat ) )
      IF ( PRESENT( ErrStat) ) ErrStat = 1
      RETURN

   ELSE

      IF ( PRESENT( ErrStat) ) ErrStat = 0

   END IF


   RETURN

END SUBROUTINE OpenUInBEFile !( Un, InFile, RecLen [, ErrStat] )
!=======================================================================
   SUBROUTINE OpenUOutfile ( Un, OutFile, ErrStat )


      !  This routine opens an unformatted output file.


      ! Argument declarations.

   INTEGER, INTENT(IN)            ::  Un                                        ! Logical unit for the output file
   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                    ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)       ::  OutFile                                   ! Name of the output file


      ! Local declarations.

   INTEGER                        ::  IOS                                       ! Returned input/output status.



      ! Open the file.

   OPEN ( Un, FILE=TRIM( OutFile ), STATUS='UNKNOWN', FORM=UnfForm, ACCESS='SEQUENTIAL', IOSTAT=IOS, ACTION='WRITE' )


   IF ( PRESENT( ErrStat ) )   ErrStat = IOS

   IF ( IOS /= 0 )  CALL ProgAbort( ' Cannot open file "'//TRIM( OutFile )// &
                                    '".  Another program may have locked it for writing.', PRESENT( ErrStat ) )


   RETURN
   END SUBROUTINE OpenUOutfile ! ( Un, InFile [,ErrStat] )
!=======================================================================
   FUNCTION PathIsRelative ( GivenFil )


      ! Let's determine in the given file name is absolute or relative.
      !
      ! We'll consider an absolute path one that satisfies one of the
      ! following four criteria:
      !     1) It contains ":/"
      !     2) It contains ":\"
      !     3) It starts with "/"
      !     4) It starts with "\"
      ! All others are considered relative.



      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: GivenFil                                            ! The name of the given file.
   LOGICAL                      :: PathIsRelative                                      ! The function return value


      ! Determine if file name begins with an absolute path name or if it is relative

   PathIsRelative = .FALSE.

   IF ( ( INDEX( GivenFil, ':/') == 0 ) .AND. ( INDEX( GivenFil, ':\') == 0 ) ) THEN   ! No drive is specified (by ':\' or ':/')

      IF ( INDEX( '/\', GivenFil(1:1) ) == 0 ) THEN                                    ! The file name doesn't start with '\' or '/'

         PathIsRelative = .TRUE.

      END IF

   END IF

   RETURN
   END FUNCTION PathIsRelative ! ( GivenFil )
!=======================================================================
   SUBROUTINE PremEOF ( Fil , Variable, TrapErrors )


      ! This routine prints out an EOF message and aborts the program.


      ! Argument declarations.

   LOGICAL, INTENT(IN), OPTIONAL:: TrapErrors                                   ! Determines if the program should abort or return to calling function
   LOGICAL                      :: TrapThisError                                ! The local version of TrapErrors

   CHARACTER(*), INTENT(IN)     :: Fil                                          ! The name of the file that ran out of data.
   CHARACTER(*), INTENT(IN)     :: Variable                                     ! The name of the variable we were trying to read at the time.


   IF ( PRESENT( TrapErrors ) ) THEN
      TrapThisError = TrapErrors
   ELSE
      TrapThisError = .FALSE.
   END IF

   CALL WrScr1 ( ' Premature EOF for file "'//TRIM( Fil )//'".' )

   CALL ProgAbort  ( ' The error occurred while trying to read '//TRIM( Variable )//'.', TrapThisError )


   RETURN
   END SUBROUTINE PremEOF ! ( Fil , Variable [, TrapErrors] )
!=======================================================================
   SUBROUTINE ProgAbort ( Message, TrapErrors )


      ! This routine outputs fatal error messages and stops the program.


      ! Argument declarations.

   LOGICAL, INTENT(IN), OPTIONAL:: TrapErrors                                   ! Determines if the program should abort or return to calling function
   CHARACTER(*), INTENT(IN)     :: Message                                      ! Error message.



   IF ( Beep )  CALL UsrAlarm

   CALL WrScr    ( Message )
   IF ( PRESENT(TrapErrors) )  THEN
      IF ( TrapErrors ) RETURN
   END IF

   IF ( LEN_TRIM(ProgName) > 0 ) THEN
      CALL WrScr1   ( ' Aborting '//TRIM( ProgName )//'.' )
   ELSE
      CALL WrScr1   ( ' Aborting program.' )
   END IF

   CALL WrScr1   ( ' Hit the <Enter> key to continue.' )
   READ (*,'()')
   CALL ProgExit ( 1 )


   END SUBROUTINE ProgAbort ! ( Message [, TrapErrors] )
!=======================================================================
   SUBROUTINE ProgWarn ( Message )


      ! This routine outputs non-fatal warning messages and returns to the calling routine.


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: Message                                      ! Warning message.



   IF ( Beep )  CALL UsrAlarm
   CALL WrScr ( ' WARNING:  '//Message )


   RETURN
   END SUBROUTINE ProgWarn ! ( Message )
!=======================================================================
   FUNCTION R2LStr4 ( FltNum )

      ! This function converts a 4-byte floating point number to
      ! a left-aligned string.  It eliminates trailing zeroes
      ! and even the decimal point if it is not a fraction.


      ! Function declaration.

   CHARACTER(15)                :: R2LStr4                                         ! This function.


      ! Argument declarations.

   REAL(SiKi), INTENT(IN)       :: FltNum                                          ! The floating-point number to convert.


      ! Return a 0 if that's what we have.

   IF ( FltNum == 0.0_SiKi )  THEN
      R2LStr4 = '0'
      RETURN
   END IF


      ! Write the number into the string using G format and left justify it.

   WRITE (R2LStr4,'(1PG15.5)')  FltNum

   CALL AdjRealStr( R2LStr4 )


   RETURN
   END FUNCTION R2LStr4 !  ( FltNum )
!=======================================================================
   FUNCTION R2LStr8 ( FltNum )

      ! This function converts a 8-byte floating point number to
      ! a left-aligned string.  It eliminates trailing zeroes
      ! and even the decimal point if it is not a fraction.


      ! Function declaration.

   CHARACTER(15)                :: R2LStr8                                         ! This function.


      ! Argument declarations.

   REAL(R8Ki), INTENT(IN)       :: FltNum                                          ! The floating-point number to convert.


      ! Return a 0 if that's what we have.

   IF ( FltNum == 0.0_R8Ki )  THEN
      R2LStr8 = '0'
      RETURN
   END IF


      ! Write the number into the string using G format and left justify it.

   WRITE (R2LStr8,'(1PG15.5)')  FltNum

   CALL AdjRealStr( R2LStr8 )


   RETURN
   END FUNCTION R2LStr8 !  ( FltNum )
!=======================================================================
   FUNCTION R2LStr16 ( FltNum )

      ! This function converts a 16-byte floating point number to
      ! a left-aligned string.  It eliminates trailing zeroes
      ! and even the decimal point if it is not a fraction.


      ! Function declaration.

   CHARACTER(15)                :: R2LStr16                                        ! This function.


      ! Argument declarations.

   REAL(QuKi), INTENT(IN)       :: FltNum                                          ! The floating-point number to convert.


      ! Return a 0 if that's what we have.

   IF ( FltNum == 0.0_QuKi )  THEN
      R2LStr16 = '0'
      RETURN
   END IF


      ! Write the number into the string using G format and left justify it.

   WRITE (R2LStr16,'(1PG15.5)')  FltNum

   CALL AdjRealStr( R2LStr16 )


   RETURN
   END FUNCTION R2LStr16 !  ( FltNum )

!======================================================================
   SUBROUTINE ReadCAry ( UnIn, Fil, CharAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a character array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(OUT)    :: CharAry(AryLen)                                 ! Real variable being read.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.
   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the string array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(44)                :: Frmt = "(15X,A,T30,' - ',A,/,2X,100('""',A,'""',:,1X))"    ! Output format for string parameters.



   READ (UnIn,*,IOSTAT=IOS)  ( CharAry(Ind), Ind=1,AryLen )

   CALL CheckIOS ( IOS, Fil, TRIM( AryName ), StrType, PRESENT(ErrStat) )

   IF (PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  TRIM( AryName ), AryDescr, ( TRIM( CharAry(Ind) ), Ind=1,AryLen )
   END IF


   RETURN
   END SUBROUTINE ReadCAry ! ( UnIn, Fil, CharAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadCAryLines ( UnIn, Fil, CharAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a real array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(OUT)    :: CharAry(AryLen)                                 ! Char variable being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the real array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(35)                :: Frmt = "( 15X, A, T30, ' - ', A, /, 2X, A )"    ! Output format for string parameters.


   IF ( PRESENT(ErrStat) ) ErrStat = 0

   DO Ind=1,AryLen
      READ (UnIn,*,IOSTAT=IOS)  CharAry(Ind)

      CALL CheckIOS ( IOS, Fil, TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', StrType, PRESENT(ErrStat) )

      IF (IOS /= 0) THEN
         IF ( PRESENT(ErrStat) ) ErrStat = IOS
         RETURN
      ENDIF

      IF ( Echo )  THEN
         WRITE (UnEc,Frmt)  TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', AryDescr, TRIM(CharAry(Ind))
      END IF
   END DO

   RETURN
   END SUBROUTINE ReadCAryLines ! ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadCom ( UnIn, Fil, ComName, ErrStat )

      ! This routine reads a comment from the next line of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)   :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)   :: ComName                                         ! Text string containing the comment name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(200)               :: Comment                                         ! Text string containing the comment.



   READ (UnIn,'(A)',IOSTAT=IOS)  Comment

   CALL CheckIOS ( IOS, Fil, ComName, StrType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      WRITE (UnEc,'(A)')  Comment
   END IF


   RETURN
   END SUBROUTINE ReadCom ! ( UnIn, Fil, ComName [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadCVar ( UnIn, Fil, CharVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single character variable from the next line of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(OUT)    :: CharVar                                         ! Integer variable being read.
   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: VarDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(35)                :: Frmt = "( 15X, A, T30, ' - ', A, /, 2X, A )"    ! Output format for string parameters.




   READ (UnIn,*,IOSTAT=IOS)  CharVar

   CALL CheckIOS ( IOS, Fil, VarName, StrType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  VarName, VarDescr, '"'//TRIM( CharVar )//'"'
   END IF


   RETURN
   END SUBROUTINE ReadCVar ! ( UnIn, Fil, CharVar, VarName, VarDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadFASTbin ( UnIn, FASTdata , ErrLev, ErrMsg )

      ! This routine reads the contents of a FAST binary output file (FASTbinFile) and stores it in FASTdata.
      ! It is assumed that the name of the binary file is preloaded into FASTdata%File by the calling procedure.


      ! Argument declarations.

   INTEGER(IntKi), OPTIONAL, INTENT(OUT)  :: ErrLev                  ! An optional error level to be returned to the calling routine.
   INTEGER(IntKi), INTENT(INOUT)          :: UnIn                    ! The IO unit for the FAST binary file.

   CHARACTER(*), OPTIONAL, INTENT(OUT)    :: ErrMsg                  ! An optional error message to be returned to the calling routine.

   TYPE (FASTdataType), INTENT(INOUT)     :: FASTdata                ! The derived type for holding FAST output data.


      ! Local declarations.

   REAL(R8Ki)                             :: TimeIncr                ! The increment for the time data when a time channel is not included.
   REAL(R8Ki)                             :: TimeOff                 ! The offset for the time data when a time channel is included.
   REAL(R8Ki)                             :: TimeOut1                ! The first output data when a time channel is not included.
   REAL(R8Ki)                             :: TimeScl                 ! The slope for the time data when a time channel is included.

   REAL(ReKi), ALLOCATABLE                :: ColMax(:)               ! The maximum value of the column data.
   REAL(ReKi), ALLOCATABLE                :: ColMin(:)               ! The minimum value of the column data.

   REAL(SiKi), ALLOCATABLE                :: ColOff(:)               ! The offset for the column data.
   REAL(SiKi), ALLOCATABLE                :: ColScl(:)               ! The slope for the column data.

   INTEGER(IntKi)                         :: IChan                   ! The channel index used for DO loops.
   INTEGER(IntKi)                         :: IChr                    ! The character index used for DO loops.
   INTEGER(IntKi)                         :: IRow                    ! The row index used for DO loops.
   INTEGER(IntKi)                         :: LenDesc                 ! The length of the description string, DescStr.
   INTEGER(IntKi), PARAMETER              :: MaxLenDesc = 1024       ! The maximum allowed length of the description string, DescStr.
   INTEGER(IntKi), PARAMETER              :: MaxChrLen  = 10         ! The maximum length for channel names and units.

   INTEGER(B4Ki), ALLOCATABLE             :: TmpTimeArray(:)         ! This array holds the normalized time channel that was read from the binary file.

   INTEGER(B2Ki)                          :: FileType                ! The type of FAST data file (1: Time channel included in file; 2: Time stored as start time and step).
   INTEGER(B2Ki), ALLOCATABLE             :: TmpInArray(:,:)         ! This array holds the normalized channels that were read from the binary file.

   INTEGER(B1Ki), ALLOCATABLE             :: DescStrASCII(:)         ! The ASCII equivalent of DescStr.
   INTEGER(B1Ki)                          :: TmpStrASCII(MaxChrLen)  ! The temporary ASCII equivalent of a channel name or units.


      !  Open data file.

   CALL OpenBInpFile ( UnIn, FASTdata%File, ErrLev )
   IF ( ErrLev /= 0 )  THEN
      RETURN
   ENDIF


      ! Process the requested data records of this file.

   CALL WrScr1 ( ' =======================================================' )
   CALL WrScr  ( ' Reading in data from file "'//TRIM( FASTdata%File )//'".' )
   CALL WrScr  ( ' ' )


      ! Read some of the header information.

   READ (UnIn, IOSTAT=ErrLev)  FileType
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading FileType in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF

   READ (UnIn, IOSTAT=ErrLev)  FASTdata%NumChans
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the number of channels in ReadFASTbin for file "' &
                                      //TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF

   READ (UnIn, IOSTAT=ErrLev)  FASTdata%NumRecs
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the number of records in ReadFASTbin for file "' &
                                          //TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF

   IF ( FileType == 1 )  THEN

      READ (UnIn, IOSTAT=ErrLev)  TimeScl
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading TimeScl in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF

      READ (UnIn, IOSTAT=ErrLev)  TimeOff
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading TimeOff in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF

   ELSE

      READ (UnIn, IOSTAT=ErrLev)  TimeOut1
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading TimeOut1 in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF

      READ (UnIn, IOSTAT=ErrLev)  TimeIncr
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading TimeIncr in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF

   END IF ! IF ( FileType == 1 )


      ! Allocate the necessary arrays.

   ALLOCATE ( ColMax( FASTdata%NumChans ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for ColMax array in ReadFASTbin.' )
      RETURN
   ENDIF

   ALLOCATE ( ColMin( FASTdata%NumChans ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for ColMin array in ReadFASTbin.' )
      RETURN
   ENDIF

   ALLOCATE ( ColOff( FASTdata%NumChans ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for ColOff array in ReadFASTbin.' )
      RETURN
   ENDIF

   ALLOCATE ( FASTdata%ChanNames( FASTdata%NumChans+1 ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for FASTdata%ChanNames array in ReadFASTbin.' )
      RETURN
   ENDIF

   ALLOCATE ( FASTdata%ChanUnits( FASTdata%NumChans+1 ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine( ErrID_Fatal, '>>Error allocating memory for FASTdata%ChanUnits array in ReadFASTbin.' )
      RETURN
   ENDIF

   ALLOCATE ( ColScl( FASTdata%NumChans ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for ColScl array in ReadFASTbin.' )
      RETURN
   ENDIF

   ALLOCATE ( TmpInArray( FASTdata%NumRecs, FASTdata%NumChans ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for the TmpInArray array in ReadFASTbin.' )
      RETURN
   ENDIF

   IF ( FileType == 1 ) THEN
      ALLOCATE ( TmpTimeArray( FASTdata%NumRecs ) , STAT=ErrLev )
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for the TmpTimeArray array in ReadFASTbin.' )
         RETURN
      ENDIF
   END IF

   ALLOCATE ( FASTdata%Data( FASTdata%NumRecs, FASTdata%NumChans+1 ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for the FASTdata%Data array in ReadFASTbin.' )
      RETURN
   ENDIF


      ! Read more of the header information.

   READ (UnIn, IOSTAT=ErrLev)  ColScl
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the ColScl array in ReadFASTbin for file "' &
                                          //TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF

   READ (UnIn, IOSTAT=ErrLev)  ColOff
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the ColOff array in ReadFASTbin for file "' &
                                          //TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF

   READ (UnIn, IOSTAT=ErrLev)  LenDesc
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading LenDesc in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF
   LenDesc = MIN( LenDesc, MaxLenDesc )

   ALLOCATE ( DescStrASCII( LenDesc ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for the DescStrASCII array in ReadFASTbin.' )
      RETURN
   ENDIF

   READ (UnIn, IOSTAT=ErrLev)  DescStrASCII
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the DescStrASCII array in ReadFASTbin for file "' &
                                      //TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF

   FASTdata%Descr = ''

   DO IChr=1,LenDesc
      FASTdata%Descr(IChr:IChr) = CHAR( DescStrASCII(IChr) )
   END DO

   TmpStrASCII(:) = ICHAR( ' ' )
   DO IChan=1,FASTdata%NumChans+1
      READ (UnIn, IOSTAT=ErrLev)  TmpStrASCII
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the title of Channel #'//Int2LStr(  IChan )// &
                                          ' in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF
      FASTdata%ChanNames(IChan) = ''
      DO IChr=1,MaxChrLen
         FASTdata%ChanNames(IChan)(IChr:IChr) = CHAR( TmpStrASCII(IChr) )
      END DO
   END DO

   TmpStrASCII(:) = ICHAR( ' ' )
   DO IChan=1,FASTdata%NumChans+1
      READ (UnIn, IOSTAT=ErrLev)  TmpStrASCII
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the units of Channel #'//Int2LStr(  IChan )// &
                                          ' in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF
      FASTdata%ChanUnits(IChan) = ''
      DO IChr=1,MaxChrLen
         FASTdata%ChanUnits(IChan)(IChr:IChr) = CHAR( TmpStrASCII(IChr) )
      END DO
   END DO


      ! If the file contains a time channel (as opposed to just initial time and time step), read it.
      ! There are four bytes per time value.

   IF ( FileType == 1 ) THEN

      READ (UnIn, IOSTAT=ErrLev)  TmpTimeArray                                 ! Time data stored in normalized 32-bit integers
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading time data from the FAST binary file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF

   END IF ! FileType


      ! Put time data in the data array.

   IF ( FileType == 1 )  THEN
      FASTdata%Data(:,1) = ( TmpTimeArray(:) - TimeOff )/TimeScl;
      FASTdata%TimeStep  = FASTdata%Data(2,1) - FASTdata%Data(1,1)
   ELSE
      FASTdata%Data(:,1) = REAL( TimeOut1, DbKi ) + REAL( TimeIncr, DbKi )*[ (IRow, IRow=0,FASTdata%NumRecs-1 ) ];
      FASTdata%TimeStep  = TimeIncr
   END IF


      ! Read the FAST channel data.

   DO IRow=1,FASTdata%NumRecs
      READ (UnIn, IOSTAT=ErrLev)  TmpInArray(IRow,:)
   END DO ! IRow=1,FASTdata%NumRecs


      ! Denormalize the data one row at a time and store it in the FASTdata%Data array.

   DO IRow=1,FASTdata%NumRecs
      FASTdata%Data(IRow,2:) = ( TmpInArray(IRow,:) - ColOff(:) )/ColScl(:)
   END DO ! IRow=1,FASTdata%NumRecs


   CALL ExitThisRoutine( ErrID_None, '' )
   RETURN

   !=======================================================================
   CONTAINS
   !=======================================================================
      SUBROUTINE ExitThisRoutine ( ErrID, Msg )

         ! This subroutine cleans up all the allocatable arrays, sets the error status/message and closes the binary file

            ! Passed arguments

         INTEGER(IntKi), INTENT(IN) :: ErrID       ! The error identifier (ErrLev)
         CHARACTER(*),   INTENT(IN) :: Msg         ! The error message (ErrMsg)


            ! Set error status/message

         ErrLev = ErrID
         ErrMsg  = Msg


            ! Deallocate arrays created in this routine.

         IF ( ALLOCATED( ColMax             ) ) DEALLOCATE( ColMax             )
         IF ( ALLOCATED( ColMin             ) ) DEALLOCATE( ColMin             )
         IF ( ALLOCATED( ColOff             ) ) DEALLOCATE( ColOff             )
         IF ( ALLOCATED( ColScl             ) ) DEALLOCATE( ColScl             )
         IF ( ALLOCATED( DescStrASCII       ) ) DEALLOCATE( DescStrASCII       )
         IF ( ALLOCATED( TmpInArray         ) ) DEALLOCATE( TmpInArray         )
         IF ( ALLOCATED( TmpTimeArray       ) ) DEALLOCATE( TmpTimeArray       )


            ! If there was an error, deallocate the arrays in the FASTdata structure.

         IF ( ErrLev /= 0 )  THEN
            IF ( ALLOCATED( FASTdata%ChanNames ) ) DEALLOCATE( FASTdata%ChanNames )
            IF ( ALLOCATED( FASTdata%ChanUnits ) ) DEALLOCATE( FASTdata%ChanUnits )
            IF ( ALLOCATED( FASTdata%Data      ) ) DEALLOCATE( FASTdata%Data      )
         END IF ! ( ErrLev /= 0 )


            ! Close file

         CLOSE ( UnIn )

      END SUBROUTINE ExitThisRoutine

   END SUBROUTINE ReadFASTbin ! ( FASTbinData [, ErrLev] )
!=======================================================================
   SUBROUTINE ReadIAry ( UnIn, Fil, IntAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into an integer array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(OUT)         :: IntAry(AryLen)                                  ! Integer array being read.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the integer array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, I11, 2X, A, T30, ' - ', A )"      ! Output format for integer array parameters



   READ (UnIn,*,IOSTAT=IOS)  ( IntAry(Ind), Ind=1,AryLen )

   CALL CheckIOS ( IOS, Fil, TRIM( AryName ), NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      DO Ind=1,AryLen
         WRITE (UnEc,Frmt)  IntAry(Ind), TRIM( AryName ), AryDescr
      END DO ! Ind
   END IF


   RETURN
   END SUBROUTINE ReadIAry ! ( UnIn, Fil, IntAry, AryLen, AryName, AryDescr [, ErrStat])
!=======================================================================
   SUBROUTINE ReadIVar ( UnIn, Fil, IntVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single integer variable from the next line of the input file.


      ! Argument declarations:

   INTEGER, INTENT(OUT)         :: IntVar                                          ! Integer variable being read.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: VarDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(33)                :: Frmt = "( 2X, I11, 2X, A, T30, ' - ', A )"      ! Output format for integer parameters.
   CHARACTER(30)                :: Word                                            ! String to hold the first word on the line.



   IF ( PRESENT(ErrStat) ) THEN
      CALL ReadNum ( UnIn, Fil, Word, VarName, ErrStat )
      IF (ErrStat /= 0) RETURN
   ELSE
      CALL ReadNum ( UnIn, Fil, Word, VarName )
   END IF

   READ (Word,*,IOSTAT=IOS)  IntVar

   CALL CheckIOS ( IOS, Fil, VarName, NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  IntVar, VarName, VarDescr
   END IF


   RETURN
   END SUBROUTINE ReadIVar ! ( UnIn, Fil, IntVar, VarName, VarDescr [, ErrStat])
!=======================================================================
   SUBROUTINE ReadLAry ( UnIn, Fil, LogAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into an logical array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   LOGICAL, INTENT(OUT)         :: LogAry(AryLen)                                  ! Logical array being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the integer array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, I11, 2X, A, T30, ' - ', A )"      ! Output format for integer array parameters



   READ (UnIn,*,IOSTAT=IOS)  ( LogAry(Ind), Ind=1,AryLen )

   CALL CheckIOS ( IOS, Fil, TRIM( AryName ), NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      DO Ind=1,AryLen
         WRITE (UnEc,Frmt)  LogAry(Ind), TRIM( AryName ), AryDescr
      END DO ! Ind
   END IF


   RETURN
   END SUBROUTINE ReadLAry ! ( UnIn, Fil, LogAry, AryLen, AryName, AryDescr [, ErrStat])
!=======================================================================
   SUBROUTINE ReadLVar ( UnIn, Fil, LogVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single logical variable from the next line of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   LOGICAL, INTENT(OUT)         :: LogVar                                          ! Logical variable being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: VarDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(33)                :: Frmt  = "( 2X, L11, 2X, A, T30, ' - ', A )"     ! Output format for logical parameters.
   CHARACTER( 4)                :: VName                                           ! Temporary holder for the variable name.




   READ (UnIn,*,IOSTAT=IOS)  LogVar

   CALL CheckIOS ( IOS, Fil, VarName, FlgType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   VName = VarName

   CALL Conv2UC ( VName )

   IF ( Echo .AND. ( VName /= 'ECHO' ) )  THEN
      WRITE (UnEc,Frmt)  LogVar, VarName, VarDescr
   END IF


   RETURN
   END SUBROUTINE ReadLVar ! ( UnIn, Fil, LogVar, VarName, VarDescr [, ErrStat])
!=======================================================================
   SUBROUTINE ReadNum ( UnIn, Fil, Word, VarName, ErrStat )


      ! This routine reads a single word from a file and tests to see if it's a pure number (no true or false).


      ! Argument declarations:

   INTEGER, INTENT(IN)            :: UnIn                                          ! I/O unit for input file.
   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                       ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)       :: Fil                                           ! Name of the input file.
   CHARACTER(*), INTENT(IN)       :: VarName                                       ! Text string containing the variable name.
   CHARACTER(*), INTENT(Out)      :: Word                                          ! Text string containing the first word from the input line.


      ! Local declarations:

   INTEGER                        :: IOS                                           ! I/O status returned from the read statement.


   IF ( PRESENT(ErrStat) ) ErrStat = 0


      ! Read in the first word of the input line.  Check I/O status.

   READ (UnIn,*,IOSTAT=IOS)  Word

   CALL CheckIOS ( IOS, Fil, VarName, NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF


      ! See if the word starts with a T or F.  If so, flag it as an invalid number.

   IF ( INDEX( 'FTft', Word(:1) ) > 0 )  THEN
      CALL WrScr ( '' )
      CALL ProgAbort( ' Invalid numeric input.  "'//TRIM( Word )//'" found when trying to read the number, '// &
                      TRIM( VarName )//'.', PRESENT(ErrStat) )

      IF ( PRESENT(ErrStat) ) ErrStat = 1
   END IF



   RETURN
   END SUBROUTINE ReadNum ! ( UnIn, Fil, Word, VarName [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadOutputList ( UnIn, Fil, CharAry, AryLenRead, AryName, AryDescr, ErrStat )


      ! This routine reads up to MaxAryLen values from an input file and store them in CharAry(:).
      ! These values represent the names of output channels, and they are specified in the format
      ! required for OutList(:) in FAST input files.
      ! The end of this list is specified with the line beginning with the 3 characters "END".


      ! Argument declarations:

   INTEGER, INTENT(OUT)         :: AryLenRead                                      ! Length of the array that was actually read.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(OUT)    :: CharAry(:)                                      ! Character array being read (calling routine dimensions it to max allowable size).

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: MaxAryLen                                       ! Maximum length of the array being read
   INTEGER                      :: NumWords                                        ! Number of words contained on a line


   CHARACTER(1000)              :: OutLine
   CHARACTER(3)                 :: EndOfFile


      ! Initialize some values

   IF ( PRESENT(ErrStat) ) ErrStat = 0
   MaxAryLen  = SIZE(CharAry)
   AryLenRead = 0

   CharAry = ''



      ! Read in all of the lines containing output parameters and store them in CharAry(:).
      ! The end of this list is specified with the line beginning with END.

   DO

      IF ( PRESENT(ErrStat) ) THEN
         CALL ReadVar ( UnIn, Fil, OutLine, AryName, AryDescr, ErrStat )
         IF ( ErrStat /= 0 ) RETURN
      ELSE
         CALL ReadVar ( UnIn, Fil, OutLine, AryName, AryDescr  )
      END IF

      EndOfFile = OutLine(1:3)            ! EndOfFile is the 1st 3 characters of OutLine
      CALL Conv2UC( EndOfFile )           ! Convert EndOfFile to upper case
      IF ( EndOfFile == 'END' )  EXIT     ! End of OutList has been reached; therefore, exit this DO

      NumWords = CountWords( OutLine )    ! The number of words in OutLine.

      AryLenRead = AryLenRead + NumWords  ! The total number of output channels read in so far.

         ! Check to see if the maximum # allowable in the array has been reached.

      IF ( AryLenRead > MaxAryLen )  THEN

         CALL ProgAbort ( ' The maximum number of output channels allowed is ' &
                     //TRIM( Int2LStr(MaxAryLen) )//'.', PRESENT(ErrStat)      )
         ErrStat = 1
         RETURN

      ELSE

         CALL GetWords ( OutLine, CharAry((AryLenRead - NumWords + 1):AryLenRead), NumWords )

      END IF

   END DO


   RETURN
   END SUBROUTINE ReadOutputList ! ( UnIn, Fil, CharAry, AryLenRead, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadRAry ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a real array separated by white space (possibly on the same line of the input file).


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   REAL(ReKi), INTENT(INOUT)    :: RealAry(AryLen)                                 ! Real array being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the real array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real array parameters



   READ (UnIn,*,IOSTAT=IOS)  ( RealAry(Ind), Ind=1,AryLen )

   CALL CheckIOS ( IOS, Fil, TRIM( AryName ), NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      DO Ind=1,AryLen
         WRITE (UnEc,Frmt)  RealAry(Ind), TRIM( AryName ), AryDescr
      END DO ! Ind
   END IF


   RETURN
   END SUBROUTINE ReadRAry ! ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadRAryLines ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a real array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   REAL(ReKi), INTENT(OUT)      :: RealAry(AryLen)                                 ! Real array being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the real array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real array parameters


   IF ( PRESENT(ErrStat) ) ErrStat = 0

   DO Ind=1,AryLen
      READ (UnIn,*,IOSTAT=IOS)  RealAry(Ind)

      CALL CheckIOS ( IOS, Fil, TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', NumType, PRESENT(ErrStat) )

      IF (IOS /= 0) THEN
         IF ( PRESENT(ErrStat) ) ErrStat = IOS
         RETURN
      ENDIF

      IF ( Echo )  THEN
         WRITE (UnEc,Frmt)  RealAry(Ind), TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', AryDescr
      END IF
   END DO

   RETURN
   END SUBROUTINE ReadRAryLines ! ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadRAryLines4 ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a real array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   REAL(SiKi), INTENT(OUT)      :: RealAry(AryLen)                                 ! Real (4-byte) array being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the real array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real array parameters


   IF ( PRESENT(ErrStat) ) ErrStat = 0

   DO Ind=1,AryLen
      READ (UnIn,*,IOSTAT=IOS)  RealAry(Ind)

      CALL CheckIOS ( IOS, Fil, TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', NumType, PRESENT(ErrStat) )

      IF (IOS /= 0) THEN
         IF ( PRESENT(ErrStat) ) ErrStat = IOS
         RETURN
      ENDIF

      IF ( Echo )  THEN
         WRITE (UnEc,Frmt)  RealAry(Ind), TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', AryDescr
      END IF
   END DO

   RETURN
   END SUBROUTINE ReadRAryLines4 ! ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadRAryLines8 ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a real array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   REAL(R8Ki), INTENT(OUT)      :: RealAry(AryLen)                                 ! Real (8-byte) array being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the real array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real array parameters


   IF ( PRESENT(ErrStat) ) ErrStat = 0

   DO Ind=1,AryLen
      READ (UnIn,*,IOSTAT=IOS)  RealAry(Ind)

      CALL CheckIOS ( IOS, Fil, TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', NumType, PRESENT(ErrStat) )

      IF (IOS /= 0) THEN
         IF ( PRESENT(ErrStat) ) ErrStat = IOS
         RETURN
      ENDIF

      IF ( Echo )  THEN
         WRITE (UnEc,Frmt)  RealAry(Ind), TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', AryDescr
      END IF
   END DO

   RETURN
   END SUBROUTINE ReadRAryLines8 ! ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadRAryLines16 ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a real array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   REAL(QuKi), INTENT(OUT)      :: RealAry(AryLen)                                 ! Real (16-byte) array being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the real array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real array parameters


   IF ( PRESENT(ErrStat) ) ErrStat = 0

   DO Ind=1,AryLen
      READ (UnIn,*,IOSTAT=IOS)  RealAry(Ind)

      CALL CheckIOS ( IOS, Fil, TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', NumType, PRESENT(ErrStat) )

      IF (IOS /= 0) THEN
         IF ( PRESENT(ErrStat) ) ErrStat = IOS
         RETURN
      ENDIF

      IF ( Echo )  THEN
         WRITE (UnEc,Frmt)  RealAry(Ind), TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', AryDescr
      END IF
   END DO

   RETURN
   END SUBROUTINE ReadRAryLines16 ! ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadRVar ( UnIn, Fil, RealVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single real variable from the next line of the input file.
      ! New code should use ReadVar instead of this routine.


      ! Argument declarations:

   REAL(ReKi), INTENT(OUT)      :: RealVar                                         ! Real variable being read.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.

   CHARACTER( *), INTENT(IN)    :: Fil                                             ! Name of the input file.
   CHARACTER( *), INTENT(IN)    :: VarDescr                                        ! Text string describing the variable.
   CHARACTER( *), INTENT(IN)    :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real parameters
   CHARACTER(30)                :: Word                                            ! String to hold the first word on the line.



   IF ( PRESENT(ErrStat) ) THEN
      CALL ReadNum ( UnIn, Fil, Word, VarName, ErrStat )
      IF (ErrStat /= 0) RETURN
   ELSE
      CALL ReadNum ( UnIn, Fil, Word, VarName )
   END IF

   READ (Word,*,IOSTAT=IOS)  RealVar

   CALL CheckIOS ( IOS, Fil, VarName, NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   END IF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  RealVar, VarName, VarDescr
   END IF


   RETURN
   END SUBROUTINE ReadRVar ! ( UnIn, Fil, RealVar, VarName, VarDescr [, ErrStat] )
!=======================================================================
  SUBROUTINE ReadR4Var ( UnIn, Fil, RealVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single double (real) variable from the next line of the input file.


      ! Argument declarations:

   REAL(SiKi), INTENT(OUT)      :: RealVar                                         ! Real (4-byte) variable being read.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.

   CHARACTER( *), INTENT(IN)    :: Fil                                             ! Name of the input file.
   CHARACTER( *), INTENT(IN)    :: VarDescr                                        ! Text string describing the variable.
   CHARACTER( *), INTENT(IN)    :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real parameters
   CHARACTER(30)                :: Word                                            ! String to hold the first word on the line.



   IF ( PRESENT(ErrStat) ) THEN
      CALL ReadNum ( UnIn, Fil, Word, VarName, ErrStat )
      IF (ErrStat /= 0) RETURN
   ELSE
      CALL ReadNum ( UnIn, Fil, Word, VarName )
   END IF

   READ (Word,*,IOSTAT=IOS)  RealVar

   CALL CheckIOS ( IOS, Fil, VarName, NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   END IF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  RealVar, VarName, VarDescr
   END IF


   RETURN
  END SUBROUTINE ReadR4Var ! ( UnIn, Fil, RealVar, VarName, VarDescr [, ErrStat] )
!=======================================================================
  SUBROUTINE ReadR8Var ( UnIn, Fil, RealVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single double (real) variable from the next line of the input file.


      ! Argument declarations:

   REAL(R8Ki), INTENT(OUT)      :: RealVar                                         ! Real (8-byte) variable being read.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.

   CHARACTER( *), INTENT(IN)    :: Fil                                             ! Name of the input file.
   CHARACTER( *), INTENT(IN)    :: VarDescr                                        ! Text string describing the variable.
   CHARACTER( *), INTENT(IN)    :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real parameters
   CHARACTER(30)                :: Word                                            ! String to hold the first word on the line.



   IF ( PRESENT(ErrStat) ) THEN
      CALL ReadNum ( UnIn, Fil, Word, VarName, ErrStat )
      IF (ErrStat /= 0) RETURN
   ELSE
      CALL ReadNum ( UnIn, Fil, Word, VarName )
   END IF

   READ (Word,*,IOSTAT=IOS)  RealVar

   CALL CheckIOS ( IOS, Fil, VarName, NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   END IF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  RealVar, VarName, VarDescr
   END IF


   RETURN
  END SUBROUTINE ReadR8Var ! ( UnIn, Fil, RealVar, VarName, VarDescr [, ErrStat] )
!=======================================================================
  SUBROUTINE ReadR16Var ( UnIn, Fil, RealVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single double (real) variable from the next line of the input file.


      ! Argument declarations:

   REAL(QuKi), INTENT(OUT)      :: RealVar                                         ! Real (16-byte) variable being read.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.

   CHARACTER( *), INTENT(IN)    :: Fil                                             ! Name of the input file.
   CHARACTER( *), INTENT(IN)    :: VarDescr                                        ! Text string describing the variable.
   CHARACTER( *), INTENT(IN)    :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real parameters
   CHARACTER(30)                :: Word                                            ! String to hold the first word on the line.



   IF ( PRESENT(ErrStat) ) THEN
      CALL ReadNum ( UnIn, Fil, Word, VarName, ErrStat )
      IF (ErrStat /= 0) RETURN
   ELSE
      CALL ReadNum ( UnIn, Fil, Word, VarName )
   END IF

   READ (Word,*,IOSTAT=IOS)  RealVar

   CALL CheckIOS ( IOS, Fil, VarName, NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   END IF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  RealVar, VarName, VarDescr
   END IF


   RETURN
   END SUBROUTINE ReadR16Var ! ( UnIn, Fil, RealVar, VarName, VarDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadStr ( UnIn, Fil, CharVar, VarName, VarDescr, ErrStat )


      ! This routine reads a string from the next line of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(OUT)    :: CharVar                                         ! Integer variable being read.
   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: VarDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(35)                :: Frmt = "( 15X, A, T30, ' - ', A, /, 2X, A )"    ! Output format for string parameters.




   READ (UnIn,'(A)',IOSTAT=IOS)  CharVar

   CALL CheckIOS ( IOS, Fil, VarName, StrType )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   END IF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  VarName, VarDescr, '"'//TRIM( CharVar )//'"'
   END IF


   RETURN
   END SUBROUTINE ReadStr ! ( UnIn, Fil, CharVar, VarName, VarDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE WaitTime ( WaitSecs )


      ! This routine writes out a prompt to the screen without
      ! following it with a new line, though a new line precedes it.


   IMPLICIT NONE


      ! Argument declarations:

   REAL(ReKi), INTENT(IN)       :: WaitSecs                                        ! The number of seconds to wait.


      ! Local declarations:

   REAL(ReKi)                   :: EndCounts                                       ! The number of counts when wait time is over.

   INTEGER                      :: Counts                                          ! Current number of counts on the system clock.
   INTEGER                      :: CountMax                                        ! Maximum number of counts possible on the system clock.
   INTEGER                      :: CountRate                                       ! Number of counts per second on the system clock.



   CALL SYSTEM_CLOCK ( Counts, CountRate, CountMax )
   EndCounts = Counts + INT( WaitSecs*CountRate )

   DO
      CALL SYSTEM_CLOCK ( Counts, CountRate, CountMax )
      IF ( Counts > EndCounts )  EXIT
   END DO


   RETURN
   END SUBROUTINE WaitTime ! ( Seconds )
!=======================================================================
   SUBROUTINE WrPr ( Str )


      ! This routine writes out a prompt to the screen without
      ! following it with a new line, though a new line precedes it.


      ! Argument declarations:

   CHARACTER(*), INTENT(IN)     :: Str                                          ! The prompt string to print.



   CALL WrScr ( ' ' )
   CALL WrNR  ( TRIM( Str )//' > ' )


   RETURN
   END SUBROUTINE WrPr ! ( Str )
!=======================================================================
   SUBROUTINE WrFileNR ( Unit, Str )


      ! This routine writes out a string to the file connected to Unit without following it with a new line.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Unit                                         ! I/O unit for input file.

   CHARACTER(*), INTENT(IN)     :: Str                                          ! String to be written without a newline at the end.



   WRITE (Unit,'(A)',ADVANCE='NO')  Str


   RETURN
   END SUBROUTINE WrFileNR ! ( Unit, Str )
!=======================================================================
   SUBROUTINE WrML ( Str )


      ! This routine writes out a string in the middle of a line.


      ! Argument declarations.

   CHARACTER(*)                 :: Str



   CALL WrNR ( Str )


   RETURN
   END SUBROUTINE WrML ! ( Str )
!=======================================================================
   SUBROUTINE WrScr1 ( Str )


      ! This routine writes out a string to the screen after a blank line.


      ! Argument declarations.

   CHARACTER(*)                 :: Str                                         ! The string to print.



   CALL WrScr ( ' ' )
   CALL WrScr ( TRIM( Str ) )


   RETURN
   END SUBROUTINE WrScr1 ! ( Str )
!=======================================================================

END MODULE NWTC_IO
MODULE NWTC_Num


   ! This module contains numeric-type routines with non-system-specific logic and references.


   ! It contains the following routines:

   !     SUBROUTINE AddOrSub2Pi   ( OldAngle, NewAngle )
   !     SUBROUTINE BSortReal     ( RealAry, NumPts )
   !     FUNCTION   CROSS_PRODUCT ( Vector1, Vector2 )
   !     FUNCTION   EqualRealNos  ( ReNum1, ReNum2 )
   !     SUBROUTINE GL_Pts        ( IPt, NPts, Loc, Wt [, ErrStat] )
   !     FUNCTION   IndexCharAry  ( CVal, CAry )
   !     FUNCTION   InterpBin     ( XVal, XAry, YAry, ILo, AryLen )             ! Generic interface for InterpBinComp and InterpBinReal.
   !     FUNCTION   InterpBinComp ( XVal, XAry, YAry, ILo, AryLen )
   !     FUNCTION   InterpBinReal ( XVal, XAry, YAry, ILo, AryLen )
   !     FUNCTION   InterpStp     ( XVal, XAry, YAry, ILo, AryLen )             ! Generic interface for InterpStpComp and InterpStpReal.
   !     FUNCTION   InterpStpComp ( XVal, XAry, YAry, Ind, AryLen )
   !     FUNCTION   InterpStpReal ( XVal, XAry, YAry, Ind, AryLen )
   !     SUBROUTINE LocateStp     ( XVal, XAry, Ind, AryLen )
   !     FUNCTION   Mean          ( Ary, AryLen )                               ! Function to calculate the mean value of a vector array.
   !     SUBROUTINE MPi2Pi        ( Angle )
   !     SUBROUTINE RombergInt    ( f, a, b, R, err, eps, ErrStat )
   !     SUBROUTINE SetConstants
   !     SUBROUTINE SmllRotTrans  ( RotationType, Theta1, Theta2, Theta3, TransMat, ErrTxt )
   !     SUBROUTINE SortUnion     ( Ary1, N1, Ary2, N2, Ary, N )
   !     FUNCTION   StdDevFn      ( Ary, AryLen, Mean )                         ! Function to calculate the standard deviation of a vector array.


   USE                             NWTC_IO

   IMPLICIT NONE

!=======================================================================


      ! Global numeric-related variables.

   REAL(DbKi)                   :: D2R_D                                        ! Factor to convert degrees to radians in double precision.
   REAL(DbKi)                   :: Inf_D                                        ! IEEE value for NaN (not-a-number) in double precision 
   REAL(DbKi)                   :: NaN_D                                        ! IEEE value for Inf (infinity) in double precision
   REAL(DbKi)                   :: Pi_D                                         ! Ratio of a circle's circumference to its diameter in double precision.
   REAL(DbKi)                   :: PiBy2_D                                      ! Pi/2 in double precision.
   REAL(DbKi)                   :: R2D_D                                        ! Factor to convert radians to degrees in double precision.
   REAL(DbKi)                   :: RPM2RPS_D                                    ! Factor to convert revolutions per minute to radians per second in double precision.
   REAL(DbKi)                   :: RPS2RPM_D                                    ! Factor to convert radians per second to revolutions per minute in double precision.
   REAL(DbKi)                   :: TwoByPi_D                                    ! 2/Pi in double precision.
   REAL(DbKi)                   :: TwoPi_D                                      ! 2*Pi in double precision.
   
   
   REAL(ReKi)                   :: D2R                                          ! Factor to convert degrees to radians.
   REAL(ReKi)                   :: Inf                                          ! IEEE value for NaN (not-a-number)
   REAL(ReKi)                   :: NaN                                          ! IEEE value for Inf (infinity)
   REAL(ReKi)                   :: Pi                                           ! Ratio of a circle's circumference to its diameter.
   REAL(ReKi)                   :: PiBy2                                        ! Pi/2.
   REAL(ReKi)                   :: R2D                                          ! Factor to convert radians to degrees.
   REAL(ReKi)                   :: RPM2RPS                                      ! Factor to convert revolutions per minute to radians per second.
   REAL(ReKi)                   :: RPS2RPM                                      ! Factor to convert radians per second to revolutions per minute.
   REAL(ReKi)                   :: TwoByPi                                      ! 2/Pi.
   REAL(ReKi)                   :: TwoPi                                        ! 2*Pi.

   INTEGER, ALLOCATABLE         :: IntIndx  (:,:)                               ! The array of indices holding that last index used for interpolation in IntBlade().


!=======================================================================

      ! Create interface for a generic EqualRealNos that uses specific routines.

   INTERFACE EqualRealNos
      MODULE PROCEDURE EqualRealNos4
      MODULE PROCEDURE EqualRealNos8
      MODULE PROCEDURE EqualRealNos16
   END INTERFACE
   

      ! Create interface for a generic InterpBin that actually uses specific routines.

   INTERFACE InterpBin
      MODULE PROCEDURE InterpBinComp
      MODULE PROCEDURE InterpBinReal
   END INTERFACE


      ! Create interface for a generic InterpStp that actually uses specific routines.

   INTERFACE InterpStp
      MODULE PROCEDURE InterpStpComp
      MODULE PROCEDURE InterpStpReal
   END INTERFACE


CONTAINS

!=======================================================================
   SUBROUTINE AddOrSub2Pi ( OldAngle, NewAngle )


      ! This routine is used to convert NewAngle to an angle within 2*Pi of
      !   OldAngle by adding or subtracting 2*Pi accordingly; it then sets
      !   OldAngle equal to NewAngle.  This routine is useful for converting
      !   angles returned from a call to the ATAN2() FUNCTION into angles that may
      !   exceed the -Pi to Pi limit of ATAN2().  For example, if the nacelle yaw
      !   angle was 179deg in the previous time step and the yaw angle increased
      !   by 2deg in the new time step, we want the new yaw angle returned from a
      !   call to the ATAN2() FUNCTION to be 181deg instead of -179deg.  This
      !   routine assumes that the angle change between calls is not more than
      !   2*Pi in absolute value.  OldAngle should be SAVEd in the calling
      !   routine.


      ! Argument declarations:

   REAL(ReKi), INTENT(INOUT)    :: OldAngle                                     ! Angle from which NewAngle will be converted to within 2*Pi of, rad.
   REAL(ReKi), INTENT(INOUT)    :: NewAngle                                     ! Angle to be converted to within 2*Pi of OldAngle, rad.


      ! Local declarations:

   REAL(ReKi)                   :: DelAngle                                     ! The difference between OldAngle and NewAngle, rad.



      ! Add or subtract 2*Pi in order to convert NewAngle two within 2*Pi of
      !   OldAngle:

   DelAngle = OldAngle - NewAngle

   DO WHILE ( ABS( DelAngle ) >= TwoPi )

      NewAngle = NewAngle + SIGN( TwoPi, DelAngle )
      DelAngle = OldAngle - NewAngle

   END DO


      ! Set OldAngle to equal NewAngle:

   OldAngle = NewAngle



   RETURN
   END SUBROUTINE AddOrSub2Pi
!=======================================================================
   SUBROUTINE BSortReal ( RealAry, NumPts )


      ! This routine sorts a list of real numbers.  It uses the buble sort algorithm,
      ! which is only suitable for short lists.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: NumPts                                       ! The length of the list to be sorted.

   REAL(ReKi), INTENT(INOUT)    :: RealAry(NumPts)                              ! The list of real numbers to be sorted.


      ! Local declarations:

   REAL(ReKi)                   :: Temp                                         ! Temporary variable to hold the current element.

   INTEGER                      :: I                                            ! Index into the array.

   LOGICAL                      :: Change                                       ! Flag to indicate if a change of order was made.


      ! Sort the list

   Change = .TRUE.

   DO WHILE ( Change )

      Change = .FALSE.

      DO I=2,NumPts
         IF ( RealAry(I) < RealAry(I-1) )  THEN
            Temp           = RealAry(I)
            RealAry(I)   = RealAry(I-1)
            RealAry(I-1) = Temp
            Change         = .TRUE.
         END IF
      END DO ! I

   END DO ! WHILE


   RETURN
   END SUBROUTINE BSortReal ! ( RealAry, NumPts )
!=======================================================================
   FUNCTION Cross_Product(Vector1, Vector2)

      ! This function computes the cross product of two 3-element arrays:
      ! Cross_Product = Vector1 X Vector2 (resulting in a vector)


      ! Argument declarations.

   REAL(ReKi), INTENT(IN )         :: Vector1       (3)
   REAL(ReKi), INTENT(IN )         :: Vector2       (3)

      ! Function definition
   REAL(ReKi)                      :: Cross_Product (3)        ! = Vector1 X Vector2 (resulting in a vector)


   Cross_Product(1) = Vector1(2)*Vector2(3) - Vector1(3)*Vector2(2)
   Cross_Product(2) = Vector1(3)*Vector2(1) - Vector1(1)*Vector2(3)
   Cross_Product(3) = Vector1(1)*Vector2(2) - Vector1(2)*Vector2(1)


   RETURN
   END FUNCTION Cross_Product
!=======================================================================
!   SUBROUTINE GetPermMat ( InpMat, PMat, ErrStat )
!
!      ! This subroutine computes a permutation matrix, PMat, for a given
!      ! input matrix, InpMat. It assumes that InpMat is of full rank
!      ! and for now, the matrices are 3 x 3.
!
!      ! passed variables
!
!   REAL(ReKi), INTENT(IN )         :: InpMat       (3,3)
!   REAL(ReKi), INTENT(OUT )        :: PMat         (3,3) !this could be integer, but we'll leave it real now
!   INTEGER,    INTENT(OUT )        :: ErrStat            ! a non-zero value indicates an error in the permutation matrix algorithm
!
!      ! local variables
!   INTEGER                         :: iCol               ! loop counter
!   INTEGER                         :: iRow               ! loop counter
!   INTEGER                         :: MaxCol             ! holds index of maximum value in a column
!
!   LOGICAL                         :: ChkCols     (3)    ! a check to make sure we have only one non-zero element per column
!
!      ! initialize some variables
!   PMat    = 0.0
!   ChkCols = .FALSE.
!   ErrStat = 0
!
!      ! find the pivots
!   DO iRow = 1,3
!
!      MaxCol = 1        ! initialize max index
!      DO iCol = 2,3
!         IF ( ABS(InpMat(iRow,iCol)) > ABS(InpMat(iRow,MaxCol)) ) &
!            MaxCol = iCol
!      END DO ! iCol
!
!      IF ( ChkCols(MaxCol) ) THEN   ! we can have only 1 non-zero entry per row and column, but we've just violated that!
!         CALL ProgAbort( ' Error in GetPermMat(): InpMat is not full rank.', TrapErrors = .TRUE. )
!         ErrStat = 1
!      END IF
!
!      PMat(MaxCol, iRow) = SIGN( 1.0_ReKi, InpMat(iRow,MaxCol) )  ! technically a permutation matrix would only have +1.0 (not -1.0)
!      ChkCols(MaxCol)    = .TRUE.
!
!   END DO ! iRow
!
!   RETURN
!   END SUBROUTINE GetPermMat ! ( InpMat, PMat, ErrStat )

!=======================================================================
   FUNCTION EqualRealNos4 ( ReNum1, ReNum2 )

      ! This function compares 2 real numbers and determines if they
      ! are "almost" equal, i.e. within some relative tolerance
      ! ("Safe Comparisons" suggestion from http://www.lahey.com/float.htm)

      ! passed variables

   REAL(SiKi), INTENT(IN )         :: ReNum1                            ! the first  real number to compare
   REAL(SiKi), INTENT(IN )         :: ReNum2                            ! the second real number to compare

   LOGICAL                         :: EqualRealNos4                     ! the function definition -- returns .true. if the numbers are almost equal

      ! local variables
   REAL(SiKi), PARAMETER           :: Eps = EPSILON(ReNum1)             ! machine precision
   REAL(SiKi), PARAMETER           :: Tol = 100.0_SiKi*Eps / 2.0_SiKi   ! absolute tolerance (ignore the last 2 significant digits)

   REAL(SiKi)                      :: Fraction


      ! make sure we're never trying to get more precision than Tol

   Fraction = MAX( ABS(ReNum1+ReNum2), 1.0_SiKi )



      ! determine if ReNum1 and ReNum2 are approximately equal

   IF ( ABS(ReNum1 - ReNum2) <= Fraction*Tol ) THEN  ! the relative error 
      EqualRealNos4 = .TRUE.
   ELSE
      EqualRealNos4 = .FALSE.
   ENDIF


   END FUNCTION EqualRealNos4
!=======================================================================
  FUNCTION EqualRealNos8 ( ReNum1, ReNum2 )

      ! This function compares 2 real numbers and determines if they
      ! are "almost" equal, i.e. within some relative tolerance
      ! ("Safe Comparisons" suggestion from http://www.lahey.com/float.htm)

      ! passed variables

   REAL(R8Ki), INTENT(IN )         :: ReNum1                            ! the first  real number to compare
   REAL(R8Ki), INTENT(IN )         :: ReNum2                            ! the second real number to compare

   LOGICAL                         :: EqualRealNos8                     ! the function definition -- returns .true. if the numbers are almost equal

      ! local variables
   REAL(R8Ki), PARAMETER           :: Eps = EPSILON(ReNum1)             ! machine precision
   REAL(R8Ki), PARAMETER           :: Tol = 100.0_R8Ki*Eps / 2.0_R8Ki   ! absolute tolerance (ignore the last 2 significant digits)

   REAL(R8Ki)                      :: Fraction


      ! make sure we're never trying to get more precision than Tol

   Fraction = MAX( ABS(ReNum1+ReNum2), 1.0_R8Ki )



      ! determine if ReNum1 and ReNum2 are approximately equal

   IF ( ABS(ReNum1 - ReNum2) <= Fraction*Tol ) THEN  ! the relative error
      EqualRealNos8 = .TRUE.
   ELSE
      EqualRealNos8 = .FALSE.
   ENDIF


  END FUNCTION EqualRealNos8
!=======================================================================
  FUNCTION EqualRealNos16 ( ReNum1, ReNum2 )

      ! This function compares 2 real numbers and determines if they
      ! are "almost" equal, i.e. within some relative tolerance
      ! ("Safe Comparisons" suggestion from http://www.lahey.com/float.htm)

      ! passed variables

   REAL(QuKi), INTENT(IN )         :: ReNum1                            ! the first  real number to compare
   REAL(QuKi), INTENT(IN )         :: ReNum2                            ! the second real number to compare

   LOGICAL                         :: EqualRealNos16                    ! the function definition -- returns .true. if the numbers are almost equal

      ! local variables
   REAL(QuKi), PARAMETER           :: Eps = EPSILON(ReNum1)             ! machine precision
   REAL(QuKi), PARAMETER           :: Tol = 100.0_QuKi*Eps / 2.0_QuKi   ! absolute tolerance (ignore the last 2 significant digits)

   REAL(QuKi)                      :: Fraction


      ! make sure we're never trying to get more precision than Tol

   Fraction = MAX( ABS(ReNum1+ReNum2), 1.0_QuKi )



      ! determine if ReNum1 and ReNum2 are approximately equal

   IF ( ABS(ReNum1 - ReNum2) <= Fraction*Tol ) THEN  ! the relative error
      EqualRealNos16 = .TRUE.
   ELSE
      EqualRealNos16 = .FALSE.
   ENDIF


  END FUNCTION EqualRealNos16
!=======================================================================
   FUNCTION GetSmllRotAngs ( DCMat, ErrStat )

      ! This subroutine computes the angles that make up the input
      ! direction cosine matrix, DCMat

      ! passed variables

   REAL(ReKi), INTENT(IN )         :: DCMat          (3,3)
   INTEGER,    INTENT(OUT )        :: ErrStat               ! a non-zero value indicates an error in the permutation matrix algorithm

   REAL(ReKi)                      :: GetSmllRotAngs ( 3 )

      ! local variables
   REAL(ReKi)                      :: denom                 ! the denominator of the resulting matrix
   REAL(ReKi), PARAMETER           :: LrgAngle  = 0.4       ! Threshold for when a small angle becomes large (about 23deg).  This comes from: COS(SmllAngle) ~ 1/SQRT( 1 + SmllAngle^2 ) and SIN(SmllAngle) ~ SmllAngle/SQRT( 1 + SmllAngle^2 ) results in ~5% error when SmllAngle = 0.4rad.
   REAL(ReKi), PARAMETER           :: TOL = EPSILON(TOL)    ! tolerance for division by zero



      ! initialize output angles (just in case there is an error that prevents them from getting set)

   GetSmllRotAngs = 0.0
   ErrStat        = 0


      ! calculate the small angles
   GetSmllRotAngs(1) = DCMat(2,3) - DCMat(3,2)
   GetSmllRotAngs(2) = DCMat(3,1) - DCMat(1,3)
   GetSmllRotAngs(3) = DCMat(1,2) - DCMat(2,1)

   denom             = DCMat(1,1) + DCMat(2,2) + DCMat(3,3) - 1

   IF ( ABS(denom) > TOL ) THEN
      GetSmllRotAngs = GetSmllRotAngs / denom

               ! check that the angles are, in fact, small
      IF ( ANY( ABS(GetSmllRotAngs) > LrgAngle ) ) THEN
         CALL ProgWarn( ' Angles in GetSmllRotAngs() are larger than '//TRIM(Num2LStr(LrgAngle))//' radians.' )
         ErrStat = 1
      END IF

   ELSE
            ! check that the angles are, in fact, small (denom should be close to 2 if angles are small)
      CALL ProgAbort( ' Denominator is zero in GetSmllRotAngs().', TrapErrors = .TRUE. )
      ErrStat = -1

   END IF


   END FUNCTION GetSmllRotAngs ! ( DCMat, PMat, ErrStat )
!=======================================================================
   SUBROUTINE GL_Pts ( IPt, NPts, Loc, Wt, ErrStat )

      ! This funtion returns the non-dimensional (-1:+1) location of the given Gauss-Legendre Quadrature point and its weight.
      ! The values came from Carnahan, Brice; Luther, H.A.; Wilkes, James O.  (1969)  "Applied Numerical Methods."


      ! Argument declarations.

   REAL(ReKi)                     :: Loc                                         ! The location of the specified point.
   REAL(ReKi)                     :: Wt                                          ! The weight for the specified point.

   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                     ! Error status; if present, program does not abort on error
   INTEGER, INTENT(INOUT)         :: IPt                                         ! The quadrature point in question.
   INTEGER, INTENT(INOUT)         :: NPts                                        ! The number of points used in the quadrature.


   IF ( PRESENT(ErrStat) ) ErrStat = 0


      ! Check to see if the number of points and the specific point are valid values.

   IF ( ( NPts < 1 ) .OR. ( NPts > 6 ) )  THEN
      CALL ProgAbort ( ' In function GL_Loc, the number of points used for Gauss-Legendre Quadrature must be between 1 and 6' &
                    //' (inclusive).  Instead, it is "'//TRIM( Int2LStr( NPts ) )//'".', PRESENT(ErrStat) )
      IF ( PRESENT(ErrStat) ) THEN ! this should always be true here
         ErrStat = 1
         RETURN
      END IF
   END IF

   IF ( ( Ipt < 1 ) .OR. ( Ipt > NPts ) )  THEN
      CALL ProgAbort ( ' In function GL_Loc, the point being used for Gauss-Legendre Quadrature must be between 1 and ' &
                   //TRIM( Int2LStr( NPts ) )//' (inclusive).  Instead, it is "'//TRIM( Int2LStr( Ipt ) )//'".', PRESENT(ErrStat) )
      IF ( PRESENT(ErrStat) ) THEN
         ErrStat = 1
         RETURN
      END IF
   END IF


      ! Set the location and weight of the point.

   SELECT CASE ( NPts )
      CASE ( 1 )                         ! Case 1 is really just rectangular integration.
         Loc = 0.0
         Wt  = 2.0
      CASE ( 2 )
         SELECT CASE ( Ipt )
            CASE ( 1 )
               Loc = -0.5773503
               Wt  =  1.0
            CASE ( 2 )
               Loc = 0.5773503
               Wt  = 1.0
          END SELECT ! Ipt
      CASE ( 3 )
         SELECT CASE ( Ipt )
            CASE ( 1 )
               Loc = -0.7745967
               Wt  =  0.5555556
            CASE ( 2 )
               Loc =  0.0
               Wt  =  0.8888889
            CASE ( 3 )
               Loc =  0.7745967
               Wt  =  0.5555556
         END SELECT ! Ipt
      CASE ( 4 )
         SELECT CASE ( Ipt )
            CASE ( 1 )
               Loc = -0.8611363
               Wt  =  0.3478548
            CASE ( 2 )
               Loc = -0.3399810
               Wt  =  0.6521452
            CASE ( 3 )
               Loc =  0.3399810
               Wt  =  0.6521452
            CASE ( 4 )
               Loc =  0.8611363
               Wt  =  0.3478548
         END SELECT ! Ipt
      CASE ( 5 )
         SELECT CASE ( Ipt )
            CASE ( 1 )
               Loc = -0.9061798
               Wt  =  0.2369269
            CASE ( 2 )
               Loc = -0.5384693
               Wt  =  0.4786287
            CASE ( 3 )
               Loc =  0.0
               Wt  =  0.5688889
            CASE ( 4 )
               Loc =  0.5384693
               Wt  =  0.4786287
            CASE ( 5 )
               Loc =  0.9061798
               Wt  =  0.2369269
         END SELECT ! Ipt
      CASE ( 6 )
         SELECT CASE ( Ipt )
            CASE ( 1 )
               Loc = -0.9324695
               Wt  =  0.1713245
            CASE ( 2 )
               Loc = -0.6612094
               Wt  =  0.3607616
            CASE ( 3 )
               Loc = -0.2386192
               Wt  =  0.4679139
            CASE ( 4 )
               Loc =  0.2386192
               Wt  =  0.4679139
            CASE ( 5 )
               Loc =  0.6612094
               Wt  =  0.3607616
            CASE ( 6 )
               Loc =  0.9324695
               Wt  =  0.1713245
         END SELECT ! Ipt
   END SELECT ! Npts

   RETURN
   END SUBROUTINE GL_Pts ! ( IPt, NPts, Loc, Wt [, ErrStat] )
!=======================================================================
   FUNCTION IndexCharAry( CVal, CAry )


      ! This funtion returns an integer index such that CAry(IndexCharAry) = CVal. If
      ! no element in the array matches CVal, the value -1 is returned.  The routine
      ! performs a binary search on the input array to determine if CVal is an
      ! element of the array; thus, CAry must be sorted and stored in increasing
      ! alphebetical (ASCII) order. The routine does not check that the array is
      ! sorted.  The routine assumes that CVal is type CHARACTER and CAry
      ! is an array of CHARACTERS.


      ! Function declaration.


   INTEGER                      :: IndexCharAry                                   ! This function

      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: CVal                                           ! String to find.
   CHARACTER(*), INTENT(IN)     :: CAry(:)                                        ! Array of strings to search.



      ! Local declarations.

   INTEGER                      :: IHi                                             ! The high index into the arrays.
   INTEGER                      :: IMid                                            ! The mid-point index between IHi and ILo.
   INTEGER                      :: ILo


      ! Initialize some variables

   ILo = 1
   IHi = SIZE(CAry)

   IF (     CVal == CAry(ILo) ) THEN
      IndexCharAry = ILo
   ELSEIF ( CVal == CAry(IHi) ) THEN
      IndexCharAry = IHi
   ELSE
      IndexCharAry = -1


         ! Let's search!

      DO WHILE ( IHi-ILo > 1 )

         IMid = ( IHi + ILo )/2

         IF( CVal > CAry(IMid) ) THEN
            ILo = IMid
         ELSEIF (CVal < CAry(IMid) ) THEN
            IHi = IMid
         ELSE !Found it
            IndexCharAry = IMid
            EXIT
         END IF

      END DO

   END IF


   RETURN

   END FUNCTION IndexCharAry
!=======================================================================
   FUNCTION InterpBinComp( XVal, XAry, YAry, ILo, AryLen )


      ! This funtion returns a y-value that corresponds to an input x-value by interpolating into the arrays.
      ! It uses a binary interpolation scheme that takes about log(AryLen)/log(2) steps to converge.
      ! It returns the first or last YAry() value if XVal is outside the limits of XAry().
      ! This routine assumes YAry is COMPLEX.


      ! Function declaration.


   COMPLEX(ReKi)                :: InterpBinComp                                   ! This function.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the arrays.
   INTEGER, INTENT(INOUT)       :: ILo                                             ! The low index into the arrays.

   REAL(ReKi), INTENT(IN)       :: XAry    (AryLen)                                ! Array of X values to be interpolated.
   REAL(ReKi), INTENT(IN)       :: XVal                                            ! X value to be interpolated.

   COMPLEX(ReKi), INTENT(IN)    :: YAry    (AryLen)                                ! Array of Y values to be interpolated.


      ! Local declarations.

   INTEGER                      :: IHi                                             ! The high index into the arrays.
   INTEGER                      :: IMid                                            ! The mid-point index between IHi and ILo.



      ! Let's check the limits first.

   IF ( XVal <= XAry(1) )  THEN
      InterpBinComp = YAry(1)
      ILo           = 1
      RETURN
   ELSE IF ( XVal >= XAry(AryLen) )  THEN
      InterpBinComp = YAry(AryLen)
      ILo           = AryLen - 1
      RETURN
   END IF


      ! Let's interpolate!

   ILo  = 1
   IHi  = AryLen

   DO WHILE ( IHi-ILo > 1 )

      IMid = ( IHi + ILo )/2

      IF ( XVal >= XAry(IMid) ) THEN
         ILo = IMid
      ELSE
         IHi = IMid
      END IF

   END DO

   InterpBinComp = YAry(ILo) + ( YAry(IHi) - YAry(ILo) )*( XVal - XAry(ILo) )/( XAry(IHi) - XAry(ILo) )


   RETURN
   END FUNCTION InterpBinComp ! ( XVal, XAry, YAry, ILo, AryLen )
!=======================================================================
   FUNCTION InterpBinReal( XVal, XAry, YAry, ILo, AryLen )


      ! This funtion returns a y-value that corresponds to an input x-value by interpolating into the arrays.
      ! It uses a binary interpolation scheme that takes about log(AryLen)/log(2) steps to converge.
      ! It returns the first or last YAry() value if XVal is outside the limits of XAry().
      ! This routine assumes YAry is REAL.


      ! Function declaration.


   REAL(ReKi)                   :: InterpBinReal                                   ! This function.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the arrays.
   INTEGER, INTENT(INOUT)       :: ILo                                             ! The low index into the arrays.

   REAL(ReKi), INTENT(IN)       :: XAry    (AryLen)                                ! Array of X values to be interpolated.
   REAL(ReKi), INTENT(IN)       :: XVal                                            ! X value to be interpolated.
   REAL(ReKi), INTENT(IN)       :: YAry    (AryLen)                                ! Array of Y values to be interpolated.


      ! Local declarations.

   INTEGER                      :: IHi                                             ! The high index into the arrays.
   INTEGER                      :: IMid                                            ! The mid-point index between IHi and ILo.



      ! Let's check the limits first.

   IF ( XVal <= XAry(1) )  THEN
      InterpBinReal = YAry(1)
      ILo           = 1
      RETURN
   ELSE IF ( XVal >= XAry(AryLen) )  THEN
      InterpBinReal = YAry(AryLen)
      ILo           = AryLen - 1
      RETURN
   END IF


      ! Let's interpolate!

   ILo  = 1
   IHi  = AryLen

   DO WHILE ( IHi-ILo > 1 )

      IMid = ( IHi + ILo )/2

      IF ( XVal >= XAry(IMid) ) THEN
         ILo = IMid
      ELSE
         IHi = IMid
      END IF

   END DO

   InterpBinReal = YAry(ILo) + ( YAry(IHi) - YAry(ILo) )*( XVal - XAry(ILo) )/( XAry(IHi) - XAry(ILo) )


   RETURN
   END FUNCTION InterpBinReal ! ( XVal, XAry, YAry, ILo, AryLen )
!=======================================================================
   FUNCTION InterpStpComp( XVal, XAry, YAry, Ind, AryLen )


      ! This funtion returns a y-value that corresponds to an input x-value by interpolating into the arrays.
      ! It uses the passed index as the starting point and does a stepwise interpolation from there.  This is
      ! especially useful when the calling routines save the value from the last time this routine was called
      ! for a given case where XVal does not change much from call to call.  When there is no correlation
      ! from one interpolation to another, InterpBin() may be a better choice.
      ! It returns the first or last YAry() value if XVal is outside the limits of XAry().
      ! This routine assumes YAry is COMPLEX.


      ! Function declaration.


   COMPLEX(ReKi)                :: InterpStpComp                                   ! This function.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the arrays.
   INTEGER, INTENT(INOUT)       :: Ind                                             ! Initial and final index into the arrays.

   REAL(ReKi), INTENT(IN)       :: XAry    (AryLen)                                ! Array of X values to be interpolated.
   REAL(ReKi), INTENT(IN)       :: XVal                                            ! X value to be interpolated.

   COMPLEX(ReKi), INTENT(IN)    :: YAry    (AryLen)                                ! Array of Y values to be interpolated.



      ! Let's check the limits first.

   IF ( XVal <= XAry(1) )  THEN
      InterpStpComp = YAry(1)
      Ind           = 1
      RETURN
   ELSE IF ( XVal >= XAry(AryLen) )  THEN
      InterpStpComp = YAry(AryLen)
      Ind           = AryLen - 1
      RETURN
   END IF


     ! Let's interpolate!

   Ind = MAX( MIN( Ind, AryLen-1 ), 1 )

   DO

      IF ( XVal < XAry(Ind) )  THEN

         Ind = Ind - 1

      ELSE IF ( XVal >= XAry(Ind+1) )  THEN

         Ind = Ind + 1

      ELSE

         InterpStpComp = ( YAry(Ind+1) - YAry(Ind) )*( XVal - XAry(Ind) )/( XAry(Ind+1) - XAry(Ind) ) + YAry(Ind)
         RETURN

      END IF

   END DO


   RETURN
   END FUNCTION InterpStpComp ! ( XVal, XAry, YAry, Ind, AryLen )
!=======================================================================
   FUNCTION InterpStpReal( XVal, XAry, YAry, Ind, AryLen )


      ! This funtion returns a y-value that corresponds to an input x-value by interpolating into the arrays.
      ! It uses the passed index as the starting point and does a stepwise interpolation from there.  This is
      ! especially useful when the calling routines save the value from the last time this routine was called
      ! for a given case where XVal does not change much from call to call.  When there is no correlation
      ! from one interpolation to another, InterpBin() may be a better choice.
      ! It returns the first or last YAry() value if XVal is outside the limits of XAry().
      ! This routine assumes YAry is REAL.


      ! Function declaration.

   REAL(ReKi)                   :: InterpStpReal                                   ! This function.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the arrays.
   INTEGER, INTENT(INOUT)       :: Ind                                             ! Initial and final index into the arrays.

   REAL(ReKi), INTENT(IN)       :: XAry    (AryLen)                                ! Array of X values to be interpolated.
   REAL(ReKi), INTENT(IN)       :: XVal                                            ! X value to be interpolated.
   REAL(ReKi), INTENT(IN)       :: YAry    (AryLen)                                ! Array of Y values to be interpolated.



      ! Let's check the limits first.

   IF ( XVal <= XAry(1) )  THEN
      InterpStpReal = YAry(1)
      Ind           = 1
      RETURN
   ELSE IF ( XVal >= XAry(AryLen) )  THEN
      InterpStpReal = YAry(AryLen)
      Ind           = AryLen - 1
      RETURN
   END IF


     ! Let's interpolate!

   Ind = MAX( MIN( Ind, AryLen-1 ), 1 )

   DO

      IF ( XVal < XAry(Ind) )  THEN

         Ind = Ind - 1

      ELSE IF ( XVal >= XAry(Ind+1) )  THEN

         Ind = Ind + 1

      ELSE

         InterpStpReal = ( YAry(Ind+1) - YAry(Ind) )*( XVal - XAry(Ind) )/( XAry(Ind+1) - XAry(Ind) ) + YAry(Ind)
         RETURN

      END IF

   END DO


   RETURN
   END FUNCTION InterpStpReal ! ( XVal, XAry, YAry, Ind, AryLen )
!=======================================================================
   SUBROUTINE LocateBin( XVal, XAry, Ind, AryLen )

      ! This subroutine finds the lower-bound index of an input x-value located in an array.
      ! On return, Ind has a value such that
      !           XAry(Ind) <= XVal < XAry(Ind+1), with the exceptions that
      !             Ind = 0 when XVal < XAry(1), and
      !          Ind = AryLen when XAry(AryLen) <= XVal.
      !
      ! It uses a binary interpolation scheme that takes about log(AryLen)/log(2) steps to converge.
      ! If the index doesn't change much between calls, LocateStp() may be a better option.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(OUT)         :: Ind                                             ! Final (low) index into the array.

   REAL(ReKi), INTENT(IN)       :: XAry    (AryLen)                                ! Array of X values to be interpolated.
   REAL(ReKi), INTENT(IN)       :: XVal                                            ! X value to be interpolated.


      ! Local declarations.

   INTEGER                      :: IHi                                             ! The high index into the arrays.
   INTEGER                      :: IMid                                            ! The mid-point index between IHi and Ind.



      ! Let's check the limits first.

   IF ( XVal < XAry(1) )  THEN
      Ind = 0
   ELSE IF ( XVal >= XAry(AryLen) )  THEN
      Ind = AryLen
   ELSE
         ! Let's interpolate!

      Ind  = 1
      IHi  = AryLen

      DO WHILE ( IHi-Ind > 1 )

         IMid = ( IHi + Ind )/2

         IF ( XVal >= XAry(IMid) ) THEN
            Ind = IMid
         ELSE
            IHi = IMid
         END IF

      END DO

   END IF

   RETURN
   END SUBROUTINE LocateBin
!=======================================================================
   SUBROUTINE LocateStp( XVal, XAry, Ind, AryLen )

      ! This subroutine finds the lower-bound index of an input x-value located in an array.
      ! On return, Ind has a value such that
      !           XAry(Ind) <= XVal < XAry(Ind+1), with the exceptions that
      !             Ind = 0 when XVal < XAry(1), and
      !          Ind = AryLen when XAry(AryLen) <= XVal.
      !
      ! It uses the passed index as the starting point and does a stepwise search from there.  This is
      ! especially useful when the calling routines save the value from the last time this routine was called
      ! for a given case where XVal does not change much from call to call.  When there is no correlation
      ! from one interpolation to another, a binary search may be a better choice.



      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(INOUT)       :: Ind                                             ! Initial and final index into the array.

   REAL(ReKi), INTENT(IN)       :: XAry    (AryLen)                                ! Array of X values to be interpolated.
   REAL(ReKi), INTENT(IN)       :: XVal                                            ! X value to be interpolated.



      ! Let's check the limits first.

   IF ( XVal < XAry(1) )  THEN
      Ind = 0
   ELSE IF ( XVal >= XAry(AryLen) )  THEN
      Ind = AryLen
   ELSE

      Ind = MAX( MIN( Ind, AryLen-1 ), 1 )

      DO

         IF ( XVal < XAry(Ind) )  THEN

            Ind = Ind - 1

         ELSE IF ( XVal >= XAry(Ind+1) )  THEN

            Ind = Ind + 1

         ELSE

            RETURN

         END IF

      END DO


   END IF

   RETURN

   END SUBROUTINE LocateStp
!=======================================================================
   FUNCTION Mean ( Ary, AryLen )


      ! This routine calculates the mean value of an array.


      ! Function declaration.

   REAL(ReKi)                   :: Mean                                         ! This function.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                       ! Length of the array.

   REAL(ReKi), INTENT(IN)       :: Ary  (AryLen)                                ! Input array.


      ! Local declarations.

   INTEGER                      :: I                                            ! The index into the array.



   Mean = 0.0

   DO I=1,AryLen
      Mean = Mean + Ary(I)
   END DO ! I

   Mean = Mean/AryLen


   RETURN
   END FUNCTION Mean ! ( Ary, AryLen )
!=======================================================================
   SUBROUTINE MPi2Pi ( Angle )


      ! This routine ensures that Angle lies between -pi and pi.


      ! Argument declarations:

   REAL(ReKi), INTENT(INOUT)    :: Angle



      ! Get the angle between 0 and 2Pi.

   Angle = MODULO( Angle, TwoPi )


      ! Get the angle between -Pi and Pi.

   IF ( Angle > Pi )  THEN
      Angle = Angle - TwoPi
   END IF


   RETURN
   END SUBROUTINE MPi2Pi
!=======================================================================
   SUBROUTINE RombergInt(f, a, b, R, err, eps, ErrStat)

      ! This routine is used to integrate funciton f over the interval [a, b]. This routine
      ! is useful for sufficiently smooth (e.g., analytic) integrands, integrated over
      ! intervals which contain no singularities, and where the endpoints are also nonsingular.
      !
      ! f is an external function. For example f(x) = 1 + x.
      !
      !   FUNCTION f(x)
      !      USE PRECISION
      !      IMPLICIT NONE
      !
      !      REAL(ReKi) f
      !      REAL(ReKi) x
      !
      !      f = 1 + x
      !
      !      RETURN
      !   END FUNCTION f

   IMPLICIT NONE

      ! Argument declarations:

   REAL(ReKi), EXTERNAL              :: f               ! Integrand function name
   REAL(ReKi), INTENT(IN)            :: a               ! Lower integration limit
   REAL(ReKi), INTENT(IN)            :: b               ! Upper integration limit
   REAL(ReKi), INTENT(IN)            :: eps             ! Absolute error bound
   REAL(ReKi), INTENT(OUT)           :: R               ! The result of integration
   REAL(ReKi), INTENT(OUT)           :: err             ! Actual absolute error
   INTEGER, INTENT(OUT), OPTIONAL    :: ErrStat         ! Error status; if present, program does not abort on error

      ! Local declarations:

   INTEGER                           :: m, i, j, k
   INTEGER, PARAMETER                :: mmax = 50       ! Maximum iteration number for m
   INTEGER, PARAMETER                :: imax = 50       ! Maximum iteration number for i

   REAL(ReKi), ALLOCATABLE           :: T(:,:)
   REAL(ReKi)                        :: h               ! Step length
   REAL(ReKi)                        :: sumf

      ! Initialize T
   ALLOCATE( T( mmax, imax ) )
   T = 0

   T(1, 1) = 0.5*(b - a)*( f(a) + f(b) )

   k = 2
   DO m = 1, mmax-2
      h = (b-a)*(0.5)**m

      sumf = 0
      DO i = 1, 2**(m-1)
         sumf = sumf + f(a + (2*i-1)*h)
         k = k + 1
      END DO


      T( m+1, 1) = 0.5*T( m, 1 )+ h * sumf

      DO j = 1, m
         T(m-j+1, j+1) = ( 4.0**j * T(m-j+2, j) - T(m-j+1, j) )/(4.0**j - 1.0)

            ! absolute error
         err = ABS( T(m-j+1, j+1) - T( m-j+2, j ) )

            ! set k >=9 to prevent early terminations
         IF( (err .LT. eps) .and. (k >= 9) ) THEN

               ! return the intergration result if the conditions are met
            R = T(m-j+1, j+1)

            IF( ALLOCATED(T) ) DEALLOCATE(T)

            RETURN
         END IF

      END DO

   END DO

   err = ABS( T(m-j+1, j+1) - T( m-j+2, j ) )
   R = T(m-j+1, j+1)

   IF( ALLOCATED(T) ) DEALLOCATE(T)

      ! Return error message if the maximum iteration number is reached.
   CALL ProgAbort ( ' In subroutine RombergInt, the iteration reaches the maximum number. The integration did NOT converge! ', &
                    PRESENT(ErrStat) )
   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = 1
      RETURN
   END IF

   RETURN
END SUBROUTINE RombergInt
!=======================================================================
   SUBROUTINE SetConstants( )

      ! This routine computes numeric constants stored in the NWTC Library

!   USE, INTRINSIC :: ieee_arithmetic  !use this for compilers that have implemented 

      ! local variables for getting values of NaN and Inf (not necessary when using ieee_arithmetic)
   REAL(DbKi)                          :: Neg_D          ! a negative real(DbKi) number
   REAL(ReKi)                          :: Neg            ! a negative real(ReKi) number                                        

      
      ! Constants based upon Pi:

   Pi_D      = ACOS( -1.0_DbKi )
   D2R_D     = Pi_D/180.0_DbKi
   R2D_D     = 180.0_DbKi/Pi_D
   PiBy2_D   = Pi_D/2.0_DbKi
   RPM2RPS_D = Pi_D/30.0_DbKi
   RPS2RPM_D = 30.0_DbKi/Pi_D
   TwoByPi_D = 2.0_DbKi/Pi_D
   TwoPi_D   = 2.0_DbKi*Pi_D

   Pi      = ACOS( -1.0_ReKi )
   D2R     = Pi/180.0_ReKi
   R2D     = 180.0_ReKi/Pi
   PiBy2   = Pi/2.0_ReKi
   RPM2RPS = Pi/30.0_ReKi
   RPS2RPM = 30.0_ReKi/Pi
   TwoByPi =  2.0_ReKi/Pi
   TwoPi   =  2.0_ReKi*Pi
   
   
      ! IEEE constants:
      
!   NaN_D = ieee_value(0.0_DbKi, ieee_quiet_nan)
!   Inf_D = ieee_value(0.0_DbKi, ieee_positive_inf)
!
!   NaN   = ieee_value(0.0_ReKi, ieee_quiet_nan)
!   Inf   = ieee_value(0.0_DbKi, ieee_positive_inf)
   
      ! set variables to negative numbers to calculate NaNs (compilers may complain when taking sqrt of negative constants)
   Neg   = -1.0_ReKi
   Neg_D = -1.0_DbKi
   
   NaN_D = SQRT ( Neg_D )
   Inf_D = Pi_D / 0.0_DbKi

   NaN   = SQRT ( Neg )
   Inf   = Pi / 0.0_ReKi
   
   
   RETURN
   END SUBROUTINE SetConstants
!=======================================================================
   SUBROUTINE SmllRotTrans( RotationType, Theta1, Theta2, Theta3, TransMat, ErrTxt )


      ! This routine computes the 3x3 transformation matrix, TransMat,
      !   to a coordinate system x (with orthogonal axes x1, x2, x3)
      !   resulting from three rotations (Theta1, Theta2, Theta3) about the
      !   orthogonal axes (X1, X2, X3) of coordinate system X.  All angles
      !   are assummed to be small, as such, the order of rotations does
      !   not matter and Euler angles do not need to be used.  This routine
      !   is used to compute the transformation matrix (TransMat) between
      !   undeflected (X) and deflected (x) coordinate systems.  In matrix
      !   form:
      !      {x1}   [TransMat(Theta1, ] {X1}
      !      {x2} = [         Theta2, ]*{X2}
      !      {x3}   [         Theta3 )] {X3}

      ! The transformation matrix, TransMat, is the closest orthonormal
      !   matrix to the nonorthonormal, but skew-symmetric, Bernoulli-Euler
      !   matrix:
      !          [   1.0    Theta3 -Theta2 ]
      !      A = [ -Theta3   1.0    Theta1 ]
      !          [  Theta2 -Theta1   1.0   ]
      !
      !   In the Frobenius Norm sense, the closest orthornormal matrix is:
      !      TransMat = U*V^T,
      !
      !   where the columns of U contain the eigenvectors of A*A^T and the
      !   columns of V contain the eigenvectors of A^T*A (^T = transpose).
      !   This result comes directly from the Singular Value Decomposition
      !   (SVD) of A = U*S*V^T where S is a diagonal matrix containing the
      !   singular values of A, which are SQRT( eigenvalues of A*A^T ) =
      !   SQRT( eigenvalues of A^T*A ).

      ! The algebraic form of the transformation matrix, as implemented
      !   below, was derived symbolically by J. Jonkman by computing U*V^T
      !   by hand with verification in Mathematica.



      ! Passed Variables:

   REAL(ReKi), INTENT(IN )             :: Theta1                                          ! The small rotation about X1, (rad).
   REAL(ReKi), INTENT(IN )             :: Theta2                                          ! The small rotation about X2, (rad).
   REAL(ReKi), INTENT(IN )             :: Theta3                                          ! The small rotation about X3, (rad).
   REAL(ReKi), INTENT(OUT)             :: TransMat (3,3)                                  ! The resulting transformation matrix from X to x, (-).

   CHARACTER(*), INTENT(IN)            :: RotationType                                    ! The type of rotation; used to inform the user where a large rotation is occuring upon such an event.
   CHARACTER(*), INTENT(IN ), OPTIONAL :: ErrTxt                                          ! an additional message to be displayed as a warning (typically the simulation time)


      ! Local Variables:

   REAL(ReKi)                          :: ComDenom                                        ! = ( Theta1^2 + Theta2^2 + Theta3^2 )*SQRT( 1.0 + Theta1^2 + Theta2^2 + Theta3^2 )
   REAL(ReKi), PARAMETER               :: LrgAngle  = 0.4                                 ! Threshold for when a small angle becomes large (about 23deg).  This comes from: COS(SmllAngle) ~ 1/SQRT( 1 + SmllAngle^2 ) and SIN(SmllAngle) ~ SmllAngle/SQRT( 1 + SmllAngle^2 ) results in ~5% error when SmllAngle = 0.4rad.
   REAL(ReKi)                          :: Theta11                                         ! = Theta1^2
   REAL(ReKi)                          :: Theta12S                                        ! = Theta1*Theta2*[ SQRT( 1.0 + Theta1^2 + Theta2^2 + Theta3^2 ) - 1.0 ]
   REAL(ReKi)                          :: Theta13S                                        ! = Theta1*Theta3*[ SQRT( 1.0 + Theta1^2 + Theta2^2 + Theta3^2 ) - 1.0 ]
   REAL(ReKi)                          :: Theta22                                         ! = Theta2^2
   REAL(ReKi)                          :: Theta23S                                        ! = Theta2*Theta3*[ SQRT( 1.0 + Theta1^2 + Theta2^2 + Theta3^2 ) - 1.0 ]
   REAL(ReKi)                          :: Theta33                                         ! = Theta3^2
   REAL(ReKi)                          :: SqrdSum                                         ! = Theta1^2 + Theta2^2 + Theta3^2
   REAL(ReKi)                          :: SQRT1SqrdSum                                    ! = SQRT( 1.0 + Theta1^2 + Theta2^2 + Theta3^2 )

   LOGICAL,    SAVE                    :: FrstWarn  = .TRUE.                              ! When .TRUE., indicates that we're on the first warning.



      ! Display a warning message if at least one angle gets too large in
      !   magnitude:

   IF ( ( ( ABS(Theta1) > LrgAngle ) .OR. ( ABS(Theta2) > LrgAngle ) .OR. ( ABS(Theta3) > LrgAngle ) ) .AND. FrstWarn )  THEN

               
      CALL ProgWarn(' Small angle assumption violated in SUBROUTINE SmllRotTrans() due to'// &
                     ' a large '//TRIM(RotationType)//'. The solution may be inaccurate.'// &
                     ' Simulation continuing, but future warnings will be suppressed.')
      IF ( PRESENT(ErrTxt) ) THEN
         CALL WrScr(' Additional debugging message from SUBROUTINE SmllRotTrans(): '//TRIM(ErrTxt) )
      END IF

      FrstWarn = .FALSE.   ! Don't enter here again!

   ENDIF



      ! Compute some intermediate results:

   Theta11      = Theta1*Theta1
   Theta22      = Theta2*Theta2
   Theta33      = Theta3*Theta3

   SqrdSum      = Theta11 + Theta22 + Theta33
   SQRT1SqrdSum = SQRT( 1.0 + SqrdSum )
   ComDenom     = SqrdSum*SQRT1SqrdSum

   Theta12S     = Theta1*Theta2*( SQRT1SqrdSum - 1.0 )
   Theta13S     = Theta1*Theta3*( SQRT1SqrdSum - 1.0 )
   Theta23S     = Theta2*Theta3*( SQRT1SqrdSum - 1.0 )


      ! Define the transformation matrix:

   IF ( ComDenom == 0.0 )  THEN  ! All angles are zero and matrix is ill-conditioned (the matrix is derived assuming that the angles are not zero); return identity

      TransMat(1,:) = (/ 1.0, 0.0, 0.0 /)
      TransMat(2,:) = (/ 0.0, 1.0, 0.0 /)
      TransMat(3,:) = (/ 0.0, 0.0, 1.0 /)

   ELSE                          ! At least one angle is nonzero

      TransMat(1,1) = ( Theta11*SQRT1SqrdSum + Theta22              + Theta33              )/ComDenom
      TransMat(2,2) = ( Theta11              + Theta22*SQRT1SqrdSum + Theta33              )/ComDenom
      TransMat(3,3) = ( Theta11              + Theta22              + Theta33*SQRT1SqrdSum )/ComDenom
      TransMat(1,2) = (  Theta3*SqrdSum + Theta12S )/ComDenom
      TransMat(2,1) = ( -Theta3*SqrdSum + Theta12S )/ComDenom
      TransMat(1,3) = ( -Theta2*SqrdSum + Theta13S )/ComDenom
      TransMat(3,1) = (  Theta2*SqrdSum + Theta13S )/ComDenom
      TransMat(2,3) = (  Theta1*SqrdSum + Theta23S )/ComDenom
      TransMat(3,2) = ( -Theta1*SqrdSum + Theta23S )/ComDenom

   ENDIF



   RETURN
   END SUBROUTINE SmllRotTrans
!=======================================================================
   SUBROUTINE SortUnion ( Ary1, N1, Ary2, N2, Ary, N )


      ! This routine takes two sorted arrays and finds the sorted union of the two.

      ! Note: If the same value is found in both arrays, only one is kept.  However, if either
      !       array as multiple occurances of the same value, the largest multiple will be
      !       kept.  Duplicates should be eliminated externally if this is not desirable.


      ! Argument declarations:

   INTEGER, INTENT(OUT)         :: N                                            ! The length of the output array.
   INTEGER, INTENT(IN)          :: N1                                           ! The length of the first input array.
   INTEGER, INTENT(IN)          :: N2                                           ! The length of the second input array.

   REAL(ReKi), INTENT(OUT)      :: Ary(N1+N2)                                   ! The sorted union.
   REAL(ReKi), INTENT(IN)       :: Ary1(N1)                                     ! The first list of sorted real numbers.
   REAL(ReKi), INTENT(IN)       :: Ary2(N2)                                     ! The second list of sorted real numbers.


      ! Local declarations:

   INTEGER                      :: I1                                           ! Index into the first array.
   INTEGER                      :: I2                                           ! Index into the second array.



   I1 = 1
   I2 = 1
   N  = 1

   DO WHILE ( ( I1 <= N1 ) .AND. ( I2 <= N2 ) )

      IF ( Ary1(I1) < Ary2(I2) )  THEN
         Ary(N) = Ary1(I1)
         I1 = I1 + 1
      ELSE IF ( Ary1(I1) > Ary2(I2) )  THEN
         Ary(N) = Ary2(I2)
         I2 = I2 + 1
      ELSE
         Ary(N) = Ary1(I1)
         I1 = I1 + 1
         I2 = I2 + 1
      END IF

      N  = N  + 1

   END DO ! WHILE


     ! We've reached the end of one array, but we need to add the end
     ! of the other array if we haven't reached the end of it yet.

   IF ( I1 <= N1 ) THEN
      Ary(N:N+N1-I1) = Ary1(I1:)
      N = N+N1-I1
   ELSEIF ( I2 <= N2 ) THEN
      Ary(N:N+N2-I2) = Ary2(I2:)
      N = N+N2-I2
   ELSE
      N = N - 1
   ENDIF


   RETURN
   END SUBROUTINE SortUnion ! ( Ary1, N1, Ary2, N2, Ary, N )
!=======================================================================
   FUNCTION StdDevFn ( Ary, AryLen, Mean )


      ! This routine calculates the standard deviation of a population contained in Ary.


      ! Function declaration.

   REAL(ReKi)                   :: StdDevFn                                     ! This function.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                       ! Length of the array.

   REAL(ReKi), INTENT(IN)       :: Ary  (AryLen)                                ! Input array.
   REAL(ReKi), INTENT(IN)       :: Mean                                         ! The previously calculated mean of the array.


      ! Local declarations.

   REAL(DbKi)                   :: Sum                                          ! A temporary sum.

   INTEGER                      :: I                                            ! The index into the array.



   Sum = 0.0_DbKi

   DO I=1,AryLen
      Sum = Sum + ( Ary(I) - Mean )**2
   END DO ! I

   StdDevFn = SQRT( Sum/( AryLen - 1 ) )


   RETURN
   END FUNCTION StdDevFn ! ( Ary, AryLen, Mean )
!=======================================================================

END MODULE NWTC_Num
MODULE ModMesh
! (c) 2012 National Renewable Energy Laboratory
!
!BJJ: This is a place holder for a module John Michalaches and Ilene Carpenter are writing.
! This will be part of the NWTC Subroutine Library.


 USE PRECISION

   INTEGER(IntKi), PARAMETER :: MESH_NEWCOPY    = 1
   INTEGER(IntKi), PARAMETER :: MESH_SIBLING    = 2
   INTEGER(IntKi), PARAMETER :: MESH_UPDATECOPY = 3


TYPE, PUBLIC :: MeshType
   LOGICAL                 :: committed             ! Indicate whether this mesh is committed
   INTEGER(IntKi)          :: ios                   ! COMPONENT_INPUT/OUTPUT/STATE/PARAMETER
   INTEGER(IntKi)          :: RemapFlag             ! Remap flag: zero=noaction/ignore
                                                    !             nonzero=module_defined
   INTEGER(IntKi)          :: Nnodes                ! Number of nodes (vertices) in mesh
   INTEGER(IntKi)          :: Nelements             ! Number of elements in mesh
   INTEGER(IntKi)          :: Npoint                ! Number of point elements
   INTEGER(IntKi)          :: Nline2                ! Number of 2-node line elements
   INTEGER(IntKi)          :: Nline3                ! Number of 3-node line elements
   INTEGER(IntKi)          :: Ntri3                 ! Number of 3-node triangle elements
   INTEGER(IntKi)          :: Ntri6                 ! Number of 6-node triangle elements
   INTEGER(IntKi)          :: Nquad4                ! Number of 4-node quadrilateral elements
   INTEGER(IntKi)          :: Nquad8                ! Number of 8-node quadrilateral elements
   INTEGER(IntKi)          :: Ntet4                 ! Number of 4-node tet elements
   INTEGER(IntKi)          :: Ntet10                ! Number of 10-node tet elements
   INTEGER(IntKi)          :: Nhex8                 ! Number of 8-node hex elements
   INTEGER(IntKi)          :: Nhex20                ! Number of 20-node hex elements
   INTEGER(IntKi)          :: Nwedge6               ! Number of 6-node wedge elements
   INTEGER(IntKi)          :: Nwedge15              ! Number of 15-node wedgeelements
   INTEGER(IntKi), POINTER :: element_point(:)      ! Point connectivity
   INTEGER(IntKi), POINTER :: element_line2(:,:)    ! 2-node line connectivity
   INTEGER(IntKi), POINTER :: element_line3(:,:)    ! 3-node line connectivity
   INTEGER(IntKi), POINTER :: element_tri3(:,:)     ! 3-node triangle connectivity
   INTEGER(IntKi), POINTER :: element_tri6(:,:)     ! 6-node triangle connectivity
   INTEGER(IntKi), POINTER :: element_quad4(:,:)    ! 4-node quad connectivity
   INTEGER(IntKi), POINTER :: element_quad8(:,:)    ! 8-node quad connectivity
   INTEGER(IntKi), POINTER :: element_tet4(:,:)     ! 4-node tet connectivity
   INTEGER(IntKi), POINTER :: element_tet10(:,:)   ! 10-node tet connectivity
   INTEGER(IntKi), POINTER :: element_hex8(:,:)     ! 8-node hex connectivity
   INTEGER(IntKi), POINTER :: element_hex20(:,:)   ! 20-node hex connectivity
   INTEGER(IntKi), POINTER :: element_wedge6(:,:)   ! 6-node wedge connectivity
   INTEGER(IntKi), POINTER :: element_wedge15(:,:) ! 15-node wedge connectivity
   REAL(ReKi),     POINTER :: Position(:,:)         ! XYZ coordinate of node
   REAL(ReKi),     POINTER :: Force(:,:)            ! Force vectors
   REAL(ReKi),     POINTER :: Moment(:,:)           ! Moment vectors
   REAL(ReKi),     POINTER :: Orientation(:,:,:)    ! Direction Cosine Matrix (DCM)
   REAL(ReKi),     POINTER :: Rotation(:,:)         ! Rotational Velocities
   REAL(ReKi),     POINTER :: Translation(:,:)      ! Translational Velocities
   REAL(ReKi),     POINTER :: AddedMass(:,:,:)      ! Added mass matrix
   REAL(ReKi),     POINTER :: Scalars(:,:)          ! Scalars (2nd Dim is over Scalars)
   TYPE(MeshType), POINTER :: YoungerSibling        ! Pointer to next sibling in list
   TYPE(MeshType), POINTER :: ElderSibling          ! Pointer to prev sibling in list
END TYPE MeshType


END MODULE
MODULE NWTC_Aero


   ! This module contains aerodynamics routines with non-system-specific logic and references.


   ! It contains the following routines:

   !     SUBROUTINE AeroInt  ( ISeg, Alpha, Re, AF_Table, IntData, DoCl, DoCd, DoCm, DoCpmin [, ErrStat] )
   !     SUBROUTINE CompDR   ( NumSeg, RLoc, HubRad, RotorRad, DimenInp, DelRLoc [, ErrStat] )
   !     SUBROUTINE GetAF    ( AF_File, AF_Table, ISeg )
   !     FUNCTION   GetCoef  ( ISeg, Alpha, AlfaTab, CoefTab, NumRows, Ind [, ErrStat] )
   !     SUBROUTINE GetCoefs ( ISeg, Alpha, Re, AF_Table, ClInt, CdInt, CmInt, CpminInt, DoCl, DoCd, DoCm, DoCpmin [, ErrStat] )


   USE                             NWTC_IO
   USE                             NWTC_Num
   
   IMPLICIT  NONE


!=======================================================================


      ! Global aerodynamics-related variables.

   TYPE                            :: AeroData                                  ! Declare new type that holds the interpolated aero data from the big tables.
      REAL(ReKi)                   :: AlfaStal                                  ! The stall AoA for this table.
      REAL(ReKi)                   :: AOD                                       ! The AoA for minimum CD.
      REAL(ReKi)                   :: AOL                                       ! The zero-lift AoA.
      REAL(ReKi)                   :: Cd0                                       ! The minimum Cd value.
      REAL(ReKi)                   :: CnA                                       ! The Cn slope for zero-lift.
      REAL(ReKi)                   :: CnS                                       ! The Cn at stall value for positive AoA.
      REAL(ReKi)                   :: CnSL                                      ! Cn at stall value for negative AoA.
      REAL(ReKi)                   :: Cl                                        ! The lift coefficient.
      REAL(ReKi)                   :: Cd                                        ! The drag coefficient.
      REAL(ReKi)                   :: Cm                                        ! The pitching-moment coefficient.
      REAL(ReKi)                   :: Cpmin                                     ! The minimum pressure coefficient.
      REAL(ReKi)                   :: FTB                                       ! The normal-coefficient divided by the Cn slope at zero lift.
      REAL(ReKi)                   :: FTBC                                      ! The chordwise-coefficient divided by the Cn slope at zero lift.
   ENDTYPE AeroData

   TYPE                            :: AeroTable                                 ! Declare new type that is an allocatable table of data.
      REAL(ReKi)                   :: AlfaStal                                  ! The stall AoA for this table.
      REAL(ReKi)                   :: AOD                                       ! The AoA for minimum CD.
      REAL(ReKi)                   :: AOL                                       ! The zero-lift AoA.
      REAL(ReKi)                   :: Cd0                                       ! The minimum Cd value.
      REAL(ReKi)                   :: CnA                                       ! The Cn slope for zero-lift.
      REAL(ReKi)                   :: CnS                                       ! The Cn at stall value for positive AoA.
      REAL(ReKi)                   :: CnSL                                      ! Cn at stall value for negative AoA.
      REAL(ReKi)                   :: Re                                        ! The Re for this table.
      REAL(ReKi)                   :: Ctrl                                      ! The control setting for this table.
      INTEGER                      :: Ind      = 0                              ! Last-used index into table.  Zero at beginning.
      INTEGER                      :: NumAlf                                    ! Number of angles of attack in the table.
      REAL(ReKi), ALLOCATABLE      :: Alpha    (:)                              ! The angle of attack vector.
      REAL(ReKi), ALLOCATABLE      :: Cl       (:)                              ! The lift-coefficient vector.
      REAL(ReKi), ALLOCATABLE      :: Cd       (:)                              ! The drag-coefficient vector.
      REAL(ReKi), ALLOCATABLE      :: Cm       (:)                              ! The pitching-moment-coefficient vector.
      REAL(ReKi), ALLOCATABLE      :: Cpmin    (:)                              ! The minimum-pressure-coefficient vector.
      REAL(ReKi), ALLOCATABLE      :: FTB      (:)                              ! The normal-coefficient divided by the Cn slope at zero lift.
      REAL(ReKi), ALLOCATABLE      :: FTBC     (:)                              ! The chordwise-coefficient divided by the Cn slope at zero lift.
   ENDTYPE AeroTable

   TYPE                            :: AlfIndx                                   ! Declare new type that is an allocatable table of alpha indices.
      INTEGER                      :: NumBld                                    ! Number of blades in the table.
      INTEGER                      :: NumElm                                    ! Number of segments in the table.
      INTEGER, ALLOCATABLE         :: Ind      (:,:)                            ! The tables in this supertable.
   ENDTYPE AlfIndx

   TYPE                            :: ElmTable                                  ! Declare new type that is an allocatable table of data.
      INTEGER                      :: NumTabs                                   ! Number of tables in the supertable for an element.
      TYPE(AeroTable), ALLOCATABLE :: Tab      (:)                              ! The tables in this supertable.
   ENDTYPE ElmTable

   LOGICAL                         :: UseCm    = .FALSE.                        ! Flag to tell if there are Cm data in the airfoil files.
   LOGICAL                         :: UseCpmin = .FALSE.                        ! Flag to tell if there are Cp,min data in the airfoil files.


CONTAINS

!=======================================================================
   SUBROUTINE AeroInt ( ISeg, Alpha, Re, AF_Table, IntData, DoCl, DoCd, DoCm, DoCpmin, ErrStat )

      ! This routine finds the Re-bounding tables and then calls GetCoef() to get the
      ! desired coefficients for the two tables and then interpolates between them.

!NOTE: This routine needs to be modified to account for various control settings.  mlb  1-May-2010

      ! Argument declarations.

   REAL(ReKi), INTENT(IN)            :: Alpha                                   ! Angle of attack to get the coefficient for.
   REAL(ReKi), INTENT(IN)            :: Re                                      ! Reynolds number.

   INTEGER, INTENT(OUT), OPTIONAL    :: ErrStat                                 ! Error status; if present, program does not abort on error
   INTEGER, INTENT(IN)               :: ISeg                                    ! The current segment.

   LOGICAL, INTENT(IN)               :: DoCd                                    ! Get Cd.
   LOGICAL, INTENT(IN)               :: DoCl                                    ! Get Cl.
   LOGICAL, INTENT(IN)               :: DoCm                                    ! Get Cm.
   LOGICAL, INTENT(IN)               :: DoCpmin                                 ! Get Cp,min.

   TYPE (ElmTable), INTENT(INOUT)    :: AF_Table                                ! The table of airfoil data for the current segment.
   TYPE (AeroData), INTENT(OUT)      :: IntData                                 ! The interpolated airfoil data for the current segment.


      ! Local declarations.

   REAL(ReKi)                        :: CdHi                                    ! The drag coefficient for the higher Re.
   REAL(ReKi)                        :: ClHi                                    ! The lift coefficient for the higher Re.
   REAL(ReKi)                        :: CmHi                                    ! The pitching-moment coefficient for the higher Re.
   REAL(ReKi)                        :: CpminHi                                 ! The minimum pressure coefficient for the higher Re.
   REAL(ReKi)                        :: Fract                                   ! The fractional distance between tables.

   INTEGER                           :: ITab                                    ! An index for table number.
   INTEGER                           :: ITabLo                                  ! The table number that is the lower bound for Re.
   INTEGER                           :: ITabHi                                  ! The table number that is the lower bound for Re.

   LOGICAL                           :: OneTable                                ! Flag that tells if we need to read only one table (no interpolation).



      ! Find the bounding tables (if multiple) for this Re.  If there is only one table
      ! or if we are outside the range of tables, we won't need to interpolate.

   IF ( Re <= AF_Table%Tab(1)%Re )  THEN
      ITabLo   = 1
      OneTable = .TRUE.
   ELSE IF ( Re >= AF_Table%Tab(AF_Table%NumTabs)%Re )  THEN
      ITabLo   = AF_Table%NumTabs
      OneTable = .TRUE.
   ELSE IF ( AF_Table%NumTabs > 1 )  THEN
      DO ITab=1,AF_Table%NumTabs-1
         IF ( Re <= AF_Table%Tab(ITab+1)%Re )  THEN
            ITabLo = ITab
            ITabHi = ITab + 1
            EXIT
         END IF
      END DO
      OneTable = .FALSE.
   ELSE
      ITabLo   = 1
      OneTable = .TRUE.
   END IF


      ! Get the coefficients for ITabLo.

   IF ( DoCl )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         IntData%Cl = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cl, AF_Table%Tab(ITabLo)%NumAlf &
                           , AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         IntData%Cl = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cl, AF_Table%Tab(ITabLo)%NumAlf &
                           , AF_Table%Tab(ITabLo)%Ind )
      END IF
   END IF

   IF ( DoCd )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         IntData%Cd  = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cd, AF_Table%Tab(ITabLo)%NumAlf &
                              , AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         IntData%Cd  = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cd, AF_Table%Tab(ITabLo)%NumAlf &
                              , AF_Table%Tab(ITabLo)%Ind )
      END IF
   END IF

   IF ( DoCm )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         IntData%Cm = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cm, AF_Table%Tab(ITabLo)%NumAlf &
                             , AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         IntData%Cm = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cm, AF_Table%Tab(ITabLo)%NumAlf &
                             , AF_Table%Tab(ITabLo)%Ind )
      END IF
   END IF

   IF ( DoCpmin )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         IntData%Cpmin = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cpmin, AF_Table%Tab(ITabLo)%NumAlf &
                                , AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         IntData%Cpmin = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cpmin, AF_Table%Tab(ITabLo)%NumAlf &
                                , AF_Table%Tab(ITabLo)%Ind )
      END IF
   END IF

   IntData%AlfaStal = AF_Table%Tab(ITabLo)%AlfaStal
   IntData%AOD      = AF_Table%Tab(ITabLo)%AOD
   IntData%AOL      = AF_Table%Tab(ITabLo)%AOL
   IntData%Cd0      = AF_Table%Tab(ITabLo)%Cd0
   IntData%CnA      = AF_Table%Tab(ITabLo)%CnA
   IntData%CnS      = AF_Table%Tab(ITabLo)%CnS
   IntData%CnSL     = AF_Table%Tab(ITabLo)%CnSL


      ! If we don't need to interpolate, we don't need to make a second call and we are done.

   IF ( OneTable )  RETURN


      ! Get the coefficients for ITabHi.  Use step-wise interpolation for all but the first coefficient called.

   Fract = ( Re - AF_Table%Tab(ITabLo)%Re )/( AF_Table%Tab(ITabHi)%Re - AF_Table%Tab(ITabLo)%Re )


   IF ( DoCl )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         ClHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cl, AF_Table%Tab(ITabHi)%NumAlf, &
                                      AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         ClHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cl, AF_Table%Tab(ITabHi)%NumAlf, &
                                      AF_Table%Tab(ITabHi)%Ind )
      END IF
      IntData%Cl  = IntData%Cl + Fract*( ClHi - IntData%Cl )
   END IF

   IF ( DoCd )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         CdHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cd, AF_Table%Tab(ITabHi)%NumAlf, &
                                      AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         CdHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cd, AF_Table%Tab(ITabHi)%NumAlf, &
                                      AF_Table%Tab(ITabHi)%Ind )
      END IF
      IntData%Cd = IntData%Cd + Fract*( CdHi - IntData%Cd )
   END IF

   IF ( DoCm )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         CmHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cm, AF_Table%Tab(ITabHi)%NumAlf, &
                                      AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         CmHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cm, AF_Table%Tab(ITabHi)%NumAlf, &
                                      AF_Table%Tab(ITabHi)%Ind )
      END IF
      IntData%Cm = IntData%Cm + Fract*( CmHi - IntData%Cm )
   END IF

   IF ( DoCpmin )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         CpminHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cpmin, AF_Table%Tab(ITabHi)%NumAlf, &
                                         AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         CpminHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cpmin, AF_Table%Tab(ITabHi)%NumAlf, &
                                         AF_Table%Tab(ITabHi)%Ind )
      END IF
      IntData%Cpmin = IntData%Cpmin + Fract*( CpminHi - IntData%Cpmin )
   END IF

   IntData%AlfaStal = IntData%AlfaStal + Fract*( AF_Table%Tab(ITabHi)%AlfaStal - IntData%AlfaStal )
   IntData%AOD      = IntData%AOD      + Fract*( AF_Table%Tab(ITabHi)%AOD      - IntData%AOD      )
   IntData%AOL      = IntData%AOL      + Fract*( AF_Table%Tab(ITabHi)%AOL      - IntData%AOL      )
   IntData%Cd0      = IntData%Cd0      + Fract*( AF_Table%Tab(ITabHi)%Cd0      - IntData%Cd0      )
   IntData%CnA      = IntData%CnA      + Fract*( AF_Table%Tab(ITabHi)%CnA      - IntData%CnA      )
   IntData%CnS      = IntData%CnS      + Fract*( AF_Table%Tab(ITabHi)%CnS      - IntData%CnS      )
   IntData%CnSL     = IntData%CnSL     + Fract*( AF_Table%Tab(ITabHi)%CnSL     - IntData%CnSL     )


   RETURN
   END SUBROUTINE AeroInt ! ( ISeg, Alpha, Re, AF_Table, IntData, ClInt, CdInt, CmInt )
!=======================================================================
   SUBROUTINE CompDR ( NumSeg, RLoc, HubRad, RotorRad, DimenInp, DelRLoc, ErrStat )


      ! This routine computes the segment lengths from the local radii and the rotor radius.
      ! It prints and error if the list of radii is not realizable.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: NumSeg                                       ! Number of blade segments.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                      ! Error status; if present, program does not abort on error

   REAL(ReKi), INTENT(OUT)      :: DelRLoc (NumSeg)                             ! The array of segment lengths.
   REAL(ReKi), INTENT(IN)       :: HubRad                                       ! The hub radius.
   REAL(ReKi), INTENT(IN)       :: RLoc    (NumSeg)                             ! The array of radii (segment centers).
   REAL(ReKi), INTENT(IN)       :: RotorRad                                     ! The rotor radius.

   LOGICAL, INTENT(IN)          :: DimenInp                                     ! Flag that tells if input is dimensional or not.


      ! Local declarations.

   REAL(ReKi)                   :: CompRad                                      ! The computed radius of the rotor.
   REAL(ReKi)                   :: ErrFact                                      ! The conversion to non-dimensional form if needed.
   REAL(ReKi)                   :: SegBeg                                       ! The beginning of the current segment.

   INTEGER                      :: ISeg                                         ! Segment index



   IF ( PRESENT(ErrStat) ) ErrStat = 0


      ! Determine the correct units for error messages.

   IF ( DimenInp )  THEN
      ErrFact = 1.0
   ELSE
      ErrFact = RotorRad
   END IF


      ! We will work our way from the root to the tip.

   SegBeg = HubRad

   DO ISeg=1,NumSeg

      IF ( RLoc(ISeg) <= SegBeg )  THEN
         ! START v1.03.00b-dcm  21-Jun-2010  D. Maniaci
         CALL WrScr1('Your analysis nodes are incorrectly defined.  Please review the following forum topic for an explaination' &
                    //' of this error:')
         CALL WrScr1('  https://wind.nrel.gov/forum/wind/viewtopic.php?f=4&t=241')
         ! END v1.03.00b-dcm  21-Jun-2010  D. Maniaci
         CALL ProgAbort ( ' The radius for blade segment #'//Trim( Int2LStr( ISeg ) )//' is too far inboard for a physically' &
                    //' realizable blade.  It must be greater than '//Trim( Num2LStr( SegBeg/ErrFact ) )//'.', PRESENT(ErrStat) )
         IF ( PRESENT(ErrStat) ) ErrStat = 1
         RETURN
      END IF

      DelRLoc(ISeg) = 2.0*( RLoc(ISeg) - SegBeg )
      SegBeg        = SegBeg + DelRLoc(ISeg)

   END DO ! ISeg


      ! Ensure that the segments (almost) exactly fill the blade.

   CompRad = RLoc(NumSeg) + 0.5*DelRLoc(NumSeg)

   IF ( ABS( CompRad - RotorRad )/RotorRad > 0.005 )  THEN
         ! START v1.03.00b-dcm  21-Jun-2010  D. Maniaci
         CALL WrScr1('Your analysis nodes are incorrectly defined.  Please review the following forum topic for an explaination' &
                    //' of this error:')
         CALL WrScr1('  https://wind.nrel.gov/forum/wind/viewtopic.php?f=4&t=241')
         ! END v1.03.00b-dcm  21-Jun-2010  D. Maniaci
         CALL ProgAbort ( ' The sum of the lengths of the blade segments does not match the rotor radius.  The segments add up' &
                    //' to a rotor radius of '//Trim( Num2LStr( CompRad ) )//' instead of the specified radius of ' &
                    //Trim( Num2LStr( RotorRad ) )//'.  They must agree within 0.5%', PRESENT(ErrStat) )
         IF ( PRESENT(ErrStat) ) ErrStat = 1
         RETURN
   ELSE IF ( ABS( CompRad - RotorRad )/RotorRad > 0.001 )  THEN
! Nice message, Marshall! ;-)  Thank you!  :-)  I don't even remember writing this.
         ! START v1.03.00b-dcm  21-Jun-2010  D. Maniaci
         CALL WrScr1('Your analysis nodes are incorrectly defined.  Please review the following forum topic for an explaination' &
                    //' of this error:')
         CALL WrScr1('  https://wind.nrel.gov/forum/wind/viewtopic.php?f=4&t=241')
         ! END v1.03.00b-dcm  21-Jun-2010  D. Maniaci
         CALL WrScr1 ( ' The sum of the lengths of the blade segments does not match the rotor radius.  The segments add up to a' &
                    //' rotor radius of '//Trim( Num2LStr( CompRad ) )//' instead of the specified radius of ' &
                    //Trim( Num2LStr( RotorRad ) )//'.  They really should agree within 0.1%, but I''ll let you slide.' )
!      IF ( Beep ) &
         CALL UsrAlarm
   END IF


   RETURN
   END SUBROUTINE CompDR ! ( NumSeg, RLoc, RotorRad, DimenInp, DelRLoc [, ErrStat] )
!=======================================================================
   SUBROUTINE GetAF ( AF_File, AF_Table, ISeg )
!bjj: note that this routine aborts instead of allowing an optional returned error code.

      ! Routine to get airfoil data from either a new NWTC-style or an old AeroDyn-style airfoil file.


      ! Argument declarations.

   TYPE (ElmTable), INTENT(OUT) :: AF_Table                                  ! The table of airfoil data for the current segment.

   INTEGER, INTENT(IN)          :: ISeg                                      ! The segment number.

   CHARACTER(*), INTENT(IN)     :: AF_File                                   ! Name of file containing AeroDyn-style airfoil data.


      ! Local declarations.

      ! Because of what seems to be a compiler bug, we cannot dynamically allocate the data arrays for the new-style
      ! airfoil files.  We really need to do it for the old-style files because there is no limit on the number of points.

!   TYPE                            :: DataRowO                                  ! Declare new type that is an allocatable table of data using a linked list.
!      REAL(ReKi), ALLOCATABLE      :: Data      (:)
!      TYPE(DataRowO), POINTER      :: Next            => NULL()
!   ENDTYPE DataRowO

   REAL(ReKi)                      :: AF_Data   (5)                             ! The values from one line of airfol data.
   REAL(ReKi), ALLOCATABLE         :: AF_DataO  (:)                             ! The values from one line of airfol data.
   REAL(ReKi), ALLOCATABLE         :: RnAry     (:)                             ! The temporary array for Re.
   REAL(ReKi), ALLOCATABLE         :: ASAry     (:)                             ! The temporary array for Stall AoA.
   REAL(ReKi), ALLOCATABLE         :: AOLAry    (:)                             ! The temporary array for zero-lift AoA.
   REAL(ReKi)                      :: Cc                                        ! The chordwise force coefficient.
   REAL(ReKi)                      :: Cn                                        ! The normal force coefficient.
   REAL(ReKi), ALLOCATABLE         :: CnAAry    (:)                             ! The temporary array for Cn slope for zero lift.
   REAL(ReKi), ALLOCATABLE         :: CnSAry    (:)                             ! The temporary array for Cn at stall value for positive AoA.
   REAL(ReKi), ALLOCATABLE         :: CnSLAry   (:)                             ! The temporary array for Cn at stall value for negative AoA.
   REAL(ReKi), ALLOCATABLE         :: AODAry    (:)                             ! The temporary array for AoA for minimum Cd.
   REAL(ReKi), ALLOCATABLE         :: CDOAry    (:)                             ! The temporary array for minimum Cd value.

   INTEGER                         :: IAlf                                      ! A generic array index for angle of attack.
   INTEGER                         :: Ind                                       ! A generic array index.
   INTEGER                         :: IOS                                       ! The status of an I/O operation.
   INTEGER                         :: ITab                                      ! The table index.
   INTEGER                         :: NumAlf                                    ! The number of lines in an old-style airfoil table.
   INTEGER                         :: NumAlpha                                  ! The number of non--blank lines in an old-style airfoil table.
   INTEGER                         :: NumCoef                                   ! The number of coefficiants in an airfoil table.
   INTEGER                         :: NumVals                                   ! The total number of values on one line of airfoil data.
   INTEGER                         :: Sttus                                     ! The status returned from the allocation.
   INTEGER                         :: UnAF     = 20                             ! I/O unit number for the airfoil file.

   CHARACTER( 15)                  :: Frmt = "(1000(F11.4,:))"                  ! Output format for a line of airfoil data.
   CHARACTER(999)                  :: Line                                      ! A line of text.
   CHARACTER(  3)                  :: Line3                                     ! The first three characters of a line of text.



      ! Open the airfoil data file.

   CALL OpenFInpFile ( UnAF, AF_File )


      ! Read the header block of the airfoil file.  Look to see if this is a new-format file.

   READ (UnAF,'(A)',IOSTAT=IOS)  Line

   CALL CheckIOS ( IOS, AF_File, 'FirstHead', StrType )

   IF ( Echo )  THEN
      WRITE (UnEc,"(15X,A,T30,' - ',A,/,2X,A)")  'FirstHead', 'First line in the airfoil file.', TRIM( Line )
   END IF

   CALL Conv2UC  ( Line )

   IF ( Line(:21) == 'AERODYN AIRFOIL FILE.' )  THEN


         ! This is new style of AeroDyn file.

      CALL ReadCom  ( UnAF, AF_File, 'the first title' )
      CALL ReadCom  ( UnAF, AF_File, 'the second title' )
      CALL ReadIVar ( UnAF, AF_File, AF_Table%NumTabs, 'NumTabs', 'Number of airfoil tables for segment #' &
                                                                 //TRIM( Int2LStr( ISeg ) )//'.' )

      IF ( AF_Table%NumTabs < 1 )  CALL ProgAbort ( ' Number of tables in airfoil file, "'//TRIM( AF_File ) &
                                              //'", must be > 0 for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )


         ! Are we expecting Cm data in the file?  Allocate the temporary data array.

      IF ( UseCm )  THEN
         NumVals = 4
      ELSE
         NumVals = 3
      END IF


         ! Are we expecting Cp,min data in the file?  Allocate the temporary data array.

      IF ( UseCpmin )  THEN
         NumVals = NumVals + 1
      END IF


         ! Allocate the AF_Table of pointers for this element.

      ALLOCATE ( AF_Table%Tab(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the Tab subtable of the AF_Table of pointers for segment #' &
                    //TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF


         ! Read the NumTabs airfoil tables.

      DO ITab=1,AF_Table%NumTabs


            ! Read in the Table ID (Re), control setting, and stall parameters for this table.

         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%Re      , 'Re('      //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'Reynolds number for this airfoil table.'    )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%Ctrl    , 'Ctrl('    //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'Control setting for this airfoil table.'    )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%AlfaStal, 'AlfaStal('//TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'stall AoA for this airfoil table.'          )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%AOL     , 'AOL('     //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'zero-lift AoA.'                             )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%CnA     , 'CnA('     //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'Cn slope for zero-lift.'                    )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%CnS     , 'CnS('     //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'Cn at stall value for positive AoA.'        )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%CnSL    , 'CnSL('    //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'Cn at stall value for negative AoA.'        )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%AOD     , 'AOD('     //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'AoA for minimum CD.'                        )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%Cd0     , 'Cd0('     //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'minimum Cd value.'                          )


            ! Convert to proper units.

         AF_Table%Tab(ITab)%AlfaStal = AF_Table%Tab(ITab)%AlfaStal*D2R
         AF_Table%Tab(ITab)%AOD      = AF_Table%Tab(ITab)%AOD     *D2R
         AF_Table%Tab(ITab)%AOL      = AF_Table%Tab(ITab)%AOL     *D2R
         AF_Table%Tab(ITab)%Re       = AF_Table%Tab(ITab)%Re      *1.0e6


            ! Find the length of this table.

         AF_Table%Tab(ITab)%NumAlf = 0

         DO

            READ (UnAF,'(A)',IOSTAT=IOS)  Line3

            IF ( IOS < 0 )  THEN
               CALL PremEOF ( AF_File , 'the "EOT" end-of-table mark for airfoil table #'//TRIM( Int2LStr( ITab ) ) &
                                      //' and segment #'//TRIM( Int2LStr( ISeg ) ) )
            ELSE IF ( IOS > 0 )  THEN
               CALL WrScr1 ( ' Invalid character input for file "'//TRIM( AF_File )//'.' )
               CALL ProgAbort  ( ' The error occurred while trying to read line #'//TRIM( Int2LStr( AF_Table%Tab(ITab)%NumAlf+1 ) )&
                           //' of airfoil table #'//TRIM( Int2LStr( ITab ) )//' for segment #'//TRIM( Int2LStr( ISeg ) )//'.' )
            END IF

            CALL Conv2UC ( Line3 )
            IF ( Line3 == 'EOT' )  EXIT
            AF_Table%Tab(ITab)%NumAlf = AF_Table%Tab(ITab)%NumAlf + 1

         END DO


            ! Rewind the file to the beginning of this table.

         DO IAlf=1,AF_Table%Tab(ITab)%NumAlf+1
            BACKSPACE UnAF
         END DO ! IAlf


            ! Let's allocate the permanent table.

         ALLOCATE ( AF_Table%Tab(ITab)%Alpha(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the Alpha subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%Cl(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the Cl subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%Cd(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the Cd subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
         END IF

         IF ( UseCm )  THEN
            ALLOCATE ( AF_Table%Tab(ITab)%Cm(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
            IF ( Sttus /= 0 )  THEN
               CALL ProgAbort ( ' Error allocating memory for the Cm subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
            END IF
         END IF

         IF ( UseCpmin )  THEN
            ALLOCATE ( AF_Table%Tab(ITab)%Cpmin(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
            IF ( Sttus /= 0 )  THEN
               CALL ProgAbort ( ' Error allocating memory for the Cpmin subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
            END IF
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%FTB(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the FTB subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%FTBC(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the FTBC subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
         END IF


            ! Read in the airfoil data for this table.

         DO IAlf=1,AF_Table%Tab(ITab)%NumAlf

            READ (UnAF,*,IOSTAT=IOS)  ( AF_Data(Ind), Ind=1,NumVals )

            CALL CheckIOS ( IOS, AF_File, 'AF_Data', NumType )

            IF ( Echo )  WRITE (UnEc,Frmt)  ( AF_Data(Ind), Ind=1,NumVals )

            AF_Table%Tab(ITab)%Alpha(IAlf) = AF_Data(1)

            AF_Table%Tab(ITab)%Cl(IAlf) = AF_Data(2)
            AF_Table%Tab(ITab)%Cd(IAlf) = AF_Data(3)

            IF ( ABS( AF_Table%Tab(ITab)%CnA ) .GT. 1.0e-6 )  THEN

               Cn = AF_Data(2)*COS( AF_Data(1) ) + ( AF_Data(3) - AF_Table%Tab(ITab)%Cd0 )*SIN( AF_Data(1) )
               Cc = AF_Data(2)*SIN( AF_Data(1) ) - ( AF_Data(3) - AF_Table%Tab(ITab)%Cd0 )*COS( AF_Data(1) )

               AF_Table%Tab(ITab)%FTB (IAlf) = Cn/AF_Table%Tab(ITab)%CnA
               AF_Table%Tab(ITab)%FTBC(IAlf) = Cc/AF_Table%Tab(ITab)%CnA

            ELSE

               AF_Table%Tab(ITab)%FTB (IAlf) = 1.0
               AF_Table%Tab(ITab)%FTBC(IAlf) = 1.0

            END IF

            IF ( UseCm )  THEN
               AF_Table%Tab(ITab)%Cm(IAlf) = AF_Data(4)
            END IF

            IF ( UseCpmin )  THEN
               AF_Table%Tab(ITab)%Cpmin(IAlf) = AF_Data(NumVals)
            END IF

         END DO ! IAlf


            ! Check AoA range.

         IF ( ( AF_Table%Tab(ITab)%Alpha(1)                         > -180.0 ) .OR. &
              ( AF_Table%Tab(ITab)%Alpha(AF_Table%Tab(ITab)%NumAlf) <  180.0 ) )  THEN
            CALL ProgAbort ( 'Angle of attack range for airfoil table #'//TRIM( Int2LStr( ITab ) )//' of segment #' &
                       //TRIM( Int2LStr( ISeg ) )//' must be from -180 to 180.' )
         END IF


            ! Skip this EOT mark.

         READ (UnAF,'()')

      END DO ! ITab

   ELSE


         ! This is old style of AeroDyn file.

      CALL ReadCom  ( UnAF, AF_File, 'the second title' )
      CALL ReadIVar ( UnAF, AF_File, AF_Table%NumTabs, 'NumTabs', 'Number of airfoil tables for segment #' &
                                                                //TRIM( Int2LStr( ISeg ) )//'.' )

      ALLOCATE ( RnAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the RnAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( ASAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the ASAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( AOLAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the AOLAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( CnAAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the CnAAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( CnSAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the CnSAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( CnSLAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the CnSLAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( AODAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the AODAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( CDOAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the CDOAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      CALL ReadRAry ( UnAF, AF_File, RnAry  , AF_Table%NumTabs, 'RnAry'  , 'Reynolds number values for the airfoil tables.' )
      CALL ReadRAry ( UnAF, AF_File, ASAry  , AF_Table%NumTabs, 'ASAry'  , 'Stall AoA for this airfoil table.'              )
      CALL ReadCom  ( UnAF, AF_File,                                       'the unused first obsolete stall parameter'      )
      CALL ReadCom  ( UnAF, AF_File,                                       'the unused second obsolete stall parameter'     )
      CALL ReadCom  ( UnAF, AF_File,                                       'the unused third obsolete stall parameter'      )
      CALL ReadRAry ( UnAF, AF_File, AOLAry , AF_Table%NumTabs, 'AOLAry' , 'zero-lift AoA'                                  )
      CALL ReadRAry ( UnAF, AF_File, CnAAry , AF_Table%NumTabs, 'CnAAry' , 'Cn slope for zero lift'                         )
      CALL ReadRAry ( UnAF, AF_File, CnSAry , AF_Table%NumTabs, 'CnSAry' , 'Cn at stall value for positive AoA'             )
      CALL ReadRAry ( UnAF, AF_File, CnSLAry, AF_Table%NumTabs, 'CnSLAry', 'Cn at stall value for negative AoA'             )
      CALL ReadRAry ( UnAF, AF_File, AODAry , AF_Table%NumTabs, 'AODAry' , 'AoA for minimum Cd'                             )
      CALL ReadRAry ( UnAF, AF_File, CDOAry , AF_Table%NumTabs, 'CDOAry' , 'minimum Cd value'                               )


         ! Are we expecting Cm data in the file?  Allocate the temporary data array.

      IF ( UseCm )  THEN
         NumCoef = 3
      ELSE
         NumCoef = 2
      END IF

      NumVals = 1 + NumCoef*AF_Table%NumTabs

      ALLOCATE ( AF_DataO(NumVals) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the AF_DataO array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF


         ! Allocate the AF_Table of pointers for this element.

      ALLOCATE ( AF_Table%Tab(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the AF_Table of pointers in GetAF.' )
      END IF


            ! Find the length of this table.

      NumAlf = 0

      DO
         READ (UnAF,'()',IOSTAT=IOS)
         IF ( IOS < 0 )  EXIT
         NumAlf = NumAlf + 1
      END DO


         ! Rewind the file to the beginning of this table.

      DO IAlf=1,NumAlf+1
         BACKSPACE UnAF
      END DO ! IAlf


         ! Let's allocate the tables.

      DO ITab=1,AF_Table%NumTabs

         ALLOCATE ( AF_Table%Tab(ITab)%Alpha(NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the Alpha vector of airfoil table #'//TRIM( Int2LStr( ITab) ) &
                       //' for element #'//TRIM( Int2LStr( ISeg) )//'.' )
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%Cl(NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the Cl vector of airfoil table #'//TRIM( Int2LStr( ITab) ) &
                       //' for element #'//TRIM( Int2LStr( ISeg) )//'.' )
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%Cd(NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the Cd vector of airfoil table #'//TRIM( Int2LStr( ITab) ) &
                       //' for element #'//TRIM( Int2LStr( ISeg) )//'.' )
         END IF

         IF ( UseCm )  THEN
            ALLOCATE ( AF_Table%Tab(ITab)%Cm(NumAlf) , STAT=Sttus )
            IF ( Sttus /= 0 )  THEN
               CALL ProgAbort ( ' Error allocating memory for the Cm vector of airfoil table #'//TRIM( Int2LStr( ITab) ) &
                          //' for element #'//TRIM( Int2LStr( ISeg) )//'.' )
            END IF
         END IF

!         ALLOCATE ( AF_Table%Tab(ITab)%FTB(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
         ALLOCATE ( AF_Table%Tab(ITab)%FTB(NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the FTB subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%FTBC(NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the FTBC subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                      //' and table #' //TRIM( Int2LStr( ITab) )//').' )
         END IF

      END DO ! ITab


         ! Let's read the data this time through.

      NumAlpha = NumAlf

      DO IAlf=1,NumAlf


            ! Let's skip blank lines.  Decrement the number of alphas when we find them.

         READ (UnAF,'(A)')  Line

         IF ( LEN_TRIM( Line ) == 0 )  THEN
            NumAlpha = NumAlpha - 1
            CYCLE
         END IF


            ! Let's get the data from the non-blank line.

         READ (Line,*,IOSTAT=IOS)  ( AF_DataO(Ind), Ind=1,NumVals )

         CALL CheckIOS ( IOS, AF_File, 'AF_DataO', NumType )

         IF ( Echo )  THEN
            WRITE (UnEc,Frmt)  ( AF_DataO(Ind), Ind=1,NumVals )
         END IF


            ! Let's move this good data into permanent storage.

         DO ITab=1,AF_Table%NumTabs

            AF_Table%Tab(ITab)%Alpha(IAlf) = AF_DataO(1)
            AF_Table%Tab(ITab)%Cl   (IAlf) = AF_DataO(NumCoef*(ITab-1)+2)
            AF_Table%Tab(ITab)%Cd   (IAlf) = AF_DataO(NumCoef*(ITab-1)+3)

            IF ( UseCm )  THEN
               AF_Table%Tab(ITab)%Cm(IAlf) = AF_DataO(NumCoef*(ITab-1)+4)
            END IF

            IF ( ABS( AF_Table%Tab(ITab)%CnA ) .GT. 1.0e-6 )  THEN

               Cn = AF_Data(2)*COS( AF_Data(1) ) + ( AF_Data(3) - AF_Table%Tab(ITab)%Cd0 )*SIN( AF_Data(1) )
               Cc = AF_Data(2)*SIN( AF_Data(1) ) - ( AF_Data(3) - AF_Table%Tab(ITab)%Cd0 )*COS( AF_Data(1) )

               AF_Table%Tab(ITab)%FTB (IAlf) = Cn/AF_Table%Tab(ITab)%CnA
               AF_Table%Tab(ITab)%FTBC(IAlf) = Cc/AF_Table%Tab(ITab)%CnA

            ELSE

               AF_Table%Tab(ITab)%FTB (IAlf) = 1.0
               AF_Table%Tab(ITab)%FTBC(IAlf) = 1.0

            END IF

         END DO ! ITab

      END DO ! IAlf


         ! Check AoA range.  AoAs are the same for all tables in a given segment.

      IF ( ( AF_Table%Tab(1)%Alpha(1)      > -180.0 ) .OR. &
           ( AF_Table%Tab(1)%Alpha(NumAlf) <  180.0 ) )  THEN
!           ( AF_Table%Tab(1)%Alpha(AF_Table%Tab(ITab)%NumAlf) <  180.0 ) )  THEN
         CALL ProgAbort ( 'Angle of attack range of airfoil tables for segment #'//TRIM( Int2LStr( ISeg ) ) &
                    //' must be from -180 to 180.' )
      END IF


           ! Store the header data in the permanent structure.

      DO ITab=1,AF_Table%NumTabs
         AF_Table%Tab(ITab)%AlfaStal = ASAry  (ITab)*D2R
         AF_Table%Tab(ITab)%Re       = RnAry  (ITab)*1.0e6
         AF_Table%Tab(ITab)%AOD      = AODAry (ITab)*D2R
         AF_Table%Tab(ITab)%AOL      = AOLAry (ITab)*D2R
         AF_Table%Tab(ITab)%Cd0      = CDOAry (ITab)
         AF_Table%Tab(ITab)%CnA      = CnAAry (ITab)
         AF_Table%Tab(ITab)%CnS      = CnSAry (ITab)
         AF_Table%Tab(ITab)%CnSL     = CnSLAry(ITab)
         AF_Table%Tab(ITab)%NumAlf   = NumAlpha
      END DO ! ITab


         ! Deallocate the temporary Re array.

      DEALLOCATE ( RnAry, STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error deallocating memory for the RnAry array in GetAF.' )
      END IF


         ! Deallocate the temporary data array.

      DEALLOCATE ( AF_DataO, STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error deallocating memory for the AF_DataO array in GetAF.' )
      END IF

   END IF

   CLOSE ( UnAF )


   RETURN
   END SUBROUTINE GetAF !  ( AF_File, AF_Table, ISeg )
!=======================================================================
   FUNCTION GetCoef( ISeg, Alpha, AlfaTab, CoefTab, NumRows, Ind, ErrStat )


      ! Interpolation routine for airfoil section coefficients.


      ! Function declaration.

   REAL(ReKi)                        :: GetCoef                                 ! The value returned by this function.


      ! Argument declarations.

   INTEGER, INTENT(INOUT)            :: Ind                                     ! The starting/resulting index into the tables.
   INTEGER, INTENT(IN)               :: ISeg                                    ! The current segment.
   INTEGER, INTENT(IN)               :: NumRows                                 ! The length of the arrays.
   INTEGER, INTENT(OUT), OPTIONAL    :: ErrStat                                 ! Error status; if present, program does not abort on error

   REAL(ReKi), INTENT(IN)            :: AlfaTab   (NumRows)                     ! Table of AoAs.
   REAL(ReKi), INTENT(IN)            :: Alpha                                   ! Angle of attack to get the coefficient for.
   REAL(ReKi), INTENT(IN)            :: CoefTab   (NumRows)                     ! Table of coefficients.


   IF ( PRESENT(ErrStat) ) ErrStat = 1


      ! If Alpha is to the outside the table, the user needs to make up some data.  Warn the user and stop the program.

   IF ( ( Alpha < AlfaTab(1) ) .OR. ( AlfaTab(NumRows) < Alpha ) )  THEN

      CALL ProgAbort ( ' For segment '//TRIM( Int2LStr( ISeg ) )//', the current angle of attack ('//TRIM( Num2LStr( Alpha ) ) &
                 //' degrees) is outside the domain of your data table (' //TRIM( Num2LStr( AlfaTab(1) ) )//' to ' &
                 //TRIM( Num2LStr( AlfaTab(NumRows) ) )//' degrees).  Please extend your data table.', PRESENT(ErrStat) )
      IF ( PRESENT(ErrStat) ) ErrStat = 1
      RETURN

   END IF


      ! Alpha is in range.  Interpolate.  Use binary interpolation if this is the first time to access this table.

   IF ( Ind == 0 )  THEN
      GetCoef = InterpBin( Alpha, AlfaTab, CoefTab, Ind, NumRows )
   ELSE
      GetCoef = InterpStp( Alpha, AlfaTab, CoefTab, Ind, NumRows )
   END IF


   RETURN
   END FUNCTION GetCoef ! ( ISeg, Alpha, AlfaTab, CoefTab, NumRows, Ind )
!=======================================================================
   SUBROUTINE GetCoefs ( ISeg, Alpha, Re, AF_Table, ClInt, CdInt, CmInt, CpminInt, DoCl, DoCd, DoCm, DoCpmin, ErrStat )


      ! This routine finds the Re-bounding tables and then calls GetCoef() to get the
      ! desired coefficients for the two tables and then interpolates between them.


      ! Argument declarations.

   TYPE (ElmTable), INTENT(INOUT)    :: AF_Table                                ! The table of airfoil data for the current segment.

   INTEGER, INTENT(IN)               :: ISeg                                    ! The current segment.
   INTEGER, INTENT(OUT), OPTIONAL    :: ErrStat                                 ! Error status; if present, program does not abort on error

   LOGICAL, INTENT(IN)               :: DoCd                                    ! Get Cd.
   LOGICAL, INTENT(IN)               :: DoCl                                    ! Get Cl.
   LOGICAL, INTENT(IN)               :: DoCm                                    ! Get Cm.
   LOGICAL, INTENT(IN)               :: DoCpmin                                 ! Get Cp,min.

   REAL(ReKi), INTENT(IN)            :: Alpha                                   ! Angle of attack to get the coefficient for.
   REAL(ReKi), INTENT(OUT)           :: CdInt                                   ! Interpolated drag coefficient.
   REAL(ReKi), INTENT(OUT)           :: ClInt                                   ! Interpolated lift coefficient.
   REAL(ReKi), INTENT(OUT)           :: CmInt                                   ! Interpolated pitching-moment coefficient.
   REAL(ReKi), INTENT(OUT)           :: CpminInt                                ! Interpolated minimum-pressure coefficient.
   REAL(ReKi), INTENT(IN)            :: Re                                      ! Reynolds number.


      ! Local declarations.

   REAL(ReKi)                        :: CdHi                                    ! The drag coefficient for the higher Re.
   REAL(ReKi)                        :: ClHi                                    ! The lift coefficient for the higher Re.
   REAL(ReKi)                        :: CmHi                                    ! The pitching-moment coefficient for the higher Re.
   REAL(ReKi)                        :: CpminHi                                 ! The minimum-pressure coefficient for the higher Re.
   REAL(ReKi)                        :: Fract                                   ! The fractional distance between tables.

   INTEGER                           :: ITab                                    ! An index for table number.
   INTEGER                           :: ITabLo                                  ! The table number that is the lower bound for Re.
   INTEGER                           :: ITabHi                                  ! The table number that is the lower bound for Re.

   LOGICAL                           :: OneTable                                ! Flag that tells if we need to read only one table (no interpolation).


   IF ( PRESENT(ErrStat) ) ErrStat = 0

      ! Find the bounding tables (if multiple) for this Re.  If there is only one table
      ! or if we are outside the range of tables, we won't need to interpolate.

   IF ( Re <= AF_Table%Tab(1)%Re )  THEN
      ITabLo   = 1
      OneTable = .TRUE.
   ELSE IF ( Re >= AF_Table%Tab(AF_Table%NumTabs)%Re )  THEN
      ITabLo   = AF_Table%NumTabs
      OneTable = .TRUE.
   ELSE IF ( AF_Table%NumTabs > 1 )  THEN
      DO ITab=1,AF_Table%NumTabs-1
         IF ( Re <= AF_Table%Tab(ITab+1)%Re )  THEN
            ITabLo = ITab
            ITabHi = ITab + 1
            EXIT
         END IF
      END DO
      OneTable = .FALSE.
   ELSE
      ITabLo   = 1
      OneTable = .TRUE.
   END IF


      ! Get the coefficients for ITabLo.


   IF ( PRESENT(ErrStat) ) THEN
      IF ( DoCl )  THEN
         ClInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cl, AF_Table%Tab(ITabLo)%NumAlf, &
                                       AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      END IF

      IF ( DoCd )  THEN
         CdInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cd, AF_Table%Tab(ITabLo)%NumAlf, &
                                       AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      END IF

      IF ( DoCm )  THEN
         CmInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cm, AF_Table%Tab(ITabLo)%NumAlf, &
                                       AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      END IF

      IF ( DoCpmin )  THEN
         CpminInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cpmin, AF_Table%Tab(ITabLo)%NumAlf, &
                                          AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      END IF

   ELSE  ! Abort the program when errors are found

      IF ( DoCl )  THEN
         ClInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cl, AF_Table%Tab(ITabLo)%NumAlf, &
                                       AF_Table%Tab(ITabLo)%Ind )
      END IF

      IF ( DoCd )  THEN
         CdInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cd, AF_Table%Tab(ITabLo)%NumAlf, &
                                       AF_Table%Tab(ITabLo)%Ind )
      END IF

      IF ( DoCm )  THEN
         CmInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cm, AF_Table%Tab(ITabLo)%NumAlf, &
                                       AF_Table%Tab(ITabLo)%Ind )
      END IF

      IF ( DoCpmin )  THEN
         CpminInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cpmin, AF_Table%Tab(ITabLo)%NumAlf, &
                                          AF_Table%Tab(ITabLo)%Ind )
      END IF

   END IF


      ! If we don't need to interpolate, we don't need to make a second call and we are done.

   IF ( OneTable )  RETURN                 ! We probably shouldn't do this.  We should probably do a block IF.  mlb


      ! Get the coefficients for ITabHi.  Use step-wise interpolation for all but the first coefficient called.

   Fract = ( Re - AF_Table%Tab(ITabLo)%Re )/( AF_Table%Tab(ITabHi)%Re - AF_Table%Tab(ITabLo)%Re )

   IF ( DoCl )  THEN
      IF ( PRESENT(ErrStat) ) THEN
         ClHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cl, AF_Table%Tab(ITabHi)%NumAlf, &
                                       AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      ELSE
         ClHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cl, AF_Table%Tab(ITabHi)%NumAlf, &
                                       AF_Table%Tab(ITabHi)%Ind )
      END IF
      ClInt = ClInt + Fract*( ClHi - ClInt )
   END IF

   IF ( DoCd )  THEN
      IF ( PRESENT(ErrStat) ) THEN
         CdHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cd, AF_Table%Tab(ITabHi)%NumAlf, &
                                       AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      ELSE
         CdHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cd, AF_Table%Tab(ITabHi)%NumAlf, &
                                       AF_Table%Tab(ITabHi)%Ind )
      END IF
      CdInt = CdInt + Fract*( CdHi - CdInt )
   END IF

   IF ( DoCm )  THEN
      IF ( PRESENT(ErrStat) ) THEN
         CmHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cm, AF_Table%Tab(ITabHi)%NumAlf, &
                                       AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      ELSE
         CmHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cm, AF_Table%Tab(ITabHi)%NumAlf, &
                                       AF_Table%Tab(ITabHi)%Ind )
      END IF
      CmInt = CmInt + Fract*( CmHi - CmInt )
   END IF

   IF ( DoCpmin )  THEN
      IF ( PRESENT(ErrStat) ) THEN
         CpminHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cpmin, AF_Table%Tab(ITabHi)%NumAlf, &
                                          AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      ELSE
         CpminHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cpmin, AF_Table%Tab(ITabHi)%NumAlf, &
                                          AF_Table%Tab(ITabHi)%Ind )
      END IF
      CpminInt = CpminInt + Fract*( CpminHi - CpminInt )
   END IF


   RETURN
   END SUBROUTINE GetCoefs ! ( ISeg, Alpha, Re, AF_Table, ClInt, CdInt, CmInt, CpminInt, DoCl, DoCd, DoCm, DoCpmin, ErrStat )
!=======================================================================

END MODULE NWTC_Aero
MODULE NWTC_Library


      ! Notes:

         ! Your project must include the following files:
         !     NWTC_Aero.f90
         !     NWTC_IO.f90
         !     NWTC_Library.f90
         !     NWTC_Num.f90
         !     ModMesh.f90

         ! Your project must include one, but not both, of the following files:
         !     DoubPrec.f90 - for double-precision arithmetic for floating-points variables.  You may have to set a compiler option to have constants use double precision.
         !     SingPrec.f90 - for single-precision arithmetic for floating-points variables.

         ! Your project must include one, and only one, of the following files:
         !     SysIVF.f90    - for Intel Visual Fortran for Windows compiler
         !     SysGnu.f90    - for Gnu Fortran for Linux compiler
         !     SysIFL.f90    - for Intel Fortran for Linux compiler
         !     SysMatlab.f90 - for Intel Visual Fortran for Windows compiler with Matlab's mex functions


         ! Compilation order for command-line compilation:
         !     SingPrec.f90 or DoubPrec.f90
         !     SysIVF.f90 (or other Sys*.f90 file)
         !     NWTC_IO.f90
         !     NWTC_Num.f90
         !     NWTC_Aero.f90
         !     ModMesh.f90
         !     NWTC_Library.f90

         ! Invoking programs should call NWTC_Init() to initialize data important to the use of the library.  Currently,
         !  this is used for the NaN, Inf, and Pi-based constants.


   USE NWTC_Aero   ! The other modules (NWTC_IO, NWTC_Num, Precision, SysSubs, and F2kCLI) are already included in NWTC_Aero.

   USE ModMesh  !BJJ update with JM/IC's Mesh module

   IMPLICIT  NONE


CONTAINS

!=======================================================================
   SUBROUTINE NWTC_Init( ProgNameIn, ProgVerIn )

      ! passed parameters

   CHARACTER(*), INTENT(IN), OPTIONAL :: ProgNameIn
   CHARACTER(*), INTENT(IN), OPTIONAL :: ProgVerIn



      ! Initialize ProgName and ProgVer if parameters have been passed

   IF ( PRESENT( ProgNameIN ) ) THEN
      ProgName = ProgNameIN
   END IF

   IF ( PRESENT( ProgVerIn ) ) THEN
      ProgVer = ProgVerIn
   END IF


      ! This routine calls all required initialization routines.

   CALL SetConstants()

!mlb Let's get rid of this once FLUSH works.
   CALL OpenCon( )


      ! Write the version of the NWTC subroutine library that we are running
   CALL DispNVD( NWTC_Ver )


   RETURN
   END SUBROUTINE NWTC_Init
!=======================================================================

END MODULE NWTC_Library
!----------------------------------------------------------------------------------------------------
MODULE SharedInflowDefns
! This module is used to define shared types and parameters that are used in the module InflowWind.
! 7 Oct 2009    B. Jonkman, NREL/NWTC
!----------------------------------------------------------------------------------------------------

   USE NWTC_Library                                               ! Precision module 

   !-------------------------------------------------------------------------------------------------
   ! Shared types
   !-------------------------------------------------------------------------------------------------

!   TYPE, PUBLIC :: InflLoc   
!      REAL(ReKi)                    :: Position(3)                ! X, Y, Z
!   END TYPE InflLoc
   
   
   TYPE, PUBLIC :: InflIntrpOut
      REAL(ReKi)                    :: Velocity(3)                ! U, V, W
   END TYPE InflIntrpOut

   !-------------------------------------------------------------------------------------------------
   ! Shared parameters, defining the wind types
   ! THEY MUST BE UNIQUE!
   !-------------------------------------------------------------------------------------------------

   INTEGER, PARAMETER, PUBLIC  :: DEFAULT_Wind = -1        ! Undetermined wind type; calls internal routine to guess what type of file it is.
   INTEGER, PARAMETER, PUBLIC  :: Undef_Wind   =  0        ! This is the code for an undefined WindType
   INTEGER, PARAMETER, PUBLIC  :: HH_Wind      =  1        ! Hub-Height wind file
   INTEGER, PARAMETER, PUBLIC  :: FF_Wind      =  2        ! Binary full-field wind file
   INTEGER, PARAMETER, PUBLIC  :: UD_Wind      =  3        ! User-defined wind
   INTEGER, PARAMETER, PUBLIC  :: FD_Wind      =  4        ! 4-dimensional wind (LES)
   INTEGER, PARAMETER, PUBLIC  :: CTP_Wind     =  5        ! Coherent turbulence wind field (superimpose KH billow on background wind)
   INTEGER, PARAMETER, PUBLIC  :: HAWC_Wind    =  6        ! Binary full-field wind file in HAWC format

END MODULE SharedInflowDefns
MODULE CTWind
! This module uses reads coherent turbulence parameter (CTP) files and processes the data in them
! to get coherent turbulence which is later superimposed on a background wind field (the super-
! positioning occurs elsewhere).  The turbulence in this module is part of the KH billow, which
! can be read using FDWind.  As a result, the scaling here should be similiar to FDWind.
!
! This module assumes that the origin, (0,0,0), is located at the tower centerline at ground level,
! and that all units are specified in the metric system (using meters and seconds).
! Data is shifted by half the grid width when used with FFWind.
!
!  Created 25-Sept-2009 by B. Jonkman, National Renewable Energy Laboratory
!     using subroutines and modules from AeroDyn v12.58
!
!----------------------------------------------------------------------------------------------------

   USE                     NWTC_Library
   USE                     SharedInflowDefns

   IMPLICIT                NONE
   PRIVATE
   
      
   INTEGER, PARAMETER           :: NumComps  = 3                              ! number of components
   
            ! CT_Wind
   REAL(ReKi)                   :: DelYCTgrid                                 ! The nondimensional distance between grid points in the y direction.
   REAL(ReKi)                   :: DelZCTgrid                                 ! The nondimensional distance between grid points in the z direction.
   REAL(ReKi)                   :: CTDistSc                                   ! Disturbance scale (ratio of wave height to rotor diameter).
   REAL(ReKi)                   :: CTOffset (NumComps)                        ! Offsets to convert integer data to actual wind speeds.
   REAL(ReKi)                   :: CTScale  (NumComps)                        ! Scaling factors to convert integer data to actual wind speeds.

   
   REAL(ReKi), ALLOCATABLE      :: CTvelU   (:,:,:)                         ! The y-z grid velocity data (U components) for the lower- and upper-bound time slices
   REAL(ReKi), ALLOCATABLE      :: CTvelV   (:,:,:)                         ! The y-z grid velocity data (V components) for the lower- and upper-bound time slices
   REAL(ReKi), ALLOCATABLE      :: CTvelW   (:,:,:)                         ! The y-z grid velocity data (W components) for the lower- and upper-bound time slices
   REAL(ReKi)                   :: CTLy                                       ! Fractional location of tower centerline from right (looking downwind) to left side of the dataset.
   REAL(ReKi)                   :: CTLz                                       ! Fractional location of hub height from bottom to top of dataset.
   REAL(ReKi)                   :: CTScaleVel                                 ! Scaling velocity, U0.  2*U0 is the difference in wind speed between the top and bottom of the wave.
   REAL(ReKi), ALLOCATABLE      :: Tdata    (:)                               ! The list of times for the CT-wind input files.  
   
   REAL(ReKi)                   :: CT_Zref                                    ! The reference height for the CT file (the bottom of the billow)
   REAL(ReKi)                   :: CTYHWid                                    ! The half the width of the background dataset, used to compute the CTwind time offset
   REAL(ReKi)                   :: CTYmax                                     ! The dimensional lateral width of the dataset.
   REAL(ReKi)                   :: CTYt                                       ! Distance of the tower from the right side of the dataset (looking downwind).
   REAL(ReKi)                   :: CTZmax                                     ! The dimensional vertical height of the dataset.
   REAL(ReKi)                   :: InvMCTWS                                   ! The multiplicative inverse of the mean hub height wind speed for the CT wind data

   INTEGER                      :: CT_DF_Y                                    ! The decimation factor for the CT wind data in the y direction.
   INTEGER                      :: CT_DF_Z                                    ! The decimation factor for the CT wind data in the z direction.
   INTEGER                      :: CTvel_files(2)                             ! Times for the CT wind files stored in CTvel arrays.

   INTEGER                      :: IndCT_hi                                   ! An index into the 3rd dimension of the CTvel arrays, indicating the upper time slice (allows us to avoid copying array)
   INTEGER                      :: IndCT_lo                                   ! An index into the 3rd dimension of the CTvel arrays, indicating the lower time slice (allows us to avoid copying array)
   
   INTEGER                      :: NumCTt                                     ! The number of CT wind grids, no more than one grid per time step.
   INTEGER                      :: NumCTy                                     ! The number of CT wind grid points in the y direction.
   INTEGER                      :: NumCTyD                                    ! The decimated number of CT wind grid points in the y direction.
   INTEGER                      :: NumCTyD1                                   ! The decimated number of CT wind grid points in the y direction minus 1.
   INTEGER                      :: NumCTz                                     ! The number of CT wind grid points in the z direction.
   INTEGER                      :: NumCTzD                                    ! The decimated number of CT wind grid points in the z direction.
   INTEGER                      :: NumCTzD1                                   ! The decimated number of CT wind grid points in the z direction minus 1.
   INTEGER, SAVE                :: TimeIndx  = 0                              ! Index into the time array
   INTEGER, ALLOCATABLE         :: TimeStpCT (:)                              ! The list of time steps from the original LE simulation, associated with the CT-wind times.

   INTEGER                      :: CTWindUnit                                 ! unit number used to read the wind files at each call to CT_GetWindSpeed()
   
   LOGICAL                      :: CTVertShft                                 ! Flag to indicate whether or not to shift the z values for the w component.

   CHARACTER(3)                 :: CText                                      ! The extension used for coherent turbulence data files. (usually "les" or "dns")
   CHARACTER(1024)              :: CTSpath                                    ! The path to the CT wind files.

   TYPE :: CTWindFiles
      CHARACTER(1024)           :: CTTSfile                                   ! The name of the file containing the time-step history of the wind files.
      CHARACTER(1024)           :: CTbackgr                                   ! The name of the background wind data
   END TYPE CTWindFiles


   TYPE, PUBLIC :: CT_Backgr
      CHARACTER(1024)           :: WindFile                                   ! The name of the background wind file
      INTEGER                   :: WindFileType                               ! The type of background wind file (currently only FF)
      LOGICAL                   :: CoherentStr                                ! If the coherent time step file is blank or doesn't exist, this is FALSE (use the background only)
   END TYPE CT_Backgr
            
   
   PUBLIC                       :: CT_Init
   PUBLIC                       :: CT_GetWindSpeed
   PUBLIC                       :: CT_SetRefVal
   PUBLIC                       :: CT_Terminate

CONTAINS
!====================================================================================================
SUBROUTINE CT_Init(UnWind, WindFile, BackGrndValues, ErrStat)
!  This subroutine is called at the beginning of a simulation.  It reads the CTP file to obtain
!  the name of the CTS file, the path locating the binary KH files, and decimation factors.
!  It returns the background wind file and type; it also returns a flag that determines if CT wind
!  files are ACTUALLY to be used (e.g., if the CTS file is blank or there is one line of zero in the
!  CTS time array).  
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: WindFile                     ! Name of the CTP (.ctp) wind file
   TYPE(CT_Backgr), INTENT(OUT)   :: BackGrndValues               ! output background values
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise


      ! Local Variables:
      
   TYPE(CTWindFiles)              :: CTP_files
   CHARACTER(3)                   :: CT_SC_ext                    ! extension of the scaling file
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( TimeIndx /= 0 ) THEN  
      CALL WrScr( ' CTWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Read the CTP file and set the background data info to be returned later
   !-------------------------------------------------------------------------------------------------
   
   CALL ReadCTP( UnWind, WindFile, CTP_files, ErrStat )
   IF (ErrStat /= 0) RETURN           
   
  
   BackGrndValues%WindFile     = CTP_files%CTbackgr
   BackGrndValues%WindFileType = FF_Wind             !bjj: perhaps we should check the wind type here
   
   !-------------------------------------------------------------------------------------------------
   ! Read the CTTS file to get the time step and file number arrays
   !-------------------------------------------------------------------------------------------------   
   CALL ReadCTTS( UnWind, CTP_files%CTTSfile, CT_SC_ext, ErrStat )

   IF (ErrStat == 0 .AND. NumCTt > 1) THEN    
      BackGrndValues%CoherentStr  = .TRUE.
      
      !-------------------------------------------------------------------------------------------------
      ! Read file containing scaling for the binary large-eddy files
      !-------------------------------------------------------------------------------------------------
      CALL ReadCTScales( UnWind, TRIM( CTSpath )//'\Scales.'//TRIM( CT_SC_ext ), ErrStat )
      IF (ErrStat /= 0) RETURN


      CTScale(:)  = CTScaleVel*CTScale(:)
      CTOffset(:) = CTScaleVel*CTOffset(:)

   ELSE              
      
      IF (ErrStat <= 0) THEN
         
            ! The file is missing, blank (or possibly incomplete), or has only 1 time step line (which  
            ! is zero); Go on without the CT file, using just the background

         CALL ProgWarn( ' Coherent turbulence wind file will be turned off.' )
         
         BackGrndValues%CoherentStr  = .FALSE.
         CALL CT_Terminate( ErrStat )          
         
      END IF

      RETURN
      
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Set some values that don't change during the run
   !-------------------------------------------------------------------------------------------------
      
   CTYHWid        = 0.0                                                    ! This value is used to perform a time shift (the equivalent distance of FFYHWid [approx. rotor radius])
   CT_Zref        = -1.0                                                   ! This value needs to be set after the corresponding background turbulence has been read (or the CTS file should be changed)

   NumCTyD        = ( NumCTy + CT_DF_Y - 1 )/CT_DF_Y                       ! The decimated number of CT wind grid points in the y direction.
   NumCTzD        = ( NumCTz + CT_DF_Z - 1 )/CT_DF_Z                       ! The decimated number of CT wind grid points in the z direction.
   NumCTyD1       = NumCTyD - 1                                            ! The decimated number of CT wind grid points in the y direction minus 1.
   NumCTzD1       = NumCTzD - 1                                            ! The decimated number of CT wind grid points in the z direction minus 1.

   CTYt           = CTYmax*CTLy                                            ! Distance of the tower from the right side of the dataset (looking downwind).
!   CTZt           = CTZmax*CTLz                                            ! Distance of the hub from the bottom of the dataset.
   DelYCTgrid     = 1.0/NumCTyD1                                           ! The nondimensional distance between grid points in the y direction.
   DelZCTgrid     = 1.0/NumCTzD1                                           ! The nondimensional distance between grid points in the z direction.
    

     
   !-------------------------------------------------------------------------------------------------
   ! Allocate the wind array and initialize it
   !-------------------------------------------------------------------------------------------------
   
   IF (.NOT. ALLOCATED(CTvelU) ) THEN
      ALLOCATE ( CTvelU(NumCTyD,NumCTzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the CTvelU array.' )
         RETURN
      END IF
   END IF   
   
   IF (.NOT. ALLOCATED(CTvelV) ) THEN
!      CALL AllocAry( CTvelV, NumCTyD, NumCTzD, 2, 'CTvelV', ErrStat ) !AllRAry3 AllocAry
      ALLOCATE ( CTvelV(NumCTyD,NumCTzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the CTvelV array.' )
         RETURN
      END IF
   END IF   
   
   IF (.NOT. ALLOCATED(CTvelW) ) THEN
!      CALL AllocAry( CTvelW, NumCTyD, NumCTzD, 2, 'CTvelW', ErrStat ) !AllRAry3 AllocAry
      ALLOCATE ( CTvelW(NumCTyD,NumCTzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the CTvelW array.' )
         RETURN
      END IF
   END IF   

   CTvelU(:,:,:) = 0.0                                                    ! the original velocity data      
   CTvelV(:,:,:) = 0.0                                                    ! the original velocity data      
   CTvelW(:,:,:) = 0.0                                                    ! the original velocity data      
      
   !-------------------------------------------------------------------------------------------------
   ! Initialize the arrays and set the initialization flag
   !-------------------------------------------------------------------------------------------------   
   CTvel_files(:) = 0                                                      ! the name of the files currently in the CTvel array
   CTWindUnit     = UnWind                                                 ! This unit is needed to open the binary files at each step
   TimeIndx       = 1
    
   RETURN

END SUBROUTINE CT_Init
!====================================================================================================
SUBROUTINE CT_SetRefVal(Height, HWidth, ErrStat)

   REAL(ReKi), INTENT(IN)           :: Height                                 ! a reference height (should be hub height)
   REAL(ReKi), INTENT(IN), OPTIONAL :: HWidth                                 ! a reference offset (should be half grid width [~rotor radius])
   INTEGER,    INTENT(OUT)          :: ErrStat                                ! returns 0 if no error; non-zero otherwise


   !-------------------------------------------------------------------------------------------------     
   ! Check that we've initialized everything first
   !-------------------------------------------------------------------------------------------------     
     
   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Initialialize the CTWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE IF ( CT_Zref >= 0 ) THEN
      CALL WrScr( ' Cannot reset the CTWind reference height in the middle of a simulation.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0         
   END IF      


   !-------------------------------------------------------------------------------------------------     
   ! Set the grid shift using the half-width
   !-------------------------------------------------------------------------------------------------     
   IF ( PRESENT( HWidth ) ) THEN
      CTYHWid = HWidth
        
      IF ( CTYHWid < 0 ) THEN
         CALL WrScr( ' Reference width in CTWind cannot be negative.')
         CTYHWid = 0
         ErrStat = 1
      END IF
   END IF
 
 
   !-------------------------------------------------------------------------------------------------     
   ! Set the reference height (bottom of the KH billow) using the input hub-height
   !-------------------------------------------------------------------------------------------------     
      ! CTZt = CTZmax*CTLz             ! the distance between the hub and the bottom of the dataset

   CT_Zref = Height - CTZmax*CTLz      ! the height of the bottom of the KH billow

   IF ( CT_Zref < 0 ) THEN
      CALL WrScr( ' Reference height in CTWind cannot be negative.')
      CT_Zref = 0
      ErrStat = 1
   END IF      

   
END SUBROUTINE CT_SetRefVal
!====================================================================================================
FUNCTION CT_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are are 
! requested.  It returns the velocities at the specified time and space that are superimposed on
! a background wind flow.  This function interpolates into the full-field CT wind arrays, performing
! a time shift based on the average windspeed. The modified time is used to decide which pair of time 
! slices to interpolate within and between. After finding the two time slices, it decides which four 
! grid points bound the (Y,Z) pair. It does a bilinear interpolation for (Y,Z) on each bounding time 
! slice, then linearly interpolates between the 2 time slices. This routine assumes that X is downwind, 
! Y is to the left when looking downwind and Z is up.  In the time (X) and Z directions, steady winds 
! are used when extrapolation is required.  The dataset is assumed to be periodic in the Y direction.
!----------------------------------------------------------------------------------------------------
 
      ! Passed variables:
      
   REAL(ReKi),        INTENT(IN) :: Time                                   ! the time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)                       ! the position (X,Y,Z)
   INTEGER,           INTENT(OUT):: ErrStat                                ! returns 0 if no error; non-zero otherwise
   TYPE(InflIntrpOut)            :: CT_GetWindSpeed                        ! the resultant wind speed
   
   
      ! Local Variables:

   REAL(ReKi)                    :: Iyz_th                                 ! Temporary interpolated value. (time hi, all y, all z)
   REAL(ReKi)                    :: Iyz_tl                                 ! Temporary interpolated value. (time lo, all y, all z)
   REAL(ReKi)                    :: Iyhz                                   ! Temporary interpolated value. (y hi, all z)
   REAL(ReKi)                    :: Iylz                                   ! Temporary interpolated value. (y lo, all z)
   REAL(ReKi)                    :: TimeShifted                            ! Shifted time (necessary because we're keeping x constant)
   REAL(ReKi)                    :: Tgrid                                  ! Fractional distance between time grids.
   REAL(ReKi)                    :: Ygrid                                  ! Fractional distance between grids in the y direction.
   REAL(ReKi)                    :: Ynorm                                  ! Nondimensional lateral distance of the analysis point from right side of dataset (looking downwind).
   REAL(ReKi)                    :: Zgrid(3)                               ! Fractional distance between grids in the z direction.
   REAL(ReKi)                    :: Znorm                                  ! Nondimensional vertical distance of the analysis point from bottom of dataset.

   INTEGER                       :: I
   INTEGER                       :: IYHi
   INTEGER                       :: IYLo
   INTEGER                       :: IZHi(3)
   INTEGER                       :: IZLo(3)


   !-------------------------------------------------------------------------------------------------     
   ! Check that we've initialized everything first
   !-------------------------------------------------------------------------------------------------     
     
   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Initialialize the CTWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE IF ( CT_Zref < 0 ) THEN
      CALL WrScr( ' Set the reference height in the CTWind module before calling CT_GetWindSpeed.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------     
   ! Perform the time shift. At time=0, a point half the grid width downstream will index into the zero 
   ! time slice.  CTYHWid is used to shift the CT wind the same as FF wind is shifted.
   ! This assumes that the coherent turbulence events are moving at MCTWS
   !-------------------------------------------------------------------------------------------------     

   TimeShifted = TIME + ( CTYHWid - InputPosition(1) )*InvMCTWS


   !-------------------------------------------------------------------------------------------------
   ! Find the bounding time slices:
   ! Linearly interpolate in time (or set to 0 before and/or after) 
   ! (compare with NWTC_Num.f90\InterpStpReal) 
   !-------------------------------------------------------------------------------------------------

      ! Let's check the limits first.

   IF ( TimeShifted <= Tdata(1) )  THEN
   
      TimeIndx = 1
      Tgrid    = 0.0
                     
!      CT_GetWindSpeed%Velocity(:) = 0.0
!      RETURN
                           
   ELSE IF ( TimeShifted >= Tdata(NumCTt) )  THEN
   
      TimeIndx = NumCTt - 1
      Tgrid    = 1.0

!      CT_GetWindSpeed%Velocity(:) = 0.0
!      RETURN
      
   ELSE
   
         ! Let's interpolate!

      TimeIndx = MAX( MIN( TimeIndx, NumCTt-1 ), 1 )


      DO 

         IF ( TimeShifted < Tdata(TimeIndx) )  THEN

            TimeIndx = TimeIndx - 1

         ELSE IF ( TimeShifted >= Tdata(TimeIndx+1) )  THEN

            TimeIndx = TimeIndx + 1

         ELSE
         
            Tgrid = MIN( MAX( ( TimeShifted - Tdata(TimeIndx) )/( Tdata(TimeIndx+1) - Tdata(TimeIndx) ), 0.0 ), 1.0 )
            EXIT

         END IF

      END DO
      
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Read the data at the two time steps, if necessary
   !-------------------------------------------------------------------------------------------------
     
   IF ( TimeStpCT(TimeIndx) == CTvel_files(2) ) THEN
      IndCT_lo = 2      
      IndCT_hi = 1
            
   ELSE
      IndCT_lo = 1
      IndCT_hi = 2 
        
      IF ( TimeStpCT(TimeIndx) /= CTvel_files(IndCT_lo) ) THEN         
         CTvel_files(IndCT_lo) = TimeStpCT(TimeIndx)
         CALL ReadCTData ( CTWindUnit, CTvel_files(IndCT_lo), IndCT_lo, ErrStat  )
      END IF
      
   END IF
   

   IF ( CTvel_files(IndCT_hi) /= TimeStpCT(TimeIndx+1) ) THEN
      
      CTvel_files(IndCT_hi) = TimeStpCT(TimeIndx+1)
      CALL ReadCTData ( CTWindUnit, CTvel_files(IndCT_hi), IndCT_hi, ErrStat  )

   END IF
         

   !-------------------------------------------------------------------------------------------------
   ! Calculate the y values;                   The lower-right corner is (1,1) when looking downwind.
   ! note that the KH data is periodic in this direction
   !-------------------------------------------------------------------------------------------------
   
   Ynorm = ( CTYt + InputPosition(2) )/CTYmax

      ! Ensure Ynorm is not negative.  The wave is periodic in y.

   IF ( Ynorm < 0.0 ) THEN
      Ynorm = 1.0 + MOD(Ynorm, 1.0)
   ENDIF

   Ygrid = MIN( MAX( MOD( Ynorm, DelYCTgrid ), 0.0 ), 1.0 )
   IYLo  = MAX( MOD( INT( Ynorm*NumCTyD1 ) + 1, NumCTyD1 ), 1 )
   IYHi =  MOD( IYLo, NumCTyD ) + 1


   !-------------------------------------------------------------------------------------------------
   ! Calculate the z values                   The lower-right corner is (1,1) when looking downwind.
   ! Note: the equivalent Znorm for the w-component may be shifted vertically by half the original
   ! grid spacing. (the K-H data staggers w differently than u & v).  We store IZLo, IZHi, and 
   ! Zgrid in an array to account for this difference.
   !-------------------------------------------------------------------------------------------------

   Znorm = MIN( MAX( ( InputPosition(3) - CT_Zref )/CTZmax, 0.0 ), 1.0 ) ! non-dimensional height (CT_Zref is the bottom of the billow)

      ! Find out fractionally how far we are between grids in time and between grid points in each direction.
      ! Limit values to avoid extrapolation.  We need this for interpolation later on.

   Zgrid(1:2)   = MIN( MAX( MOD( Znorm, DelZCTgrid ), 0.0 ), 1.0 )
   IZLo(1:2)    = MAX( INT( Znorm*NumCTzD1 ) + 1, 1 )            ! Make sure the lowest possible value is 1.

      ! If we are located at the upper end of the z dimension, decrement the index by one and set the grid coordinate to 1.

   IF ( IZLo(1) == NumCTzD )  THEN
      IZLo(1:2)  = NumCTzD1
      Zgrid(1:2) = 1.0
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Find the equivalent Znorm for the w-component, which may be shifted vertically by half 
   ! the original grid spacing. (This is necessary due to the fact that the K-H data staggers w 
   ! differently than u & v).  LES and DNS scale differently.
   !-------------------------------------------------------------------------------------------------

   IF ( CTVertShft )  THEN
      Znorm = MAX( Znorm - 0.5*DelZCTgrid/CT_DF_Z, 0.0 )
      
      Zgrid(3) = MIN( MAX( MOD( Znorm, DelZCTgrid ), 0.0 ), 1.0 )
      IZLo(3)  = MAX( INT( Znorm*NumCTzD1 ) + 1, 1 )       ! Make sure the lowest possible value is 1.


         ! If we are located at the upper end of the z dimension, decrement the index by one and set the grid coordinate to 1.

      IF ( IZLo(3) == NumCTzD )  THEN
         IZLo(3)  = NumCTzD1
         Zgrid(3) = 1.0
      ENDIF
                 
   ELSE
      IZLo(3) = IZLo(1)
      Zgrid(3)= Zgrid(1)          
   ENDIF

   IZHi(:) = IZLo(:) + 1
   
!bjj: old versions used Zgrid(3) = Zgrid(1) without regard to CTVertShft. It seemed wrong to me so I changed it.

   !-------------------------------------------------------------------------------------------------
   !  Interpolate for U component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

      I = 1
         ! linearaly interpolate in the lower time slice
      Iylz   = ( CTvelU(IYLo,IZHi(I),IndCT_lo) - CTvelU(IYLo,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelU(IYLo,IZLo(I),IndCT_lo)
      Iyhz   = ( CTvelU(IYHi,IZHi(I),IndCT_lo) - CTvelU(IYHi,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelU(IYHi,IZLo(I),IndCT_lo)     
      Iyz_tl = ( Iyhz - Iylz )*Ygrid + Iylz

         ! linearaly interpolate in the upper time slice
      Iylz   = ( CTvelU(IYLo,IZHi(I),IndCT_hi) - CTvelU(IYLo,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelU(IYLo,IZLo(I),IndCT_hi)
      Iyhz   = ( CTvelU(IYHi,IZHi(I),IndCT_hi) - CTvelU(IYHi,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelU(IYHi,IZLo(I),IndCT_hi)     
      Iyz_th = ( Iyhz - Iylz )*Ygrid + Iylz

      CT_GetWindSpeed%Velocity(I) = ( Iyz_th - Iyz_tl )*Tgrid + Iyz_tl


   !-------------------------------------------------------------------------------------------------
   !  Interpolate for V component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

      I = 2

         ! linearaly interpolate in the lower time slice
      Iylz   = ( CTvelV(IYLo,IZHi(I),IndCT_lo) - CTvelV(IYLo,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelV(IYLo,IZLo(I),IndCT_lo)
      Iyhz   = ( CTvelV(IYHi,IZHi(I),IndCT_lo) - CTvelV(IYHi,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelV(IYHi,IZLo(I),IndCT_lo)     
      Iyz_tl = ( Iyhz - Iylz )*Ygrid + Iylz

         ! linearaly interpolate in the upper time slice
      Iylz   = ( CTvelV(IYLo,IZHi(I),IndCT_hi) - CTvelV(IYLo,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelV(IYLo,IZLo(I),IndCT_hi)
      Iyhz   = ( CTvelV(IYHi,IZHi(I),IndCT_hi) - CTvelV(IYHi,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelV(IYHi,IZLo(I),IndCT_hi)     
      Iyz_th = ( Iyhz - Iylz )*Ygrid + Iylz

      CT_GetWindSpeed%Velocity(I) = ( Iyz_th - Iyz_tl )*Tgrid + Iyz_tl


   !-------------------------------------------------------------------------------------------------
   !  Interpolate for W component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

      I = 3

         ! linearaly interpolate in the lower time slice
      Iylz   = ( CTvelW(IYLo,IZHi(I),IndCT_lo) - CTvelW(IYLo,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelW(IYLo,IZLo(I),IndCT_lo)
      Iyhz   = ( CTvelW(IYHi,IZHi(I),IndCT_lo) - CTvelW(IYHi,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelW(IYHi,IZLo(I),IndCT_lo)     
      Iyz_tl = ( Iyhz - Iylz )*Ygrid + Iylz

         ! linearaly interpolate in the upper time slice
      Iylz   = ( CTvelW(IYLo,IZHi(I),IndCT_hi) - CTvelW(IYLo,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelW(IYLo,IZLo(I),IndCT_hi)
      Iyhz   = ( CTvelW(IYHi,IZHi(I),IndCT_hi) - CTvelW(IYHi,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelW(IYHi,IZLo(I),IndCT_hi)     
      Iyz_th = ( Iyhz - Iylz )*Ygrid + Iylz

      CT_GetWindSpeed%Velocity(I) = ( Iyz_th - Iyz_tl )*Tgrid + Iyz_tl


   RETURN

END FUNCTION CT_GetWindSpeed
!====================================================================================================
SUBROUTINE ReadCTData ( UnWind, CTFileNo, Itime, ErrStat )
!    This subroutine is used to read one time-step's worth of large-eddy
!    zero-mean wind data for each wind component from a file.
!----------------------------------------------------------------------------------------------------


      ! Passed variables.

   INTEGER,       INTENT(IN)     :: UnWind                                    ! The I/O unit of the input file
   INTEGER,       INTENT(IN)     :: CTFileNo                                  ! The number of the file to read
   INTEGER,       INTENT(IN)     :: Itime                                     ! The index of the time slice
   INTEGER,       INTENT(OUT)    :: ErrStat                                   ! returns 0 if no error; non-zero otherwise

      ! Local variables.

!   CHARACTER(1),PARAMETER        :: Comp(NumComps) = (/'u', 'v', 'w' /)       ! the wind components
   CHARACTER(5)                  :: CTnum                                     ! string equivalent of input variable CTFileNo
   CHARACTER(1024)               :: FileName                                  ! The name of the input data file
   
   
   IF ( CTFileNo == 0 ) THEN
   
      CTvelU(:,:,Itime) = 0.0
      CTvelV(:,:,Itime) = 0.0
      CTvelW(:,:,Itime) = 0.0
      
   ELSE
         ! Loop through the components

      WRITE( CTnum, '(I5.5)' ) CTFileNo


      FileName = TRIM( CTSpath )//'\u\u_16i_'//CTnum//'.'//TRIM( CText )
      CALL LoadCTData( UnWind, TRIM(FileName), Itime, 1, CTvelU, ErrStat )
      IF ( ErrStat /= 0 ) RETURN
      

      FileName = TRIM( CTSpath )//'\v\v_16i_'//CTnum//'.'//TRIM( CText )
      CALL LoadCTData( UnWind, TRIM(FileName), Itime, 2, CTvelV, ErrStat )
      IF ( ErrStat /= 0 ) RETURN
      
      
      FileName = TRIM( CTSpath )//'\w\w_16i_'//CTnum//'.'//TRIM( CText )
      CALL LoadCTData( UnWind, TRIM(FileName), Itime, 3, CTvelW, ErrStat )
      IF ( ErrStat /= 0 ) RETURN
      
   
   END IF

   RETURN
   
END SUBROUTINE ReadCTData
!====================================================================================================
SUBROUTINE LoadCTData( UnWind, FileName, ITime, IComp, Vel, ErrStat )
!  This function is used to read the input parameters for the coherent turbulence events, 
!  based on the large-eddy simulation.
!----------------------------------------------------------------------------------------------------

      ! Passed variables.

   INTEGER,       INTENT(IN)     :: UnWind                                    ! The I/O unit of the input file
   CHARACTER(*),  INTENT(IN)     :: FileName                                  ! The name of the file to open
   INTEGER,       INTENT(IN)     :: Itime                                     ! The index of the time slice
   INTEGER,       INTENT(IN)     :: IComp                                     ! The index of the component
   REAL(ReKi),    INTENT(INOUT)  :: Vel    (NumCTyD,NumCTzD,2)                ! returns the velocity array (don't use INTENT OUT!)  
   INTEGER,       INTENT(OUT)    :: ErrStat                                   ! returns 0 if no error; non-zero otherwise

   INTEGER(B2Ki)                 :: Com    (NumCTy)                           ! Temporary array to hold component's integer values for a given Z.
   INTEGER                       :: IY                                        ! A DO index for indexing the arrays in the y direction.
   INTEGER                       :: IYK                                       ! An index for the decimated arrays in the y direction.
   INTEGER                       :: IZ                                        ! A DO index for indexing the arrays in the z direction.
   INTEGER                       :: IZK                                       ! An index for the decimated arrays in the z direction.



   !-------------------------------------------------------------------------------------------------
   ! Open the input file
   !-------------------------------------------------------------------------------------------------

   CALL OpenUInBEFile( UnWind, TRIM(FileName), 2*NumCTy, ErrStat )
   IF (ErrStat /= 0) RETURN


   !-------------------------------------------------------------------------------------------------
   ! Read the data and fill the arrays
   !-------------------------------------------------------------------------------------------------
      
   IZK = 0                          ! the Z index into the array (necessary b/c of decimation factor)
   DO IZ=1,NumCTz,CT_DF_Z

      READ (UnWind,REC=IZ,IOSTAT=ErrStat)  Com

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Error reading record '//TRIM( Num2LStr( IZ ) )//' of the binary CT wind file, "' &
                           //TRIM( FileName )//'."')
         RETURN                           

      ENDIF

      IZK = IZK + 1
      IYK = 0                       ! the Y index into the array (necessary b/c of decimation factor)
      
      DO IY=1,NumCTy,CT_DF_Y
         IYK = IYK + 1
         Vel(IYK,IZK,ITime) = CTScale(IComp)*Com(IY) + CTOffset(IComp)
      ENDDO ! IY

   ENDDO ! IZ


   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
      CLOSE ( UnWind )

   RETURN


END SUBROUTINE LoadCTData
!====================================================================================================
SUBROUTINE ReadCTP( UnWind, FileName, CTPscaling, ErrStat )
!  This function is used to read the input parameters for the coherent turbulence events, 
!  based on the large-eddy simulation.
!----------------------------------------------------------------------------------------------------


      ! Passed variables.

   INTEGER,            INTENT(IN)  :: UnWind                                   ! The I/O unit of the input file
   CHARACTER(*),       INTENT(IN)  :: FileName                                 ! The name of the input data file
   TYPE(CTWindFiles),  INTENT(OUT) :: CTPscaling                               ! The file names contained in the CTP file
   INTEGER,            INTENT(OUT) :: ErrStat                                  ! returns 0 if no error; non-zero otherwise


      ! Local variables.
      
   CHARACTER(1024)                 :: HeaderLine                               ! The header text in the file
   CHARACTER(1024)                 :: TmpPath

   !-------------------------------------------------------------------------------------------------
   ! Open the CTP input file
   !-------------------------------------------------------------------------------------------------
   
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) RETURN


   !-------------------------------------------------------------------------------------------------
   ! Read the CTP input file
   !-------------------------------------------------------------------------------------------------
   CALL ReadStr( UnWind, TRIM( FileName ), HeaderLine, 'Header line', 'The header line in the CTP file', ErrStat )
   IF (ErrStat /= 0) RETURN   
   CALL WrScr ( ' Heading of the CT-wind-parameter file: "'//TRIM(HeaderLine)//'"' )


   CALL ReadCom( UnWind, TRIM( FileName ), 'parameter header line', ErrStat )
   IF (ErrStat /= 0) RETURN
   

   CALL ReadVar( UnWind, TRIM( FileName ), CTSpath,  'CTSpath',  & 
                  'Location (path) of the binary coherent turbulence dataset', ErrStat )
   IF (ErrStat /= 0) RETURN
                  

   CALL ReadVar( UnWind, TRIM( FileName ), CTPscaling%CTTSfile, 'CTTSfile', &
                  'File containing the time steps for the coherent turbulence events (.cts)', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   
   IF ( PathIsRelative( CTPscaling%CTTSfile ) ) THEN
      CALL GetPath( FileName, TmpPath ) 
      CTPscaling%CTTSfile = TRIM(TmpPath)//TRIM(CTPscaling%CTTSfile)
   END IF      

   CALL ReadVar( UnWind, TRIM( FileName ), CTPscaling%CTbackgr, 'CTbackgr', 'File containing the background wind', ErrStat )
   IF (ErrStat /= 0) RETURN

   IF ( PathIsRelative( CTPscaling%CTbackgr ) ) THEN
      CALL GetPath( FileName, TmpPath ) 
      CTPscaling%CTbackgr = TRIM(TmpPath)//TRIM(CTPscaling%CTbackgr)
   END IF      


   CALL ReadVar( UnWind, TRIM( FileName ), CT_DF_Y, 'CT_DF_Y', 'Decimation factor for wind data in the Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CT_DF_Z, 'CT_DF_Z', 'Decimation factor for wind data in the Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN

   
   !-------------------------------------------------------------------------------------------------
   ! Close the CTP input file
   !-------------------------------------------------------------------------------------------------
   
   CLOSE( UnWind )


END SUBROUTINE ReadCTP
!====================================================================================================
SUBROUTINE ReadCTTS ( UnWind, FileName, CT_SC_ext, ErrStat )
!  This subroutine is used to read the input parameters calculated in TurbSim for the scaling of 
!  coherent turbulence events.  It reads the .cts file and saves the time step and file number arrays.
!----------------------------------------------------------------------------------------------------


      ! Passed variables.

   INTEGER,            INTENT(IN)  :: UnWind                                   ! The I/O unit of the input file
   CHARACTER(*),       INTENT(IN)  :: FileName                                 ! The name of the input data file
   INTEGER,            INTENT(OUT) :: ErrStat                                  ! returns 0 if no error; -1 if the file is blank or can't be opened;                                                                               ! non-zero otherwise
   CHARACTER(3),       INTENT(OUT) :: CT_SC_ext                                ! The extension used for coherent turbulence scale files.(usually "les", "dns", or "dat")

      ! Local variables
   INTEGER                         :: IT                                       ! Loop counter

   !-------------------------------------------------------------------------------------------------
   ! Initialize variables
   !-------------------------------------------------------------------------------------------------

   NumCTt = 0

   !-------------------------------------------------------------------------------------------------
   ! Open the CTS input file
   !-------------------------------------------------------------------------------------------------
   
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) THEN
      ErrStat = -1
      RETURN
   END IF
   
   !-------------------------------------------------------------------------------------------------
   ! Read the header of the CTS input file
   !-------------------------------------------------------------------------------------------------
   
      ! Check to see if the first value is numeric (old) or the file type (new) and start again
      
   READ ( UnWind, *, IOSTAT=ErrStat ) CTScaleVel       
   REWIND( UnWind )  


   IF ( ErrStat /= 0 )  THEN   ! try again
            
      CALL ReadVar( UnWind, TRIM( FileName ), CText, 'CText', 'FileType ', ErrStat ) 
      IF ( ErrStat /= 0 ) THEN
         ErrStat = SIGN( 1, ErrStat)
         RETURN
      END IF
      CT_SC_ext = CText      
      
      CALL ReadVar( UnWind, TRIM( FileName ), CTScaleVel, 'CTScaleVel', ' ', ErrStat ) 
      IF ( ErrStat /= 0 ) RETURN
   ELSE  ! assume LES files
   
      CALL ReadVar( UnWind, TRIM( FileName ), CTScaleVel, 'CTScaleVel', ' ', ErrStat ) 

      CText     = 'les'
      CT_SC_ext = 'dat'
   END IF
   
   CALL ReadVar( UnWind, TRIM( FileName ), InvMCTWS, 'MeanCTWS', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   InvMCTWS = 1.0 / InvMCTWS
      

   CALL ReadVar( UnWind, TRIM( FileName ), CTYmax, 'CTYmax', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   

   CALL ReadVar( UnWind, TRIM( FileName ), CTZmax, 'CTZmax', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CTDistSc, 'CTDistSc', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CTLy, 'CTLy', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   
   
   CALL ReadVar( UnWind, TRIM( FileName ), CTLz, 'CTLz', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   
   
   CALL ReadVar( UnWind, TRIM( FileName ), NumCTt, 'NumCTt', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   !-------------------------------------------------------------------------------------------------
   ! Allocate space for the arrays
   !-------------------------------------------------------------------------------------------------

   IF (.NOT. ALLOCATED(Tdata) ) THEN
      ALLOCATE ( Tdata(NumCTt) , STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the Tdata array.' )
         RETURN
      END IF
   END IF

   IF (.NOT. ALLOCATED(TimeStpCT) ) THEN
      ALLOCATE ( TimeStpCT(NumCTt) , STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the TimeStpCT array.' )
         RETURN
      END IF
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Read the arrays from the CTS input file
   !-------------------------------------------------------------------------------------------------
   
   DO IT=1,NumCTt

      READ (UnWind,*,IOSTAT=ErrStat)  Tdata(IT), TimeStpCT(IT)

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error reading record '//TRIM( Num2LStr( IT ) )//' of the CT-wind time-steps file, "' &
                         //TRIM( FileName )//'."')

         NumCTt = IT - 1
         RETURN
      ENDIF

   ENDDO ! IT


   !-------------------------------------------------------------------------------------------------
   ! Close the CTS input file
   !-------------------------------------------------------------------------------------------------
   CLOSE( UnWind )


   RETURN
   
END SUBROUTINE ReadCTTS
!====================================================================================================
SUBROUTINE ReadCTScales ( UnWind, FileName, ErrStat )
!  This subroutine is used to read the input parameters for the coherent turbulence events, based
!  on the large-eddy simulation.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,            INTENT(IN)  :: UnWind                                   ! The I/O unit of the input file
   CHARACTER(*),       INTENT(IN)  :: FileName                                 ! The name of the input data file
   INTEGER,            INTENT(OUT) :: ErrStat                                  ! returns 0 if no error; non-zero otherwise


      ! Local variables
      
   INTEGER                         :: I                                        ! Array counter

   !-------------------------------------------------------------------------------------------------
   ! Open the file with the scales (les or dns)
   !-------------------------------------------------------------------------------------------------

   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) RETURN
   

   !-------------------------------------------------------------------------------------------------
   ! Read the file with the scales (les or dns)
   !-------------------------------------------------------------------------------------------------

   CALL ReadCom( UnWind, TRIM( FileName ), 'First line', ErrStat )
   IF (ErrStat /= 0) RETURN

   CALL ReadVar( UnWind, TRIM( FileName ), CTVertShft, 'CTVertShft', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN

   DO I = 1,3
      CALL ReadVar( UnWind, TRIM( FileName ), CTScale(I), 'CTScale('//TRIM(Num2LStr(I))//')', ' ', ErrStat ) 
      IF ( ErrStat /= 0 )  RETURN
   
      CALL ReadVar( UnWind, TRIM( FileName ), CTOffset(I), 'CTOffset('//TRIM(Num2LStr(I))//')', ' ', ErrStat ) 
      IF ( ErrStat /= 0 )  RETURN
   END DO !I

   CALL ReadVar( UnWind, TRIM( FileName ), NumCTy, 'NumCTy', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN

   CALL ReadVar( UnWind, TRIM( FileName ), NumCTz, 'NumCTz', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   !-------------------------------------------------------------------------------------------------
   ! Close the file with the scales (les or dns)
   !-------------------------------------------------------------------------------------------------
   
   CLOSE( UnWind )
   

   RETURN
   
END SUBROUTINE ReadCTScales
!====================================================================================================
SUBROUTINE CT_Terminate( ErrStat )
! This subroutine closes files, deallocates memory, and un-sets the initialization flag
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise


   CLOSE( CTWindUnit )
   
   ErrStat = 0

   IF ( ALLOCATED( CTvelU    ) )  DEALLOCATE( CTvelU,    STAT=ErrStat )
   IF ( ALLOCATED( CTvelV    ) )  DEALLOCATE( CTvelV,    STAT=ErrStat )
   IF ( ALLOCATED( CTvelW    ) )  DEALLOCATE( CTvelW,    STAT=ErrStat )
   IF ( ALLOCATED( Tdata     ) )  DEALLOCATE( Tdata,     STAT=ErrStat )
   IF ( ALLOCATED( TimeStpCT ) )  DEALLOCATE( TimeStpCT, STAT=ErrStat )

   TimeIndx = 0

END SUBROUTINE CT_Terminate
!====================================================================================================
END MODULE CTWind
MODULE FDWind
! This module reads and processes 4-dimensional wind fields.
! The subroutines were originally created by Marshall Buhl to read LES data provided by researchers
! at NCAR. It was later updated by Bonnie Jonkman to read DNS data provided by researchers at CoRA.
!
! Data are assumed to be in units of meters and seconds.
!
!  7 Oct 2009    B. Jonkman, NREL/NWTC using subroutines from AeroDyn 12.57
!----------------------------------------------------------------------------------------------------  

    USE                     NWTC_Library
    USE                     SharedInflowDefns

    IMPLICIT                NONE
   PRIVATE
  
      ! FD_Wind
      
   REAL(ReKi)                   :: DelXgrid                                   ! The nondimensional distance between grid points in the x direction.
   REAL(ReKi)                   :: DelYgrid                                   ! The nondimensional distance between grid points in the y direction.
   REAL(ReKi)                   :: DelZgrid                                   ! The nondimensional distance between grid points in the z direction.
   REAL(ReKi)                   :: FDper                                      ! Total time in dataset.
   REAL(ReKi)                   :: FDTime   (2)                               ! Times for the 4D wind files.
   REAL(ReKi), ALLOCATABLE      :: FDu      (:,:,:,:)                         ! The u-component array of 4D wind data.
   REAL(ReKi), ALLOCATABLE      :: FDv      (:,:,:,:)                         ! The v-component array of 4D wind data.
   REAL(ReKi), ALLOCATABLE      :: FDw      (:,:,:,:)                         ! The w-component array of 4D wind data.
   REAL(ReKi), ALLOCATABLE      :: FDuData  (:,:,:,:)                         ! The u-component array of all 4D wind data when used with advection.
   REAL(ReKi), ALLOCATABLE      :: FDvData  (:,:,:,:)                         ! The v-component array of all 4D wind data when used with advection.
   REAL(ReKi), ALLOCATABLE      :: FDwData  (:,:,:,:)                         ! The w-component array of all 4D wind data when used with advection.
   REAL(ReKi)                   :: Lx                                         ! Fractional location of tower centerline from upwind end to downwind end of the dataset.
   REAL(ReKi)                   :: Ly                                         ! Fractional location of tower centerline from right (looking downwind) to left side of the dataset.
   REAL(ReKi)                   :: Lz                                         ! Fractional location of hub height from bottom to top of dataset.
   REAL(ReKi)                   :: Offsets  (3)                               ! Offsets to convert integer data to actual wind speeds.
   REAL(ReKi), SAVE             :: PrevTime                                   ! The previous time this was called -- so we can go back in time if necessary
   REAL(ReKi)                   :: RotDiam                                    ! Rotor diameter.
   REAL(ReKi)                   :: ScalFact (3)                               ! Scaling factors to convert integer data to actual wind speeds.
   REAL(ReKi)                   :: ScaleVel                                   ! Scaling velocity, U0.  2*U0 is the difference in wind speed between the top and bottom of the wave.
   REAL(ReKi), ALLOCATABLE      :: Times4D  (:)                               ! The list of times for the 4D-wind input files.
   REAL(ReKi)                   :: Tm_max                                     ! The total nondimensional time of the dataset.
   REAL(ReKi)                   :: TSclFact                                   ! Scale factor for time (h/U0).
   REAL(ReKi)                   :: T_4D_En                                    ! Time at which the wave event ends.
   REAL(ReKi)                   :: T_4D_St                                    ! Time at which the wave event starts.
   REAL(ReKi)                   :: Xmax                                       ! The dimensional downwind length of the dataset.
   REAL(ReKi)                   :: Xt                                         ! Distance of the tower from the upwind end of the dataset.
   REAL(ReKi)                   :: Ymax                                       ! The dimensional lateral width of the dataset.
   REAL(ReKi)                   :: Yt                                         ! Distance of the tower from the right side of the dataset (looking downwind).
   REAL(ReKi)                   :: Zmax                                       ! The dimensional vertical height of the dataset.
   REAL(ReKi)                   :: Zt                                         ! Distance of the hub from the bottom of the dataset.
   REAL(ReKi)                   :: Zref                                       ! The reference height (hub height)

   INTEGER                      :: FD_DF_X                                    ! The decimation factor for the 4D wind data in the x direction.
   INTEGER                      :: FD_DF_Y                                    ! The decimation factor for the 4D wind data in the y direction.
   INTEGER                      :: FD_DF_Z                                    ! The decimation factor for the 4D wind data in the z direction.
   INTEGER                      :: FDFileNo                                   ! The 4D wind file number.
   INTEGER                      :: FDRecL                                     ! The length, in bytes, of the LE binary records.
   INTEGER                      :: Ind4DAdv                                   ! Index of the file to be used in advection
   INTEGER                      :: Ind4Dnew                                   ! Index of the newest 4D wind file.
   INTEGER                      :: Ind4Dold                                   ! Index of the older 4D wind file.
   INTEGER                      :: Num4Dt                                     ! The number of 4D wind grids, one grid per time step.
   INTEGER, PARAMETER           :: Num4DtD = 2                                ! The number of 4D wind grids stored in memory, normally 2
   INTEGER                      :: Num4Dx                                     ! The number of 4D wind grid points in the x direction.
   INTEGER                      :: Num4DxD                                    ! The decimated number of 4D wind grid points in the x direction.
   INTEGER                      :: Num4DxD1                                   ! The decimated number of 4D wind grid points in the x direction minus 1.
   INTEGER                      :: Num4Dy                                     ! The number of 4D wind grid points in the y direction.
   INTEGER                      :: Num4DyD                                    ! The decimated number of 4D wind grid points in the y direction.
   INTEGER                      :: Num4DyD1                                   ! The decimated number of 4D wind grid points in the y direction minus 1.
   INTEGER                      :: Num4Dz                                     ! The number of 4D wind grid points in the z direction.
   INTEGER                      :: Num4DzD                                    ! The decimated number of 4D wind grid points in the z direction.
   INTEGER                      :: Num4DzD1                                   ! The decimated number of 4D wind grid points in the z direction minus 1.
   INTEGER                      :: NumAdvect                                  ! Number of frozen timesteps to advect past the turbine
   INTEGER                      :: Shft4Dnew                                  ! Number of times the x-data needs to be shifted for advection
   INTEGER, ALLOCATABLE         :: Times4DIx (:)                              ! Index number of the 4D time files (used for advection)

   INTEGER                      :: FDUnit                                     ! Unit number for reading wind files

   LOGICAL                      :: Advect                                     ! Flag to indicate whether or not to advect a given data set or to just use the time step files 
   LOGICAL                      :: VertShft                                   ! Flag to indicate whether or not to shift the z values for the w component.

   LOGICAL, SAVE                :: Initialized = .FALSE.

   CHARACTER(5), ALLOCATABLE    :: AdvFiles (:)
   CHARACTER(1024)              :: FDSpath                                    ! The path to the 4D wind files.


   PUBLIC                       :: FD_Init
   PUBLIC                       :: FD_GetWindSpeed
   PUBLIC                       :: FD_Terminate
   PUBLIC                       :: FD_GetValue


CONTAINS
!====================================================================================================
SUBROUTINE FD_Init(UnWind, WindFile, RefHt, ErrStat)
!  This subroutine is called at the beginning of a simulation to initialize the module.  
!----------------------------------------------------------------------------------------------------

      ! Passed variables
      
   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: WindFile                     ! Name of the 4D wind parameter file (.fdp)
   REAL(ReKi),      INTENT(IN)    :: RefHt                        ! The reference height for the billow (should be hub height)
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors; non-zero otherwise

      ! Local variables

   CHARACTER(1024)                :: FDTSfile                     ! name of the 4D time step file
   REAL(ReKi)                     :: FDTimStp                     ! Average time step for 4D wind data.
   INTEGER                        :: IT
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' FDWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Set the reference height for the wind file (this takes the place of HH that was used earlier)
   !-------------------------------------------------------------------------------------------------

   ZRef = RefHt         
   
   !-------------------------------------------------------------------------------------------------
   ! Read the main 4D input file
   !-------------------------------------------------------------------------------------------------
   
   CALL ReadFDP( UnWind, WindFile, FDTSfile, ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   !-------------------------------------------------------------------------------------------------
   ! Get the times array, which must be scaled and shifted later using TSclFact and T_4D_St
   !-------------------------------------------------------------------------------------------------

   CALL Read4Dtimes ( UnWind, FDTSfile, ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   
   !-------------------------------------------------------------------------------------------------
   ! Calculate some values that don't change during the run.
   !-------------------------------------------------------------------------------------------------

   FDRecL      = 2*Num4Dx*Num4Dy                                           ! The length, in bytes, of the 4D binary records.
   Num4DxD     = ( Num4Dx + FD_DF_X - 1 )/FD_DF_X                          ! The decimated number of 4D wind grid points in the x direction.
   Num4DyD     = ( Num4Dy + FD_DF_Y - 1 )/FD_DF_Y                          ! The decimated number of 4D wind grid points in the y direction.
   Num4DzD     = ( Num4Dz + FD_DF_Z - 1 )/FD_DF_Z                          ! The decimated number of 4D wind grid points in the z direction.
   Num4DxD1    = Num4DxD - 1                                               ! The decimated number of 4D wind grid points in the x direction minus 1.
   Num4DyD1    = Num4DyD - 1                                               ! The decimated number of 4D wind grid points in the y direction minus 1.
   Num4DzD1    = Num4DzD - 1                                               ! The decimated number of 4D wind grid points in the z direction minus 1.

   Tm_max      = Times4D(Num4Dt)                                           ! Time of end of dataset.
   IF ( ADVECT ) THEN
      FDTimStp   = Xmax / ( ( Num4Dx - 1 )*( ScaleVel )*Num4Dt )           ! The timestep is calculated by the approximation dx/dt ~= U0 (divide by num4dt to get delta for a full timestep).
      FDper      = FDTimStp * Num4Dt                                       ! Total time in dataset. (We have periodic time, so multiply by number of time steps, without subtracting 1)
      TSclFact   = FDper / Tm_max                                          ! Equivalent scale factor for time.
   ELSE
      FDper       = TSclFact*Tm_max                                        ! Total time in dataset.
      FDTimStp    = FDper/( Num4Dt - 1 )                                   ! Average time step.
   ENDIF

   T_4D_En     = T_4D_St + FDper                                           ! Time for the end of the dataset.
   Xt          = Xmax*Lx                                                   ! Distance of the tower from the upwind end of the dataset.
   Yt          = Ymax*Ly                                                   ! Distance of the tower from the right side of the dataset (looking downwind).
   Zt          = Zmax*Lz                                                   ! Distance of the hub from the bottom of the dataset.
   DelXgrid    = 1.0/Num4DxD1                                              ! The nondimensional distance between grid points in the x direction.
   DelYgrid    = 1.0/Num4DyD1                                              ! The nondimensional distance between grid points in the y direction.
   DelZgrid    = 1.0/Num4DzD1                                              ! The nondimensional distance between grid points in the z direction.


   !-------------------------------------------------------------------------------------------------
   ! Scale and shift the times array using TSclFact and T_4D_St
   !-------------------------------------------------------------------------------------------------

   DO IT=1,Num4Dt
      
      Times4D(IT) = TSclFact*Times4D(IT) + T_4D_St

   ENDDO ! IT


   !-------------------------------------------------------------------------------------------------
   ! Allocate velocity arrays and fill Data arrays for advection (DNS files)
   !-------------------------------------------------------------------------------------------------

   IF (.NOT. ALLOCATED(FDu) ) THEN
!      CALL AllocAry ( FDu, Num4DxD, Num4DyD, Num4DzD, 2, 'U-component velocity array (FDu)', ErrStat)
      ALLOCATE ( FDu(Num4DxD,Num4DyD,Num4DzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the U-component velocity array (FDu) array.' )
         RETURN
      END IF
   END IF
   
   IF (.NOT. ALLOCATED(FDv) ) THEN
!      CALL AllocAry ( FDv, Num4DxD, Num4DyD, Num4DzD, 2, 'V-component velocity array (FDv)', ErrStat)
      ALLOCATE ( FDv(Num4DxD,Num4DyD,Num4DzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the V-component velocity array (FDv) array.' )
         RETURN
      END IF
   END IF

   IF (.NOT. ALLOCATED(FDw) ) THEN
!      CALL AllocAry ( FDw, Num4DxD, Num4DyD, Num4DzD, 2, 'W-component velocity array (FDw)', ErrStat)
      ALLOCATE ( FDw(Num4DxD,Num4DyD,Num4DzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the W-component velocity array (FDw) array.' )
         RETURN
      END IF
   END IF

   IF ( ADVECT ) THEN

      IF (.NOT. ALLOCATED(FDuData) ) THEN
!         CALL AllocAry ( FDuData, Num4DxD, Num4DyD, Num4DzD, Num4Dt, 'U-component velocity array (FDuData)', ErrStat)
         ALLOCATE ( FDuData(Num4DxD,Num4DyD,Num4DzD,Num4Dt), STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error allocating memory for the U-component velocity array (FDuData) array.' )
            RETURN
         END IF
      END IF

      IF (.NOT. ALLOCATED(FDvData) ) THEN
!         CALL AllocAry ( FDvData, Num4DxD, Num4DyD, Num4DzD, Num4Dt, 'V-component velocity array (FDvData)', ErrStat)
         ALLOCATE ( FDvData(Num4DxD,Num4DyD,Num4DzD,Num4Dt), STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error allocating memory for the V-component velocity array (FDvData) array.' )
            RETURN
         END IF
      END IF

      IF (.NOT. ALLOCATED(FDwData) ) THEN
!         CALL AllocAry ( FDwData, Num4DxD, Num4DyD, Num4DzD, Num4Dt, 'W-component velocity array (FDwData)', ErrStat)
         ALLOCATE ( FDwData(Num4DxD,Num4DyD,Num4DzD,Num4Dt), STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error allocating memory for the W-component velocity array (FDwData) array.' )
            RETURN
         END IF
      END IF

      CALL ReadAll4DData(UnWind, ErrStat) !This needs AdvFiles(:), which was is read in ReadFDP()
      IF ( ErrStat /= 0 ) RETURN

   ENDIF

     
   !-------------------------------------------------------------------------------------------------
   ! Determine the first file needed for this simulation.
   !-------------------------------------------------------------------------------------------------
   Ind4Dold  = 1                                                           ! Put the old stuff in the first part of the array.
   Ind4Dnew  = 2                                                           ! Put the new stuff in the second part of the array.

   Shft4Dnew = 0


   IF ( T_4D_St >= 0.0 )  THEN
      FDFileNo = 1
   ELSE
      FDFileNo = Num4Dt
      DO IT=1,Num4Dt
         IF ( Times4D(IT) > 0.0 )  THEN
            FDFileNo = IT - 1
            EXIT
         END IF
      END DO ! IT
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Open, read, and close the first set of files.
   !-------------------------------------------------------------------------------------------------
   FDTime(Ind4Dold) = Times4D(FDFileNo)                                 ! Set the time for this file.

   IF ( ADVECT ) THEN
      CALL Load4DData(Ind4Dold)     ! load data stored in FDuData, FDvData, and FDwData arrays
   ELSE
      CALL LoadLESData( UnWind, FDFileNo, Ind4Dold, ErrStat )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Open, read, and close the second set of files.
   !-------------------------------------------------------------------------------------------------
   FDFileNo  = FDFileNo + 1


   IF ( ADVECT ) THEN
      FDFileNo = MOD(FDFileNo-1,Num4Dt) + 1

      IF (FDFileNo == 1) THEN
         Shft4Dnew = Shft4Dnew + 1

         IF (Ind4DAdv <= NumAdvect) THEN                             ! Ind4DAdv was set in ReadFDP
            IF ( MOD( Shft4Dnew, Num4Dx ) == 0 ) THEN
               CALL ReadAll4DData(UnWind, ErrStat)
               IF ( ErrStat /= 0 ) RETURN
            END IF
         END IF

      ENDIF

      FDTime(Ind4Dnew) = Times4D(FDFileNo) + Shft4Dnew*FDPer         ! Set the time for this file.

      CALL Load4DData( Ind4Dnew )    ! shift the data

   ELSE   
      FDTime(Ind4Dnew) = Times4D(FDFileNo)                                           ! Set the time for this file.

      CALL LoadLESData( UnWind, FDFileNo, Ind4Dnew, ErrStat )
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Set the initialization flag
   !-------------------------------------------------------------------------------------------------
   FDUnit      = UnWind
   PrevTime    = 0.0
   
   Initialized = .TRUE.
   
   RETURN

END SUBROUTINE FD_Init
!====================================================================================================
SUBROUTINE ReadFDP ( UnWind, FileName, FDTSfile, ErrStat )
!  This subroutine is used to read the input parameters for the large-eddy simulation.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: FileName                     ! Then name of the LE data file.
   CHARACTER(*),    INTENT(OUT)   :: FDTSfile                     ! The name of the file containing the time-step history of the wind files.
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise


      ! Local variables

   CHARACTER(1024)                :: HeaderLine
   CHARACTER(1),PARAMETER         :: Comp(3) = (/'U', 'V', 'W' /) ! the wind components

   REAL(ReKi)                     :: CoefTE                       ! Coefficient of thermal expansion.
   REAL(ReKi)                     :: DistScal                     ! Disturbance scale (ratio of wave height to rotor diameter) from input file.
   REAL(ReKi)                     :: Grav                         ! Gravitational acceleration.
   REAL(ReKi)                     :: LenScale                     ! Length scale (h).
   REAL(ReKi)                     :: Ri                           ! Richardson number.
   REAL(ReKi)                     :: Ubot                         ! Steady u-component wind speed at the bottom of the wave.
   REAL(ReKi)                     :: Zm_maxo                      ! The nondimensional vertical height of the untrimmed dataset.

   REAL(ReKi)                     :: Xm_max                       ! The nondimensional downwind length of the dataset.
   REAL(ReKi)                     :: Ym_max                       ! The nondimensional lateral width of the dataset.
   REAL(ReKi)                     :: Zm_max                       ! The nondimensional vertical height of the dataset.

   INTEGER                        :: I

   !-------------------------------------------------------------------------------------------------
   ! Open the 4D parameter file for reading
   !-------------------------------------------------------------------------------------------------
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) RETURN   


   !-------------------------------------------------------------------------------------------------
   ! Read the 4D parameter input file
   !-------------------------------------------------------------------------------------------------

      !..............................................................................................
      ! Read the 4D wind parameters specific to this turbine simulation.  
      !..............................................................................................

   CALL ReadStr( UnWind, TRIM( FileName ), HeaderLine, 'Header line', 'The header line in the FTP file', ErrStat )
   IF (ErrStat /= 0) RETURN   
   CALL WrScr ( ' Heading of the 4D-wind-parameter file: "'//TRIM(HeaderLine)//'"' )


   CALL ReadCom( UnWind, TRIM( FileName ), 'Header line', ErrStat )
   IF (ErrStat /= 0) RETURN
      

   CALL ReadVar( UnWind, TRIM( FileName ), FDSpath,  'FDSpath', 'Location (path) of the binary dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FDTSfile,  'FDTSfile', & 
                                  'Name of the file containing the time-step history of the wind files', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ubot,  'Ubot', 'Steady u-component wind speed at the bottom of the wave', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), DistScal,  'DistScal', 'Disturbance scale', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Lx,  'Lx', &
                            'Fractional location of tower centerline from upwind end to downwind end of the dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ly,  'Ly', &
                 'Fractional location of tower centerline from right (looking downwind) to left side of the dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Lz,  'Lz', &
                                          'Fractional location of hub height from bottom to top of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), T_4D_St,  'T_4D_St', 'Time at which the wave event starts', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), ScaleVel,  'ScaleVel', &
                 'Scaling velocity, U0: half the difference in wind speed between the top and bottom of the billow.', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), RotDiam,  'RotDiam', 'Rotor diameter', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FD_DF_X,  'FD_DF_X', 'Decimation factor in X direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FD_DF_Y,  'FD_DF_Y', 'Decimation factor in Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FD_DF_Z,  'FD_DF_Z', 'Decimation factor in Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadCom( UnWind, TRIM( FileName ), 'blank line', ErrStat )
   IF (ErrStat /= 0) RETURN

      !..............................................................................................
      ! Read the 4D wind parameters specific to the K-H billow simulation being used.  
      !..............................................................................................

   CALL ReadCom( UnWind, TRIM( FileName ), 'LES parameters specific to the K-H billow simulation being used', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), VertShft,  'VertShft', & 
                           'Flag to indicate whether or not to shift the z values for the w component', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Xm_max,  'Xm_max', & 
                           'Maximum nondimensional downwind distance from center of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ym_max,  'Ym_max', & 
                           'Maximum nondimensional lateral distance from center of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Zm_max,  'Zm_max', & 
                           'Maximum nondimensional vertical distance from center of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Zm_maxo,  'Zm_maxo', & 
                 'Maximum nondimensional vertical distance from center of untrimmed dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   DO I = 1,3

      CALL ReadVar( UnWind, TRIM( FileName ), ScalFact(I),  Comp(I)//'Scl', & 
                    Comp(I)//'-component scale factor for converting from integers to reals', ErrStat )
      IF (ErrStat /= 0) RETURN
      ScalFact(I) = ScalFact(I) * ScaleVel


      CALL ReadVar( UnWind, TRIM( FileName ), Offsets(I), Comp(I)//'Off', & 
                    Comp(I)//'-component offset for converting from integers to reals', ErrStat )
      IF (ErrStat /= 0) RETURN
      Offsets(I) = Offsets(I) * ScaleVel
      
   END DO   
   Offsets (1) = Offsets (1) + ScaleVel + Ubot                           ! u-component offset to convert integer data to actual wind speeds.


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dt, 'Num4Dt', 'The number of LE grids, one grid per time step', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dx, 'Num4Dx', 'The number of LE grid points in the x direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dy, 'Num4Dy', 'The number of LE grid points in the y direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dz, 'Num4Dz', 'The number of LE grid points in the z direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ri, 'Ri', 'Richardson number', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CoefTE, 'CoefTE', 'Coefficient of thermal expansion', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Grav, 'Grav', 'Gravitational acceleration', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Advect, 'Advect', 'Advection flag', ErrStat )
   
   IF (ErrStat /= 0) THEN
   
      Advect   = .FALSE.
      Ind4DAdv = 0
      ErrStat  = 0
      CALL WrScr( ' Advection will not be used.')
      
   ELSE
   
      IF (Advect) THEN
         IF ( FD_DF_X /= 1 ) THEN
            CALL WrScr( ' FD_DF_X must be 1 when using advection. ' )
            FD_DF_X = 1            
         ENDIF

         CALL ReadVar( UnWind, TRIM( FileName ), NumAdvect, 'NumAdvect', 'Number of 4D files for advection', ErrStat )
         IF (ErrStat /= 0) RETURN
         

         IF ( NumAdvect < 1 ) THEN
            CALL WrScr( ' NumAdvect in 4D-wind-parameter file, "'//TRIM( FileName )//'," must be at least 1.' )
            ErrStat = 1
            RETURN
         ENDIF

         IF ( .NOT. ALLOCATED( AdvFiles ) ) THEN
!            CALL AllocAry( AdvFiles, NumAdvect, 'AdvFiles array', ErrStat )
            ALLOCATE ( AdvFiles(NumAdvect), STAT=ErrStat )

            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error allocating memory for the AdvFiles array.' )
               RETURN
            END IF
         ENDIF

         CALL ReadAryLines( UnWind, TRIM( FileName ), AdvFiles, NumAdvect, 'AdvFiles', 'Advection file names', ErrStat )
         IF (ErrStat /= 0) RETURN
         Ind4DAdv = 1
         
      ELSE
         Ind4DAdv = 0
      ENDIF !Advect == .TRUE.
   
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Close the 4D parameter input file
   !-------------------------------------------------------------------------------------------------
   CLOSE ( UnWind )
   
   !-------------------------------------------------------------------------------------------------
   ! Close the 4D parameter input file
   !-------------------------------------------------------------------------------------------------

   LenScale    = RotDiam*DistScal/Zm_max                             ! Length scale (h).
   Xmax        = Xm_max*LenScale                                     ! The dimensional length of the dataset.
   Ymax        = Ym_max*LenScale                                     ! The dimensional width of the dataset
   Zmax        = Zm_max*LenScale                                     ! The dimensional vertical height of the dataset.
   TSclFact    = LenScale/ScaleVel                                   ! Scale factor for time (h/U0).

   

   RETURN

END SUBROUTINE ReadFDP
!====================================================================================================
SUBROUTINE Read4Dtimes ( UnWind, FileName, ErrStat )
!  This subroutine is used to read the time array for the 4D data.  The times in the file are 
!  non-dimensional and non-uniformly spaced. They are scaled using TSclFact to obtain units of seconds
!  and T_4D_St is added to allow the billow to start at non-zero time.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: FileName                     ! Then name of the LE data file.
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise


      ! Local variables

   INTEGER                        :: I                            ! Loop counter

   !-------------------------------------------------------------------------------------------------
   ! Allocate arrays to store the data in
   !-------------------------------------------------------------------------------------------------
   
   IF (.NOT. ALLOCATED( Times4D) ) THEN
!      CALL AllocAry( Times4D, Num4Dt, '4D time array', ErrStat)
      ALLOCATE ( Times4D(Num4Dt), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the Times4D array.' )
         RETURN
      END IF
   END IF
      
   IF (.NOT. ALLOCATED( Times4DIx) ) THEN
!      CALL AllocAry( Times4DIx, Num4Dt, '4D time array', ErrStat)
      ALLOCATE ( Times4DIx(Num4Dt), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the Times4DIx array.' )
         RETURN
      END IF
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Open the 4D times file
   !-------------------------------------------------------------------------------------------------
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   !-------------------------------------------------------------------------------------------------
   ! Read the 4D times file
   !-------------------------------------------------------------------------------------------------
   CALL ReadCom( UnWind, TRIM( FileName ), 'first line', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   DO I=1,Num4Dt

      READ (UnWind,*,IOSTAT=ErrStat)  Times4DIx(I), Times4D(I)

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Error reading line '//TRIM( Num2LStr( I+1 ) )// &
                        ' of the 4D-wind time-steps file, "'//TRIM( FileName )//'."')
         RETURN                        

      ENDIF
      
   ENDDO ! I

   
   !-------------------------------------------------------------------------------------------------
   ! Close the 4D times file
   !-------------------------------------------------------------------------------------------------
   
   CLOSE ( UnWind )  
   
   RETURN     
   
END SUBROUTINE Read4Dtimes
!====================================================================================================
SUBROUTINE ReadAll4DData(UnWind, ErrStat)
! This subroutine reads the data into one array to be accessed later when ADVECT=.TRUE. Since there 
! are just a few time steps, we'll load them into memory to (hopefully) save I/O time.
!----------------------------------------------------------------------------------------------------

   INTEGER, INTENT(IN)        :: UnWind
   INTEGER, INTENT(OUT)       :: ErrStat                            ! 
   INTEGER                    :: IT

   CHARACTER(1)               :: FDNum
   CHARACTER(20)              :: DNSFileName                        ! String containing part of the current file name.


   DO IT = 1,Num4Dt

      WRITE(FDNum,'(I1.1)') Times4DIx(IT)
      DNSFileName = TRIM(AdvFiles(Ind4DAdv))//'_'//TRIM(FDNum)//'.dns'

      CALL Read4DData ( UnWind, TRIM( FDSpath )//'\u\u_16i_'//TRIM(DNSFileName), FDuData, IT, ScalFact(1), Offsets(1), ErrStat )
      IF ( ErrStat /= 0 ) RETURN

      CALL Read4DData ( UnWind, TRIM( FDSpath )//'\v\v_16i_'//TRIM(DNSFileName), FDvData, IT, ScalFact(2), Offsets(2), ErrStat )
      IF ( ErrStat /= 0 ) RETURN

      CALL Read4DData ( UnWind, TRIM( FDSpath )//'\w\w_16i_'//TRIM(DNSFileName), FDwData, IT, ScalFact(3), Offsets(3), ErrStat )
      IF ( ErrStat /= 0 ) RETURN

   ENDDO ! IT

   Ind4DAdv = Ind4DAdv + 1

   RETURN

END SUBROUTINE ReadAll4DData
!====================================================================================================
SUBROUTINE LoadLESData( UnWind, FileNo, Indx, ErrStat )
! This subroutine reads binary data from the U, V, and W files and stores them in the arrays FDu,
! FDv, and FDw (by calling Read4DData).
!----------------------------------------------------------------------------------------------------
      ! Passed variables

   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,         INTENT(IN)    :: FileNo                       ! current file number to read
   INTEGER,         INTENT(IN)    :: Indx                         ! index into the data arrays
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise
   
      ! local variables
   CHARACTER(5)                   :: FDNum
   CHARACTER(20)                  :: LESFileName                  ! String containing part of the current file name.      
   
      
      ! get the file name for the file number
      
   WRITE(FDNum,'(I5.5)', IOStat=ErrStat) FileNo
   IF ( ErrStat /= 0 ) RETURN
   
   LESFileName = TRIM(FDNum)//'.les'


      ! set the paths and read the data for each component
      
   CALL Read4DData ( UnWind, TRIM( FDSpath )//'\u\u_16i_'//TRIM(LESFileName), FDu, Indx, ScalFact(1), Offsets(1), ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   CALL Read4DData ( UnWind, TRIM( FDSpath )//'\v\v_16i_'//TRIM(LESFileName), FDv, Indx, ScalFact(2), Offsets(2), ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   CALL Read4DData ( UnWind, TRIM( FDSpath )//'\w\w_16i_'//TRIM(LESFileName), FDw, Indx, ScalFact(3), Offsets(3), ErrStat )


END SUBROUTINE LoadLESData
!====================================================================================================
SUBROUTINE Read4DData ( UnWind, FileName, Comp, Indx4, Scale, Offset,  ErrStat)
! This subroutine is used to read one time-step's worth of large-eddy wind data for one component 
! from a file.
!----------------------------------------------------------------------------------------------------

      ! Passed variables
      
   INTEGER,     INTENT(IN)    :: UnWind               ! The I/O unit of the LE file.
   CHARACTER(*),INTENT(IN)    :: FileName             ! Then name of the LE data file.

   REAL(ReKi),  INTENT(INOUT) :: Comp (:,:,:,:)       ! The velocity array [do NOT make this INTENT(OUT): other parts of the array may become undefined]
   INTEGER,     INTENT(IN)    :: Indx4                ! The index of the 4th dimension of Comp, which is to be read.
   REAL(ReKi),  INTENT(IN)    :: Scale                ! The scale factor for converting from intergers to non-normalized reals.
   REAL(ReKi),  INTENT(IN)    :: Offset               ! The offset for converting from intergers to non-normalized reals.

   INTEGER,     INTENT(OUT)   :: ErrStat              ! The returned status of a READ.
      
      ! Local variables

   INTEGER                    :: IX                   ! A DO index for indexing the arrays in the x direction.
   INTEGER                    :: IXK                  ! An index for the decimated arrays in the x direction.
   INTEGER                    :: IY                   ! A DO index for indexing the arrays in the y direction.
   INTEGER                    :: IYK                  ! An index for the decimated arrays in the y direction.
   INTEGER                    :: IZ                   ! A DO index for indexing the arrays in the z direction.
   INTEGER                    :: IZK                  ! An index for the decimated arrays in the z direction.

   INTEGER(B2Ki)              :: Com (Num4Dx,Num4Dy)  ! Temporary array to hold component's integer values for a given Z.


   !-------------------------------------------------------------------------------------------------
   ! Open the binary input file
   !-------------------------------------------------------------------------------------------------
   CALL OpenUInBEFile( UnWind, TRIM( FileName ), FDRecL, ErrStat )
   IF ( ErrStat /= 0 ) RETURN


   !-------------------------------------------------------------------------------------------------
   ! Read the input file
   !-------------------------------------------------------------------------------------------------

   IZK = 0
   DO IZ=1,Num4Dz,FD_DF_Z

      READ (UnWind,REC=IZ,IOSTAT=ErrStat)  Com

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Error reading record '//TRIM( Num2LStr( IZ ) )// & 
                                            ' of the binary 4D wind file, "'//TRIM( FileName )//'".')
         RETURN

      ENDIF

      IZK = IZK + 1                                ! IZK = ( IZ - 1 + FD_DF_Z )/FD_DF_Z
      IYK = 0
      
      DO IY=1,Num4Dy,FD_DF_Y
         
         IYK = IYK + 1                             ! IYK = ( IY - 1 + FD_DF_Y )/FD_DF_Y
         
         DO IX=1,Num4Dx,FD_DF_X
         
               ! shift the x-index, if necessary, to perform Advection
               
            !IXK = ( IX + FD_DF_X - 1 )/FD_DF_X
            IXK = ( MOD(IX+Shft4Dnew-1,Num4Dx) + FD_DF_X )/FD_DF_X
         
            Comp(IXK,IYK,IZK,Indx4) = Scale*Com(IX,IY) + Offset
         
         ENDDO ! IX
         
      ENDDO ! IY

   ENDDO ! IZ


   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
   CLOSE ( UnWind )

   RETURN

END SUBROUTINE Read4DData
!====================================================================================================
SUBROUTINE Load4DData( InpIndx )
! This subroutine takes the data from the storage array (used when ADVECT=.TRUE., shifts it if necessary, 
! and loads it into the array for the time slice indexed by InpIndx.
!----------------------------------------------------------------------------------------------------

   INTEGER, INTENT(IN) :: InpIndx

   INTEGER             :: IX
   INTEGER             :: IXK


   DO IX=1,Num4Dx,FD_DF_X

         ! shift the x-index, if necessary, to perform Advection
      IXK = ( MOD(IX+Shft4Dnew-1,Num4Dx) + FD_DF_X )/FD_DF_X

      FDu(IXK,:,:,InpIndx) = FDuData(IX,:,:,FDFileNo)
      FDv(IXK,:,:,InpIndx) = FDvData(IX,:,:,FDFileNo)
      FDw(IXK,:,:,InpIndx) = FDwData(IX,:,:,FDFileNo)

   ENDDO ! IX


   RETURN

END SUBROUTINE Load4DData
!====================================================================================================
FUNCTION FD_GetValue(RVarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the RVarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------

   CHARACTER(*),   INTENT(IN)    :: RVarName
   INTEGER,        INTENT(OUT)   :: ErrStat
   REAL(ReKi)                    :: FD_GetValue

   
   CHARACTER(20)                 :: VarNameUC
   

   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FDWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = RVarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
            
      CASE ('ROTDIAM' )
         FD_GetValue = RotDiam         
         
      CASE DEFAULT
         CALL WrScr( ' Invalid variable name in FD_GetRValue().' )
         ErrStat = 1
         
   END SELECT

END FUNCTION FD_GetValue
!====================================================================================================
FUNCTION FD_GetWindSpeed(Time, InputPosition, ErrStat)
! This function is used to interpolate into the 4D wind arrays.  It receives X, Y, Z and TIME from the 
! calling routine.  The time since the start of the 4D data is used to decide which pair of time slices 
! to interpolate within and between.  After finding the two time slices, it decides which eight grid 
! points bound the (X,Y,Z) pair. It does a trilinear interpolation for each time slice. Linear 
! interpolation is then used to interpolate between time slices.  This routine assumes that X is 
! downwind, Y is to the left when looking downwind and Z is up.  It also assumes that no 
! extrapolation will be needed except in time and the Z direction.  In those cases, the appropriate
! steady winds are used.
!----------------------------------------------------------------------------------------------------

      ! Passed variables:
      
   REAL(ReKi),        INTENT(IN) :: Time                                   ! the time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)                       ! structure that contains the position
   INTEGER,           INTENT(OUT):: ErrStat                                ! returns 0 if no error; non-zero otherwise
   TYPE(InflIntrpOut)            :: FD_GetWindSpeed                        ! the resultant wind speed


      ! Local Variables:

   REAL(ReKi)                 :: Ixhyz                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Ixlyz                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Ixyzo                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Iyhz                                      ! Temporary interpolated value.
   REAL(ReKi)                 :: Iylz                                      ! Temporary interpolated value.
   REAL(ReKi)                 :: Ixyzn                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Tgrid                                     ! Fractional distance between time grids.
   REAL(ReKi)                 :: Xgrid                                     ! Fractional distance between grids in the x direction.
   REAL(ReKi)                 :: Xnorm                                     ! Nondimensional downwind distance of the analysis point from upwind end of dataset.
   REAL(ReKi)                 :: Ygrid                                     ! Fractional distance between grids in the y direction.
   REAL(ReKi)                 :: Ynorm                                     ! Nondimensional lateral distance of the analysis point from right side of dataset (looking downwind).
   REAL(ReKi)                 :: Zgrid                                     ! Fractional distance between grids in the z direction.
   REAL(ReKi)                 :: Zgrid_w                                   ! Fractional distance between grids in the z direction for the w component.
   REAL(ReKi)                 :: Znorm                                     ! Nondimensional vertical distance of the analysis point from bottom of dataset.
   REAL(ReKi)                 :: Znorm_w                                   ! Nondimensional vertical distance of the analysis point from bottom of dataset for the w component.

   INTEGER                    :: IT                                        ! Index for do loop
   INTEGER                    :: IXHI                                      ! Index for the more-positive x value.
   INTEGER                    :: IXLO                                      ! Index for the more-negative x value.
   INTEGER                    :: IYHI                                      ! Index for the more-positive y value.
   INTEGER                    :: IYLO                                      ! Index for the more-negative y value.
   INTEGER                    :: IZHI                                      ! Index for the more-positive z value.
   INTEGER                    :: IZHI_w                                    ! Index for the more-positive z value for the w component.
   INTEGER                    :: IZLO                                      ! Index for the more-negative z value.
   INTEGER                    :: IZLO_w                                    ! Index for the more-negative z value for the w component.

   !-------------------------------------------------------------------------------------------------     
   ! Check that we've initialized everything first
   !-------------------------------------------------------------------------------------------------     
     
   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FDWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE 
      ErrStat = 0   
   END IF      

   !-------------------------------------------------------------------------------------------------     
   ! If the TIME is greater than the time for the last file read, read another set of files until we straddle the current time.
   ! Stick with the last file if we've exhausted the data.
   ! We're assuming here that the simulation time step is smaller than the wind-file time step.
   !-------------------------------------------------------------------------------------------------     

   IF ( Time < PrevTime .AND. Time < FDTime(Ind4Dold) ) THEN  ! bjj: GET THE CORRECT TIME if we're going backward!
     
      !----------------------------------------------------------------------------------------------
      ! Determine the first file needed for this simulation.
      !----------------------------------------------------------------------------------------------
      Ind4Dold  = 1                                                           ! Put the old stuff in the first part of the array.
      Ind4Dnew  = 2                                                           ! Put the new stuff in the second part of the array.
      
      FDFileNo  = Num4Dt
      DO IT=1,Num4Dt
         IF ( Times4D(IT) > Time )  THEN
            FDFileNo = IT - 1
            EXIT
         END IF
      END DO ! IT
         
      !----------------------------------------------------------------------------------------------
      ! Open, read, and close the first set of files.
      !----------------------------------------------------------------------------------------------
      FDTime(Ind4Dold) = Times4D(FDFileNo)                                 ! Set the time for this file.

      IF ( ADVECT ) THEN
         CALL Load4DData(Ind4Dold)     ! load data stored in FDuData, FDvData, and FDwData arrays
      ELSE
         CALL LoadLESData( FDUnit, FDFileNo, Ind4Dold, ErrStat )
      END IF
            
      !----------------------------------------------------------------------------------------------
      ! Open, read, and close the second set of files.
      !----------------------------------------------------------------------------------------------
      FDFileNo  = MIN(FDFileNo + 1, Num4Dt)
      Shft4Dnew = 0
      
      IF ( ADVECT ) THEN
         FDFileNo = MOD(FDFileNo-1,Num4Dt) + 1

         IF (FDFileNo == 1) THEN
            Shft4Dnew = Shft4Dnew + 1

            IF (Ind4DAdv <= NumAdvect) THEN                             ! Ind4DAdv was set in ReadFDP
               IF ( MOD( Shft4Dnew, Num4Dx ) == 0 ) THEN
                  CALL ReadAll4DData(FDUnit, ErrStat)
                  IF ( ErrStat /= 0 ) RETURN
               END IF
            END IF

         ENDIF

         FDTime(Ind4Dnew) = Times4D(FDFileNo) + Shft4Dnew*FDPer         ! Set the time for this file.

         CALL Load4DData( Ind4Dnew )    ! shift the data

      ELSE   
         FDTime(Ind4Dnew) = Times4D(FDFileNo)                                           ! Set the time for this file.
!
         CALL LoadLESData( FDUnit, FDFileNo, Ind4Dnew, ErrStat )
      ENDIF
                     
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Move forward in time
   !-------------------------------------------------------------------------------------------------

   DO WHILE ( Time > FDTime(Ind4Dnew) .AND. ( Time < T_4D_En .OR. ADVECT ) )

      Ind4Dnew         = Ind4Dold                                          ! Reverse array indices (1 or 2).
      Ind4Dold         = 3 - Ind4Dnew
      FDFileNo         = FDFileNo + 1                                      ! Increment file number.


      IF ( ADVECT ) THEN
         FDFileNo = MOD(FDFileNo-1,Num4Dt) + 1

         IF (FDFileNo == 1) THEN
               Shft4Dnew = Shft4Dnew + 1

               IF (Ind4DAdv <= NumAdvect) THEN
                  IF ( MOD( Shft4Dnew, Num4Dx ) == 0 ) THEN
                     CALL ReadAll4DData(FDUnit, ErrStat)
                     IF ( ErrStat /= 0 ) RETURN
                  END IF                  
               ENDIF

         ENDIF

         FDTime(Ind4Dnew) = Times4D(FDFileNo) + Shft4Dnew*FDPer

         CALL Load4DData( Ind4Dnew )  ! shift the data
      ELSE
         FDTime(Ind4Dnew) = Times4D(FDFileNo)

         CALL LoadLESData( FDUnit, FDFileNo, Ind4Dnew, ErrStat )
      ENDIF

   ENDDO


   !.................................................................................................
   ! Find the bounding rows, columns, and planes for the X,Y,Z position.  The near, lower-right  
   ! corner is (1,1,1) when looking downwind. Make sure the lowest possible value is 1.
   !.................................................................................................


   !-------------------------------------------------------------------------------------------------
   ! get values of Time for interpolation. Linear interpolation; Nearest-neighbor extrapolation.
   !-------------------------------------------------------------------------------------------------

      ! Find out fractionally how far we are between grids in time and between grid points in each direction.
      !  Limit values to avoid extrapolation.  We need this for interpolation later on.

   Tgrid = MIN( MAX( ( Time - FDTime(Ind4Dold) )/( FDTime(Ind4Dnew) - FDTime(Ind4Dold) ), 0.0 ), 1.0 )


   !-------------------------------------------------------------------------------------------------
   ! get values of X for interpolation. Grid is periodic in X.
   !-------------------------------------------------------------------------------------------------
   Xnorm = ( Xt + InputPosition(1) )/Xmax

   DO WHILE ( Xnorm < 0.0 )   ! Ensure Xnorm is not negative.  The wave is periodic in x.
      Xnorm = Xnorm + 1.0
   ENDDO

   Xgrid = MIN( MAX( MOD( Xnorm, DelXgrid ), 0.0 ), 1.0 )
   IXLo  = MAX( MOD( INT( Xnorm*Num4DxD1 ) + 1, Num4DxD1 ), 1 )
   IXHi  = MOD( IXLo, Num4DxD ) + 1

   !-------------------------------------------------------------------------------------------------
   ! get values of Y for interpolation. Grid is periodic in Y.
   !-------------------------------------------------------------------------------------------------
   Ynorm = ( Yt + InputPosition(2) )/Ymax

   DO WHILE ( Ynorm < 0.0 )  ! Ensure Ynorm is not negative.  The wave is periodic in y.
      Ynorm = Ynorm + 1.0
   ENDDO

   Ygrid = MIN( MAX( MOD( Ynorm, DelYgrid ), 0.0 ), 1.0 )
   IYLo  = MAX( MOD( INT( Ynorm*Num4DyD1 ) + 1, Num4DyD1 ), 1 )
   IYHi  = MOD( IYLo, Num4DyD ) + 1

   !-------------------------------------------------------------------------------------------------
   ! get values of Z for interpolation.  Linear interpolation; Nearest-neighbor extrapolation.  
   !-------------------------------------------------------------------------------------------------
   Znorm = MIN( MAX( ( Zt + InputPosition(3) - ZRef )/Zmax, 0.0 ), 1.0 ) !bjj: define ZRef

   Zgrid = MIN( MAX( MOD( Znorm, DelZgrid ), 0.0 ), 1.0 )
   IZLo  = MAX( INT( Znorm*Num4DzD1 ) + 1, 1 )

      ! If we are located at the upper end of the z dimension, decrement the index by one and set the grid coordinate to 1.

   IF ( IZLo == Num4DzD )  THEN
      IZLo  = Num4DzD1
      Zgrid = 1.0
   ENDIF
   IZHi = IZLo + 1

      !..............................................................................................
      ! Find the equivalent Znorm (Znorm_w) for the w-component, which may be shifted vertically
      ! by half the original grid spacing.
      !..............................................................................................

   IF ( VertShft ) THEN
      Znorm_w = MAX( Znorm - 0.5*DelZgrid/FD_DF_Z, 0.0 )
   ELSE
      Znorm_w = Znorm
   ENDIF

   Zgrid_w = MIN( MAX( MOD( Znorm_w, DelZgrid ), 0.0 ), 1.0 )
   IZLo_w  = MAX( INT( Znorm_w*Num4DzD1 ) + 1, 1 )

   IF ( IZLo_w == Num4DzD )  THEN
      IZLo_w  = Num4DzD1
      Zgrid_w = 1.0
   ENDIF

   IZHi_w = IZLo_w + 1


   !-------------------------------------------------------------------------------------------------
   ! Interpolate for u component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

   Iylz  = ( FDu(IXLo,IYLo,IZHi,Ind4Dold) - FDu(IXLo,IYLo,IZLo,Ind4Dold) )*Zgrid + FDu(IXLo,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDu(IXLo,IYHi,IZHi,Ind4Dold) - FDu(IXLo,IYHi,IZLo,Ind4Dold) )*Zgrid + FDu(IXLo,IYHi,IZLo,Ind4Dold)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDu(IXHi,IYLo,IZHi,Ind4Dold) - FDu(IXHi,IYLo,IZLo,Ind4Dold) )*Zgrid + FDu(IXHi,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDu(IXHi,IYHi,IZHi,Ind4Dold) - FDu(IXHi,IYHi,IZLo,Ind4Dold) )*Zgrid + FDu(IXHi,IYHi,IZLo,Ind4Dold)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzo = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   Iylz  = ( FDu(IXLo,IYLo,IZHi,Ind4Dnew) - FDu(IXLo,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDu(IXLo,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDu(IXLo,IYHi,IZHi,Ind4Dnew) - FDu(IXLo,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDu(IXLo,IYHi,IZLo,Ind4Dnew)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDu(IXHi,IYLo,IZHi,Ind4Dnew) - FDu(IXHi,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDu(IXHi,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDu(IXHi,IYHi,IZHi,Ind4Dnew) - FDu(IXHi,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDu(IXHi,IYHi,IZLo,Ind4Dnew)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzn = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   FD_GetWindSpeed%Velocity(1) = ( Ixyzn - Ixyzo )*Tgrid + Ixyzo

   !-------------------------------------------------------------------------------------------------
   ! Interpolate for v component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

   Iylz  = ( FDv(IXLo,IYLo,IZHi,Ind4Dold) - FDv(IXLo,IYLo,IZLo,Ind4Dold) )*Zgrid + FDv(IXLo,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDv(IXLo,IYHi,IZHi,Ind4Dold) - FDv(IXLo,IYHi,IZLo,Ind4Dold) )*Zgrid + FDv(IXLo,IYHi,IZLo,Ind4Dold)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDv(IXHi,IYLo,IZHi,Ind4Dold) - FDv(IXHi,IYLo,IZLo,Ind4Dold) )*Zgrid + FDv(IXHi,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDv(IXHi,IYHi,IZHi,Ind4Dold) - FDv(IXHi,IYHi,IZLo,Ind4Dold) )*Zgrid + FDv(IXHi,IYHi,IZLo,Ind4Dold)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzo = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   Iylz  = ( FDv(IXLo,IYLo,IZHi,Ind4Dnew) - FDv(IXLo,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDv(IXLo,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDv(IXLo,IYHi,IZHi,Ind4Dnew) - FDv(IXLo,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDv(IXLo,IYHi,IZLo,Ind4Dnew)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDv(IXHi,IYLo,IZHi,Ind4Dnew) - FDv(IXHi,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDv(IXHi,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDv(IXHi,IYHi,IZHi,Ind4Dnew) - FDv(IXHi,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDv(IXHi,IYHi,IZLo,Ind4Dnew)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzn = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   FD_GetWindSpeed%Velocity(2) = ( Ixyzn - Ixyzo )*Tgrid + Ixyzo

   !-------------------------------------------------------------------------------------------------
   ! Interpolate for w component of wind within the grid.
   !-------------------------------------------------------------------------------------------------
   !bjj: should Zgrid actually be Zgrid_w here?  I changed it so that it's consistent
   
   Iylz  = ( FDw(IXLo,IYLo,IZHi_w,Ind4Dold) - FDw(IXLo,IYLo,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXLo,IYLo,IZLo_w,Ind4Dold)
   Iyhz  = ( FDw(IXLo,IYHi,IZHi_w,Ind4Dold) - FDw(IXLo,IYHi,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXLo,IYHi,IZLo_w,Ind4Dold)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDw(IXHi,IYLo,IZHi_w,Ind4Dold) - FDw(IXHi,IYLo,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXHi,IYLo,IZLo_w,Ind4Dold)
   Iyhz  = ( FDw(IXHi,IYHi,IZHi_w,Ind4Dold) - FDw(IXHi,IYHi,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXHi,IYHi,IZLo_w,Ind4Dold)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzo = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   Iylz  = ( FDw(IXLo,IYLo,IZHi_w,Ind4Dnew) - FDw(IXLo,IYLo,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXLo,IYLo,IZLo_w,Ind4Dnew)
   Iyhz  = ( FDw(IXLo,IYHi,IZHi_w,Ind4Dnew) - FDw(IXLo,IYHi,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXLo,IYHi,IZLo_w,Ind4Dnew)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDw(IXHi,IYLo,IZHi_w,Ind4Dnew) - FDw(IXHi,IYLo,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXHi,IYLo,IZLo_w,Ind4Dnew)
   Iyhz  = ( FDw(IXHi,IYHi,IZHi_w,Ind4Dnew) - FDw(IXHi,IYHi,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXHi,IYHi,IZLo_w,Ind4Dnew)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzn = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   FD_GetWindSpeed%Velocity(3) = ( Ixyzn - Ixyzo )*Tgrid + Ixyzo


   !-------------------------------------------------------------------------------------------------
   ! Set the previous time here to compare with later...
   !-------------------------------------------------------------------------------------------------
   PrevTime = Time

   RETURN
   
END FUNCTION FD_GetWindSpeed
!====================================================================================================
SUBROUTINE FD_Terminate( ErrStat )
! This subroutine deallocates arrays, closes files, and un-sets the initialization flag.
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise


   CLOSE( FDunit )

   ErrStat = 0

   IF ( ALLOCATED( FDu       ) )   DEALLOCATE( FDu,       STAT=ErrStat )
   IF ( ALLOCATED( FDv       ) )   DEALLOCATE( FDv,       STAT=ErrStat )
   IF ( ALLOCATED( FDw       ) )   DEALLOCATE( FDw,       STAT=ErrStat )
   IF ( ALLOCATED( FDuData   ) )   DEALLOCATE( FDuData,   STAT=ErrStat )  
   IF ( ALLOCATED( FDvData   ) )   DEALLOCATE( FDvData,   STAT=ErrStat )
   IF ( ALLOCATED( FDwData   ) )   DEALLOCATE( FDwData,   STAT=ErrStat )
   IF ( ALLOCATED( Times4D   ) )   DEALLOCATE( Times4D,   STAT=ErrStat )
   IF ( ALLOCATED( Times4DIx ) )   DEALLOCATE( Times4DIx, STAT=ErrStat )
   IF ( ALLOCATED( AdvFiles  ) )   DEALLOCATE( AdvFiles,  STAT=ErrStat )

   Initialized = .FALSE.

END SUBROUTINE FD_Terminate
!====================================================================================================
END MODULE FDWind
MODULE FFWind
!
!  This module uses full-field binary wind files to determine the wind inflow.
!  This module assumes that the origin, (0,0,0), is located at the tower centerline at ground level,
!  and that all units are specified in the metric system (using meters and seconds).
!  Data is shifted by half the grid width to account for turbine yaw (so that data in the X 
!  direction actually starts at -1*FFYHWid meters).
!
!  Created 25-Sept-2009 by B. Jonkman, National Renewable Energy Laboratory
!     using subroutines and modules from AeroDyn v12.58
!
!----------------------------------------------------------------------------------------------------

   USE      NWTC_Library
   USE      SharedInflowDefns

   IMPLICIT NONE

   PRIVATE                                                        ! By default, everything in FFWind is private (methods, data, types, etc.)
   
      ! former FF_Wind module
      
   REAL(ReKi), ALLOCATABLE          :: FFData  (:,:,:,:)          ! Array of FF data
   REAL(ReKi), ALLOCATABLE          :: FFtower (:,:,:)            ! Array of data along the tower, below the FF array

   REAL(ReKi)                       :: FFDTime                    ! delta time
   REAL(ReKi)                       :: FFRate                     ! data rate in Hz (1/FFDTime)
   REAL(ReKi)                       :: FFYHWid                    ! half the grid width
   REAL(ReKi)                       :: FFZHWid                    ! half the grid height
   REAL(ReKi)                       :: RefHt                      ! the reference (hub) height of the grid in meters 
   REAL(ReKi)                       :: GridBase                   ! the height of the bottom of the grid in meters
   REAL(ReKi)                       :: InitXPosition              ! the initial x location of the wind file (distance the FF file will be offset)
   REAL(ReKi)                       :: InvFFYD                    ! reciprocal of delta y
   REAL(ReKi)                       :: InvFFZD                    ! reciprocal of delta z
   REAL(ReKi)                       :: InvMFFWS                   ! reciprocal of the mean wind speed (MeanFFWS)
   REAL(ReKi)                       :: MeanFFWS                   ! the mean wind speed (as defined in the FF file), not necessarially the mean of the portion of the wind used
   REAL(ReKi)                       :: TotalTime                  ! the total time in the simulation

   INTEGER                          :: NFFComp                    ! number of wind components
   INTEGER                          :: NFFSteps                   ! number of time steps in the FF array
   INTEGER                          :: NYGrids                    ! number of points in the lateral (y) direction of the grids
   INTEGER                          :: NZGrids                    ! number of points in the vertical (z) direction of the grids
   INTEGER                          :: NTGrids                    ! number of points in the vertical (z) direction on the tower (below the grids)
         
   LOGICAL, SAVE                    :: Initialized = .FALSE.      ! flag that determines if the module has been initialized
   LOGICAL                          :: Periodic    = .FALSE.      ! flag that determines if the wind is periodic


   INTERFACE FF_GetValue
      MODULE PROCEDURE FF_GetRValue                               ! routine to return scalar real values 
   END INTERFACE


   PUBLIC                           :: FF_Init                    ! initialization subroutine to read the FF grids
   PUBLIC                           :: FF_GetWindSpeed            ! interpolation function that returns velocities at specified time and space
   PUBLIC                           :: FF_GetValue                ! interface to return requested values
   PUBLIC                           :: FF_Terminate               ! subroutine that deallocates memory stored in the FFWind module

CONTAINS
!====================================================================================================
SUBROUTINE FF_Init ( UnWind, BinFile, ErrStat )
!  This routine is used read the full-field turbulence data.
!  09/25/97 - Created by M. Buhl from GETFILES in ViewWind.
!  09/23/09 - modified by B. Jonkman: this subroutine was split into several subroutines (was ReadFF)
!----------------------------------------------------------------------------------------------------

   IMPLICIT                       NONE


      ! Passed Variables:
      
   INTEGER,      INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered
   
   CHARACTER(*), INTENT(IN)    :: BinFile                      ! Name of the binary FF wind file

      ! Local Variables:

   REAL(ReKi)                  :: TI      (3)                  ! turbulence intensities of the wind components as defined in the FF file, not necessarially the actual TI
   REAL(ReKi)                  :: BinTI   (3)                  ! turbulence intensities of the wind components as defined in the FF binary file, not necessarially the actual TI
   REAL(ReKi)                  :: UBar
   REAL(ReKi)                  :: ZCenter
   
   INTEGER(B2Ki)               :: Dum_Int2
   INTEGER                     :: DumInt
   INTEGER                     :: I
   LOGICAL                     :: CWise
   LOGICAL                     :: Exists
   CHARACTER( 1028 )           :: SumFile                      ! length is LEN(BinFile) + the 4-character extension.
   CHARACTER( 1028 )           :: TwrFile                      ! length is LEN(BinFile) + the 4-character extension.


      !----------------------------------------------------------------------------------------------
      ! Check that the module hasn't already been initialized.
      !----------------------------------------------------------------------------------------------   
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' FFWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF   


      !----------------------------------------------------------------------------------------------
      ! Open the binary file, read its "header" (first 2-byte integer) to determine what format
      ! binary file it is, and close it.
      !----------------------------------------------------------------------------------------------

   CALL OpenBInpFile (UnWind, TRIM(BinFile), ErrStat)
   IF (ErrStat /= 0) RETURN
      
   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2
   CLOSE( UnWind )
   
   IF (ErrStat /= 0) THEN
      CALL WrScr( ' Error reading first binary integer from file "'//TRIM(BinFile)//'."' )
      RETURN
   END IF
   
      !----------------------------------------------------------------------------------------------
      ! Read the files to get the required FF data.
      !----------------------------------------------------------------------------------------------   
   DumInt = Dum_Int2  ! change to default INTEGER, instead of INT(2) to compare in SELECT below
    
   SELECT CASE (DumInt)  
   
      CASE ( 7, 8 )                                                    ! TurbSim binary format
         
         CALL Read_TurbSim_FF(UnWind, TRIM(BinFile), ErrStat)
         
      CASE ( -1, -2, -3, -99 )                                         ! Bladed-style binary format
      
         !...........................................................................................
         ! Create full-field summary file name from binary file root name.  Also get tower file
         ! name.
         !...........................................................................................

            CALL GetRoot(BinFile, SumFile)
            
            TwrFile = TRIM(SumFile)//'.twr'
            SumFile = TRIM(SumFile)//'.sum'
      
         !...........................................................................................
         ! Read the summary file to get necessary scaling information
         !...........................................................................................
   
            CALL Read_Summary_FF (UnWind, TRIM(SumFile), CWise, ZCenter, TI, ErrStat ) 
            IF (ErrStat /= 0) RETURN
            
            UBar = MeanFFWS      ! temporary storage .... this is our only check to see if the summary and binary files "match"

         !...........................................................................................
         ! Open the binary file and read its header
         !...........................................................................................
         
            CALL OpenBInpFile (UnWind, TRIM(BinFile), ErrStat)

            IF (ErrStat /= 0) RETURN

            IF ( Dum_Int2 == -99 ) THEN                                       ! Newer-style BLADED format
               CALL Read_Bladed_FF_Header1 (UnWind, BinTI, ErrStat)    
               
                  ! If the TIs are also in the binary file (BinTI > 0), 
                  ! use those numbers instead of ones from the summary file
                  
               DO I =1,NFFComp                  
                  IF ( BinTI(I) > 0 ) TI(I) = BinTI(I)
               END DO
               
            ELSE
               CALL Read_Bladed_FF_Header0 (UnWind, ErrStat)                  ! Older-style BLADED format
            END IF

            IF (ErrStat /= 0) RETURN

         !...........................................................................................
         ! Let's see if the summary and binary FF wind files go together before continuing.
         !...........................................................................................
               
            IF ( ABS( UBar - MeanFFWS ) > 0.1 )  THEN
               CALL WrScr( ' Error: Incompatible mean hub-height wind speeds in FF wind files. '//&
                           '(Check that the .sum and .wnd files were generated together.)' )
               ErrStat = 1
               RETURN
            ENDIF

         !...........................................................................................
         ! Calculate the height of the bottom of the grid
         !...........................................................................................

            GridBase = ZCenter - FFZHWid         ! the location, in meters, of the bottom of the grid

         !...........................................................................................
         ! Read the binary grids (converted to m/s) and close the file
         !...........................................................................................

            CALL Read_Bladed_Grids( UnWind, CWise, TI, ErrStat) 
            CLOSE ( UnWind )
                           
            IF ( ErrStat /= 0 ) RETURN
   
         !...........................................................................................
         ! Read the tower points file
         !...........................................................................................
   
            INQUIRE ( FILE=TRIM(TwrFile) , EXIST=Exists )

            IF (  Exists )  THEN  
               CALL Read_FF_Tower( UnWind, TRIM(TwrFile), ErrStat  )
            ELSE
               NTgrids = 0            
            END IF                        

                               
      CASE DEFAULT
         
         CALL WrScr( ' Error: Unrecognized binary wind file type.' )
         ErrStat = 1
         RETURN
                  
   END SELECT


   IF (Periodic) THEN
      InitXPosition = 0                ! start at the hub
      TotalTime     = NFFSteps*FFDTime
   ELSE
      InitXPosition = FFYHWid          ! start half the grid with ahead of the turbine
      TotalTime     = (NFFSteps-1)*FFDTime      
   END IF
      
   Initialized = .TRUE.
   
   RETURN
   
END SUBROUTINE FF_Init
!====================================================================================================
SUBROUTINE Read_Bladed_FF_Header0 (UnWind, ErrStat)
!   Reads the binary headers from the turbulence files of the old Bladed variety.  Note that
!   because of the normalization, neither NZGrids or NYGrids are larger than 32 points.
!   21-Sep-2009 - B. Jonkman, NREL/NWTC.
!----------------------------------------------------------------------------------------------------


   IMPLICIT                      NONE


      ! Passed Variables:
      
   INTEGER,   INTENT(IN)      :: UnWind
   INTEGER,   INTENT(OUT)     :: ErrStat

      ! Local Variables:

   REAL(ReKi)                 :: FFXDelt
   REAL(ReKi)                 :: FFYDelt
   REAL(ReKi)                 :: FFZDelt

   INTEGER(B2Ki)              :: Dum_Int2

   INTEGER                    :: I

   !-------------------------------------------------------------------------------------------------
   ! Read the header (file has just been opened)
   !-------------------------------------------------------------------------------------------------

   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! -NFFC (file ID)

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading number of wind components from binary FF file.' )
         RETURN
      END IF
      NFFComp = -1*Dum_Int2
         

   READ (UnWind, IOSTAT=ErrStat) Dum_Int2                                                    ! delta z (mm)
    
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dz from binary FF file.' )
         RETURN
      END IF
      FFZDelt = 0.001*Dum_Int2
      InvFFZD = 1.0/FFZDelt


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! delta y (mm)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dy from binary FF file.' )
         RETURN
      END IF
      FFYDelt = 0.001*Dum_Int2
      InvFFYD = 1.0/FFYDelt


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! delta x (mm)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dx from binary FF file.' )
         RETURN
      END IF
      FFXDelt = 0.001*Dum_Int2


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! half the number of time steps
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading number of time steps from binary FF file.' )
         RETURN
      END IF
      NFFSteps = 2*Dum_Int2


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! 10 times the mean full-field wind speed
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading mean full-field wind speed from binary FF file.' )
         RETURN
      END IF
      MeanFFWS = 0.1*Dum_Int2
      InvMFFWS = 1.0/MeanFFWS
      FFDTime  = FFXDelt/MeanFFWS
      FFRate   = 1.0/FFDTime

      
   DO I = 1,5   
   
      READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                ! unused variables: zLu, yLu, xLu, dummy, random seed

         IF (ErrStat /= 0) THEN
            CALL WrScr( ' Error reading 2-byte integers from binary FF file.' )
            RETURN
         END IF
         
   END DO


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! 1000*nz

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading nz from binary FF file.' )
         RETURN
      END IF
      NZGrids  = Dum_Int2/1000
      FFZHWid  = 0.5*FFZDelt*( NZGrids - 1 )    ! half the vertical size of the grid


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! 1000*ny
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading ny from binary FF file.' )
         RETURN
      END IF   
      NYGrids  = Dum_Int2/1000
      FFYHWid  = 0.5*FFYDelt*( NYGrids - 1 )


   IF (NFFComp == 3) THEN
   
      DO I=1,6
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                             ! unused variables: zLv, yLv, xLv, zLw, yLw, xLw
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 2-byte length scales from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I
      
   END IF !NFFComp


   RETURN
   
END SUBROUTINE Read_Bladed_FF_Header0
!====================================================================================================
SUBROUTINE Read_Bladed_FF_Header1 (UnWind, TI, ErrStat)
!   Reads the binary headers from the turbulence files of the new Bladed variety.
!   16-May-2002 - Windward Engineering.
!   21-Sep-2009 - B. Jonkman, NREL.  updated to trap errors and add extra parameters for MANN model
!----------------------------------------------------------------------------------------------------


   IMPLICIT                      NONE


      ! Passed Variables:
      
   INTEGER,   INTENT(IN)      :: UnWind
   REAL(ReKi), INTENT(OUT)    :: TI(3)
   INTEGER,   INTENT(OUT)     :: ErrStat

      ! Local Variables:

   REAL(ReKi)                 :: FFXDelt
   REAL(ReKi)                 :: FFYDelt
   REAL(ReKi)                 :: FFZDelt

   REAL(SiKi)                 :: Dum_Real4
   INTEGER(B2Ki)              :: Dum_Int2
   INTEGER(B4Ki)              :: Dum_Int4

   INTEGER                    :: I
   INTEGER                    :: TurbType


   TI(:) = -1                                                                                !Initialize to -1 (not all models contain TI)

   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! -99 (file ID)

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading integer from binary FF file.' )
         RETURN
      END IF

   
   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! turbulence type

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading turbulence type from binary FF file.' )
         RETURN
      END IF
      TurbType = Dum_Int2


   SELECT CASE (TurbType)
      CASE(1, 2) 
         !----------------------------------------
         !1-component Von Karman (1) or Kaimal (2)
         !----------------------------------------
            NFFComp = 1
                  
      CASE(3, 5) 
         !----------------------------------------
         !3-component Von Karman (3) or IEC-2 
         ! Kaimal (5)
         !----------------------------------------
            NFFComp = 3
         
      CASE(4) 
         !----------------------------------------
         !improved Von Karman
         !----------------------------------------
      
            READ (UnWind, IOSTAT=ErrStat) Dum_Int4                                           ! number of components (should be 3)
            
               IF (ErrStat /= 0) THEN           
                  CALL WrScr( ' Error reading number of components from binary FF file.' )
                  RETURN
               END IF
               NFFComp = Dum_Int4
            
            READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                          ! Latitude (deg)
            
               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading latitude from binary FF file.' )  
                  RETURN
               END IF

            READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                          ! Roughness length (m)

               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading roughness length from binary FF file.' )
                  RETURN
               END IF
            
            READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                          ! Reference height (m) = Z(1) + GridHeight / 2.0

               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading reference height from binary FF file.' )
                  RETURN
               END IF
            
            
            DO I = 1,3
               READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                       ! TI(u, v, w) (%)
               
                  IF (ErrStat /= 0) THEN
                     CALL WrScr( ' Error reading TI('//'TRIM(Num2LStr(I))'//') from binary FF file.' )
                     RETURN
                  END IF
                  TI(I) = Dum_Real4                                                          ! This overwrites the TI read in the summary file
                  
            END DO !I            
                             
                  
      CASE (7, 8)
         !----------------------------------------
         ! General Kaimal (7) or  Mann model (8)
         !----------------------------------------
      
            READ (UnWind, IOSTAT=ErrStat) Dum_Int4                                           ! number of bytes in header
            
               IF (ErrStat /= 0) THEN           
                  CALL WrScr( ' Error reading number of header records from binary FF file.' )
                  RETURN
               END IF

            READ (UnWind, IOSTAT=ErrStat) Dum_Int4                                           ! number of components
            
               IF (ErrStat /= 0) THEN           
                  CALL WrScr( ' Error reading number of data from binary FF file.' )
                  RETURN
               END IF
               NFFComp = Dum_Int4

                                  
      CASE DEFAULT
      
         CALL ProgWarn( ' AeroDyn does not recognize the full-field turbulence file type ='//TRIM(Num2LStr(TurbType))//'.' )
                  
   END SELECT !TurbType


   READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                                   ! delta z (m)
    
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dz from binary FF file.' )
         RETURN
      END IF
      FFZDelt = Dum_Real4
      InvFFZD = 1.0/FFZDelt


   READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                                  ! delta y (m)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dy from binary FF file.' )
         RETURN
      END IF
      FFYDelt = Dum_Real4
      InvFFYD = 1.0/FFYDelt

   READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                                  ! delta x (m)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dx from binary FF file.' )
         RETURN
      END IF
      FFXDelt = Dum_Real4


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                   ! half the number of time steps
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading number of time steps from binary FF file.' )
         RETURN
      END IF
      NFFSteps = 2*Dum_Int4


   READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                                  ! mean full-field wind speed
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading mean full-field wind speed from binary FF file.' )
         RETURN
      END IF
      MeanFFWS = Dum_Real4
      InvMFFWS = 1.0/MeanFFWS
      FFDTime  = FFXDelt/MeanFFWS
      FFRate   = 1.0/FFDTime

      
   DO I = 1,3   
   
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                               ! unused variables: zLu, yLu, xLu

         IF (ErrStat /= 0) THEN
            CALL WrScr( ' Error reading 4-byte length scales from binary FF file.' )
            RETURN
         END IF
         
   END DO
   
   
   DO I = 1,2
   
      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                ! unused variables: dummy, random seed
      
         IF (ErrStat /= 0) THEN
            CALL WrScr( ' Error reading 4-byte integers from binary FF file.' )
            RETURN
         END IF
         
   END DO


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                   ! nz

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading nz from binary FF file.' )
         RETURN
      END IF
      NZGrids  = Dum_Int4
      FFZHWid  = 0.5*FFZDelt*( NZGrids - 1 )    ! half the vertical size of the grid


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                   ! ny
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading ny from binary FF file.' )
         RETURN
      END IF   
      NYGrids  = Dum_Int4
      FFYHWid  = 0.5*FFYDelt*( NYGrids - 1 )


   IF (NFFComp == 3) THEN
   
      DO I=1,6
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables: zLv, yLv, xLv, zLw, yLw, xLw
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte length scales from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I
      
   END IF !NFFComp



   IF ( TurbType == 7 ) THEN     ! General Kaimal model
   
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variable: coherence decay constant
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading coherence decay constant from binary FF file.' )
               RETURN
            END IF

         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables: coherence scale parameter in m
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading coherence scale parameter from binary FF file.' )
               RETURN
            END IF
         
   ELSE IF ( TurbType == 8 ) THEN     ! Mann model
      
      DO I=1,2
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables: shear parameter (gamma), scale length
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,4
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,3
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,2
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,3
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,2
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I


   END IF !TurbType


   RETURN
   
END SUBROUTINE Read_Bladed_FF_Header1
!====================================================================================================
SUBROUTINE Read_Bladed_Grids ( UnWind, CWise, TI, ErrStat )
! This subroutine continues reading UnWind, starting after the headers have been read.
! It reads the grids and converts the data to un-normalized wind speeds in m/s.
!----------------------------------------------------------------------------------------------------

   INTEGER,     INTENT(IN)    :: UnWind
   LOGICAL,     INTENT(IN)    :: CWise
   REAL(ReKi),  INTENT(IN)    :: TI      (3)                  ! turbulence intensities of the wind components as defined in the FF file, not necessarially the actual TI
   INTEGER,     INTENT(OUT)   :: ErrStat

   REAL(ReKi), PARAMETER      :: FF_Offset(3) = (/ 1.0, 0.0, 0.0 /)  ! used for "un-normalizing" the data

   INTEGER                    :: CFirst
   INTEGER                    :: CLast
   INTEGER                    :: CStep
   INTEGER(B2Ki)              :: Dum_Int2
   INTEGER                    :: I
   INTEGER                    :: IC
   INTEGER                    :: IR
   INTEGER                    :: IT
   
   INTEGER                    :: TmpNumSteps


   !-------------------------------------------------------------------------------------------------
   ! Generate an informative message.
   !-------------------------------------------------------------------------------------------------
      
   CALL WrScr1( ' Reading a '//TRIM( Num2LStr(NYGrids) )//'x'//TRIM( Num2LStr(NZGrids) )//  &
            ' grid ('//TRIM( Num2LStr(FFYHWid*2) )//' m wide, '// &
            TRIM( Num2LStr(GridBase) )//' m to '//TRIM( Num2LStr(GridBase+FFZHWid*2) )//&
            ' m above ground) with a characterstic wind speed of '//TRIM( Num2LStr(MeanFFWS) )//' m/s. ' )

   !-------------------------------------------------------------------------------------------------
   ! Allocate space for the FF array 
   !-------------------------------------------------------------------------------------------------

   TmpNumSteps = NFFSteps + 1       ! add another step, just in case there is an odd number of steps.

!bjj: should we reorganize this FFData array so we access the data faster?
   
   IF ( .NOT. ALLOCATED( FFData ) ) THEN
      ALLOCATE ( FFData(NZGrids,NYGrids,NFFComp,TmpNumSteps),STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Cannot allocate the full-field wind data array.' )
         RETURN

      ENDIF
      
   ELSE
      IF (SIZE(FFDATA,1) /= NZGrids .OR. SIZE(FFDATA,2) /= NYGrids .OR. &
          SIZE(FFDATA,3) /= NFFComp .OR. SIZE(FFDATA,3) /= TmpNumSteps ) THEN
          
            ! Let's make the array the correct size (we should never get here, but you never know)
            
         DEALLOCATE( FFData )
          
         ALLOCATE ( FFData(NZGrids,NYGrids,NFFComp,TmpNumSteps),STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN

            CALL WrScr( ' Cannot allocate the full-field wind data array.' )
            RETURN

         END IF ! Error
          
      END IF !Incorrect size
   END IF ! allocated

   !-------------------------------------------------------------------------------------------------
   ! Initialize the data and set column indexing to account for direction of turbine rotation (CWise)
   !-------------------------------------------------------------------------------------------------
   
   FFData(:,:,:,:) = 0.0                        ! we may have only one component
   
   IF ( CWise )  THEN
      CFirst    = NYGrids
      CLast     = 1
      CStep     = -1
   ELSE
      CFirst    = 1
      CLast     = NYGrids
      CStep     = 1
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Loop through all the time steps, reading the data and converting to m/s
   !-------------------------------------------------------------------------------------------------
!bjj: should we reorganize this FFData array so we access the data faster?
  
   NFFSteps = TmpNumSteps
  
TIME_LOOP:  DO IT=1,TmpNumSteps     ! time (add 1 to see if there is an odd number of grids)
   
      DO IR=1,NZGrids               ! the rows (vertical)
      
         DO IC=CFirst,CLast,CStep   ! the columns (lateral)
         
            DO I=1,NFFComp          ! wind components (U, V, W)
            
               READ (UnWind,IOStat=ErrStat)  Dum_Int2
               IF (ErrStat /= 0) THEN
                  IF ( IT == TmpNumSteps ) THEN ! There really were an even number of steps
                     NFFSteps = TmpNumSteps - 1
                     ErrStat  = 0
                     EXIT TIME_LOOP       
                  ELSE               
                     CALL WrScr( ' Error reading binary data file. ic = '//TRIM(Num2LStr(ic))// &
                                    ', ir = '//TRIM(Num2LStr(ir))//', it = '//TRIM(Num2LStr(it))// &
                                    ', nffsteps = '//TRIM(Num2LStr(nffsteps)) )
                     ErrStat = 1
                     RETURN
                  END IF
               ELSE               
                  FFData(IR,IC,I,IT) = MeanFFWS*(FF_Offset(I)+0.00001*TI(I)*Dum_Int2) 
               END IF
               
            END DO !I

         END DO !IC

      END DO !IR

   END DO TIME_LOOP !IT
   
   IF ( Periodic ) THEN
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data (period of '//TRIM( Num2LStr( FFDTime*NFFSteps ) )//' seconds).' )
   ELSE                     
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data ('//TRIM( Num2LStr( FFDTime*( NFFSteps - 1 ) ) )//' seconds).' )
   END IF

END SUBROUTINE Read_Bladed_Grids
!====================================================================================================
SUBROUTINE Read_Summary_FF ( UnWind, FileName, CWise, ZCenter, TI, ErrStat )
! This subroutine reads the text summary file to get normalizing parameters, the location of the
! grid, and the direction the grid was written to the binary file
!----------------------------------------------------------------------------------------------------

   INTEGER,     INTENT(IN)    :: UnWind         ! unit number for the file to open
   CHARACTER(*),INTENT(IN)    :: FileName       ! name of the summary file
   LOGICAL,     INTENT(OUT)   :: CWise          ! rotation (for reading the order of the binary data)
   REAL(ReKi),  INTENT(OUT)   :: ZCenter        ! the height at the center of the grid
   REAL(ReKi),  INTENT(OUT)   :: TI      (3)    ! turbulence intensities of the wind components as defined in the FF file, not necessarially the actual TI
   INTEGER,     INTENT(OUT)   :: ErrStat        ! returns 0 if no error encountered in the subroutine
   
   REAL(ReKi)                 :: ZGOffset       ! The vertical offset of the turbine on rectangular grid (allows turbulence not centered on turbine hub)

   
   INTEGER, PARAMETER         :: NumStrings = 6 ! number of strings to be looking for in the file

   INTEGER                    :: FirstIndx      ! The first character of a line where data is located
   INTEGER                    :: I              ! A loop counter
   INTEGER                    :: LastIndx       ! The last  character of a line where data is located
   INTEGER                    :: LineCount      ! Number of lines that have been read in the file
   INTEGER                    :: Status         ! Status from I/O calls
   
   LOGICAL                    :: StrNeeded(NumStrings)   ! if the string has been found
   
   CHARACTER(1024)            :: LINE           ! temporary storage for reading a line from the file
   
      !----------------------------------------------------------------------------------------------
      ! Initialize some variables
      !----------------------------------------------------------------------------------------------

   ErrStat      = 0
   LineCount    = 0
   StrNeeded(:) = .TRUE.
   ZGOffset     = 0.0
   RefHt        = 0.0
   Periodic     = .FALSE.
   
      !----------------------------------------------------------------------------------------------
      ! Open summary file.
      !----------------------------------------------------------------------------------------------
      
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat) 


      !----------------------------------------------------------------------------------------------
      ! Read the summary file.
      !----------------------------------------------------------------------------------------------

   DO WHILE ( ( ErrStat == 0 ) .AND. StrNeeded(NumStrings) )

      LineCount = LineCount + 1

      READ ( UnWind, '(A)', IOSTAT=ErrStat ) LINE
      IF ( ErrStat /= 0 ) THEN
      
         IF ( StrNeeded(NumStrings-1) ) THEN  ! the "HEIGHT OFFSET" StrNeeded(NumStrings) parameter is not necessary.  We'll assume it's zero if we didn't find it.
            CALL WrScr( ' Error reading line #'//TRIM(Num2LStr(LineCount))//' of the summary file, "'//TRIM(FileName)//'"' )
            CALL WrScr( 'Could not find all of the required parameters.' )
            ErrStat = NumStrings+1
            RETURN
         ELSE           
            EXIT
         ENDIF
         
      END IF
      
      CALL Conv2UC ( LINE )
            

      IF ( StrNeeded(1) ) THEN
      
         !-------------------------------------------------------------------------------------------
         ! #1: Get the rotation direction, using the string "CLOCKWISE" 
         !-------------------------------------------------------------------------------------------
            
         IF ( INDEX( LINE, 'CLOCKWISE' ) > 0 ) THEN
            
            READ (LINE, *, IOSTAT = Status)  CWise          ! Look for True/False values

            IF ( Status /= 0 ) THEN                         ! Look for Yes/No values instead

               LINE = ADJUSTL ( LINE )                      ! Remove leading spaces from input line

               SELECT CASE (LINE(1:1) )
                  CASE ('Y')
                     CWise = .TRUE.
                  CASE ('N')
                     CWise = .FALSE.
                  CASE DEFAULT                  
                     CALL WrScr( ' Error reading rotation direction (CLOCKWISE) from FF summary file.' )
                     ErrStat = 1
                     RETURN
               END SELECT
               
            END IF ! Status /= 0
            StrNeeded(1) = .FALSE.
            
         END IF   ! INDEX for "CLOCKWISE"
         
      ELSEIF ( StrNeeded(2) ) THEN
      
         !-------------------------------------------------------------------------------------------
         ! #2: Get the hub height, using the strings "HUB HEIGHT" or "ZHUB"
         !-------------------------------------------------------------------------------------------

         IF ( INDEX( LINE, 'HUB HEIGHT' ) > 0 .OR. INDEX( LINE, 'ZHUB' ) > 0 ) THEN
         
            READ (LINE, *, IOSTAT = Status) RefHt
         
            IF ( Status /= 0 ) THEN
               CALL WrScr( ' Error reading hub height from FF summary file.' )
               ErrStat = 2
               RETURN
            END IF ! Status /= 0
            StrNeeded(2) = .FALSE.
                  
         END IF !INDEX for "HUB HEIGHT" or "ZHUB"
         
         
!      ELSEIF ( StrNeeded(3) ) THEN
!
!         !-------------------------------------------------------------------------------------------
!         ! #3: Get the grid width (& height, if available), using the strings "GRID WIDTH" or "RDIAM"
!         !    If GRID HEIGHT is specified, use it, too. -- THIS IS UNNECESSARY AS IT'S STORED IN THE BINARY FILE
!         !-------------------------------------------------------------------------------------------         

      ELSEIF ( StrNeeded(4) ) THEN
      
         !-------------------------------------------------------------------------------------------
         ! #4: Get the mean wind speed "UBAR" and turbulence intensities from following lines for 
         !     scaling Bladed-style FF binary files
         !-------------------------------------------------------------------------------------------         

         IF ( INDEX( LINE, 'UBAR') > 0 ) THEN

            FirstIndx = INDEX( LINE, '=' ) + 1        ! Look for the equal siqn to find the number we're looking for

            READ ( LINE( FirstIndx:LEN(LINE) ), *, IOSTAT=Status ) MeanFFWS

            IF ( Status /= 0 ) THEN
               CALL WrScr( ' Error reading UBar binary data normalizing parameter from FF summary file.' )
               ErrStat = 4
               RETURN
            END IF ! Status /= 0      

            DO I = 1,3

               LineCount = LineCount + 1

               READ ( UnWind, '(A)', IOSTAT=Status ) LINE
               IF ( Status /= 0 ) THEN
                  CALL WrScr( ' Error reading line #'//TRIM(Num2LStr(LineCount))//' of the summary file, "'//TRIM(FileName)//'"' )
                  CALL WrScr( 'Could not find all of the required parameters.' )
                  ErrStat = Status
                  RETURN
               END IF

               FirstIndx = INDEX( LINE, '=' ) + 1     ! Read the number between the = and % signs
               LastIndx  = INDEX( LINE, '%' ) - 1

               IF ( LastIndx <= FirstIndx ) LastIndx = LEN( LINE )   ! If there's no % sign, read to the end of the line

               READ ( LINE( FirstIndx:LastIndx ), *, IOSTAT=Status ) TI(I)
               IF ( Status /= 0 ) THEN
                  CALL WrScr( ' Error reading TI('//TRIM(Num2LStr(I))//') binary data normalizing parameter from FF summary file.' )
                  ErrStat = 4
                  RETURN
               END IF ! Status /= 0      

            END DO !I

            StrNeeded(4) = .FALSE.            

          END IF
      
      ELSEIF ( StrNeeded(5) ) THEN
         
         !-------------------------------------------------------------------------------------------
         ! #5: Get the grid "HEIGHT OFFSET", if it exists (in TurbSim). Otherwise, assume it's zero 
         !           ZGOffset = HH - GridBase - FFZHWid
         !-------------------------------------------------------------------------------------------         
         IF ( INDEX( LINE, 'HEIGHT OFFSET' ) > 0  ) THEN
         
            FirstIndx = INDEX ( LINE, '=' ) + 1

            READ ( LINE( FirstIndx:LEN(LINE) ), *, IOSTAT=Status ) ZGOffset            
                  
            IF ( Status /= 0 ) THEN
               CALL WrScr( ' Error reading height offset from FF summary file.' )
               ErrStat = 5
               RETURN
            END IF ! Status /= 0
                  
            StrNeeded(5) = .FALSE.
            
         END IF !INDEX for "HEIGHT OFFSET"

      ELSEIF ( StrNeeded(6) ) THEN
         
         !-------------------------------------------------------------------------------------------
         ! #5: Get the grid "PERIODIC", if it exists (in TurbSim). Otherwise, assume it's  
         !        not a periodic file
         !-------------------------------------------------------------------------------------------         
         IF ( INDEX( LINE, 'PERIODIC' ) > 0  ) THEN
         
            Periodic     = .TRUE.                  
            StrNeeded(6) = .FALSE.
            
         END IF !INDEX for "PERIODIC"
         
      END IF ! StrNeeded
      
      
   END DO !WHILE

   ErrStat = 0    ! We made it to the end of the file
   
   !-------------------------------------------------------------------------------------------------
   ! Close the summary file
   !-------------------------------------------------------------------------------------------------         
   
   CLOSE ( UnWind )


   !-------------------------------------------------------------------------------------------------
   ! Calculate the height of the grid center
   !-------------------------------------------------------------------------------------------------         

    ZCenter  = RefHt - ZGOffset


END SUBROUTINE Read_Summary_FF
!====================================================================================================
SUBROUTINE Read_TurbSim_FF(UnWind,WindFile, ErrStat)
! This subroutine reads the binary TurbSim-format FF file (.bts).  It fills the FFData array with
! velocity data for the grids and fills the FFtower array with velocities at points on the tower 
! (if data exists).
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,      INTENT(IN)   :: UnWind            ! unit number for the wind file
   CHARACTER(*), INTENT(IN)   :: WindFile          ! name of the binary TurbSim file
   INTEGER,      INTENT(OUT)  :: ErrStat           ! error status return value (0=no error; non-zero is error)

      ! Local Variables:

   REAL(SiKi)                 :: Dum_Real4         ! dummy 4-byte real number
   INTEGER(B1Ki)              :: Dum_Int1          ! dummy 1-byte integer
   INTEGER(B2Ki)              :: Dum_Int2          ! dummy 2-byte integer
   INTEGER(B4Ki)              :: Dum_Int4          ! dummy 4-byte integer

   INTEGER                    :: IC                ! loop counter for wind components
   INTEGER                    :: IT                ! loop counter for time
   INTEGER                    :: IY                ! loop counter for y
   INTEGER                    :: IZ                ! loop counter for z
   INTEGER                    :: NChar             ! number of characters in the description string
   
   REAL(SiKi)                 :: Vslope(3)         ! slope  for "un-normalizing" data
   REAL(SiKi)                 :: Voffset(3)        ! offset for "un-normalizing" data
            
   CHARACTER(1024)            :: DescStr           ! description string contained in the file


   NFFComp = 3                                              ! this file contains 3 wind components
         
   !-------------------------------------------------------------------------------------------------
   ! Open the file
   !-------------------------------------------------------------------------------------------------

   CALL OpenBInpFile (UnWind, TRIM(WindFile), ErrStat)
   IF (ErrStat /= 0) RETURN
      
   !-------------------------------------------------------------------------------------------------
   ! Read the header information
   !-------------------------------------------------------------------------------------------------
      READ (UnWind, IOSTAT=ErrStat)  Dum_Int2               ! the file identifier, INT(2)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the file identifier in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF         
         Periodic = Dum_Int2 == INT( 8, B2Ki) ! the number 7 is used for non-periodic wind files; 8 is periodic wind


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4               ! the number of grid points vertically, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of z grid points in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NZgrids = Dum_Int4       

     
      READ (UnWind, IOSTAT=ErrStat) Dum_Int4                ! the number of grid points laterally, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of y grid points in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NYgrids = Dum_Int4


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4               ! the number of tower points, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of tower points in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NTgrids = Dum_Int4
         

      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4               ! the number of time steps, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of time steps in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NFFSteps = Dum_Int4


      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! grid spacing in vertical direction (dz), REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dz in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         InvFFZD = 1.0/Dum_Real4                            ! 1/dz
         FFZHWid = 0.5*(NZgrids-1)*Dum_Real4                ! half the grid height


      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! grid spacing in lateral direction (dy), REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dy in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         InvFFYD = 1.0 / Dum_Real4                          ! 1/dy
         FFYHWid = 0.5*(NYgrids-1)*Dum_Real4                ! half grid grid width


      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! grid spacing in time (dt), REAL(4), in m/s
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dt in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         FFDTime = Dum_Real4
         FFRate  = 1.0/FFDTime
                  
                  
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! the mean wind speed at hub height, REAL(4), in m/s
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading mean wind speed in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         MeanFFWS = Dum_Real4
         InvMFFWS = 1.0 / MeanFFWS
         
         
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! height of the hub, REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading zHub in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         RefHt = Dum_Real4
         
         
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! height of the bottom of the grid, REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading GridBase in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         GridBase = Dum_Real4

 !        ZGOffset = RefHt - GridBase  - FFZHWid
         
         
      !----------------------------------------------------------------------------------------------
      ! Read the binary scaling factors
      !----------------------------------------------------------------------------------------------         
         
         DO IC = 1,NFFComp         
            READ (UnWind, IOSTAT=ErrStat)  Vslope(IC)       ! the IC-component slope for scaling, REAL(4)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr ( ' Error reading Vslope('//Num2LStr(IC)//') in the FF binary file "'//TRIM( WindFile )//'."' )
                  RETURN
               ENDIF


            READ (UnWind, IOSTAT=ErrStat)  Voffset(IC)      ! the IC-component offset for scaling, REAL(4)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr ( ' Error reading Voffset('//Num2LStr(IC)//') in the FF binary file "'//TRIM( WindFile )//'."' )
                  RETURN
               ENDIF
               
         END DO !IC


      !----------------------------------------------------------------------------------------------
      ! Read the description string: "Generated by TurbSim (vx.xx, dd-mmm-yyyy) on dd-mmm-yyyy at hh:mm:ss."
      !----------------------------------------------------------------------------------------------

         READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                ! the number of characters in the description string, max 200, INT(4)
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error reading NCHAR in the FF binary file "'//TRIM( WindFile )//'."' )
               RETURN
            ENDIF
            nchar = Dum_Int4
            
         DescStr = ''                                       ! Initialize the description string
         
         DO IC=1,nchar

            READ (UnWind, IOSTAT=ErrStat) Dum_Int1          ! the ASCII integer representation of the character, INT(1)
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error reading description line in the FF binary file "'//TRIM( WindFile )//'."' )
               RETURN
            ENDIF
            
            IF ( LEN(DescStr) >= IC ) THEN
               DescStr(IC:IC) = ACHAR( Dum_Int1 )              ! converted ASCII characters
            ELSE
               CALL WrScr ( ' Description string too long.' )
               EXIT
            END IF

         ENDDO !IC


   !-------------------------------------------------------------------------------------------------
   ! Get the grid and tower velocities
   !-------------------------------------------------------------------------------------------------

   CALL WrScr1( ' Reading a '//TRIM( Num2LStr(NYGrids) )//'x'//TRIM( Num2LStr(NZGrids) )//  &
            ' grid ('//TRIM( Num2LStr(FFYHWid*2) )//' m wide, '// &
            TRIM( Num2LStr(GridBase) )//' m to '//TRIM( Num2LStr(GridBase+FFZHWid*2) )//&
            ' m above ground) with a characterstic wind speed of '//TRIM( Num2LStr(MeanFFWS) )//' m/s. '//TRIM(DescStr) )
               
               
   !----------------------------------------------------------------------------------------------
   ! Allocate arrays for the FF grid as well as the tower points, if they exist
   !----------------------------------------------------------------------------------------------
            
      IF ( .NOT. ALLOCATED( FFData ) ) THEN
         ALLOCATE ( FFData(NZGrids,NYGrids,NFFComp,NFFSteps), STAT=ErrStat )
               
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr( ' Cannot allocate the full-field wind data array.' )
            RETURN
         ENDIF         
      ENDIF
         
     
      IF ( NTgrids > 0 ) THEN
      
         IF ( .NOT. ALLOCATED( FFtower ) ) THEN
            ALLOCATE( FFtower( NFFComp, NTgrids, NFFSteps ), STAT=ErrStat )
            
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Cannot allocate the tower wind data array.' )
               RETURN
            ENDIF            
         ENDIF
         
      ENDIF         
      
   !-------------------------------------------------------------------------------------------------
   ! Read the 16-bit data and scale it to 32-bit reals
   !-------------------------------------------------------------------------------------------------
               
      ! Loop through time.

      DO IT=1,NFFSteps
      
         !...........................................................................................
         ! Read grid data at this time step.
         !...........................................................................................

         DO IZ=1,NZgrids
            ! Zgrid(IZ) = Z1 + (IZ-1)*dz                 ! Vertical location of grid data point, in m relative to ground

            DO IY=1,NYgrids
               ! Ygrid(IY) = -0.5*(ny-1)*dy + (IY-1)*dy  ! Horizontal location of grid data point, in m relative to tower centerline
            
               DO IC=1,NFFComp                           ! number of wind components (U, V, W)

                  READ (UnWind, IOSTAT=ErrStat)  Dum_Int2      ! normalized wind-component, INT(2)
                  IF ( ErrStat /= 0 )  THEN
                     CALL WrScr ( ' Error reading grid wind components in the FF binary file "'//TRIM( WindFile )//'."' )
                     RETURN
                  ENDIF
                  
                  FFData(IZ,IY,IC,IT) = ( Dum_Int2 - Voffset(IC) ) / VSlope(IC)

               ENDDO !IC

            ENDDO !IY
            
         ENDDO ! IZ


         !...........................................................................................
         ! Read the tower data at this time step.
         !...........................................................................................
            
         DO IZ=1,NTgrids         ! If NTgrids<1, there are no tower points & FFtower is not allocated

            ! Ytower     = 0               ! Lateral location of the tower data point, in m relative to tower centerline
            ! Ztower(IZ) = Z1 - (IZ-1)*dz  ! Vertical location of tower data point, in m relative to ground

            DO IC=1,NFFComp   ! number of wind components

               READ (UnWind, IOSTAT=ErrStat)  Dum_Int2      ! normalized wind-component, INT(2)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr ( ' Error reading tower wind components in the FF binary file "'//TRIM( WindFile )//'."' )
                  RETURN
               ENDIF
               
               FFtower(IC,IZ,IT) = ( Dum_Int2 - Voffset(IC) ) / VSlope(IC)  ! wind-component scaled to m/s

            ENDDO !IC

         ENDDO ! IZ


      ENDDO ! IT

   !-------------------------------------------------------------------------------------------------
   ! close the file and return
   !-------------------------------------------------------------------------------------------------
   
   CLOSE ( UnWind )


   IF ( Periodic ) THEN
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data (period of '//TRIM( Num2LStr( FFDTime*( NFFSteps ) ) )//' seconds).' )
   ELSE
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data ('//TRIM( Num2LStr( FFDTime*( NFFSteps - 1 ) ) )//' seconds).' )
   END IF                  

   RETURN

END SUBROUTINE READ_TurbSim_FF
!====================================================================================================
SUBROUTINE Read_FF_Tower( UnWind, WindFile, ErrStat )
! This subroutine reads the binary tower file that corresponds with the Bladed-style FF binary file.
! The FF grid must be read before this subroutine is called! (many checks are made to ensure the
! files belong together)
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,      INTENT(IN)   :: UnWind            ! unit number for the wind file
   CHARACTER(*), INTENT(IN)   :: WindFile          ! name of the binary TurbSim file
   INTEGER,      INTENT(OUT)  :: ErrStat           ! error status return value (0=no error; non-zero is error)

      ! Local Variables:

   REAL(SiKi)                 :: Dum_Real4         ! dummy 4-byte real number
   INTEGER(B2Ki)              :: Dum_Int2          ! dummy 2-byte integer
   INTEGER(B4Ki)              :: Dum_Int4          ! dummy 4-byte integer

   INTEGER                    :: IC                ! loop counter for wind components
   INTEGER                    :: IT                ! loop counter for time
   INTEGER                    :: IZ                ! loop counter for z
   
   REAL(ReKi), PARAMETER      :: TOL = 1E-4        ! tolerence for wind file comparisons

   REAL(ReKi), PARAMETER      :: FF_Offset(3) = (/ 1.0, 0.0, 0.0 /)  ! used for "un-normalizing" the data
   REAL(SiKi)                 :: TI       (3)      ! scaling values for "un-normalizing the data" [approx. turbulence intensities of the wind components]

   !-------------------------------------------------------------------------------------------------
   ! 
   !-------------------------------------------------------------------------------------------------

   NTgrids = 0

   IF ( NFFComp /= 3 ) THEN
      CALL WrScr( ' Error: Tower binary files require 3 wind components.' )
      ErrStat = 1
      RETURN
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Open the file
   !-------------------------------------------------------------------------------------------------

   CALL OpenBInpFile (UnWind, TRIM(WindFile), ErrStat)
   IF (ErrStat /= 0) THEN
      ErrStat = -1
      RETURN
   END IF
      
   !-------------------------------------------------------------------------------------------------
   ! Read the header information and check that it's compatible with the FF Bladed-style binary
   ! parameters already read.
   !-------------------------------------------------------------------------------------------------
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! dz, in meters [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dz in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( ABS(Dum_Real4*InvFFZD-1) > TOL ) THEN
            CALL WrScr ( ' Resolution in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF
         
         
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! dx, in meters [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dx in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         
         IF ( ABS(Dum_Real4*InvMFFWS/FFDTime-1) > TOL ) THEN
            CALL WrScr ( ' Time resolution in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF
         

      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! Zmax, in meters [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading GridBase in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( ABS(Dum_Real4/GridBase-1) > TOL ) THEN
            CALL WrScr ( ' Height in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                  ! NumOutSteps [4-byte INTEGER]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading NumOutSteps in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( Dum_Int4 /= NFFSteps ) THEN
            CALL WrScr ( ' Number of time steps in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                  ! NumZ      [4-byte INTEGER]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading NumZ in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NTgrids = Dum_Int4
         

      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! UHub      [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading UHub in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( ABS(Dum_Real4*InvMFFWS - 1) > TOL ) THEN
            CALL WrScr ( ' Mean wind speed in the FF binary file does not match the tower file.' )
            ErrStat = 1
            NTgrids = 0
            RETURN
         END IF


      DO IC=1,3
         READ (UnWind, IOSTAT=ErrStat)  TI(IC)               ! TI(u), TI(v), TI(w)  [4-byte REAL]
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error reading TI('//TRIM(Num2LStr(IC))//') in the binary tower file "' &
                               //TRIM( WindFile )//'."' )
               NTgrids = 0                               
               RETURN
            ENDIF
      END DO      

   !----------------------------------------------------------------------------------------------
   ! Allocate arrays for the tower points
   !----------------------------------------------------------------------------------------------        
     
      IF ( NTgrids > 0 ) THEN
      
         IF ( .NOT. ALLOCATED( FFtower ) ) THEN
!            CALL AllocAry( FFtower, NFFComp, NTgrids, NFFSteps, 'tower wind data', ErrStat )            
            ALLOCATE ( FFtower(NFFComp,NTgrids,NFFSteps), STAT=ErrStat )

            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error allocating memory for the tower wind data array.' )
               NTgrids = 0
               RETURN
            END IF

         ELSE
            ! Check sizes here!
         ENDIF
         
      ENDIF         
      
   !-------------------------------------------------------------------------------------------------
   ! Read the 16-bit time-series data and scale it to 32-bit reals
   !-------------------------------------------------------------------------------------------------
               
      ! Loop through time.

      DO IT=1,NFFSteps

         DO IZ=1,NTgrids         ! If NTgrids<1, there are no tower points & FFtower is not allocated

            ! Ytower     = 0               ! Lateral location of the tower data point, in m relative to tower centerline
            ! Ztower(IZ) = Z1 - (IZ-1)*dz  ! Vertical location of tower data point, in m relative to ground

            DO IC=1,NFFComp   ! number of wind components

               READ (UnWind, IOSTAT=ErrStat)  Dum_Int2      ! normalized wind-component, INT(2)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr( ' Error reading binary tower data file. it = '//TRIM(Num2LStr(it))// &
                                 ', nffsteps = '//TRIM(Num2LStr(nffsteps)) )
                  ErrStat = 1  
                  NTgrids = 0            
                  RETURN
               ENDIF
               
               FFtower(IC,IZ,IT) = MeanFFWS*(FF_Offset(IC)+0.00001*TI(IC)*Dum_Int2)   ! wind-component scaled to m/s

            ENDDO !IC

         ENDDO ! IZ


      ENDDO ! IT   

   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
   CLOSE ( UnWind )


   CALL WrScr ( ' Processed '//TRIM( Num2LStr(NFFSteps) )//' time steps of '//TRIM( Num2LStr(NTgrids) )//'x1 tower data grids.')


   RETURN

END SUBROUTINE Read_FF_Tower
!====================================================================================================
FUNCTION FF_GetRValue(RVarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the RVarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------

   CHARACTER(*),   INTENT(IN)    :: RVarName
   INTEGER,        INTENT(OUT)   :: ErrStat
   REAL(ReKi)                    :: FF_GetRValue

   
   CHARACTER(20)                 :: VarNameUC
   

   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FFWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = RVarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
   
      CASE ('HUBHEIGHT', 'REFHEIGHT' )
         FF_GetRValue = RefHt
         
      CASE ('GRIDWIDTH', 'FFYWID' )
         FF_GetRValue = FFYHWid*2

      CASE ('GRIDHEIGHT', 'FFZWID' )
         FF_GetRValue = FFZHWid*2
         
      CASE ('MEANFFWS' )
         FF_GetRValue = MeanFFWS         
         
      CASE DEFAULT
         CALL WrScr( ' Invalid variable name in FF_GetRValue().' )
         ErrStat = 1
         
   END SELECT

END FUNCTION FF_GetRValue
!====================================================================================================
FUNCTION FF_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are are 
! requested.  It determines if the point is on the FF grid or tower points and calls the
! corresponding interpolation routine, which returns the velocities at the specified time and space.
!----------------------------------------------------------------------------------------------------
   
   REAL(ReKi),        INTENT(IN) :: Time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)
   INTEGER,           INTENT(OUT):: ErrStat
   TYPE(InflIntrpOut)            :: FF_GetWindSpeed
   
   REAL(ReKi), PARAMETER         :: TOL = 1E-3
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   
   
   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FFWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      

   
   !-------------------------------------------------------------------------------------------------
   ! Find out if the location is on the grid on on tower points; interpolate and return the value.
   !-------------------------------------------------------------------------------------------------   

    FF_GetWindSpeed%Velocity = FF_Interp(Time,InputPosition, ErrStat)


!   IF ( InputPosition(3) >= GridBase - TOL ) THEN  
!   
!         ! Get the velocities interpolated on the FF grid
!      
!      FF_GetWindSpeed%Velocity = FF_Interp(Time,InputPosition, ErrStat)
!      
!   ELSE
!   
!         ! Get the velocities interpolated below the FF grid, on the tower points
!
!      IF ( NTgrids < 1 ) THEN
!      
!         CALL WrScr( ' Error: FF interpolation height is below the grid and no tower points have been defined.' )
!         ErrStat = 1
!         RETURN
!         
!      ELSE
!      
!         FF_GetWindSpeed%Velocity = FF_TowerInterp(Time,InputInfo%Position, ErrStat)
!         
!      END IF   ! NTgrids < 1
!      
!   
!   END IF      ! InputInfo%Position(3)>= GridBase


END FUNCTION FF_GetWindSpeed
!====================================================================================================
FUNCTION FF_Interp(Time, Position, ErrStat)
!    This function is used to interpolate into the full-field wind array or tower array if it has   
!    been defined and is necessary for the given inputs.  It receives X, Y, Z and
!    TIME from the calling routine.  It then computes a time shift due to a nonzero X based upon 
!    the average windspeed.  The modified time is used to decide which pair of time slices to interpolate
!    within and between.  After finding the two time slices, it decides which four grid points bound the 
!    (Y,Z) pair.  It does a bilinear interpolation for each time slice. Linear interpolation is then used 
!    to interpolate between time slices.  This routine assumes that X is downwind, Y is to the left when  
!    looking downwind and Z is up.  It also assumes that no extrapolation will be needed.
!    
!    If tower points are used, it assumes the velocity at the ground is 0.  It interpolates between
!    heights and between time slices, but ignores the Y input.
!
!    11/07/94 - Created by M. Buhl from the original TURBINT.
!    09/25/97 - Modified by M. Buhl to use f90 constructs and new variable names.  Renamed to FF_Interp.
!    09/23/09 - Modified by B. Jonkman to use arguments instead of modules to determine time and position.  
!               Height is now relative to the ground
!
!----------------------------------------------------------------------------------------------------

   IMPLICIT                      NONE

   REAL(ReKi),      INTENT(IN) :: Position(3)       ! takes the place of XGrnd, YGrnd, ZGrnd
   REAL(ReKi),      INTENT(IN) :: Time
   REAL(ReKi)                  :: FF_Interp(3)      ! The U, V, W velocities

   INTEGER,         INTENT(OUT):: ErrStat

      ! Local Variables:

   REAL(ReKi)                  :: TimeShifted
   REAL(ReKi),PARAMETER        :: Tol = 1.0E-3      ! a tolerance for determining if two reals are the same (for extrapolation)
   REAL(ReKi)                  :: W_YH_Z
   REAL(ReKi)                  :: W_YH_ZH
   REAL(ReKi)                  :: W_YH_ZL
   REAL(ReKi)                  :: W_YL_Z
   REAL(ReKi)                  :: W_YL_ZH
   REAL(ReKi)                  :: W_YL_ZL
   REAL(ReKi)                  :: Wnd      (2)
   REAL(ReKi)                  :: T
   REAL(ReKi)                  :: TGRID
   REAL(ReKi)                  :: Y
   REAL(ReKi)                  :: YGRID
   REAL(ReKi)                  :: Z
   REAL(ReKi)                  :: ZGRID

   INTEGER                    :: IDIM
   INTEGER                    :: IG
   INTEGER                    :: IT
   INTEGER                    :: ITHI
   INTEGER                    :: ITLO
   INTEGER                    :: IYHI
   INTEGER                    :: IYLO
   INTEGER                    :: IZHI
   INTEGER                    :: IZLO
   
   LOGICAL                    :: OnGrid
   
   !-------------------------------------------------------------------------------------------------
   ! Initialize variables
   !-------------------------------------------------------------------------------------------------

   FF_Interp(:)          = 0.0                         ! the output velocities (in case NFFComp /= 3)
   Wnd(:)                = 0.0                         ! just in case we're on an end point

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding time slices.
   !-------------------------------------------------------------------------------------------------

   ! Perform the time shift.  At time=0, a point half the grid width downstream (FFYHWid) will index into the zero time slice.  
   ! If we did not do this, any point downstream of the tower at the beginning of the run would index outside of the array.   
   ! This all assumes the grid width is at least as large as the rotor.  If it isn't, then the interpolation will not work.


   TimeShifted = TIME + ( InitXPosition - Position(1) )*InvMFFWS    ! in distance, X: InputInfo%Position(1) - InitXPosition - TIME*MeanFFWS
      

   IF ( Periodic ) THEN ! translate TimeShifted to ( 0 <= TimeShifted < TotalTime )

      TimeShifted = MODULO( TimeShifted, TotalTime )
   
      TGRID = TimeShifted*FFRate
      ITLO  = INT( TGRID )             ! convert REAL to INTEGER (add 1 later because our grids start at 1, not 0) 
      T     = TGRID - ITLO             ! a value between 0 and 1 that indicates a relative location between ITLO and ITHI   
      
      ITLO = ITLO + 1
      IF ( ITLO == NFFSteps ) THEN
         ITHI = 1
      ELSE
         ITHI = ITLO + 1
      END IF
      
      
   ELSE
   
      TGRID = TimeShifted*FFRate
      ITLO  = INT( TGRID )             ! convert REAL to INTEGER (add 1 later because our grids start at 1, not 0) 
      T     = TGRID - ITLO             ! a value between 0 and 1 that indicates a relative location between ITLO and ITHI   
   
      ITLO = ITLO + 1                  ! add one since our grids start at 1, not 0 
      ITHI = ITLO + 1   

      IF ( ITLO >= NFFSteps .OR. ITLO < 1 ) THEN
         IF ( ITLO == NFFSteps  ) THEN
            ITHI = ITLO   
            IF ( T <= TOL ) THEN ! we're on the last point
               T = 0.0
            ELSE  ! We'll extrapolate one dt past the last value in the file
               ITLO = ITHI - 1
            END IF         
         ELSE                 
            CALL WrScr( ' Error: FF wind array was exhausted at '//TRIM( Num2LStr( REAL( TIME,   ReKi ) ) )// & 
                           ' seconds (trying to access data at '//TRIM( Num2LStr( REAL( TimeShifted, ReKi ) ) )//' seconds).'  )
            ErrStat = 1   
            RETURN
         END IF
      ENDIF

   END IF


   !-------------------------------------------------------------------------------------------------
   ! Find the bounding rows for the Z position. [The lower-left corner is (1,1) when looking upwind.]
   !-------------------------------------------------------------------------------------------------

   ZGRID = ( Position(3) - GridBase )*InvFFZD

   IF (ZGRID > -1*TOL) THEN
      OnGrid = .TRUE.
      
      IZLO = INT( ZGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
      IZHI = IZLO + 1

      Z = ZGRID - ( IZLO - 1 )            ! a value between 0 and 1 that indicates a relative location between IZLO and IZHI

      IF ( IZLO < 1 ) THEN
         IF ( IZLO == 0 .AND. Z >= 1.0-TOL ) THEN
            Z    = 0.0 
            IZLO = 1
         ELSE
            CALL WrScr( ' Error: FF wind array boundaries violated. Grid too small in Z direction (Z='//&
                        TRIM(Num2LStr(Position(3)))//' m is below the grid).' )
            ErrStat = 1   
            RETURN
         END IF
      ELSEIF ( IZLO >= NZGrids ) THEN
         IF ( IZLO == NZGrids .AND. Z <= TOL ) THEN
            Z    = 0.0
            IZHI = IZLO                   ! We're right on the last point, which is still okay
         ELSE      
            CALL WrScr( ' Error: FF wind array boundaries violated. Grid too small in Z direction (Z='//&
                        TRIM(Num2LStr(Position(3)))//' m is above the grid).' )
            ErrStat = 3   
            RETURN
         END IF         
      ENDIF

   ELSE
   
      OnGrid = .FALSE.  ! this is on the tower
      
      IF ( NTGrids < 1 ) THEN
         CALL WrScr ( ' Error: FF wind array boundaries violated. Grid too small in Z direction '// &
                       '(height (Z='//TRIM(Num2LStr(Position(3)))//' m) is below the grid and no tower points are defined).' )
         ErrStat = 1
         RETURN
      END IF

      IZLO = INT( -1.0*ZGRID ) + 1            ! convert REAL to INTEGER, then add one since our grids start at 1, not 0      
      

      IF ( IZLO >= NTGrids ) THEN  !our dz is the difference between the bottom tower point and the ground
         IZLO = NTGrids
         
         Z    = 1.0 - Position(3) / (GridBase - (IZLO-1)/InvFFZD) !check that this isn't 0         
      ELSE
         Z    = ABS(ZGRID) - (IZLO - 1)
      END IF
      IZHI = IZLO + 1
            
   END IF


   IF ( OnGrid ) THEN      ! The tower points don't use this

      !-------------------------------------------------------------------------------------------------
      ! Find the bounding columns for the Y position. [The lower-left corner is (1,1) when looking upwind.]
      !-------------------------------------------------------------------------------------------------

         YGRID = ( Position(2) + FFYHWid )*InvFFYD    ! really, it's (Position(2) - -1.0*FFYHWid)

         IYLO = INT( YGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
         IYHI = IYLO + 1

         Y    = YGRID - ( IYLO - 1 )         ! a value between 0 and 1 that indicates a relative location between IYLO and IYHI
         
         IF ( IYLO >= NYGrids .OR. IYLO < 1 ) THEN
            IF ( IYLO == 0 .AND. Y >= 1.0-TOL ) THEN
               Y    = 0.0 
               IYLO = 1
            ELSE IF ( IYLO == NYGrids .AND. Y <= TOL ) THEN
               Y    = 0.0
               IYHI = IYLO                   ! We're right on the last point, which is still okay      
            ELSE
               CALL WrScr( ' Error FF wind array boundaries violated: Grid too small in Y direction. Y=' &
                             //TRIM(Num2LStr(Position(2)))//'; Y boundaries = ['//TRIM(Num2LStr(-1.0*FFYHWid)) &
                             //', '//TRIM(Num2LStr(FFYHWid))//']' )
               ErrStat = 2   
               RETURN
            END IF
         ENDIF

      !-------------------------------------------------------------------------------------------------
      ! Interpolate on the grid 
      !-------------------------------------------------------------------------------------------------

      DO IDIM=1,NFFComp       ! all the components

         IT = ITLO            ! Start using the ITLO slice
   
         DO IG=1,2            ! repeat for 2 time slices (by changing the value of IT. note that we can't loop from IXLO to IXHI because they could be NFFSteps and 1 respectively)

            !-------------------------------------------------------------------------------------------
            ! Get the wind velocity values for the four corners of the grid for this time.
            !-------------------------------------------------------------------------------------------

            W_YL_ZL = FFData( IZLO, IYLO, IDIM, IT )
            W_YL_ZH = FFData( IZHI, IYLO, IDIM, IT )
            W_YH_ZL = FFData( IZLO, IYHI, IDIM, IT )
            W_YH_ZH = FFData( IZHI, IYHI, IDIM, IT )


            !-------------------------------------------------------------------------------------------
            ! Interpolate within the grid for this time.
            !-------------------------------------------------------------------------------------------

            W_YL_Z  = ( W_YL_ZH - W_YL_ZL )*Z + W_YL_ZL
            W_YH_Z  = ( W_YH_ZH - W_YH_ZL )*Z + W_YH_ZL
            Wnd(IG) = ( W_YH_Z  - W_YL_Z  )*Y + W_YL_Z

            IT = ITHI            ! repeat for the using the ITHI slice

         END DO !IG

         !----------------------------------------------------------------------------------------------
         ! Interpolate between the two times.
         !----------------------------------------------------------------------------------------------
         
         FF_Interp(IDIM) = ( Wnd(2) - Wnd(1) ) * T + Wnd(1)    ! interpolated velocity
         
      END DO !IDIM

   ELSE
   
   !-------------------------------------------------------------------------------------------------
   ! Interpolate on the tower array
   !-------------------------------------------------------------------------------------------------
      
      DO IDIM=1,NFFComp    ! all the components

         IT = ITLO            ! Start using the ITLO slice

         DO IG=1,2            ! repeat for 2 time slices (by changing the value of IT. note that we can't loop from IXLO to IXHI because they could be NFFSteps and 1 respectively)

            !-------------------------------------------------------------------------------------------
            ! Get the wind velocity values for the two corners of the grid for this time.
            !-------------------------------------------------------------------------------------------

            W_YH_ZL = FFTower( IDIM, IZLO, IT )
            
            IF ( IZHI > NTGrids ) THEN
               W_YH_ZH = 0.0
            ELSE
               W_YH_ZH = FFTower( IDIM, IZHI, IT )
            END IF


            !-------------------------------------------------------------------------------------------
            ! Interpolate within the grid for this time.
            !-------------------------------------------------------------------------------------------

            Wnd(IG) = ( W_YH_ZH - W_YH_ZL )*Z + W_YH_ZL

            IT = ITHI            ! repeat for the using the ITHI slice

         END DO !IG

         !----------------------------------------------------------------------------------------------
         ! Interpolate between the two times.
         !----------------------------------------------------------------------------------------------
         
         FF_Interp(IDIM) = ( Wnd(2) - Wnd(1) ) * T + Wnd(1)    ! interpolated velocity
         
      END DO !IDIM
   
   END IF ! OnGrid

   RETURN
   
END FUNCTION FF_Interp
!====================================================================================================
SUBROUTINE FF_Terminate( ErrStat )
!  This subroutine cleans up any data that is still allocated.  The (possibly) open files are 
!  closed in InflowWindMod.
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   ErrStat = 0

   IF ( ALLOCATED( FFData  ) )   DEALLOCATE( FFData,  STAT=ErrStat )   
   IF ( ALLOCATED( FFTower ) )   DEALLOCATE( FFTower, STAT=ErrStat )   
   
   Initialized = .FALSE.


END SUBROUTINE FF_Terminate
!====================================================================================================
END MODULE FFWind

MODULE HAWCWind
!
!  This module uses full-field binary wind files to determine the wind inflow.
!  This module assumes that the origin, (0,0,0), is located at the tower centerline at ground level,
!  and that all units are specified in the metric system (using meters and seconds).
!  Data is assumed periodic in the X direction (and thus not shifted like FFWind files are).
!
!  Created 25-June-2010 by B. Jonkman, National Renewable Energy Laboratory
!     using subroutines and modules from AeroDyn v12.58
!
!----------------------------------------------------------------------------------------------------

   USE      NWTC_Library
   USE      SharedInflowDefns

   IMPLICIT NONE

   PRIVATE                                                        ! By default, everything in HAWCWind is private (methods, data, types, etc.)
   
      
   REAL(ReKi), ALLOCATABLE          :: WindData  (:,:,:,:)        ! Array of FF data for all 3 wind components

   REAL(ReKi)                       :: deltaXInv                  ! multiplicative inverse of delta X
   REAL(ReKi)                       :: deltaYInv                  ! multiplicative inverse of delta Y
   REAL(ReKi)                       :: deltaZInv                  ! multiplicative inverse of delta Z

   INTEGER, PARAMETER               :: NC = 3                     ! number of wind components
   INTEGER                          :: NX                         ! number of points in the X direction
   INTEGER                          :: NY                         ! number of points in the Y direction
   INTEGER                          :: NZ                         ! number of points in the Z direction

   REAL(ReKi)                       :: GridBase                   ! the height of the bottom of the grid (Z direction) in meters
   REAL(ReKi)                       :: LengthX                    ! the grid length in the X direction (distance between point 1 and the next point 1 [because it is periodic])
   REAL(ReKi)                       :: LengthYHalf                ! half the grid width
   REAL(ReKi)                       :: RefHt                      ! the reference (hub) height of the grid in meters 
   REAL(ReKi)                       :: URef                       ! the mean wind speed in m/s at height RefHt meters (as defined in the input file)

         
   LOGICAL, SAVE                    :: Initialized = .FALSE.      ! flag that determines if the module has been initialized


   PUBLIC                           :: HW_Init                    ! initialization subroutine to read the FF grids
   PUBLIC                           :: HW_GetWindSpeed            ! interpolation function that returns velocities at specified time and space
   PUBLIC                           :: HW_GetValue                ! interface to return requested values
   PUBLIC                           :: HW_Terminate               ! subroutine that deallocates memory stored in the FFWind module

CONTAINS
!====================================================================================================
SUBROUTINE HW_Init ( UnWind, InpFileName, ErrStat )
!  This routine is used read the full-field turbulence data stored in HAWC format.
!----------------------------------------------------------------------------------------------------

   IMPLICIT                       NONE


      ! Passed Variables:
      
   INTEGER,      INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered
   
   CHARACTER(*), INTENT(IN)    :: InpFileName                  ! Name of the input text file

      ! Local Variables:

   REAL(SiKi)                  :: DumReal                      ! real variable to temporarially store values read from binary file

   REAL(ReKi)                  :: dx
   REAL(ReKi)                  :: dy
   REAL(ReKi)                  :: dz
   REAL(ReKi)                  :: PLExp                        ! Power law exponent, for the PL mean wind profile type
   REAL(ReKi)                  :: U                            ! The mean wind speed
   REAL(ReKi)                  :: Z                            ! The height above ground/sea level
   REAL(ReKi)                  :: Z0                           ! Surface layer roughness length in meters, used for LOG profile type
    
  
   INTEGER                     :: IC                           ! Loop counter for the number of wind components
   INTEGER                     :: IX                           ! Loop counter for the number of grid points in the X direction
   INTEGER                     :: IY                           ! Loop counter for the number of grid points in the Y direction
   INTEGER                     :: IZ                           ! Loop counter for the number of grid points in the Z direction

   CHARACTER( 1024 )           :: DataFiles ( 3 )              ! Names of the files containing the 3 wind components   
   CHARACTER(3)                :: WindProfileType              ! character code of mean wind profile type


   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' HAWCWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF   

! bjj: this (reading the file) should perhaps be in a subroutine...

   !-------------------------------------------------------------------------------------------------
   ! Open the text file 
   !-------------------------------------------------------------------------------------------------

   CALL OpenFInpFile ( UnWind, TRIM(InpFileName), ErrStat )
   IF (ErrStat /= 0) RETURN

   
   !-------------------------------------------------------------------------------------------------
   ! Read some header information in the text file 
   !-------------------------------------------------------------------------------------------------
   
   CALL ReadCom( UnWind, InpFileName, 'Header 1', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Header 2', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Header 3', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Header 4', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Parameters for HAWC-format binary files', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   
   !-------------------------------------------------------------------------------------------------
   ! Read file names and scaling info from the file
   !-------------------------------------------------------------------------------------------------

   CALL ReadVar( UnWind, InpFileName, DataFiles(1), 'FileName_u', 'Name of the u-component binary file', ErrStat )
   IF (ErrStat /= 0) RETURN

   CALL ReadVar( UnWind, InpFileName, DataFiles(2), 'FileName_v', 'Name of the v-component binary file', ErrStat )
   IF (ErrStat /= 0) RETURN

   CALL ReadVar( UnWind, InpFileName, DataFiles(3), 'FileName_w', 'Name of the w-component binary file', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, InpFileName, NX, 'nx', 'Number of grid points in the X direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( NX < 1 ) THEN
      CALL WrScr ( ' HAWCWind error reading "nx": number of grid points in the X direction must be at least 1.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, NY, 'ny', 'Number of grid points in the Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( NY < 1 ) THEN
      CALL WrScr ( ' HAWCWind error reading "ny": number of grid points in the Y direction must be at least 1.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, NZ, 'nz', 'Number of grid points in the Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( NZ < 1 ) THEN
      CALL WrScr ( ' HAWCWind error reading "nz": number of grid points in the Z direction must be at least 1.')
      ErrStat = 1
      RETURN
   END IF
   

   CALL ReadVar( UnWind, InpFileName, dx, 'dx', 'Distance between two points in the X direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( DX < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "dx": the grid spacing in the X direction must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, dy, 'dy', 'Distance between two points in the Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( DY < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "dy": the grid spacing in the Y direction must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, dz, 'dz', 'Distance between two points in the Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( DZ < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "dz": the grid spacing in the Z direction must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, RefHt, 'RefHt', 'Grid reference height', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( RefHt < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "RefHt": the grid reference height must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF

 
   !-------------------------------------------------------------------------------------------------
   ! Read the section to determine the mean wind profile
   !-------------------------------------------------------------------------------------------------
 
   CALL ReadCom( UnWind, InpFileName, 'mean wind profile parameters (added to HAWC-format files)', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, InpFileName, WindProfileType, 'WindProfileType', 'Wind profile type', ErrStat )
   IF (ErrStat /= 0) RETURN

    
   CALL ReadVar( UnWind, InpFileName, URef, 'URef', 'Reference wind speed', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( URef < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error: the reference wind speed, URef, must not be negative.' )
      ErrStat = 1
      RETURN   
   END IF

    
   CALL ReadVar( UnWind, InpFileName, PLExp, 'PLExp', 'Power law exponent', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, InpFileName, Z0, 'Z0', 'Surface roughness length', ErrStat )   
   IF (ErrStat /= 0) RETURN  
   
   IF ( Z0 <= EPSILON(Z0) ) THEN
      CALL WrScr ( ' HAWCWind error: the surface roughness length, Z0, must be greater than zero.' )
      ErrStat = 1
      RETURN   
   END IF
   
   !-------------------------------------------------------------------------------------------------
   ! Close the file.
   !-------------------------------------------------------------------------------------------------

   CLOSE ( UnWind )


   !-------------------------------------------------------------------------------------------------
   ! Set some internal module parameters based on input file values
   !-------------------------------------------------------------------------------------------------

   LengthX     = dx*nx !(nx-1)   !because the turbulence box is periodic in the X direction, we need to consider the length between point 1 and the next point 1 (instead of between points 1 and nx)
   LengthYHalf = 0.5*dy*(ny-1)
   GridBase    = RefHt - 0.5*(nz-1)*dz

   IF ( GridBase <= 0.0 ) THEN
      CALL WrScr( ' HAWCWind error: the bottom of the grid is located at a height of '//&
                      TRIM( Num2LStr(GridBase) )//' meters, which is below the ground.' )
      ErrStat = 1
      RETURN
   END IF 


   deltaXInv   = 1.0 / dx
   deltaYInv   = 1.0 / dy
   deltaZInv   = 1.0 / dz
   
   
   !-------------------------------------------------------------------------------------------------
   ! Allocate space for the wind arrays.
   !-------------------------------------------------------------------------------------------------

   IF (.NOT. ALLOCATED(WindData) ) THEN
      ALLOCATE( WindData( NZ, NY, NX, NC ), STAT=ErrStat )
      IF ( ErrStat /= 0 ) THEN
         CALL WrScr ( " Error allocating space for HAWCWind's WindData array." )
         RETURN
      END IF
   END IF
      

   !-------------------------------------------------------------------------------------------------
   ! Read the 3 files containg the turbulent wind speeds.
   !-------------------------------------------------------------------------------------------------
!bjj: check these indices... they do not seem to be very consistant between the WAsP IEC Turbulence
!     simulator and documentation of OC3 file formats... the current implementation is from the 
!     OC3/Kenneth Thompson documentation.

      ! The array must be filled so that x(i) < x(i+1), y(i) < y(i+1), and z(i) < z(i+1)
      ! Also, note that the time axis is the negative x axis.

   DO IC = 1,NC
   
      CALL OpenBInpFile ( UnWind, DataFiles(IC), ErrStat )
   
      DO IX = NX,1,-1                  ! Time is the opposite of X ....
         DO IY = NY,1,-1
            DO IZ = 1,NZ 
            
               READ( UnWind, IOSTAT=ErrStat ) DumReal
               
               WindData( IZ, IY, IX, IC ) = DumReal    ! possible type conversion here
               
               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading binary data from "'//TRIM(DataFiles(IC))//'".' )
                  CALL WrScr( ' I/O error '//TRIM(Num2LStr(ErrStat))//' occurred at IZ='//TRIM(Num2LStr(IZ))//&
                                                   ', IY='//TRIM(Num2LStr(IY))//', IX='//TRIM(Num2LStr(IX))//'.' )
                  CLOSE ( UnWind )
                  RETURN
               END IF
                              
            END DO
         END DO
      END DO
      
      CLOSE ( UnWind )
      
   END DO

   
   !-------------------------------------------------------------------------------------------------
   ! Add the mean wind speed to the u component.
   !-------------------------------------------------------------------------------------------------

   CALL Conv2UC( WindProfileType )
                 
   
   IF ( RefHt > 0.0 ) THEN
   
      DO IZ = 1,NZ

         Z = GridBase  + ( IZ - 1 )*dz
         
         SELECT CASE ( TRIM(WindProfileType) )
   
            CASE ( 'PL' )         
               U = URef*( Z / RefHt )**PLExp      ! [IEC 61400-1 6.3.1.2 (10)]
      
            CASE ( 'LOG' )
            
               IF ( Z /= Z0 ) THEN
                  U = URef*( LOG( Z / Z0 ) )/( LOG( RefHt / Z0 ) )
               ELSE
                  U = 0.0
               ENDIF
            
            CASE DEFAULT
            
               CALL WrScr( ' Invalid wind profile type in HAWCWind.' )
               ErrStat = 1
               RETURN
      
         END SELECT
   
         WindData( IZ, :, :, 1 ) = WindData( IZ, :, :, 1 ) + U
            

      END DO ! IZ
   END IF ! RefHt
   
   
   !-------------------------------------------------------------------------------------------------
   ! Set initialized flag and return
   !-------------------------------------------------------------------------------------------------
   
   Initialized = .TRUE.

   RETURN
   
END SUBROUTINE HW_Init
!====================================================================================================
FUNCTION HW_GetValue(RVarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the RVarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------

   CHARACTER(*),   INTENT(IN)    :: RVarName
   INTEGER,        INTENT(OUT)   :: ErrStat
   REAL(ReKi)                    :: HW_GetValue

   
   CHARACTER(20)                 :: VarNameUC
   

   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the HAWCWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = RVarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
   
      CASE ( 'REFHEIGHT' )
         HW_GetValue = RefHt
         
      CASE ('GRIDWIDTH' )
         HW_GetValue = LengthYHalf*2

      CASE ('GRIDHEIGHT' )
         HW_GetValue = NZ/deltaZInv
         
      CASE ('UREF' )
         HW_GetValue = URef        
         
      CASE DEFAULT
         CALL WrScr( ' HAWCWind error: invalid variable name in HW_GetRValue().' )
         ErrStat = 1
         
   END SELECT

END FUNCTION HW_GetValue
!!====================================================================================================
FUNCTION HW_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are are 
! requested.  It determines if the point is on the FF grid or tower points and calls the
! corresponding interpolation routine, which returns the velocities at the specified time and space.
!----------------------------------------------------------------------------------------------------
   
   REAL(ReKi),        INTENT(IN) :: Time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)
   INTEGER,           INTENT(OUT):: ErrStat
   TYPE(InflIntrpOut)            :: HW_GetWindSpeed
     
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   
   
   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FFWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      

   
   !-------------------------------------------------------------------------------------------------
   ! interpolate and return the value.
   !-------------------------------------------------------------------------------------------------   

    HW_GetWindSpeed%Velocity = HW_LinearInterp(Time,InputPosition, ErrStat)


END FUNCTION HW_GetWindSpeed
!====================================================================================================
FUNCTION HW_LinearInterp(Time, Position, ErrStat)
!    This function is used to interpolate into the full-field wind array for the given inputs. It receives 
!    X, Y, Z and TIME from the calling routine.  It then computes a time shift in the X axis based upon 
!    the average windspeed.  The modified position is used to decide which pair of X grids to interpolate
!    within and between.  After finding the two X slices, it decides which four grid points bound the 
!    (Y,Z) pair.  It does a bilinear interpolation for each X slice. Linear interpolation is then used 
!    to interpolate between the X slices.  This routine assumes that X is downwind, Y is to the left when  
!    looking downwind and Z is up.  It also assumes that no extrapolation will be needed.
!    
!    If tower points are used, it assumes the velocity at the ground is 0.  It interpolates between
!    heights and between time slices, but ignores the Y input.
!
!    09/23/09 - Modified by B. Jonkman to use arguments instead of modules to determine time and position.  
!               Height is now relative to the ground
!
!----------------------------------------------------------------------------------------------------

   IMPLICIT                      NONE

   REAL(ReKi),      INTENT(IN) :: Position(3)       ! takes the place of XGrnd, YGrnd, ZGrnd
   REAL(ReKi),      INTENT(IN) :: Time
   REAL(ReKi)                  :: HW_LinearInterp(3)      ! The U, V, W velocities

   INTEGER,         INTENT(OUT):: ErrStat

      ! Local Variables:

   REAL(ReKi)                  :: ShiftedXPosition
   REAL(ReKi),PARAMETER        :: Tol = 1.0E-3      ! a tolerance for determining if two reals are the same (for extrapolation)
   REAL(ReKi)                  :: W_YH_Z
   REAL(ReKi)                  :: W_YH_ZH
   REAL(ReKi)                  :: W_YH_ZL
   REAL(ReKi)                  :: W_YL_Z
   REAL(ReKi)                  :: W_YL_ZH
   REAL(ReKi)                  :: W_YL_ZL
   REAL(ReKi)                  :: Wnd      (2)
   REAL(ReKi)                  :: X                 ! a value between 0 and 1 that indicates a relative location between IXLO and IXHI
   REAL(ReKi)                  :: XGRID             ! the position in the X direction relative to the first grid point
   REAL(ReKi)                  :: Y                 ! a value between 0 and 1 that indicates a relative location between IYLO and IYHI
   REAL(ReKi)                  :: YGRID             ! the position in the Y direction relative to the first grid point
   REAL(ReKi)                  :: Z                 ! a value between 0 and 1 that indicates a relative location between IZLO and IZHI
   REAL(ReKi)                  :: ZGRID             ! the position in the Z direction relative to the first grid point             

   INTEGER                     :: IC                ! loop counter for number of grid points
   INTEGER                     :: IG                ! loop counter for X grids
   INTEGER                     :: IX                ! variable to store IXLO and IXHI while looping
   INTEGER                     :: IXHI              ! high index into the array in the X dimension
   INTEGER                     :: IXLO              ! low  index into the array in the X dimension
   INTEGER                     :: IYHI              ! high index into the array in the Y dimension
   INTEGER                     :: IYLO              ! low  index into the array in the Y dimension
   INTEGER                     :: IZHI              ! high index into the array in the Z dimension
   INTEGER                     :: IZLO              ! low  index into the array in the Z dimension
   
   
   !-------------------------------------------------------------------------------------------------
   ! Initialize variables
   !-------------------------------------------------------------------------------------------------

   HW_LinearInterp(:)    = 0.0                         ! the output velocities (in case NFFComp /= 3)
   Wnd(:)                = 0.0                         ! just in case we're on an end point

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding X slices.
   !-------------------------------------------------------------------------------------------------

! bjj: should we shift by MIN(YHalfWid,FFZHWid)?
         
         ! Assume Taylor's Frozen Turbulence Hypothesis applies: u(X,Y,Z,t) = u( X-U*t, Y, Z, 0)

   ShiftedXPosition = Position(1) - TIME*URef      !this puts the first X grid point at the undeflected tower centerline

   
      ! The wind file is periodic so we'll translate this position to ( 0 <= ShiftedXPosition < LengthX )
   
   ShiftedXPosition = MODULO( ShiftedXPosition, LengthX )
    
   XGrid            = ShiftedXPosition*deltaXInv
   
   IXLO = INT( XGrid ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
   
   IF ( IXLO == NX ) THEN
      IXHI = 1
   ELSE
      IXHI = IXLO + 1
      
! BJJ: assuming LengthX and NX have been correctly defined, this cannot happen:      
!      IF ( IXLO > NX .OR. IXLO < 1 ) THEN
!            CALL WrScr( ' HAWCWind error: wind array was exhausted at '//TRIM( Num2LStr( REAL( TIME,   ReKi ) ) )//' seconds '//& 
!                        '(trying to access X data at '//TRIM( Num2LStr( REAL( ShiftedXPosition, ReKi ) ) )//' m).'  )
!            ErrStat = 1   
!            RETURN
!      ENDIF
      
   END IF
   
   X = XGrid - ( IXLO - 1 )         ! a value between 0 and 1 that indicates a relative location between IXLO and IXHI

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding rows for the Z position. [The lower-left corner is (1,1) when looking upwind.]
   !-------------------------------------------------------------------------------------------------

   ZGRID = ( Position(3) - GridBase )*deltaZInv

     
   IZLO = INT( ZGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
   IZHI = IZLO + 1

   Z = ZGRID - ( IZLO - 1 )            ! a value between 0 and 1 that indicates a relative location between IZLO and IZHI

   IF ( IZLO < 1 ) THEN
      IF ( IZLO == 0 .AND. Z >= 1.0-TOL ) THEN
         Z    = 0.0 
         IZLO = 1
      ELSE
         CALL WrScr( ' HAWCWind error: wind array boundaries violated. Grid too small in Z direction (Z='//&
                     TRIM(Num2LStr(Position(3)))//' m is below the grid).' )
         ErrStat = 1   
         RETURN
      END IF
   ELSEIF ( IZLO >= NZ ) THEN
      IF ( IZLO == NZ .AND. Z <= TOL ) THEN
         Z    = 0.0
         IZHI = IZLO                   ! We're right on the last point, which is still okay
      ELSE      
         CALL WrScr( ' HAWCWind error: wind array boundaries violated. Grid too small in Z direction (Z='//&
                     TRIM(Num2LStr(Position(3)))//' m is above the grid).' )
         ErrStat = 3   
         RETURN
      END IF         
   ENDIF
   

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding columns for the Y position. [The lower-left corner is (1,1) when looking upwind.]
   !-------------------------------------------------------------------------------------------------

   YGRID = ( Position(2) + LengthYHalf )*deltaYInv    ! really, it's (Position(2) - -1.0*YHalfWid)

   IYLO = INT( YGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
   IYHI = IYLO + 1

   Y    = YGRID - ( IYLO - 1 )         ! a value between 0 and 1 that indicates a relative location between IYLO and IYHI
   
   IF ( IYLO >= NY .OR. IYLO < 1 ) THEN
      IF ( IYLO == 0 .AND. Y >= 1.0-TOL ) THEN
         Y    = 0.0 
         IYLO = 1
      ELSE IF ( IYLO == NY .AND. Y <= TOL ) THEN
         Y    = 0.0
         IYHI = IYLO                   ! We're right on the last point, which is still okay      
      ELSE
         CALL WrScr( ' HAWCWind error: wind array boundaries violated: Grid too small in Y direction. Y=' &
                        //TRIM(Num2LStr(Position(2)))//'; Y boundaries = ['//TRIM(Num2LStr(-1.0*LengthYHalf)) &
                        //', '//TRIM(Num2LStr(LengthYHalf))//']' )
         ErrStat = 2   
         RETURN
      END IF
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Interpolate on the Y-Z grid for each X (time) slice
   !-------------------------------------------------------------------------------------------------

   DO IC=1,NC            ! all the components

      IX = IXLO          ! start using the first time (X) slice

      DO IG = 1,2        ! repeat for 2 time slices (by changing the value of IX. note that we can't loop from IXLO to IXHI because they could be NX and 1 respectively)

         !-------------------------------------------------------------------------------------------
         ! Get the wind velocity values for the four corners of the grid for this time.
         !-------------------------------------------------------------------------------------------

         W_YL_ZL = WindData( IZLO, IYLO, IX, IC )
         W_YL_ZH = WindData( IZHI, IYLO, IX, IC )
         W_YH_ZL = WindData( IZLO, IYHI, IX, IC )
         W_YH_ZH = WindData( IZHI, IYHI, IX, IC )


         !-------------------------------------------------------------------------------------------
         ! Interpolate within the grid for this time.
         !-------------------------------------------------------------------------------------------

         W_YL_Z  = ( W_YL_ZH - W_YL_ZL )*Z + W_YL_ZL
         W_YH_Z  = ( W_YH_ZH - W_YH_ZL )*Z + W_YH_ZL
         Wnd(IG) = ( W_YH_Z  - W_YL_Z  )*Y + W_YL_Z

         IX = IXHI  ! repeat for the second time (X) slice

      END DO !IX

      !----------------------------------------------------------------------------------------------
      ! Interpolate between the two times.
      !----------------------------------------------------------------------------------------------
      
      HW_LinearInterp( IC ) = ( Wnd(2) - Wnd(1) ) * X + Wnd(1)    ! interpolated velocity
      
   END DO !IDIM


   RETURN
   
END FUNCTION HW_LinearInterp
!====================================================================================================
SUBROUTINE HW_Terminate( ErrStat )
!  This subroutine cleans up any data that is still allocated.  The (possibly) open files are 
!  closed in InflowWindMod.
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   ErrStat = 0

   IF ( ALLOCATED( WindData  ) )   DEALLOCATE( WindData,  STAT=ErrStat )   
   
   Initialized = .FALSE.


END SUBROUTINE HW_Terminate
!====================================================================================================
END MODULE HAWCWind
MODULE HHWind
! This module contains all the data and procedures that define hub-height wind files. This could 
! more accurately be called a point wind file since the wind speed at any point is calculated by 
! shear applied to the point where wind is defined.  It is basically uniform wind over the rotor disk.
! The entire file is read on initialization, then the columns that make up the wind file are
! interpolated to the time requested, and wind is calculated based on the location in space.
!
! the file contains header information (rows that contain "!"), followed by numeric data stored in
! 8 columns:   (1) Time                                  [s]
!              (2) Horizontal wind speed       (V)       [m/s]
!              (3) Wind direction              (Delta)   [deg]
!              (4) Vertical wind speed         (VZ)      [m/s]
!              (5) Horizontal linear shear     (HLinShr) [-]
!              (6) Vertical power-law shear    (VShr)    [-]
!              (7) Vertical linear shear       (VLinShr) [-]
!              (8) Gust (horizontal) velocity  (VGust)   [m/s]
!
! The horizontal wind speed at (X, Y, Z) is then calculated using the interpolated columns by
!   Vh = V * ( Z/RefHt ) ** VShr                                        ! power-law wind shear
!      + V * HLinShr/RefWid * ( Y * COS(Delta) + X * SIN(Delta) )       ! horizontal linear shear
!      + V * VLinShr/RefWid * ( Z-RefHt )                               ! vertical linear shear
!      + VGust                                                          ! gust speed
!----------------------------------------------------------------------------------------------------

   USE                     NWTC_Library
   USE                     SharedInflowDefns
   
   IMPLICIT                NONE
   PRIVATE

      
   REAL(ReKi), ALLOCATABLE      :: Tdata  (:)                              ! Time array from the HH wind file
   REAL(ReKi), ALLOCATABLE      :: DELTA  (:)                              ! HH Wind direction (angle)
   REAL(ReKi), ALLOCATABLE      :: V      (:)                              ! HH horizontal wind speed
   REAL(ReKi), ALLOCATABLE      :: VZ     (:)                              ! wind, including tower shadow, along the Z axis
   REAL(ReKi), ALLOCATABLE      :: HSHR   (:)                              ! HH Horizontal linear shear
   REAL(ReKi), ALLOCATABLE      :: VSHR   (:)                              ! HH vertical shear exponent
   REAL(ReKi), ALLOCATABLE      :: VLINSHR(:)                              ! HH vertical linear shear
   REAL(ReKi), ALLOCATABLE      :: VGUST  (:)                              ! HH wind gust

   REAL(ReKi)                   :: LinearizeDels(7)                        ! The delta values for linearization -- perhaps at some point, this could be T/F and we determine the deltas by sqrt(eps) or something similar
   REAL(ReKi)                   :: RefHt                                   ! reference height; was HH (hub height); used to center the wind
   REAL(ReKi)                   :: RefWid                                  ! reference width; was 2*R (=rotor diameter); used to scale the linear shear
   
   INTEGER                      :: NumDataLines
   INTEGER, SAVE                :: TimeIndx = 0                            ! An index into the Tdata array (to allow us faster searching, starting search from previous one)

   LOGICAL, SAVE                :: Linearize = .FALSE.                     ! If this is TRUE, we are linearizing
   
   TYPE, PUBLIC                 :: HH_Info
      REAL(ReKi)                :: ReferenceHeight
      REAL(ReKi)                :: Width
   END TYPE HH_Info
      
   PUBLIC                       :: HH_Init
   PUBLIC                       :: HH_GetWindSpeed
   PUBLIC                       :: HH_Terminate
   PUBLIC                       :: HH_SetLinearizeDels
   PUBLIC                       :: HH_Get_ADhack_WindSpeed                  ! REMOVE THIS!!!!

CONTAINS
!====================================================================================================
SUBROUTINE HH_Init(UnWind, WindFile, WindInfo, ErrStat)
! A subroutine to initialize the HHWind module.  It reads the HH file and stores the data in an
! array to use later.  It requires an initial reference height (hub height) and width (rotor diameter),
! both in meters, which are used to define the volume where wind velocities will be calculated.  This
! information is necessary because of the way the shears are defined.
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,      INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered
   TYPE(HH_Info),INTENT(IN)    :: WindInfo                     ! Additional information needed to initialize this wind type
   
   CHARACTER(*), INTENT(IN)    :: WindFile                     ! Name of the text HH wind file

      ! local variables
            
   INTEGER, PARAMETER          :: NumCols = 8                  ! Number of columns in the HH file
   REAL(ReKi)                  :: TmpData(NumCols)             ! Temp variable for reading all columns from a line 
   REAL(ReKi)                  :: DelDiff                      ! Temp variable for storing the direction difference

   INTEGER                     :: I
   INTEGER                     :: NumComments
   INTEGER                     :: ILine                        ! Counts the line number in the file
   INTEGER, PARAMETER          :: MaxTries = 100
   CHARACTER(1024)             :: Line                         ! Temp variable for reading whole line from file

    
   !-------------------------------------------------------------------------------------------------
   ! Check that it's not already initialized
   !-------------------------------------------------------------------------------------------------
      
   IF ( TimeIndx /= 0 ) THEN  
      CALL WrScr( ' HHWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
      
      LinearizeDels(:) = 0.0
      Linearize        = .FALSE.
   END IF   

  
   !-------------------------------------------------------------------------------------------------
   ! Open the file for reading
   !-------------------------------------------------------------------------------------------------
   CALL OpenFInpFile (UnWind, TRIM(WindFile), ErrStat)
   
   IF ( ErrStat /= 0 ) RETURN

   !-------------------------------------------------------------------------------------------------
   ! Find the number of comment lines
   !-------------------------------------------------------------------------------------------------
   LINE = '!'                          ! Initialize the line for the DO WHILE LOOP
   NumComments = -1
   
   DO WHILE (INDEX( LINE, '!' ) > 0 ) ! Lines containing "!" are treated as comment lines
      NumComments = NumComments + 1
      
      READ(UnWind,'( A )',IOSTAT=ErrStat) LINE
            
      IF ( ErrStat /=0 ) THEN
         CALL WrScr ( ' Error reading from HH wind file on line '//TRIM(Num2LStr(NumComments))//'.' )
         RETURN
      END IF
      
   END DO !WHILE
   
   !-------------------------------------------------------------------------------------------------
   ! Find the number of data lines
   !-------------------------------------------------------------------------------------------------
   NumDataLines = 0
   
   READ(LINE,*,IOSTAT=ErrStat) ( TmpData(I), I=1,NumCols )

   DO WHILE (ErrStat == 0)  ! read the rest of the file (until an error occurs)
      NumDataLines = NumDataLines + 1               
      
      READ(UnWind,*,IOSTAT=ErrStat) ( TmpData(I), I=1,NumCols )

   END DO !WHILE


   IF (NumDataLines < 1) THEN
      CALL WrScr ( ' Error reading data from HH wind file on line '//TRIM(Num2LStr(NumDataLines+NumComments))//'.' )
      RETURN
   ELSE
      CALL WrScr ( ' Reading '//TRIM(Num2LStr(NumDataLines))//' lines of data from the HH wind file.' )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Allocate arrays for the HH data
   !-------------------------------------------------------------------------------------------------
   ! BJJ note: If the subroutine AllocAry() is called, the CVF compiler with A2AD does not work
   !   properly.  The arrays are not properly read even though they've been allocated.
   !-------------------------------------------------------------------------------------------------
   
   IF (.NOT. ALLOCATED(Tdata) ) THEN
      ALLOCATE ( Tdata(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH time array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(V) ) THEN
      ALLOCATE ( V(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH horizontal wind speed array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(Delta) ) THEN
      ALLOCATE ( Delta(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH wind direction array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VZ) ) THEN
      ALLOCATE ( VZ(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH vertical wind speed array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(HShr) ) THEN
      ALLOCATE ( HShr(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH horizontal linear shear array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VShr) ) THEN
      ALLOCATE ( VShr(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH vertical power-law shear exponent array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VLinShr) ) THEN
      ALLOCATE ( VLinShr(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH vertical linear shear array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VGust) ) THEN
      ALLOCATE ( VGust(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH gust velocity array.' )
         RETURN
      END IF   
   END IF
   

   !-------------------------------------------------------------------------------------------------
   ! Rewind the file (to the beginning) and skip the comment lines
   !-------------------------------------------------------------------------------------------------
   REWIND( UnWind )
   
   DO I=1,NumComments
      CALL ReadCom( UnWind, TRIM(WindFile), 'Header line #'//TRIM(Num2LStr(I)), ErrStat )
      IF ( ErrStat /= 0 ) RETURN
   END DO !I


   !-------------------------------------------------------------------------------------------------
   ! Read the data arrays
   !-------------------------------------------------------------------------------------------------

   DO I=1,NumDataLines
         
      CALL ReadAry( UnWind, TRIM(WindFile), TmpData(1:NumCols), NumCols, 'TmpData', & 
                'Data from HH line '//TRIM(Num2LStr(NumComments+I)), ErrStat )
      IF (ErrStat /= 0) RETURN
                 
      Tdata(  I) = TmpData(1)
      V(      I) = TmpData(2)
      Delta(  I) = TmpData(3)*D2R 
      VZ(     I) = TmpData(4)
      HShr(   I) = TmpData(5)
      VShr(   I) = TmpData(6)
      VLinSHR(I) = TmpData(7)
      VGust(  I) = TmpData(8)           
      
   END DO !I


   !-------------------------------------------------------------------------------------------------
   ! Make sure the wind direction isn't jumping more than 180 degrees between any 2 consecutive
   ! input times.  (Avoids interpolation errors with modular arithemetic.)
   !-------------------------------------------------------------------------------------------------

   DO I=2,NumDataLines
   
      ILine = 1
      
      DO WHILE ( ILine < MaxTries )
     
         DelDiff = ( Delta(I) - Delta(I-1) )

         IF ( ABS( DelDiff ) < Pi ) EXIT  ! exit inner loop

         Delta(I) = Delta(I) - SIGN( TwoPi, DelDiff )
         
         ILine = ILine + 1

      END DO
      
      IF ( ILine >= MaxTries ) THEN
         CALL WrScr( ' Error calculating wind direction from HH file. Delta(' &
               // TRIM(Num2LStr(I  )) // ') = ' // TRIM(Num2LStr(Delta(I))) // '; Delta(' & 
               // TRIM(Num2LStr(I+1)) // ') = ' // TRIM(Num2LStr(Delta(I+1))) )
         ErrStat = 1
      END IF
           

   END DO !I


   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
   
   CLOSE( UnWind )
   

   !-------------------------------------------------------------------------------------------------
   ! Print warnings and messages
   !-------------------------------------------------------------------------------------------------
!   CALL WrScr ( ' Processed '//TRIM( Num2LStr( NumDataLines ) )//' records of HH data' )
   
   
   IF ( Tdata(1) > 0.0 ) THEN
      CALL ProgWarn( 'The hub-height wind file : "'//TRIM(ADJUSTL(WindFile))//'" starts at a time '// & 
                     'greater than zero. Interpolation errors may result.')
   ENDIF
   
   IF ( NumDataLines == 1 ) THEN
      CALL WrScr( ' Only 1 line in HH wind file. Steady, hub-height horizontal wind speed = '//TRIM(Num2LStr(V(1)))//' m/s.' )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Set the initial index into the time array (it indicates that we've initialized the module, too)
   ! and initialize the spatial scaling for the wind calculations
   !-------------------------------------------------------------------------------------------------
   TimeIndx = 1            

   RefHt  = WindInfo%ReferenceHeight
   RefWid = WindInfo%Width   


   RETURN
     
END SUBROUTINE HH_Init
!====================================================================================================
FUNCTION HH_GetWindSpeed(Time, InputPosition, ErrStat)
! This subroutine linearly interpolates the columns in the HH input file to get the values for 
! the requested time, then uses the interpolated values to calclate the wind speed at a point
! in space represented by InputPosition.
!----------------------------------------------------------------------------------------------------

   REAL(ReKi),        INTENT(IN) :: Time                 ! time from the start of the simulation
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)     ! input information: positions X,Y,Z
   INTEGER,           INTENT(OUT):: ErrStat              ! error status
   TYPE(InflIntrpOut)            :: HH_GetWindSpeed      ! return velocities (U,V,W)
   
   REAL(ReKi)                    :: CosDelta             ! cosine of Delta_tmp
   REAL(ReKi)                    :: Delta_tmp            ! interpolated Delta   at input TIME
   REAL(ReKi)                    :: HShr_tmp             ! interpolated HShr    at input TIME
   REAL(ReKi)                    :: P                    ! temporary storage for slope (in time) used in linear interpolation
   REAL(ReKi)                    :: SinDelta             ! sine of Delta_tmp
   REAL(ReKi)                    :: V_tmp                ! interpolated V       at input TIME
   REAL(ReKi)                    :: VGust_tmp            ! interpolated VGust   at input TIME
   REAL(ReKi)                    :: VLinShr_tmp          ! interpolated VLinShr at input TIME
   REAL(ReKi)                    :: VShr_tmp             ! interpolated VShr    at input TIME
   REAL(ReKi)                    :: VZ_tmp               ! interpolated VZ      at input TIME
   REAL(ReKi)                    :: V1                   ! temporary storage for horizontal velocity
   

   !-------------------------------------------------------------------------------------------------
   ! verify the module was initialized first
   !-------------------------------------------------------------------------------------------------

   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Error: Call HH_Init() before getting wind speed.')
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
      
   !-------------------------------------------------------------------------------------------------
   ! Linearly interpolate in time (or used nearest-neighbor to extrapolate) 
   ! (compare with NWTC_Num.f90\InterpStpReal)
   !-------------------------------------------------------------------------------------------------

    IF ( Linearize ) THEN  !get the perturbed wind speed

      TimeIndx      = 1
      V_tmp         = V      (1) + LinearizeDels(1)
      Delta_tmp     = Delta  (1) + LinearizeDels(2)
      VZ_tmp        = VZ     (1) + LinearizeDels(3)
      HShr_tmp      = HShr   (1) + LinearizeDels(4)
      VShr_tmp      = VShr   (1) + LinearizeDels(5)
      VLinShr_tmp   = VLinShr(1) + LinearizeDels(6)
      VGust_tmp     = VGust  (1) + LinearizeDels(7)

      ! Let's check the limits.
   ELSE IF ( Time <= Tdata(1) .OR. NumDataLines == 1 )  THEN
   
      TimeIndx      = 1
      V_tmp         = V      (1)
      Delta_tmp     = Delta  (1)
      VZ_tmp        = VZ     (1)
      HShr_tmp      = HShr   (1)
      VShr_tmp      = VShr   (1)
      VLinShr_tmp   = VLinShr(1)
      VGust_tmp     = VGust  (1)   
         
   ELSE IF ( Time >= Tdata(NumDataLines) )  THEN
   
      TimeIndx      = NumDataLines - 1
      V_tmp         = V      (NumDataLines)
      Delta_tmp     = Delta  (NumDataLines)
      VZ_tmp        = VZ     (NumDataLines)
      HShr_tmp      = HShr   (NumDataLines)
      VShr_tmp      = VShr   (NumDataLines)
      VLinShr_tmp   = VLinShr(NumDataLines)
      VGust_tmp     = VGust  (NumDataLines)
      
   ELSE
   
         ! Let's interpolate!

      TimeIndx = MAX( MIN( TimeIndx, NumDataLines-1 ), 1 )

      DO

         IF ( Time < Tdata(TimeIndx) )  THEN

            TimeIndx = TimeIndx - 1

         ELSE IF ( Time >= Tdata(TimeIndx+1) )  THEN

            TimeIndx = TimeIndx + 1

         ELSE
            P           = ( Time - Tdata(TimeIndx) )/( Tdata(TimeIndx+1) - Tdata(TimeIndx) )
            V_tmp       = ( V(      TimeIndx+1) - V(      TimeIndx) )*P + V(      TimeIndx)
            Delta_tmp   = ( Delta(  TimeIndx+1) - Delta(  TimeIndx) )*P + Delta(  TimeIndx)
            VZ_tmp      = ( VZ(     TimeIndx+1) - VZ(     TimeIndx) )*P + VZ(     TimeIndx)
            HShr_tmp    = ( HShr(   TimeIndx+1) - HShr(   TimeIndx) )*P + HShr(   TimeIndx)
            VShr_tmp    = ( VShr(   TimeIndx+1) - VShr(   TimeIndx) )*P + VShr(   TimeIndx)
            VLinShr_tmp = ( VLinShr(TimeIndx+1) - VLinShr(TimeIndx) )*P + VLinShr(TimeIndx)
            VGust_tmp   = ( VGust(  TimeIndx+1) - VGust(  TimeIndx) )*P + VGust(  TimeIndx)
            EXIT

         END IF

      END DO
      
   END IF

   
   !-------------------------------------------------------------------------------------------------
   ! calculate the wind speed at this time
   !-------------------------------------------------------------------------------------------------
   
   CosDelta = COS( Delta_tmp )
   SinDelta = SIN( Delta_tmp )
   
   V1 = V_tmp * ( ( InputPosition(3)/RefHt ) ** VShr_tmp &                                  ! power-law wind shear
        + ( HShr_tmp   * ( InputPosition(2) * CosDelta + InputPosition(1) * SinDelta ) &    ! horizontal linear shear
        +  VLinShr_tmp * ( InputPosition(3)-RefHt ) )/RefWid  ) &                           ! vertical linear shear
        + VGUST_tmp                                                                         ! gust speed
   
   HH_GetWindSpeed%Velocity(1) =  V1 * CosDelta
   HH_GetWindSpeed%Velocity(2) = -V1 * SinDelta
   HH_GetWindSpeed%Velocity(3) =  VZ_tmp      


   RETURN

END FUNCTION HH_GetWindSpeed
!====================================================================================================
FUNCTION HH_Get_ADHack_WindSpeed(Time, InputPosition, ErrStat)
! This subroutine linearly interpolates the columns in the HH input file to get the values for 
! the requested time, then uses the interpolated values to calclate the wind speed at a point
! in space represented by InputPosition. THIS FUNCTION SHOULD BE REMOVED!!!!! (used for DISK VEL ONLY)
!----------------------------------------------------------------------------------------------------

   REAL(ReKi),        INTENT(IN) :: Time                 ! time from the start of the simulation
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)     ! input information: positions X,Y,Z   -   NOT USED HERE!!!
   INTEGER,           INTENT(OUT):: ErrStat              ! error status
   TYPE(InflIntrpOut)            :: HH_Get_ADHack_WindSpeed      ! return velocities (U,V,W)
   
   REAL(ReKi)                    :: Delta_tmp            ! interpolated Delta   at input TIME
   REAL(ReKi)                    :: P                    ! temporary storage for slope (in time) used in linear interpolation
   REAL(ReKi)                    :: V_tmp                ! interpolated V       at input TIME
   REAL(ReKi)                    :: VZ_tmp               ! interpolated VZ      at input TIME
   

   !-------------------------------------------------------------------------------------------------
   ! verify the module was initialized first
   !-------------------------------------------------------------------------------------------------

   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Error: Call HH_Init() before getting wind speed.')
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
      
   !-------------------------------------------------------------------------------------------------
   ! Linearly interpolate in time (or use nearest-neighbor to extrapolate) 
   ! (compare with NWTC_Num.f90\InterpStpReal)
   !-------------------------------------------------------------------------------------------------

     ! Let's check the limits.

   IF ( Time <= Tdata(1) .OR. NumDataLines == 1)  THEN
   
      TimeIndx      = 1
      V_tmp         = V      (1)
      Delta_tmp     = Delta  (1)
      VZ_tmp        = VZ     (1)
         
   ELSE IF ( Time >= Tdata(NumDataLines) )  THEN
   
      TimeIndx      = NumDataLines - 1
      V_tmp         = V      (NumDataLines)
      Delta_tmp     = Delta  (NumDataLines)
      VZ_tmp        = VZ     (NumDataLines)
      
   ELSE
   
         ! Let's interpolate!

      TimeIndx = MAX( MIN( TimeIndx, NumDataLines-1 ), 1 )

      DO

         IF ( Time < Tdata(TimeIndx) )  THEN

            TimeIndx = TimeIndx - 1

         ELSE IF ( Time >= Tdata(TimeIndx+1) )  THEN

            TimeIndx = TimeIndx + 1

         ELSE
            P           = ( Time - Tdata(TimeIndx) )/( Tdata(TimeIndx+1) - Tdata(TimeIndx) )
            V_tmp       = ( V(      TimeIndx+1) - V(      TimeIndx) )*P + V(      TimeIndx)
            Delta_tmp   = ( Delta(  TimeIndx+1) - Delta(  TimeIndx) )*P + Delta(  TimeIndx)
            VZ_tmp      = ( VZ(     TimeIndx+1) - VZ(     TimeIndx) )*P + VZ(     TimeIndx)
            EXIT

         END IF

      END DO
      
   END IF
   
   !-------------------------------------------------------------------------------------------------
   ! calculate the wind speed at this time
   !-------------------------------------------------------------------------------------------------
      
   HH_Get_ADHack_WindSpeed%Velocity(1) =  V_tmp * COS( Delta_tmp )
   HH_Get_ADHack_WindSpeed%Velocity(2) = -V_tmp * SIN( Delta_tmp )
   HH_Get_ADHack_WindSpeed%Velocity(3) =  VZ_tmp      


   RETURN

END FUNCTION HH_Get_ADHack_WindSpeed
!====================================================================================================
SUBROUTINE HH_SetLinearizeDels( Perturbations, ErrStat )
! This subroutine sets the perturbation values for the linearization scheme.
!----------------------------------------------------------------------------------------------------

   REAL(ReKi),       INTENT(IN)  :: Perturbations(7)     ! purturbations for each of the 7 input parameters
   INTEGER,          INTENT(OUT) :: ErrStat              ! time from the start of the simulation

   !-------------------------------------------------------------------------------------------------
   ! verify the module was initialized first
   !-------------------------------------------------------------------------------------------------

   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Error: Call HH_Init() before getting wind speed.')
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF

   Linearize = .TRUE.
   LinearizeDels(:) = Perturbations(:)

   RETURN

END SUBROUTINE HH_SetLinearizeDels
!====================================================================================================
SUBROUTINE HH_Terminate(ErrStat)

   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered

   INTEGER                     :: SumErrs
   
   SumErrs = 0

   IF ( ALLOCATED(Tdata  ) ) DEALLOCATE( Tdata,   STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(DELTA  ) ) DEALLOCATE( DELTA,   STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(V      ) ) DEALLOCATE( V,       STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VZ     ) ) DEALLOCATE( VZ,      STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(HSHR   ) ) DEALLOCATE( HSHR,    STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VSHR   ) ) DEALLOCATE( VSHR,    STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VGUST  ) ) DEALLOCATE( VGUST,   STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VLINSHR) ) DEALLOCATE( VLINSHR, STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)

   ErrStat  = SumErrs
   TimeIndx = 0            
   
END SUBROUTINE HH_Terminate   
!====================================================================================================
END MODULE HHWind
MODULE UserWind
!  The purpose of this module is to allow user-defined wind.  
!----------------------------------------------------------------------------------------------------

   USE                           NWTC_Library
   USE                           SharedInflowDefns

   IMPLICIT                      NONE
   PRIVATE
    
    
      ! define variables for UserWind here
      
   LOGICAL, SAVE              :: Initialized = .FALSE.         ! This variable indicates if the initialization routine has been run
   
   REAL(ReKi)                 :: UWmeanU                       ! Possibly instantaneous, disk-averaged wind speeds.
   REAL(ReKi)                 :: UWmeanV                       !
   REAL(ReKi)                 :: UWmeanW                       !   
   

      ! allow the initialization and termination routines to be public (called from outside)

   PUBLIC                     :: UsrWnd_Init
   PUBLIC                     :: UsrWnd_Terminate
   PUBLIC                     :: UsrWnd_GetValue
   PUBLIC                     :: UsrWnd_GetWindSpeed

CONTAINS
!====================================================================================================
SUBROUTINE UsrWnd_Init(ErrStat)
!  This subroutine is called at the beginning of
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' UserWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Perform any initialization steps here (read input files, etc.)
   !-------------------------------------------------------------------------------------------------
   
   CALL WrScr( '***** NOTE: User-defined wind employed *****' )


      ! Set the disk-average wind vector.
   
   UWmeanU = 10.0
   UWmeanV =  0.0
   UWmeanW =  0.0

   
   !-------------------------------------------------------------------------------------------------
   ! Set the initialization flag
   !-------------------------------------------------------------------------------------------------
   
   Initialized = .TRUE.
   
   RETURN

END SUBROUTINE UsrWnd_Init
!====================================================================================================
FUNCTION UsrWnd_GetValue(VarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the VarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------
   
   CHARACTER(*),   INTENT(IN)    :: VarName
   INTEGER,        INTENT(OUT)   :: ErrStat           ! return 0 if no errors; non-zero otherwise
   REAL(ReKi)                    :: UsrWnd_GetValue

   
   CHARACTER(20)                 :: VarNameUC         ! upper-case VarName
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN   
      CALL WrScr( 'Initialize UserWind before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = VarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
   
      CASE ('MEANU' )
         UsrWnd_GetValue = UWmeanU
         
      CASE ('MEANV' )
         UsrWnd_GetValue = UWmeanV

      CASE ('MEANW' )
         UsrWnd_GetValue = UWmeanW
         
      CASE DEFAULT
         CALL WrScr( ' Invalid variable name in UsrWnd_GetValue().' )
         ErrStat = 1
         
   END SELECT
      
   

END FUNCTION UsrWnd_GetValue
!====================================================================================================
FUNCTION UsrWnd_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are 
! requested. It returns the velocities at the specified time and space.
!----------------------------------------------------------------------------------------------------
   
   REAL(ReKi),        INTENT(IN) :: Time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)        ! X,Y,Z (z is 0 at ground level)
   INTEGER,           INTENT(OUT):: ErrStat                 ! return 0 if no errors; non-zero otherwise
   TYPE(InflIntrpOut)            :: UsrWnd_GetWindSpeed
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   
   IF ( .NOT. Initialized ) THEN   
      CALL WrScr( 'Initialize UserWind before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Calculate the wind speed at this time and position.
   !-------------------------------------------------------------------------------------------------   
   !     Time
   !     X = InputPosition(1)           ! relative to the undeflected tower centerline (positive downwind)
   !     Y = InputPosition(2)           ! relative to the undeflected tower centerline (positive left when looking downwind)
   !     Z = InputPosition(3)           ! relative to the ground (0 is ground level)
   !-------------------------------------------------------------------------------------------------

      ! We'll test this with steady winds for now.

   UsrWnd_GetWindSpeed%Velocity(1) = 10.0    ! U velocity (along positive X)
   UsrWnd_GetWindSpeed%Velocity(2) =  0.0    ! V velocity (along positive Y)
   UsrWnd_GetWindSpeed%Velocity(3) =  0.0    ! V velocity (along positive Z)
   

END FUNCTION UsrWnd_GetWindSpeed
!====================================================================================================
SUBROUTINE UsrWnd_Terminate(ErrStat)
!  This subroutine is called at the end of program execution (including after fatal errors occur).  
!  It should close any files that could be open and deallocate any arrays that have been allocated.
!----------------------------------------------------------------------------------------------------
      
   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   ErrStat = 0

   !-------------------------------------------------------------------------------------------------
   ! Close files
   !-------------------------------------------------------------------------------------------------
      
      
   !-------------------------------------------------------------------------------------------------
   ! Deallocate arrays
   !-------------------------------------------------------------------------------------------------

      
   !-------------------------------------------------------------------------------------------------
   ! Set the initialization flag
   !-------------------------------------------------------------------------------------------------
   
   Initialized = .FALSE.

END SUBROUTINE UsrWnd_Terminate
!====================================================================================================
END MODULE UserWind
MODULE InflowWind
! This module is used to read and process the (undisturbed) inflow winds.  It must be initialized
! using WindInf_Init() with the name of the file, the file type, and possibly reference height and
! width (depending on the type of wind file being used).  This module calls appropriate routines
! in the wind modules so that the type of wind becomes seamless to the user.  WindInf_Terminate()
! should be called when the program has finshed.
!
! Data are assumed to be in units of meters and seconds.  Z is measured from the ground (NOT the hub!).
!
!  7 Oct 2009    Initial Release with AeroDyn 13.00.00      B. Jonkman, NREL/NWTC
! 14 Nov 2011    v1.00.01b-bjj                              B. Jonkman
!  1 Aug 2012    v1.01.00a-bjj                              B. Jonkman
! 10 Aug 2012    v1.01.00b-bjj                              B. Jonkman
!----------------------------------------------------------------------------------------------------

   USE                              NWTC_Library
   USE                              SharedInflowDefns

   !-------------------------------------------------------------------------------------------------
   ! The included wind modules
   !-------------------------------------------------------------------------------------------------

   USE                              FFWind               ! full-field binary wind files
   USE                              HHWind               ! hub-height text wind files
   USE                              FDWind               ! 4-D binary wind files
   USE                              CTWind               ! coherent turbulence from KH billow - binary file superimposed on another wind type
   USE                              UserWind             ! user-defined wind module
   USE                              HAWCWind             ! full-field binary wind files in HAWC format


   IMPLICIT                         NONE
   PRIVATE

   !-------------------------------------------------------------------------------------------------
   ! Private internal variables
   !-------------------------------------------------------------------------------------------------

   INTEGER, SAVE                  :: WindType = Undef_Wind  ! Wind Type Flag

   INTEGER                        :: UnWind   = 91          ! The unit number used for wind inflow files

   LOGICAL, SAVE                  :: CT_Flag  = .FALSE.     ! determines if coherent turbulence is used

   !-------------------------------------------------------------------------------------------------
   ! Definitions of public types and routines
   !-------------------------------------------------------------------------------------------------

   TYPE, PUBLIC :: InflInitInfo
      CHARACTER(1024)             :: WindFileName
      INTEGER                     :: WindFileType
      REAL(ReKi)                  :: ReferenceHeight        ! reference height for HH and/or 4D winds (was hub height), in meters
      REAL(ReKi)                  :: Width                  ! width of the HH file (was 2*R), in meters
   END TYPE InflInitInfo

   PUBLIC                         :: WindInf_Init           ! Initialization subroutine
   PUBLIC                         :: WindInf_GetVelocity    ! function to get wind speed at point in space and time
   PUBLIC                         :: WindInf_Terminate      ! subroutine to clean up

   PUBLIC                         :: WindInf_ADhack_diskVel ! used to keep old AeroDyn functionality--remove soon!
   PUBLIC                         :: WindInf_ADhack_DIcheck ! used to keep old AeroDyn functionality--remove soon!
   PUBLIC                         :: WindInf_LinearizePerturbation !used for linearization; should be modified
!!----Removed during conversion to new framework
!!       PUBLIC                         :: WindInf_GetMean        ! function to get the mean wind speed at a point in space
!!       PUBLIC                         :: WindInf_GetStdDev      ! function to calculate standard deviation at a point in space
!!       PUBLIC                         :: WindInf_GetTI          ! function to get TI at a point in space

   CHARACTER(99),PARAMETER        :: WindInfVer = 'InflowWind (v1.01.00b-bjj, 10-Aug-2012)'

CONTAINS
!====================================================================================================
SUBROUTINE WindInf_Init( FileInfo, ErrStat )
!  Open and read the wind files, allocating space for necessary variables
!
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   TYPE(InflInitInfo), INTENT(IN)   :: FileInfo
   INTEGER,            INTENT(OUT)  :: ErrStat

      ! Local variables

   TYPE(HH_Info)                    :: HHInitInfo
   TYPE(CT_Backgr)                  :: BackGrndValues

   REAL(ReKi)                       :: Height
   REAL(ReKi)                       :: HalfWidth
   CHARACTER(1024)                  :: FileName


   IF ( WindType /= Undef_Wind ) THEN
      CALL WrScr( ' Wind inflow has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      WindType = FileInfo%WindFileType
      FileName = FileInfo%WindFileName
      CALL NWTC_Init()
      CALL WrScr1( ' Using '//TRIM( WindInfVer ) )

   END IF

   !-------------------------------------------------------------------------------------------------
   ! Get default wind type, based on file name, if requested
   !-------------------------------------------------------------------------------------------------
   IF ( FileInfo%WindFileType == DEFAULT_Wind ) THEN
      WindType = GetWindType( FileName, ErrStat )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Check for coherent turbulence file (KH superimposed on a background wind file)
   ! Initialize the CTWind module and initialize the module of the other wind type.
   !-------------------------------------------------------------------------------------------------

   IF ( WindType == CTP_Wind ) THEN

      CALL CT_Init(UnWind, FileName, BackGrndValues, ErrStat)
      IF (ErrStat /= 0) THEN
         CALL WindInf_Terminate( ErrStat )
         WindType = Undef_Wind
         ErrStat  = 1
         RETURN
      END IF

      FileName = BackGrndValues%WindFile
      WindType = BackGrndValues%WindFileType
      CT_Flag  = BackGrndValues%CoherentStr

   ELSE

      CT_Flag  = .FALSE.

   END IF


   !-------------------------------------------------------------------------------------------------
   ! Initialize based on the wind type
   !-------------------------------------------------------------------------------------------------

   SELECT CASE ( WindType )

      CASE (HH_Wind)

         HHInitInfo%ReferenceHeight = FileInfo%ReferenceHeight
         HHInitInfo%Width           = FileInfo%Width

         CALL HH_Init( UnWind, FileName, HHInitInfo, ErrStat )

!        IF (CT_Flag) CALL CT_SetRefVal(FileInfo%ReferenceHeight, 0.5*FileInfo%Width, ErrStat)
         IF (ErrStat == 0 .AND. CT_Flag) CALL CT_SetRefVal(FileInfo%ReferenceHeight, REAL(0.0, ReKi), ErrStat)


      CASE (FF_Wind)

         CALL FF_Init( UnWind, FileName, ErrStat )


            ! Set CT parameters

         IF ( ErrStat == 0 .AND. CT_Flag ) THEN
            Height     = FF_GetValue('HubHeight', ErrStat)
            IF ( ErrStat /= 0 ) Height = FileInfo%ReferenceHeight

            HalfWidth  = 0.5*FF_GetValue('GridWidth', ErrStat)
            IF ( ErrStat /= 0 ) HalfWidth = 0

            CALL CT_SetRefVal(Height, HalfWidth, ErrStat)
         END IF


      CASE (UD_Wind)

         CALL UsrWnd_Init(ErrStat)


      CASE (FD_Wind)

         CALL FD_Init(UnWind, FileName, FileInfo%ReferenceHeight, ErrStat)

      CASE (HAWC_Wind)

         CALL HW_Init( UnWind, FileName, ErrStat )

      CASE DEFAULT

         CALL WrScr(' Error: Undefined wind type in WindInflow_Init()' )
         ErrStat = 1
         RETURN

   END SELECT

   IF ( ErrStat /= 0 ) THEN
      CALL WindInf_Terminate( ErrStat )  !Just in case we've allocated something
      WindType = Undef_Wind
      ErrStat  = 1
   END IF

   RETURN

END SUBROUTINE WindInf_Init
!====================================================================================================
FUNCTION WindInf_GetVelocity(Time, InputPosition, ErrStat)
! Get the wind speed at a point in space and time
!----------------------------------------------------------------------------------------------------

      ! passed variables
   REAL(ReKi),       INTENT(IN)  :: Time
   REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
   INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise

      ! local variables
   TYPE(InflIntrpOut)            :: WindInf_GetVelocity     ! U, V, W velocities
   TYPE(InflIntrpOut)            :: CTWindSpeed             ! U, V, W velocities to superimpose on background wind


   ErrStat = 0

   SELECT CASE ( WindType )
      CASE (HH_Wind)
         WindInf_GetVelocity = HH_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE (FF_Wind)
         WindInf_GetVelocity = FF_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE (UD_Wind)
         WindInf_GetVelocity = UsrWnd_GetWindSpeed( Time, InputPosition, ErrStat )

      CASE (FD_Wind)
         WindInf_GetVelocity = FD_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE (HAWC_Wind)
         WindInf_GetVelocity = HW_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in WindInf_GetVelocity(). ' &
                   //'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1
         WindInf_GetVelocity%Velocity(:) = 0.0

   END SELECT


   IF (ErrStat /= 0) THEN

      WindInf_GetVelocity%Velocity(:) = 0.0

   ELSE

         ! Add coherent turbulence to background wind

      IF (CT_Flag) THEN

         CTWindSpeed = CT_GetWindSpeed(Time, InputPosition, ErrStat)
         IF (ErrStat /=0 ) RETURN

         WindInf_GetVelocity%Velocity(:) = WindInf_GetVelocity%Velocity(:) + CTWindSpeed%Velocity(:)

      ENDIF

   ENDIF

END FUNCTION WindInf_GetVelocity
!====================================================================================================
!!    !====================================================================================================
FUNCTION GetWindType( FileName, ErrStat )
!  This subroutine checks the file FileName to see what kind of wind file we are using.  Used when
!  the wind file type is unknown.
!----------------------------------------------------------------------------------------------------


   IMPLICIT             NONE


      ! Passed Variables:

   CHARACTER(*),INTENT(INOUT) :: FileName
   INTEGER, INTENT(OUT)       :: ErrStat

      ! Function definition
   INTEGER                    :: GetWindType

      ! Local Variables:

   INTEGER                    :: IND
   LOGICAL                    :: Exists

   CHARACTER(  3)             :: FileNameEnd
   CHARACTER(  8)             :: WndFilNam

   CHARACTER(1024)            :: FileRoot


   ErrStat = 0

   !-------------------------------------------------------------------------------------------------
   ! Check for user-defined wind file first; file starts with "USERWIND"
   !-------------------------------------------------------------------------------------------------

   WndFilNam = FileName
   CALL Conv2UC( WndFilNam )

   IF ( WndFilNam == 'USERWIND' )  THEN

      CALL WrScr1( ' Detected user-defined wind file.' )
      GetWindType = UD_Wind

      RETURN
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Get the file extension (or at least what we expect the extension to be)
   !-------------------------------------------------------------------------------------------------
   CALL GetRoot ( FileName, FileRoot )                      ! Get the root name

   IND = LEN_TRIM( FileRoot ) + 1
   IF ( IND < LEN_TRIM( FileName ) ) THEN
      FileNameEnd = FileName(IND+1:)                        ! Get the extenstion, starting at first character past (may not be the whole "extension")
      CALL Conv2UC (FileNameEnd)
   ELSE
      FileNameEnd = ""
      IND = 0
   END IF


   !-------------------------------------------------------------------------------------------------
   ! If there was no '.' in the file name, assume FF, and add a .wnd extension
   !-------------------------------------------------------------------------------------------------
   IF ( IND == 0 ) THEN
      CALL WrScr1(' No file extension found. Assuming '//TRIM(FileName)// &
                  ' is a binary FF wind file with a ".wnd" extension.')
      GetWindType = FF_Wind
      FileName = TRIM(FileName)//'.wnd'
      RETURN
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Base the file type on the extension
   !-------------------------------------------------------------------------------------------------
   SELECT CASE ( TRIM(FileNameEnd) )
      CASE ('WND')

            ! If a summary file exists, assume FF; otherwise, assume HH file.

         INQUIRE ( FILE=FileName(1:IND)//'sum' , EXIST=Exists )
         IF (Exists) THEN
            CALL WrScr1(' Assuming '//TRIM(FileName)//' is a binary FF wind file.')
            GetWindType = FF_Wind
         ELSE
            CALL WrScr1(' Assuming '//TRIM(FileName)//' is a formatted HH wind file.')
            GetWindType = HH_Wind
         END IF

      CASE ('BTS')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a binary FF wind file.')
         GetWindType = FF_Wind

      CASE ('CTP')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a coherent turbulence wind file.')
         GetWindType = CTP_Wind

      CASE ('FDP')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a binary 4-dimensional wind file.')
         GetWindType = FD_Wind

      CASE ('HWC')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' contains full-field wind parameters in HAWC format.')
         GetWindType = HAWC_Wind

      CASE DEFAULT
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a formatted HH wind file.')
         GetWindType = HH_Wind

   END SELECT


RETURN
END FUNCTION GetWindType
!====================================================================================================
SUBROUTINE WindInf_LinearizePerturbation( LinPerturbations, ErrStat )
! This function is used in FAST's linearization scheme.  It should be fixed at some point.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,    INTENT(OUT)    :: ErrStat

   REAL(ReKi), INTENT(IN)     :: LinPerturbations(7)

      ! Local variables


   ErrStat = 0

   SELECT CASE ( WindType )
      CASE (HH_Wind)

         CALL HH_SetLinearizeDels( LinPerturbations, ErrStat )

      CASE ( FF_Wind, UD_Wind, FD_Wind, HAWC_Wind )

         CALL WrScr( ' Error: Linearization is valid only with HH wind files.' )
         ErrStat = 1

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in WindInf_LinearizePerturbation(). '// &
                     'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1

   END SELECT


END SUBROUTINE WindInf_LinearizePerturbation
!====================================================================================================
FUNCTION WindInf_ADhack_diskVel( Time, InpPosition, ErrStat )
! This function should be deleted ASAP.  It's purpose is to reproduce results of AeroDyn 12.57;
! when a consensus on the definition of "average velocity" is determined, this function will be
! removed.  InpPosition(2) should be the rotor radius; InpPosition(3) should be hub height
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   REAL(ReKi), INTENT(IN)     :: Time
   REAL(ReKi), INTENT(IN)     :: InpPosition(3)
   INTEGER, INTENT(OUT)       :: ErrStat

      ! Function definition
   REAL(ReKi)                 :: WindInf_ADhack_diskVel(3)

      ! Local variables
   TYPE(InflIntrpOut)         :: NewVelocity             ! U, V, W velocities
   REAL(ReKi)                 :: Position(3)
   INTEGER                    :: IY
   INTEGER                    :: IZ


   ErrStat = 0

   SELECT CASE ( WindType )
      CASE (HH_Wind)

!      VXGBAR =  V * COS( DELTA )
!      VYGBAR = -V * SIN( DELTA )
!      VZGBAR =  VZ

         Position    = (/ REAL(0.0, ReKi), REAL(0.0, ReKi), InpPosition(3) /)
         NewVelocity = HH_Get_ADHack_WindSpeed(Time, Position, ErrStat)

         WindInf_ADhack_diskVel(:) = NewVelocity%Velocity(:)


      CASE (FF_Wind)
!      VXGBAR = MeanFFWS
!      VYGBAR = 0.0
!      VZGBAR = 0.0

         WindInf_ADhack_diskVel(1)   = FF_GetValue('MEANFFWS', ErrStat)
         WindInf_ADhack_diskVel(2:3) = 0.0

      CASE (UD_Wind)
!      VXGBAR = UWmeanU
!      VYGBAR = UWmeanV
!      VZGBAR = UWmeanW

         WindInf_ADhack_diskVel(1)   = UsrWnd_GetValue('MEANU', ErrStat)
         IF (ErrStat /= 0) RETURN
         WindInf_ADhack_diskVel(2)   = UsrWnd_GetValue('MEANV', ErrStat)
         IF (ErrStat /= 0) RETURN
         WindInf_ADhack_diskVel(3)   = UsrWnd_GetValue('MEANW', ErrStat)

      CASE (FD_Wind)
!      XGrnd = 0.0
!      YGrnd = 0.5*RotDiam
!      ZGrnd = 0.5*RotDiam
!      CALL FD_Interp
!      VXGBAR = FDWind( 1 )
!      VYGBAR = FDWind( 2 )
!      VZGBAR = FDWind( 3 )
!
!      XGrnd =  0.0
!      YGrnd = -0.5*RotDiam
!      ZGrnd =  0.5*RotDiam
!      CALL FD_Interp
!      VXGBAR = VXGBAR + FDWind( 1 )
!      VYGBAR = VYGBAR + FDWind( 2 )
!      VZGBAR = VZGBAR + FDWind( 3 )
!
!      XGrnd =  0.0
!      YGrnd = -0.5*RotDiam
!      ZGrnd = -0.5*RotDiam
!      CALL FD_Interp
!      VXGBAR = VXGBAR + FDWind( 1 )
!      VYGBAR = VYGBAR + FDWind( 2 )
!      VZGBAR = VZGBAR + FDWind( 3 )
!
!      XGrnd =  0.0
!      YGrnd =  0.5*RotDiam
!      ZGrnd = -0.5*RotDiam
!      CALL FD_Interp
!      VXGBAR = 0.25*( VXGBAR + FDWind( 1 ) )
!      VYGBAR = 0.25*( VYGBAR + FDWind( 2 ) )
!      VZGBAR = 0.25*( VZGBAR + FDWind( 3 ) )


         Position(1) = 0.0
         WindInf_ADhack_diskVel(:) = 0.0

         DO IY = -1,1,2
            Position(2)  =  IY*FD_GetValue('RotDiam',ErrStat)

            DO IZ = -1,1,2
               Position(3)  = IZ*InpPosition(2) + InpPosition(3)

               NewVelocity = WindInf_GetVelocity(Time, Position, ErrStat)
               WindInf_ADhack_diskVel(:) = WindInf_ADhack_diskVel(:) + NewVelocity%Velocity(:)
            END DO
         END DO
         WindInf_ADhack_diskVel(:) = 0.25*WindInf_ADhack_diskVel(:)

      CASE (HAWC_Wind)
         WindInf_ADhack_diskVel(1)   = HW_GetValue('UREF', ErrStat)
         WindInf_ADhack_diskVel(2:3) = 0.0

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in WindInf_ADhack_diskVel(). '// &
                    'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1

   END SELECT

   RETURN

END FUNCTION WindInf_ADhack_diskVel
!====================================================================================================
FUNCTION WindInf_ADhack_DIcheck( ErrStat )
! This function should be deleted ASAP.  It's purpose is to reproduce results of AeroDyn 12.57;
! it performs a wind speed check for the dynamic inflow initialization
! it returns MFFWS for the FF wind files; for all others, a sufficiently large number is used ( > 8 m/s)
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER, INTENT(OUT)       :: ErrStat

      ! Function definition
   REAL(ReKi)                 :: WindInf_ADhack_DIcheck


   ErrStat = 0

   SELECT CASE ( WindType )
      CASE (HH_Wind, UD_Wind, FD_Wind )

         WindInf_ADhack_DIcheck = 50  ! just return something greater than 8 m/s

      CASE (FF_Wind)

         WindInf_ADhack_DIcheck = FF_GetValue('MEANFFWS', ErrStat)

      CASE (HAWC_Wind)

         WindInf_ADhack_DIcheck = HW_GetValue('UREF', ErrStat)

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in WindInf_ADhack_DIcheck(). '// &
                    'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1

   END SELECT

   RETURN

END FUNCTION WindInf_ADhack_DIcheck
!====================================================================================================
SUBROUTINE WindInf_Terminate( ErrStat )
! Clean up the allocated variables and close all open files.  Reset the initialization flag so
! that we have to reinitialize before calling the routines again.
!----------------------------------------------------------------------------------------------------

   INTEGER, INTENT(OUT)       :: ErrStat     !bjj: do we care if there's an error on cleanup?


      ! Close the wind file, if it happens to be open

   CLOSE( UnWind )


      ! End the sub-modules (deallocates their arrays and closes their files):

   SELECT CASE ( WindType )

      CASE (HH_Wind)
         CALL HH_Terminate(     ErrStat )

      CASE (FF_Wind)
         CALL FF_Terminate(     ErrStat )

      CASE (UD_Wind)
         CALL UsrWnd_Terminate( ErrStat )

      CASE (FD_Wind)
         CALL FD_Terminate(     ErrStat )

      CASE (HAWC_Wind)
         CALL HW_Terminate(     ErrStat )

      CASE ( Undef_Wind )
         ! Do nothing

      CASE DEFAULT  ! keep this check to make sure that all new wind types have a terminate function
         CALL WrScr(' Undefined wind type in WindInf_Terminate().' )
         ErrStat = 1

   END SELECT

!   IF (CT_Flag) CALL CT_Terminate( ErrStat )
   CALL CT_Terminate( ErrStat )


      ! Reset the wind type so that the initialization routine must be called
  WindType = Undef_Wind
   CT_Flag  = .FALSE.


END SUBROUTINE WindInf_Terminate
!====================================================================================================
END MODULE InflowWind





!!----Remove this functionality for now. Might put it back in sometime after the conversion to the new framework ----
!!    FUNCTION WindInf_GetMean(StartTime, EndTime, delta_time, InputPosition,  ErrStat )
!!    !  This function returns the mean wind speed
!!    !----------------------------------------------------------------------------------------------------
!!
!!          ! passed variables
!!       REAL(ReKi),       INTENT(IN)  :: StartTime
!!       REAL(ReKi),       INTENT(IN)  :: EndTime
!!       REAL(ReKi),       INTENT(IN)  :: delta_time
!!       REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
!!       INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise
!!
!!          ! function definition
!!       REAL(ReKi)                    :: WindInf_GetMean(3)      ! MEAN U, V, W
!!
!!          ! local variables
!!       REAL(ReKi)                    :: Time
!!       REAL(DbKi)                    :: SumVel(3)
!!       INTEGER                       :: I
!!       INTEGER                       :: Nt
!!
!!       TYPE(InflIntrpOut)            :: NewVelocity             ! U, V, W velocities
!!
!!
!!       Nt = (EndTime - StartTime) / delta_time
!!
!!       SumVel(:) = 0.0
!!       ErrStat   = 0
!!
!!
!!       DO I=1,Nt
!!
!!          Time = StartTime + (I-1)*delta_time
!!
!!          NewVelocity = WindInf_GetVelocity(Time, InputPosition, ErrStat)
!!          IF ( ErrStat /= 0 ) THEN
!!             WindInf_GetMean(:) = SumVel(:) / REAL(I-1, ReKi)
!!             RETURN
!!          ELSE
!!             SumVel(:) = SumVel(:) + NewVelocity%Velocity(:)
!!          END IF
!!
!!       END DO
!!
!!       WindInf_GetMean(:) = SumVel(:) / REAL(Nt, ReKi)
!!
!!
!!    END FUNCTION WindInf_GetMean
!!    !====================================================================================================
!!    FUNCTION WindInf_GetStdDev(StartTime, EndTime, delta_time, InputPosition,  ErrStat )
!!    !  This function returns the mean wind speed (mean, std, TI, etc)
!!    !----------------------------------------------------------------------------------------------------
!!
!!          ! passed variables
!!       REAL(ReKi),       INTENT(IN)  :: StartTime
!!       REAL(ReKi),       INTENT(IN)  :: EndTime
!!       REAL(ReKi),       INTENT(IN)  :: delta_time
!!       REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
!!       INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise
!!
!!          ! function definition
!!       REAL(ReKi)                    :: WindInf_GetStdDev(3)    ! STD U, V, W
!!
!!          ! local variables
!!       REAL(ReKi)                    :: Time
!!       REAL(ReKi), ALLOCATABLE       :: Velocity(:,:)
!!       REAL(DbKi)                    :: SumAry(3)
!!       REAL(DbKi)                    :: MeanVel(3)
!!       INTEGER                       :: I
!!       INTEGER                       :: Nt
!!
!!       TYPE(InflIntrpOut)            :: NewVelocity             ! U, V, W velocities
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Initialize
!!       !-------------------------------------------------------------------------------------------------
!!
!!       WindInf_GetStdDev(:) = 0.0
!!
!!       Nt = (EndTime - StartTime) / delta_time
!!
!!       IF ( Nt < 2 ) RETURN    ! StdDev is 0
!!
!!
!!       IF (.NOT. ALLOCATED(Velocity)) THEN
!!    !      CALL AllocAry( Velocity, 3, Nt, 'StdDev velocity', ErrStat)
!!          ALLOCATE ( Velocity(3, Nt), STAT=ErrStat )
!!
!!          IF ( ErrStat /= 0 )  THEN
!!             CALL WrScr ( ' Error allocating memory for the StdDev velocity array.' )
!!             RETURN
!!          END IF
!!       END IF
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the mean, storing the velocity for later
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          Time = StartTime + (I-1)*delta_time
!!
!!          NewVelocity = WindInf_GetVelocity(Time, InputPosition, ErrStat)
!!          IF ( ErrStat /= 0 ) RETURN
!!          Velocity(:,I) = NewVelocity%Velocity(:)
!!          SumAry(:)     = SumAry(:) + NewVelocity%Velocity(:)
!!
!!       END DO
!!
!!       MeanVel(:) = SumAry(:) / REAL(Nt, ReKi)
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the standard deviation
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          SumAry(:) = SumAry(:) + ( Velocity(:,I) - MeanVel(:) )**2
!!
!!       END DO ! I
!!
!!       WindInf_GetStdDev(:) = SQRT( SumAry(:) / ( Nt - 1 ) )
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Deallocate
!!       !-------------------------------------------------------------------------------------------------
!!       IF ( ALLOCATED(Velocity) ) DEALLOCATE( Velocity )
!!
!!
!!    END FUNCTION WindInf_GetStdDev
!!    !====================================================================================================
!!    FUNCTION WindInf_GetTI(StartTime, EndTime, delta_time, InputPosition,  ErrStat )
!!    !  This function returns the TI of the wind speed.  It's basically a copy of WindInf_GetStdDev,
!!    !  except the return value is divided by the mean U-component wind speed.
!!    !----------------------------------------------------------------------------------------------------
!!
!!          ! passed variables
!!       REAL(ReKi),       INTENT(IN)  :: StartTime
!!       REAL(ReKi),       INTENT(IN)  :: EndTime
!!       REAL(ReKi),       INTENT(IN)  :: delta_time
!!       REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
!!       INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise
!!
!!          ! function definition
!!       REAL(ReKi)                    :: WindInf_GetTI(3)        ! TI U, V, W
!!
!!          ! local variables
!!       REAL(ReKi)                    :: Time
!!       REAL(ReKi), ALLOCATABLE       :: Velocity(:,:)
!!       REAL(DbKi)                    :: SumAry(3)
!!       REAL(DbKi)                    :: MeanVel(3)
!!       INTEGER                       :: I
!!       INTEGER                       :: Nt
!!
!!       TYPE(InflIntrpOut)            :: NewVelocity             ! U, V, W velocities
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Initialize
!!       !-------------------------------------------------------------------------------------------------
!!
!!       WindInf_GetTI(:) = 0.0
!!
!!       Nt = (EndTime - StartTime) / delta_time
!!
!!       IF ( Nt < 2 ) RETURN    ! StdDev is 0
!!
!!
!!       IF (.NOT. ALLOCATED(Velocity)) THEN
!!    !      CALL AllocAry( Velocity, 3, Nt, 'TI velocity', ErrStat)
!!          ALLOCATE ( Velocity(3, Nt), STAT=ErrStat )
!!
!!          IF ( ErrStat /= 0 )  THEN
!!             CALL WrScr ( ' Error allocating memory for the TI velocity array.' )
!!             RETURN
!!          END IF
!!       END IF
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the mean, storing the velocity for later
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          Time = StartTime + (I-1)*delta_time
!!
!!          NewVelocity = WindInf_GetVelocity(Time, InputPosition, ErrStat)
!!          IF ( ErrStat /= 0 ) RETURN
!!          Velocity(:,I) = NewVelocity%Velocity(:)
!!          SumAry(:)     = SumAry(:) + NewVelocity%Velocity(:)
!!
!!       END DO
!!
!!       MeanVel(:) = SumAry(:) / REAL(Nt, ReKi)
!!
!!       IF ( ABS(MeanVel(1)) <= EPSILON(MeanVel(1)) ) THEN
!!          CALL WrScr( ' Wind speed is small in WindInf_GetTI(). TI is undefined.' )
!!          ErrStat = 1
!!          RETURN
!!       END IF
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the standard deviation
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          SumAry(:) = SumAry(:) + ( Velocity(:,I) - MeanVel(:) )**2
!!
!!       END DO ! I
!!
!!       WindInf_GetTI(:) = SQRT( SumAry(:) / ( Nt - 1 ) ) / MeanVel(1)
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Deallocate
!!       !-------------------------------------------------------------------------------------------------
!!       IF ( ALLOCATED(Velocity) ) DEALLOCATE( Velocity )
!!
!!
!!    END FUNCTION WindInf_GetTI
!****************************************************************************
!
!  PROGRAM: InflowWind_Test  - This program tests the inflow wind module
!
!****************************************************************************

PROGRAM InflowWind_Test
    
   USE InflowWind
   USE SharedInflowDefns
          
   IMPLICIT NONE
    
   INTEGER ErrStat
   TYPE(InflInitInfo)  :: InitWindData         ! data to initialize the module; TYPE defined in InflowWindMod.f90
    
   REAL(ReKi)          :: InpPosition(3)
   TYPE(InflIntrpOut)  :: MyWindSpeed
   REAL(ReKi)          :: Time

   REAL(ReKi)          :: dt
   INTEGER             :: I


   !-------------------------------------------------------------------------------------------------
   ! Send the data required for initialization
   !-------------------------------------------------------------------------------------------------
    
!      InitWindData%WindFileName     = "D:\DATA\Fortran\IVF Projects\AeroDyn\Update\Source\InflowWind\TestData\GPLLJ_DNS\InOut.wnd"
!      InitWindData%WindFileName     = "../TestRoutines/TestData/Periodic_Winds.wnd"    !! ff wind
!      InitWindData%WindFileName     = "Test-Data/InOut.wnd"    !! ff wind
!      InitWindData%WindFileName     = "../Samples/Steady.wnd"  !! HH wind
      InitWindData%WindFileName     = "../Samples/les.fdp"  !! 4 D -- points to some other files.
      InitWindData%ReferenceHeight  = 80.   ! meters
      InitWindData%Width            = 100.  ! meters

!     InitWindData%WindFileType     = FF_Wind  
      InitWindData%WindFileType     = DEFAULT_Wind      ! let the module figure out what type of file it is...
      

      CALL WindInf_Init( InitWindData, ErrStat )    


      IF (errstat /=0) CALL ProgAbort('Error in Initialization routine')
      
   
   !-------------------------------------------------------------------------------------------------
   ! Get the wind speeds at various times and positions
   !-------------------------------------------------------------------------------------------------
      dt     = 0.05 ! seconds   
   
      InpPosition(1) = 0.0                            ! longitudinal position front/back of tower
      InpPosition(2) = 0.0                            ! lateral position left/right of tower
      InpPosition(3) = InitWindData%ReferenceHeight   ! height relative to the ground
    
      DO I = 1,3 !time
          
         Time = 0.0 + (I-1)*dt
          
         MyWindSpeed = WindInf_GetVelocity( Time, InpPosition, ErrStat )
         
         !IF (ErrStat /=0) CALL ProgAbort('Error in getting wind speed')
            
         WRITE(*,*) TRIM(Num2LStr(ErrStat)), ' V(t=', TRIM(Num2LStr(Time)), ') = ', MyWindSpeed

      END DO
    
   !-------------------------------------------------------------------------------------------------
   ! Clean up the variables and close files
   !-------------------------------------------------------------------------------------------------
    CALL WindInf_Terminate( ErrStat )


END PROGRAM InflowWind_Test

!=======================================================================
MODULE Precision


   ! This module stores constants to specify the KIND of variables.

IMPLICIT                           NONE

   ! These values should not vary from DoubPrec.f90:
   
INTEGER, PARAMETER              :: B1Ki     = SELECTED_INT_KIND(  2 )           ! Kind for one-byte whole numbers
INTEGER, PARAMETER              :: B2Ki     = SELECTED_INT_KIND(  4 )           ! Kind for two-byte whole numbers
INTEGER, PARAMETER              :: B4Ki     = SELECTED_INT_KIND(  9 )           ! Kind for four-byte whole numbers
INTEGER, PARAMETER              :: B8Ki     = SELECTED_INT_KIND( 18 )           ! Kind for eight-byte whole numbers

INTEGER, PARAMETER              :: QuKi     = SELECTED_REAL_KIND( 20, 500 )     ! Kind for 16-byte, floating-point numbers
INTEGER, PARAMETER              :: R8Ki     = SELECTED_REAL_KIND( 14, 300 )     ! Kind for eight-byte floating-point numbers
INTEGER, PARAMETER              :: SiKi     = SELECTED_REAL_KIND(  6,  30 )     ! Kind for four-byte, floating-point numbers


      ! The default kinds for reals and integers:
      
INTEGER, PARAMETER              :: IntKi    = B4Ki                              ! Default kind for integers
INTEGER, PARAMETER              :: ReKi     = SiKi                              ! Default kind for floating-point numbers
INTEGER, PARAMETER              :: DbKi     = R8Ki                              ! Default kind for double floating-point numbers


      ! The number of bytes in the default variables

INTEGER(IntKi), PARAMETER       :: BytesPerReKi  = 4                            ! Number of bytes per ReKi number     - use SIZEOF()           
INTEGER(IntKi), PARAMETER       :: BytesPerDbKi  = 8                            ! Number of bytes per DbKi number     - use SIZEOF()          
INTEGER(IntKi), PARAMETER       :: BytesPerIntKi = 4                            ! Number of bytes per IntKi number    - use SIZEOF()           


END MODULE Precision
MODULE SysSubs


   ! This module contains routines with system-specific logic and references.
   ! It also contains standard (but not system-specific) routines it uses.

   ! SysGnu.f90 is specifically for the GNU Fortran (gfortran) compiler on Linux. This should also work for gfortran on MAC.


   ! It contains the following routines:

   !     FUNCTION    COMMAND_ARGUMENT_COUNT()
   !     SUBROUTINE  FileSize ( FileName, Size )
   !     SUBROUTINE  FindLine ( Str , MaxLen , StrEnd )
   !     SUBROUTINE  FlushOut ( Unit )
   !     SUBROUTINE  Get_Arg ( Arg_Num , Arg , Error )                                      ! Please use GET_COMMAND_ARGUMENT() instead.
   !     SUBROUTINE  Get_Arg_Num ( Arg_Num )                                                ! Please use COMMAND_ARGUMENT_COUNT() instead.
   !     SUBROUTINE  GET_COMMAND ( Command, Length, Status )
   !     SUBROUTINE  GET_COMMAND_ARGUMENT ( Number, Value, Length, Status )
   !     SUBROUTINE  GET_CWD( DirName, Status )
   !     FUNCTION    Get_Env( EnvVar )                                                      ! Please use GET_ENVIRONMENT_VARIABLE() instead.
   !     FUNCTION    GET_ENVIRONMENT_VARIABLE( Name, Value, Length, Status, Trim_Name )
   !     FUNCTION    Is_NaN( DblNum )                                                       ! Please use IEEE_IS_NAN() instead
   !     SUBROUTINE  OpenBinFile ( Un, OutFile, RecLen, Error )
   !     SUBROUTINE  OpenBinInpFile( Un, InFile, Error )
   !     SUBROUTINE  OpenCon
   !     SUBROUTINE  OpenUnfInpBEFile ( Un, InFile, RecLen, Error )
   !     SUBROUTINE  ProgExit ( StatCode )
   !     SUBROUTINE  UsrAlarm
   !     FUNCTION    UserTime()                                                             ! Removed: Replace by F95 intrinsic, CPU_TIME().
   !     SUBROUTINE  WrNR ( Str )
   !     SUBROUTINE  WrOver ( Str )
   !     SUBROUTINE  WrScr ( Str )




   USE                             Precision

   IMPLICIT                        NONE


!=======================================================================


   INTEGER                      :: ConRecL  = 120                               ! The record length for console output.
   INTEGER                      :: CU       = 6 !7                                 ! The I/O unit for the console.
   INTEGER                      :: NL_Len   = 2                                 ! The number of characters used for a new line.

   CHARACTER(10)                :: Endian   = 'BIG_ENDIAN'                      ! The internal format of numbers.
   CHARACTER( 1)                :: PathSep  = '\'                               ! The path separater.
   CHARACTER( 1)                :: SwChar   = '/'                               ! The switch character for command-line options.
!20110512 jm changed from 'BINARY' to 'UNFORMATTED' because 'BINARY' is not
!standard and caused problems in OPEN statements in NWTC_iO.f90 that use
!this definition
   CHARACTER(11)                :: UnfForm  = 'UNFORMATTED'                     ! The string to specify unformatted I/O files.


CONTAINS

!=======================================================================
   FUNCTION COMMAND_ARGUMENT_COUNT()


      ! This routine returns the number of argumenta entered on the command line..

      ! Note: This routine will be available intrinsically in Fortran 2000.


      ! Function declaration.

   INTEGER                      :: COMMAND_ARGUMENT_COUNT                       ! This function.  The command line.



      ! Determine the mumber of arguments.  Load the program name into the result.

   COMMAND_ARGUMENT_COUNT = IArgC()


   RETURN
   END FUNCTION COMMAND_ARGUMENT_COUNT ! ()
!=======================================================================
   SUBROUTINE FileSize ( FileName, Size )


      ! This routine calls the routine Stat to obtain the file size
      ! corresponding to a file name or returns -1 on error.

      ! mlb: WARNING!!!
      ! The standard version of the routine uses the file unit instead of file name.
      ! We need fix the routines that call this one.


      ! Argument declarations:

   INTEGER, INTENT(OUT)         :: Size

   CHARACTER(*), INTENT(IN)     :: FileName


      ! Intrinsic declarations:

   INTEGER(KIND=1)              :: Stat


      ! Local declarations:

   INTEGER                      :: StatArray(12)
   INTEGER                      :: Status



   Status = Stat( FileName, StatArray )

   IF ( Status /= 0 ) THEN
     Size = -1
   ELSE
     Size = StatArray(8)
   END IF


   RETURN
   END SUBROUTINE FileSize ! ( FileName, Size )
!=======================================================================
   SUBROUTINE FindLine ( Str , MaxLen , StrEnd )


      ! This routine finds one line of text with a maximum length of MaxLen from the Str.
      ! It tries to break the line at a blank.

      ! This routine isn't system specific, but it is called by WrScr(), which is, so it must be here.


   IMPLICIT                        NONE


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: MaxLen                                       ! The maximum length of the string.
   INTEGER, INTENT(OUT)         :: StrEnd                                       ! The location of the end of the string.

   CHARACTER(*), INTENT(IN)     :: Str                                          ! The string to search.


      ! Local declarations:

   INTEGER         IC



   StrEnd = MaxLen

   IF ( LEN_TRIM( Str ) > MaxLen )  THEN

      IC = INDEX( Str(1:MaxLen), ' ', BACK = .TRUE. ) ! Find the last space in the line

      IF ( IC > 1 ) THEN ! We don't want to return just one character that's a space, or do we?

         StrEnd = IC-1    ! StrEnd > 0
         DO WHILE ( Str(StrEnd:StrEnd) == ' ' )
            StrEnd = StrEnd - 1
            IF ( StrEnd <= 0 ) THEN  ! This occurs if everything before IC is a space
               StrEnd = IC
               EXIT
            ENDIF
         ENDDO

      ENDIF ! IC > 1

   ENDIF ! LEN_TRIM( Str ) > MaxLen


   RETURN
   END SUBROUTINE FindLine ! ( Str , MaxLen , StrEnd )
!=======================================================================
   SUBROUTINE FlushOut ( Unit )


      ! This subroutine flushes the buffer on the specified Unit.
      ! It is especially useful when printing "running..." type messages.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: Unit                                         ! The unit number of the file being flushed.



  ! CALL FLUSH ( Unit )


   RETURN
   END SUBROUTINE FlushOut ! ( Unit )
!=======================================================================
   SUBROUTINE Get_Arg ( Arg_Num , Arg , Error )


      ! This routine gets Arg_Num'th argument from the command line.

   ! Note: The functionality in this routine was replaced by GET_COMMAND_ARGUMENT(), which is available intrinsically in Fortran 2000.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Arg_Num                                      ! The argument number to get.

   LOGICAL, INTENT(OUT)         :: Error                                        ! The Error flag returned to the calling program.

   CHARACTER(*), INTENT(OUT)    :: Arg                                          ! The argument string returned to the calling program.


      ! Local declarations.

   INTEGER                      :: Status                                       ! The status of the attempt to get an argument.



   CALL GETARG ( Arg_Num, Arg )  !20110512 jm remove 3rd arg for Linux port

   IF ( LEN_TRIM( Arg ) > 0 )  THEN
      Error = .FALSE.
   ELSE
      Error = .TRUE.
   END IF


   RETURN
   END SUBROUTINE Get_Arg ! ( Arg_Num , Arg , Error )
!=======================================================================
   SUBROUTINE Get_Arg_Num ( Arg_Num )


      ! This routine gets the number of command line arguments.

   ! Note: The functionality in this routine was replaced by COMMAND_ARGUMENT_COUNT(), which will be available intrinsically in Fortran 2000.


      ! Argument declarations.

   INTEGER, INTENT(OUT)         :: Arg_Num                                      ! The argument to get from the command line.



   Arg_Num = IARGC()


   RETURN
   END SUBROUTINE Get_Arg_Num ! ( Arg_Num )
!=======================================================================
   SUBROUTINE GET_COMMAND ( Command, Length, Status )


      ! This routine returns the string associated with the full command line.
      ! It tries as best it can to mimic the Fortran 2000 intrinsic subroutine by the same name.


      ! Argument declarations.

   INTEGER, OPTIONAL, INTENT(OUT)      :: Length                                ! The length of the value of the environment variable.
   INTEGER, OPTIONAL, INTENT(OUT)      :: Status                                ! The status indication what happened.

   CHARACTER(*), OPTIONAL, INTENT(OUT) :: Command                               ! The command line.


      ! Local parameter declarations.

   INTEGER, PARAMETER                  :: MaxLen = 500                          ! The maximum length permitted for an environment variable value.


      ! Local declarations.

   INTEGER                             :: CallStat                              ! Status of the call.
   INTEGER                             :: IArg                                  ! Argument index.

   CHARACTER(MaxLen)                   :: Arg                                   ! The current argument.
   CHARACTER(MaxLen)                   :: ReturnVal                             ! The value that will be returned.



      ! Initialize the result with the program name.

   CALL GETARG ( 0, ReturnVal )  !20110512 jm remove 3rd arg for Linux port


      ! Loop through all the arguments and build the total command line.

   DO IArg=1,IArgC()
      CALL GETARG ( IArg, Arg )  !20110512 jm remove 3rd arg for Linux port
      ReturnVal = TRIM( ReturnVal )//' '//TRIM( Arg )
   END DO ! IArg


      ! When asking the OS about the variable, trim the name unless Trim_Name is false.

   IF ( PRESENT( Command ) )  Command = ReturnVal
   IF ( PRESENT( Length  ) )  Length  = LEN_TRIM( ReturnVal )
   IF ( PRESENT( Status  ) )  Status  = 0


   RETURN
   END SUBROUTINE GET_COMMAND ! ( Command, Length, Status )
!=======================================================================
   SUBROUTINE GET_COMMAND_ARGUMENT ( Number, Value, Length, Status )


      ! This routine returns the string associated with the Numberth command-line argument.
      ! It tries as best it can to mimic the Fortran 2000 intrinsic function by the same name.


      ! Argument declarations.

   INTEGER, OPTIONAL, INTENT(OUT)      :: Length                                ! The length of the value of the environment variable.
   INTEGER, INTENT(IN)                 :: Number                                ! The number of the argument desired.
   INTEGER, OPTIONAL, INTENT(OUT)      :: Status                                ! The status indication what happened.

   CHARACTER(*), OPTIONAL, INTENT(OUT) :: Value                                 ! The command line argument.


      ! Local parameter declarations.

   INTEGER, PARAMETER                  :: MaxLen = 500                          ! The maximum length permitted for an environment variable value.


      ! Local declarations.

   INTEGER                             :: CallStat                              ! The status of the intrinsic call.

   CHARACTER(MaxLen)                   :: ReturnVal                             ! The value that will be returned.



      ! Get the argument.

   CALL GETARG ( Number, ReturnVal )  !20110512 jm remove 3rd arg for Linux port


      ! Load up the return values.

   IF ( PRESENT( Value  ) )  Value  = ReturnVal
   IF ( PRESENT( Length ) )  Length = LEN_TRIM( ReturnVal )
   IF ( PRESENT( Status ) )  Status = CallStat


   RETURN
   END SUBROUTINE GET_COMMAND_ARGUMENT ! ( Number, Value, Length, Status )
!=======================================================================
!bjj note: this subroutine is not tested for this compiler
   SUBROUTINE Get_CWD ( DirName, Status )


      ! This routine retrieves the path of the current working directory.


   IMPLICIT                        NONE


      ! Passed variables.

   CHARACTER(*), INTENT(OUT)    :: DirName                                         ! A CHARACTER string containing the path of the current working directory.
   INTEGER,      INTENT(OUT)    :: Status                                          ! Status returned by the call to a portability routine.


   Status = GETCWD ( DirName )

   RETURN
   END SUBROUTINE Get_CWD
!=======================================================================
   FUNCTION Get_Env( EnvVar )


      ! This routine returns the string associated with the EnvVar environment variable in the OS.
      ! It returns the null string of the variable is not found.

   ! Note: The functionality in this routine was replaced by GET_ENVIRONMENT_VARIABLE(), which will be available intrinsically in Fortran 2000.


      ! Function declaration.

   CHARACTER(500)               :: Get_Env                                      ! This function.  The value of the environment variable.


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: EnvVar                                       ! The environment variable to look up.



   CALL GetEnv ( EnvVar, Get_Env )


   RETURN
   END FUNCTION Get_Env ! ( EnvVar )
!=======================================================================
   FUNCTION GET_ENVIRONMENT_VARIABLE( Name, Value, Length, Status, Trim_Name )


      ! This routine returns the string associated with the Name environment variable in the OS.
      ! It tries as best it can to mimic the Fortran 2000 intrinsic function by the same name.


      ! Argument declarations.

   INTEGER, OPTIONAL, INTENT(OUT)      :: Length                                ! The length of the value of the environment variable.
   INTEGER, OPTIONAL, INTENT(OUT)      :: Status                                ! The status indication what happened.

   LOGICAL, OPTIONAL, INTENT(IN)       :: Trim_Name                             ! Treat trailing blanks in Name as significant if true.

   CHARACTER(*), INTENT(IN)            :: Name                                  ! The environment variable to look up.
   CHARACTER(*), OPTIONAL, INTENT(OUT) :: Value                                 ! The found value of the environment variable, Name.


      ! Local parameter declarations.

   INTEGER, PARAMETER                  :: MaxLen = 500                          ! The maximum length permitted for an environment variable value.


      ! Function declaration.

   CHARACTER(MaxLen)                   :: GET_ENVIRONMENT_VARIABLE              ! This function.  The value of the environment variable.


      ! Local declarations.

   CHARACTER(MaxLen)                   :: ReturnVal                             ! The value that will be returned.



      ! When asking the OS about the variable, trim the name unless Trim_Name is false.

   IF ( PRESENT( Trim_Name ) )  THEN
      IF ( Trim_Name )  THEN
         CALL GetEnv ( TRIM( Name ), ReturnVal )
      ELSE
         CALL GetEnv ( Name, ReturnVal )
      END IF
   ELSE
      CALL GetEnv ( TRIM( Name ), ReturnVal )
   END IF

   IF ( PRESENT( Value ) )  Value = ReturnVal

   IF ( PRESENT( Length ) )  Length = LEN_TRIM( ReturnVal )


      ! If requested, set the status of the OS request.

      ! Because the VF-specific GetEnv() is less capable than the Fortran 2000 intrinsic, we can't distinguish
      ! between a variable whose value is all blanks and one that is not set.

   IF ( PRESENT( Status ) )  THEN
      IF ( LEN_TRIM( ReturnVal ) == 0 )  THEN
         Status = 1
      ELSE
         Status = 0
      END IF
   END IF

   GET_ENVIRONMENT_VARIABLE = ReturnVal


   RETURN
   END FUNCTION GET_ENVIRONMENT_VARIABLE ! ( Name, Value, Length, Status, Trim_Name )
!=======================================================================
   FUNCTION Is_NaN( DblNum )


      ! This routine determines if a REAL(DbKi) variable holds a proper number.
      ! BJJ: this routine is used in CRUNCH.
      ! Note that IsNaN does not exist in earlier versions of gfortran (e.g., 4.2.1), 
      ! but does exist in version 4.4. It should be replaced with the standard 
      ! IEEE_IS_NAN when gfortran implements it.


      ! Argument declarations.

   REAL(DbKi), INTENT(IN)       :: DblNum


      ! Function declaration.

   LOGICAL                      :: Is_Nan



   Is_NaN = IsNaN( DblNum )


   RETURN
   END FUNCTION Is_NaN ! ( DblNum )
!=======================================================================
   SUBROUTINE OpenBinFile ( Un, OutFile, RecLen, Error )


      ! This routine opens a binary output file.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the output file.
   INTEGER, INTENT(IN)          :: RecLen                                       ! Length of binary record.

   LOGICAL, INTENT(OUT)         :: Error                                        ! Flag to indicate the open failed.

   CHARACTER(*), INTENT(IN)     :: OutFile                                      ! Name of the output file.


      ! Local declarations.

   INTEGER                      :: IOS                                          ! I/O status of OPEN.



      ! Open output file.  Make sure it worked.

!20110512 jm Change ACCESS from Sequential to F03std 'stream' to avoid reading/writing record block control words
   OPEN( Un, FILE=TRIM( OutFile ), STATUS='UNKNOWN', FORM='UNFORMATTED' , ACCESS='STREAM', IOSTAT=IOS )

   IF ( IOS /= 0 )  THEN
      Error = .TRUE.
   ELSE
      Error = .FALSE.
   END IF


   RETURN
   END SUBROUTINE OpenBinFile ! ( Un, OutFile, RecLen, Error )
!=======================================================================
   SUBROUTINE OpenBinInpFile ( Un, InFile, Error )


      ! This routine opens a binary input file.

   IMPLICIT                        NONE



      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the input file.

   CHARACTER(*), INTENT(IN)     :: InFile                                       ! Name of the input file.

   LOGICAL, INTENT(OUT)         :: Error                                        ! Flag to indicate the open failed.


      ! Local declarations.

   INTEGER                      :: IOS                                          ! I/O status of OPEN.

      ! NOTE: Do not explicitly declare the precision of this variable [as in
      !       LOGICAL(1)] so that the statements using this variable work with
      !       any compiler:


      ! Open input file.  Make sure it worked.

!20110512 jm Change ACCESS from Sequential to F03std 'stream' to avoid reading/writing record block control words
   OPEN( Un, FILE=TRIM( InFile ), STATUS='OLD', FORM='UNFORMATTED', ACCESS='STREAM', IOSTAT=IOS, ACTION='READ' )

   IF ( IOS /= 0 )  THEN
      Error = .TRUE.
   ELSE
      Error = .FALSE.
   END IF


   RETURN
   END SUBROUTINE OpenBinInpFile
!=======================================================================
 SUBROUTINE OpenCon


      ! This routine opens the console for standard output.



   OPEN ( CU , FILE='/dev/stdout' , STATUS='OLD' )

   CALL FlushOut ( CU )


   RETURN
   END SUBROUTINE OpenCon
!=======================================================================
   SUBROUTINE OpenUnfInpBEFile ( Un, InFile, RecLen, Error )


      ! This routine opens a binary input file with data stored in Big Endian format (created on a UNIX machine.)
      ! Data are stored in RecLen-byte records.

   IMPLICIT                        NONE



      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the input file.

   CHARACTER(*), INTENT(IN)     :: InFile                                       ! Name of the input file.

   INTEGER, INTENT(IN)          :: RecLen                                       ! Size of records in the input file, in bytes.

   LOGICAL, INTENT(OUT)         :: Error                                        ! Flag to indicate the open failed.


      ! Local declarations.

   INTEGER                      :: IOS                                          ! I/O status of OPEN.



      ! Open input file.  Make sure it worked.

   ! The non-standard CONVERT keyword allows us to read UNIX binary files, whose bytes are in reverse order (i.e., stored in BIG ENDIAN format).

   ! NOTE: using RecLen in bytes requires using the /assume:byterecl compiler option!

   OPEN ( Un, FILE=TRIM( InFile ), STATUS='OLD', FORM='UNFORMATTED', ACCESS='DIRECT', RECL=RecLen, IOSTAT=IOS, &
                   ACTION='READ'  )                                              ! Use this for UNIX systems.
!                  ACTION='READ', CONVERT='BIG_ENDIAN' )                         ! Use this for PC systems.


   IF ( IOS /= 0 )  THEN
      Error = .TRUE.
   ELSE
      Error = .FALSE.
   END IF


   RETURN
   END SUBROUTINE OpenUnfInpBEFile
!=======================================================================
   SUBROUTINE ProgExit ( StatCode )


      ! This routine stops the program.  If the compiler supports the EXIT routine,
      ! pass the program status to it.  Otherwise, do a STOP.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: StatCode                                      ! The status code to pass to the OS.



   CALL EXIT ( StatCode )

!   IF ( StatCode == 0 ) THEN
!      STOP 0
!   ELSE
!      IF ( StatCode < 0 ) THEN
!         CALL WrScr( 'Invalid STOP code.' )
!      END IF
!
!      STOP 1
!   END IF


   RETURN
   END SUBROUTINE ProgExit ! ( StatCode )
!=======================================================================
   SUBROUTINE UsrAlarm


      ! This routine generates an alarm to warn the user that something went wrong.



   CALL WrOver ( CHAR( 7 ) )


   RETURN
   END SUBROUTINE UsrAlarm
!=======================================================================
!   FUNCTION UserTime()
!
!
!      ! This function returns the user CPU time.
!
!      ! The functionality of this routine was replaced by the F95 intrinsic, CPU_TIME().
!
!
!      ! Passed variables.
!
!   REAL(4)                      :: UserTime                                        ! User CPU time.
!
!
!      ! Local variables.
!
!   REAL(4)                      :: TimeAry (2)                                     ! TimeAry(1): User CPU time, TimeAry(2): System CPU time.
!   REAL(4)                      :: TotTime                                         ! User CPU time plus system CPU time.
!
!
!
!
!   TotTime  = DTIME( TimeAry )
!   UserTime = TimeAry(1)
!
!
!   RETURN
!   END FUNCTION UserTime
!=======================================================================
   SUBROUTINE WrNR ( Str )


      ! This routine writes out a string to the screen without following it with a new line.


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: Str                                          ! The string to write to the screen.



   WRITE (CU,'(1X,A)',ADVANCE='NO')  Str


   RETURN
   END SUBROUTINE WrNR ! ( Str )
!=======================================================================
   SUBROUTINE WrOver ( Str )


      ! This routine writes out a string that overwrites the previous line


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: Str                                          ! The string to write to the screen.



   WRITE (CU,'(''+'',A)')  Str


   RETURN
   END SUBROUTINE WrOver ! ( Str )
!=======================================================================
   SUBROUTINE WrScr ( Str )


      ! This routine writes out a string to the screen.


   IMPLICIT                        NONE


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: Str                                          ! The string to write to the screen.


      ! Local declarations.

   INTEGER                      :: Beg                                          ! The beginning of the next line of text.
   INTEGER                      :: Indent                                       ! The amunt to be indented.
   INTEGER                      :: LStr                                         ! The length of the remaining portion of the string.
   INTEGER                      :: MaxLen                                       ! Maximum number of columns to be written to the screen.

   CHARACTER(10)                :: Frm                                          ! Format specifier for the output.



      ! Find the amount of indent.  Create format.

   MaxLen = 98
   Indent = LEN_TRIM( Str ) - LEN_TRIM( ADJUSTL( Str ) )
   Indent = MIN( Indent, MaxLen-2 )                                              ! at least 2 characters per line
   MaxLen = MaxLen - Indent

   IF ( Indent > 0 )  THEN
      Frm    = '(1X,  X,A)'
      WRITE (Frm(5:6),'(I2)')  Indent
   ELSE
      Frm    = '(1X,A)'
   END IF



   !  Break long messages into multiple lines.

   Beg  = Indent + 1
   LStr = LEN_TRIM( Str(Beg:) )

   DO WHILE ( Lstr > MaxLen )

      CALL FindLine ( Str(Beg:) , MaxLen , LStr )

      WRITE (CU,Frm)  TRIM( ADJUSTL( Str(Beg:Beg+LStr-1) ) )

      Beg = Beg + LStr


         ! If we have a space at the beginning of the string, let's get rid of it

      DO WHILE ( Beg < LEN_TRIM( Str ) .AND. Str(Beg:Beg) == ' ' )
         Beg = Beg + 1
      ENDDO

      LStr = LEN_TRIM( Str(Beg:) )

   ENDDO

   IF ( LStr > 0 ) THEN
      WRITE (CU,Frm)  TRIM( ADJUSTL( Str(Beg:Beg+LStr-1) ) )
   ELSE
      WRITE (CU,'()')
   END IF


   RETURN
   END SUBROUTINE WrScr ! ( Str )
!=======================================================================

END MODULE SysSubs
MODULE NWTC_IO


   ! This module contains I/O-related variables and routines with non-system-specific logic.


   ! It contains the following routines:

   !     SUBROUTINE CheckArgs     ( InputFile [, ErrStat] )
   !     SUBROUTINE CheckIOS      ( IOS, Fil, Variable, VarType [, TrapErrors] )
   !     SUBROUTINE CloseEcho     ( )
   !     SUBROUTINE Conv2UC       ( Str )
   !     FUNCTION   CountWords    ( Line )
   !     FUNCTION   CurDate       ( )
   !     FUNCTION   CurTime       ( )
   !     SUBROUTINE DispNVD       ( )
   !     FUNCTION   Flt2LStr      ( FltNum )
   !     SUBROUTINE GetNewUnit    ( UnIn )
   !     SUBROUTINE GetPath       ( GivenFil, PathName )
   !     SUBROUTINE GetRoot       ( GivenFil, RootName )
   !     SUBROUTINE GetTokens     ( Line, NumTok, Tokens, Error )
   !     SUBROUTINE GetWords      ( Line, Words, NumWords )
   !     FUNCTION   GetNVD        ( ProgDesc )
   !     FUNCTION   Int2LStr      ( Intgr )
   !     SUBROUTINE NameOFile     ( InArg, OutExten, OutFile )
   !     SUBROUTINE NormStop      ( )
   !     FUNCTION   Num2LStr      ( Num )                                                             ! Generic interface for Int2LStr, R2LStr4, R2LStr8, R2LStr16
   !     SUBROUTINE OpenBin       ( Un, OutFile, RecLen [, ErrStat] )
   !     SUBROUTINE OpenBInpFile  ( Un, InFile [, ErrStat] )
   !     SUBROUTINE OpenEcho      ( Un, InFile [, ErrStat] )
   !     SUBROUTINE OpenFInpFile  ( Un, InFile [, ErrStat] )
   !     SUBROUTINE OpenFOutFile  ( Un, OutFile [, ErrStat] )
   !     SUBROUTINE OpenFUnkFile  ( Un, OutFile, FailAbt, Failed, Exists [, ErrStat] )
   !     SUBROUTINE OpenUInfile   ( Un, InFile [, ErrStat] )
   !     SUBROUTINE OpenUInBEFile ( Un, InFile, RecLen [, ErrStat] )
   !     SUBROUTINE OpenUOutfile  ( Un, OutFile [, ErrStat] )
   !     FUNCTION   PathIsRelative( GivenFil )
   !     SUBROUTINE PremEOF       ( Fil , Variable [, TrapErrors] )
   !     SUBROUTINE ProgAbort     ( Message [, TrapErrors] )
   !     SUBROUTINE ProgWarn      ( Message )
   !     SUBROUTINE ReadAry       ( UnIn, Fil, Ary, AryLen, AryName, AryDescr [, ErrStat] )           ! Generic interface for ReadCAry, ReadIAry, ReadLAry, and ReadRAry.
   !     SUBROUTINE ReadAryLines  ( UnIn, Fil, Ary, AryLen, AryName, AryDescr [, ErrStat] )           ! Generic interface for ReadCAryLines, ReadRAryLines4, ReadRAryLines8, and ReadRAryLines16.
   !     SUBROUTINE ReadCAry      ( UnIn, Fil, CharAry, AryLen, AryName, AryDescr [, ErrStat] )
   !     SUBROUTINE ReadCAryLines ( UnIn, Fil, CharAry, AryLen, AryName, AryDescr [, ErrStat] )
   !     SUBROUTINE ReadCom       ( UnIn, Fil, ComName [, ErrStat] )
   !     SUBROUTINE ReadCVar      ( UnIn, Fil, CharVar, VarName, VarDescr [, ErrStat] )
   !     SUBROUTINE ReadFASTbin   ( UnIn, FASTdata [, ErrLev, ErrMsg] )                               ! Read a FAST binary output file.
   !     SUBROUTINE ReadIAry      ( UnIn, Fil, IntAry, AryLen, AryName, AryDescr [, ErrStat] )
   !     SUBROUTINE ReadIVar      ( UnIn, Fil, IntVar, VarName, VarDescr [, ErrStat] )
   !     SUBROUTINE ReadLAry      ( UnIn, Fil, LogAry, AryLen, AryName, AryDescr [, ErrStat] )
   !     SUBROUTINE ReadLVar      ( UnIn, Fil, LogVar, VarName, VarDescr [, ErrStat] )
   !     SUBROUTINE ReadNum       ( UnIn, Fil, Word, VarName, ErrStat )
   !     SUBROUTINE ReadOutputList( UnIn, Fil, CharAry, AryLenRead, AryName, AryDescr, ErrStat )
   !     SUBROUTINE ReadRAry      ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
   !     SUBROUTINE ReadRAryLines ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
   !     SUBROUTINE ReadRVar      ( UnIn, Fil, RealVar, VarName, VarDescr [, ErrStat] )
   !     SUBROUTINE ReadStr       ( UnIn, Fil, CharVar, VarName, VarDescr [, ErrStat] )
   !     SUBROUTINE ReadVar       ( UnIn, Fil, Var, VarName, VarDescr [, ErrStat] )                   ! Generic interface for ReadCVar, ReadIVar, ReadLVar, and ReadRVar.
   !     SUBROUTINE WaitTime      ( WaitSecs )
   !     SUBROUTINE WrPr          ( Str )
   !     SUBROUTINE WrFileNR      ( Unit, Str )
   !     SUBROUTINE WrML          ( Str )
   !     SUBROUTINE WrScr1        ( Str )


   USE                             SysSubs

   IMPLICIT  NONE

!=======================================================================

   TYPE, PUBLIC :: ProgDesc
      CHARACTER(24)              :: Name
      CHARACTER(99)              :: Ver
      CHARACTER(24)              :: Date
   END TYPE ProgDesc

   TYPE, PUBLIC :: FASTdataType                                                  ! The derived type for holding FAST binary output data.
      CHARACTER(1024)            :: File                                         ! The name of the binary input file containing FAST output.
      CHARACTER(1024)            :: Descr                                        ! The file descriptor stored in the FAST binary output file.
      INTEGER(B4Ki)              :: NumChans                                     ! The number of channels of FAST output data (including time).
      INTEGER(B4Ki)              :: NumRecs                                      ! The number of records of FAST output data.
      REAL(R8Ki)                 :: TimeStep                                     ! The time step.
      CHARACTER(20), ALLOCATABLE :: ChanNames(:)                                 ! The channel names.
      CHARACTER(20), ALLOCATABLE :: ChanUnits(:)                                 ! The channel units.
      REAL(ReKi)   , ALLOCATABLE :: Data(:,:)                                    ! The channel data.  Time is stored in the first column.
   END TYPE FASTdataType

   INTEGER(IntKi), PARAMETER     :: ErrID_None   = 0
   INTEGER(IntKi), PARAMETER     :: ErrID_Info   = 1
   INTEGER(IntKi), PARAMETER     :: ErrID_Warn   = 2
   INTEGER(IntKi), PARAMETER     :: ErrID_Severe = 3
   INTEGER(IntKi), PARAMETER     :: ErrID_Fatal  = 4

   INTEGER(IntKi)                :: AbortErrLev  = ErrID_Fatal

      ! Global I/O-related variables.

   INTEGER(IntKi), PARAMETER     :: FlgType  = 1                                 ! Switch for telling if a variable is a flag.
   INTEGER(IntKi), PARAMETER     :: NumType  = 2                                 ! Switch for telling if a variable is a number.
   INTEGER(IntKi), PARAMETER     :: StrType  = 3                                 ! Switch for telling if a variable is a string.
   INTEGER                       :: UnEc     = 19                                ! I/O unit number for the echo file.

   LOGICAL                       :: Beep     = .TRUE.                            ! Flag that specifies whether or not to beep for error messages and program terminations.
   LOGICAL                       :: Echo     = .FALSE.                           ! Flag that specifies whether or not to produce an echo file.

   TYPE(ProgDesc), PARAMETER     :: NWTC_Ver = ProgDesc( 'NWTC Subroutine Library', 'v1.06.00b-bjj', '07-Dec-2012')       ! The name, version, and date of the NWTC Subroutine Library.
   CHARACTER(20)                 :: ProgName = ' '                               ! The name of the calling program.
   CHARACTER(99)                 :: ProgVer                                      ! The version (including date) of the calling program.
   CHARACTER(1), PARAMETER       :: Tab      = CHAR( 9 )                         ! The tab character.


!=======================================================================

      ! Create interface for a generic AllocAry that actually uses specific routines.

   INTERFACE AllocAry
      MODULE PROCEDURE AllCAry1
      MODULE PROCEDURE AllCAry2
      MODULE PROCEDURE AllCAry3
   !   MODULE PROCEDURE AllCAry4                               Not yet coded.
      MODULE PROCEDURE AllIAry1
      MODULE PROCEDURE AllIAry2
      MODULE PROCEDURE AllIAry3
   !   MODULE PROCEDURE AllIAry4                               Not yet coded.
      MODULE PROCEDURE AllLAry1
      MODULE PROCEDURE AllLAry2
      MODULE PROCEDURE AllLAry3
   !   MODULE PROCEDURE AllLAry4                               Not yet coded.
      MODULE PROCEDURE AllRAry1
      MODULE PROCEDURE AllRAry2
      MODULE PROCEDURE AllRAry3
      MODULE PROCEDURE AllRAry4
   END INTERFACE


      ! Create interface for a generic ReadVar that actually uses specific routines.

   INTERFACE ReadVar
      MODULE PROCEDURE ReadCVar
      MODULE PROCEDURE ReadIVar
      MODULE PROCEDURE ReadLVar
      MODULE PROCEDURE ReadR4Var     ! 4-byte real
      MODULE PROCEDURE ReadR8Var     ! 8-byte real
      MODULE PROCEDURE ReadR16Var    ! 16-byte real
   END INTERFACE


      ! Create interface for a generic ReadAry that actually uses specific routines.

   INTERFACE ReadAry
      MODULE PROCEDURE ReadCAry
      MODULE PROCEDURE ReadIAry
      MODULE PROCEDURE ReadLAry
      MODULE PROCEDURE ReadRAry ! replace with routines for 4-, 8-, and 16-byte reals
   END INTERFACE


   INTERFACE ReadAryLines
      MODULE PROCEDURE ReadCAryLines
      MODULE PROCEDURE ReadRAryLines4
      MODULE PROCEDURE ReadRAryLines8
      MODULE PROCEDURE ReadRAryLines16
!     MODULE PROCEDURE ReadIAryLines         ! Not coded yet
!     MODULE PROCEDURE ReadLAryLines         ! Not coded yet
   END INTERFACE


      ! Create interface for a generic Num2LStr that actually uses specific routines.

   INTERFACE Num2LStr
      MODULE PROCEDURE Int2LStr        ! default integers
      MODULE PROCEDURE R2LStr4         ! 4-byte  reals
      MODULE PROCEDURE R2LStr8         ! 8-byte  reals
      MODULE PROCEDURE R2LStr16        ! 16-byte reals
   END INTERFACE


      ! Create interface for DispNVD so that we can pass in the name of the program

   INTERFACE DispNVD
      MODULE PROCEDURE DispNVD0        ! No arguments.
      MODULE PROCEDURE DispNVD1        ! Single argument of TYPE ProgDesc
      MODULE PROCEDURE DispNVD2        ! Two arguments of TYPE character
   END INTERFACE


CONTAINS

!=======================================================================
   SUBROUTINE AdjRealStr( NumStr )

      ! This routine adjusts strings created from real numbers (4, 8, or 16-byte)
      ! It removes leading spaces and trailing zeros. It is intended to be called
      ! from routines R2LStr4, R2LStr8, and R2LStr16.

   CHARACTER(*), INTENT(INOUT) :: NumStr       ! String representing a real number (e.g., from R2LStr4)

         ! Local declarations.

   INTEGER                      :: IC          ! Character index.


   NumStr = ADJUSTL( NumStr )


      ! Replace trailing zeros and possibly the decimal point with blanks.
      ! Stop trimming once we find the decimal point or a nonzero.


      ! Don't remove (important!) trailing zeros if they are in the exponent:

   IF (INDEX( NumStr, "E" ) > 0 ) RETURN
   IF (INDEX( NumStr, "e" ) > 0 ) RETURN

      ! These are not in the exponent

   DO IC=LEN_TRIM( NumStr ),1,-1

      IF ( NumStr(IC:IC) == '.' )  THEN
         NumStr(IC:IC) = ' '
         RETURN
      ELSE IF ( NumStr(IC:IC) /= '0' )  THEN
         RETURN
      END IF

      NumStr(IC:IC) = ' '

   END DO ! IC


   END SUBROUTINE AdjRealStr
!=======================================================================
   SUBROUTINE AllCAry1 ( Ary, AryDim, Descr, ErrStat )

      ! This routine allocates a 1-D CHARACTER array.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryDim                                      ! The size of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error


   CHARACTER(*), ALLOCATABLE    :: Ary    (:)                                 ! Array to be allocated
   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim) , STAT=Sttus )


   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus

   RETURN
   END SUBROUTINE AllCAry1 ! ( Ary, AryDim, Descr )
!=======================================================================
   SUBROUTINE AllCAry2 (  Ary, AryDim1, AryDim2, Descr, ErrStat )

      ! This routine allocates a 2-D CHARACTER array.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), ALLOCATABLE    :: Ary    (:,:)                                ! Array to be allocated
   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllCAry2 ! (  Ary, AryDim1, AryDim2, Descr )
!=======================================================================
   SUBROUTINE AllCAry3 (  Ary, AryDim1, AryDim2, AryDim3, Descr, ErrStat )


      ! This routine allocates a 3-D CHARACTER array.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim3                                     ! The size of the third dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error


   CHARACTER(*), ALLOCATABLE    :: Ary    (:,:,:)                              ! Array to be allocated
   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2,AryDim3) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllCAry3 ! (  Ary, AryDim1, AryDim2, AryDim3, Descr )
!=======================================================================
   SUBROUTINE AllIAry1 ( Ary, AryDim, Descr, ErrStat )


      ! This routine allocates a 1-D INTEGER array.


      ! Argument declarations.

   INTEGER, ALLOCATABLE         :: Ary    (:)                                  ! Array to be allocated
   INTEGER, INTENT(IN)          :: AryDim                                      ! The size of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus

   RETURN
   END SUBROUTINE AllIAry1 ! ( Ary, AryDim, Descr )
!=======================================================================
   SUBROUTINE AllIAry2 (  Ary, AryDim1, AryDim2, Descr, ErrStat )


      ! This routine allocates a 2-D INTEGER array.


      ! Argument declarations.

   INTEGER, ALLOCATABLE         :: Ary    (:,:)                                ! Array to be allocated
   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus

   RETURN
   END SUBROUTINE AllIAry2 ! (  Ary, AryDim1, AryDim2, Descr )
!=======================================================================
   SUBROUTINE AllIAry3 (  Ary, AryDim1, AryDim2, AryDim3, Descr, ErrStat )


      ! This routine allocates a 3-D INTEGER array.


      ! Argument declarations.

   INTEGER, ALLOCATABLE         :: Ary    (:,:,:)                              ! Array to be allocated
   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim3                                     ! The size of the third dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2,AryDim3) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllIAry3 ! (  Ary, AryDim1, AryDim2, AryDim3, Descr )
!=======================================================================
   SUBROUTINE AllLAry1 ( Ary, AryDim, Descr, ErrStat )


      ! This routine allocates a 1-D LOGICAL array.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryDim                                      ! The size of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   LOGICAL, ALLOCATABLE         :: Ary    (:)                                  ! Array to be allocated

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllLAry1 ! ( Ary, AryDim, Descr )
!=======================================================================
   SUBROUTINE AllLAry2 (  Ary, AryDim1, AryDim2, Descr, ErrStat )


      ! This routine allocates a 2-D LOGICAL array.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   LOGICAL, ALLOCATABLE         :: Ary    (:,:)                                ! Array to be allocated

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllLAry2 ! (  Ary, AryDim1, AryDim2, Descr )
!=======================================================================
   SUBROUTINE AllLAry3 (  Ary, AryDim1, AryDim2, AryDim3, Descr, ErrStat )


      ! This routine allocates a 3-D LOGICAL array.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim3                                     ! The size of the third dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   LOGICAL, ALLOCATABLE         :: Ary    (:,:,:)                              ! Array to be allocated

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2,AryDim3) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllLAry3 ! (  Ary, AryDim1, AryDim2, AryDim3, Descr )
!=======================================================================
   SUBROUTINE AllRAry1 ( Ary, AryDim, Descr, ErrStat )


      ! This routine allocates a 1-D REAL array.


      ! Argument declarations.

   REAL(ReKi), ALLOCATABLE      :: Ary    (:)                                  ! Array to be allocated

   INTEGER, INTENT(IN)          :: AryDim                                      ! The size of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllRAry1 ! ( Ary, AryDim, Descr )
!=======================================================================
   SUBROUTINE AllRAry2 (  Ary, AryDim1, AryDim2, Descr, ErrStat )


      ! This routine allocates a 2-D REAL array.


      ! Argument declarations.

   REAL(ReKi), ALLOCATABLE      :: Ary    (:,:)                                ! Array to be allocated

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllRAry2 ! (  Ary, AryDim1, AryDim2, Descr )
!=======================================================================
   SUBROUTINE AllRAry3 (  Ary, AryDim1, AryDim2, AryDim3, Descr, ErrStat )


      ! This routine allocates a 3-D REAL array.


      ! Argument declarations.

   REAL(ReKi), ALLOCATABLE      :: Ary    (:,:,:)                              ! Array to be allocated

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim3                                     ! The size of the third dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2,AryDim3) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
  END SUBROUTINE AllRAry3 ! (  Ary, AryDim1, AryDim2, AryDim3, Descr )
!=======================================================================
   SUBROUTINE AllRAry4 (  Ary, AryDim1, AryDim2, AryDim3, AryDim4, Descr, ErrStat )


      ! This routine allocates a 4-D REAL array.


      ! Argument declarations.

   REAL(ReKi), ALLOCATABLE      :: Ary    (:,:,:,:)                            ! Array to be allocated

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim3                                     ! The size of the third dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim4                                     ! The size of the fourth dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2,AryDim3,AryDim4) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
  END SUBROUTINE AllRAry4 ! (  Ary, AryDim1, AryDim2, AryDim3, AryDim4, Descr )
!=======================================================================
!bjj: shouldn't this come after the next subroutine, alphabetically?
   SUBROUTINE CheckIOS ( IOS, Fil, Variable, VarType, TrapErrors )


      ! This routine checks the I/O status and prints either an end-of-file or
      ! an invalid-input message, and then aborts the program.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: IOS                                          ! I/O status.
   INTEGER, INTENT(IN)          :: VarType                                      ! Type of variable.

   LOGICAL, INTENT(IN), OPTIONAL:: TrapErrors                                   ! Determines if the program should abort or return to calling function
   LOGICAL                      :: TrapThisError                                ! The local version of TrapErrors

   CHARACTER(*), INTENT(IN)     :: Fil                                          ! Name of input file.
   CHARACTER(*), INTENT(IN)     :: Variable                                     ! Variable name.


   IF ( PRESENT( TrapErrors ) ) THEN
      TrapThisError = TrapErrors
   ELSE
      TrapThisError = .FALSE.
   END IF


   IF ( IOS < 0 )  THEN

      CALL PremEOF ( TRIM( Fil ), Variable, TrapThisError )

   ELSE IF ( IOS > 0 )  THEN

      SELECTCASE ( VarType )

      CASE ( NumType )
         CALL WrScr1 ( ' Invalid numerical input for file "'//TRIM( Fil )//'".' )
      CASE ( FlgType )
         CALL WrScr1 ( ' Invalid logical input for file "'//TRIM( Fil )//'".' )
      CASE ( StrType )
         CALL WrScr1 ( ' Invalid character input for file "'//TRIM( Fil )//'".' )
      ENDSELECT

      CALL ProgAbort  ( ' The error occurred while trying to read '//TRIM( Variable )//'.', TrapThisError )

   END IF


   RETURN
   END SUBROUTINE CheckIOS ! ( IOS, Fil, Variable, VarType )
!=======================================================================
   SUBROUTINE CheckArgs ( InputFile, ErrStat )


      ! This subroutine is used to check for command-line arguments.


      ! Argument declarations:
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                      ! Error status; if present, program does not abort on error
!bjj: I made this INOUT instead of OUT so that a default input name can be used
!bjj: MLB requests no default InputFile names be allowed; generate error when there is InputFile listed
!Thus, change to
! CALL WrScr1   ( '    '//TRIM( ProgName )//' ['//SwChar//'h] <InputFile>' )
! and add error when NumArg == 0

   CHARACTER(*), INTENT(INOUT)  :: InputFile                                    ! The name of the input file specified on the command line.


      ! Local declarations:

   INTEGER                      :: IArg                                         ! The argument number.
   INTEGER                      :: NumArg                                       ! The number of arguments on the command line.

   LOGICAL                      :: Error                                        ! Flag indicating if there was an error getting an argument.

   CHARACTER(LEN(InputFile))    :: Arg                                          ! A command-line argument.




      ! Find out how many arguments were entered on the command line.

   CALL Get_Arg_Num ( NumArg )


      ! Parse them.

   IF ( NumArg .GT. 0 )  THEN

      DO IArg=1,NumArg

         CALL Get_Arg ( IArg , Arg , Error )

         IF ( Error )  THEN
            CALL ProgAbort ( ' Error getting command-line argument #'//TRIM( Int2LStr( IArg ) )//'.', PRESENT(ErrStat) )
            IF ( PRESENT(ErrStat) ) THEN
               ErrStat = 1
               RETURN
            END IF
         END IF

         IF ( Arg(1:1) == SwChar )  THEN

            CALL WrScr1   ( ' Syntax is:' )
            CALL WrScr1   ( '    '//TRIM( ProgName )//' ['//SwChar//'h] [<InputFile>]' )
            CALL WrScr1   ( ' where:' )
            CALL WrScr1   ( '    '//SwChar//'h generates this help message.' )
            CALL WrScr    ( '    <InputFile> is the name of the primary input file ['//TRIM( InputFile )//'].' )
            CALL WrScr    ( ' ')

            IF ( INDEX( 'Hh?', Arg(2:2)  ) > 0 )  THEN
               IF ( PRESENT(ErrStat) ) THEN
                  ErrStat = -1
                  RETURN
               ELSE
                  CALL ProgExit ( 1 )
               END IF
            ELSE
               CALL ProgAbort ( ' Invalid command-line switch "'//SwChar//TRIM( Arg(2:) )//'".', PRESENT(ErrStat) )
               IF ( PRESENT(ErrStat) ) THEN
                  ErrStat = 1
                  RETURN
               END IF
            END IF

         ELSE
            InputFile = Arg
         END IF

      END DO

   END IF

   IF ( PRESENT( ErrStat ) ) ErrStat = 0

   RETURN
   END SUBROUTINE CheckArgs
!=======================================================================
   SUBROUTINE CloseEcho( )

      ! This subroutine closes the echo file and sets Echo to false

      CLOSE ( UnEc )

      Echo  = .FALSE.

   END SUBROUTINE CloseEcho
!=======================================================================
   SUBROUTINE Conv2UC ( Str )


      ! This routine converts all the text in a string to upper case.


      ! Argument declarations.

   CHARACTER(*), INTENT(INOUT)  :: Str                                          ! The string to be converted to UC.


      ! Local declarations.

   INTEGER                      :: IC                                           ! Character index



   DO IC=1,LEN_TRIM( Str )

      IF ( ( Str(IC:IC) >= 'a' ).AND.( Str(IC:IC) <= 'z' ) )  THEN
         Str(IC:IC) = CHAR( ICHAR( Str(IC:IC) ) - 32 )
      ELSE
         Str(IC:IC) = Str(IC:IC)
      END IF

   END DO ! IC


   RETURN
   END SUBROUTINE Conv2UC !  ( Str )
!=======================================================================
   FUNCTION CountWords ( Line )


      ! This subroutine is used to count the number of "words" in a line of text.
      ! It uses spaces, tabs, commas, semicolons, single quotes, and double quotes ("whitespace")
      !  as word separators.


      ! Function declaration.

   INTEGER                      :: CountWords                                   ! This function.


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: Line                                         ! Count the words in this text string.


      ! Local declarations.

   INTEGER                      :: Ch                                           ! Character position.
   INTEGER                      :: NextWhite                                    ! Position of the next white space.



      ! Let's initialize the number of columns and the character pointer.

   CountWords = 0


      ! Let's make sure we have text on this line.

   IF ( LEN_TRIM( Line ) == 0 )  RETURN


      ! Count words separated by any combination of spaces, tabs, commas,
      ! semicolons, single quotes, and double quotes ("whitespace").

   Ch = 0

   DO

      NextWhite = SCAN( Line(Ch+1:) , ' ,;''"'//Tab )
      Ch        = Ch + NextWhite

      IF ( NextWhite > 1 )  THEN
         CountWords = CountWords + 1
      ELSE IF ( NextWhite == 1 )  THEN
         CYCLE
      ELSE
         EXIT
      END IF

   END DO


   RETURN
   END FUNCTION CountWords ! ( Line )
!=======================================================================
   FUNCTION CurDate( )


      ! This function returns a character string encoded with the date in the form dd-mmm-ccyy.


      ! Function declaration.

   CHARACTER(11)                :: CurDate                                      ! This function


      ! Local declarations.

   CHARACTER(8)                 :: CDate                                        ! String to hold the returned value from the DATE_AND_TIME subroutine call.



   !  Call the system date function.

   CALL DATE_AND_TIME ( CDate )


   !  Parse out the day.

   CurDate(1:3) = CDate(7:8)//'-'


   !  Parse out the month.

   SELECT CASE ( CDate(5:6) )
      CASE ( '01' )
         CurDate(4:6) = 'Jan'
      CASE ( '02' )
         CurDate(4:6) = 'Feb'
      CASE ( '03' )
         CurDate(4:6) = 'Mar'
      CASE ( '04' )
         CurDate(4:6) = 'Apr'
      CASE ( '05' )
         CurDate(4:6) = 'May'
      CASE ( '06' )
         CurDate(4:6) = 'Jun'
      CASE ( '07' )
         CurDate(4:6) = 'Jul'
      CASE ( '08' )
         CurDate(4:6) = 'Aug'
      CASE ( '09' )
         CurDate(4:6) = 'Sep'
      CASE ( '10' )
         CurDate(4:6) = 'Oct'
      CASE ( '11' )
         CurDate(4:6) = 'Nov'
      CASE ( '12' )
         CurDate(4:6) = 'Dec'
   END SELECT


   !  Parse out the year.

   CurDate(7:11) = '-'//CDate(1:4)


   RETURN
   END FUNCTION CurDate ! ()
!=======================================================================
   FUNCTION CurTime( )


      ! This function returns a character string encoded with the time in the form "hh:mm:ss".


      ! Function declaration.

   CHARACTER(8)                 :: CurTime                                      ! This function.


      ! Local declarations.

   CHARACTER(10)                :: CTime                                        ! String to hold the returned value from the DATE_AND_TIME subroutine call.



   CALL DATE_AND_TIME ( TIME=CTime )

   CurTime = CTime(1:2)//':'//CTime(3:4)//':'//CTime(5:6)


   RETURN
   END FUNCTION CurTime ! ()
!=======================================================================
   SUBROUTINE DispNVD0


      ! This routine displays the name of the program, its version, and its release date.


      ! Print out program name, version, and date.

   CALL WrScr1 ( ' Running '//TRIM( ProgName )//' '//Trim( ProgVer )//'.' )


   RETURN
   END SUBROUTINE DispNVD0
!=======================================================================
   SUBROUTINE DispNVD1( ProgInfo )


      ! This routine displays the name of the program, its version, and its release date.


   IMPLICIT NONE
   TYPE( ProgDesc ), INTENT(IN)        :: ProgInfo    ! Contains the name and version info


      ! Print out program name, version, and date.

   CALL WrScr1 ( ' Running '//TRIM( GetNVD( ProgInfo ) )//'.' )


   RETURN
   END SUBROUTINE DispNVD1
!=======================================================================
   SUBROUTINE DispNVD2( Name, Ver )


      ! This routine displays the name of the program, its version, and its release date passed in as strings
      ! This routine is depricated and for legacy purposes only. Please don't use for any new code (Dec-2012)

   IMPLICIT NONE
   CHARACTER(*),  INTENT(IN)           :: Name     ! String containing the name of the program using the library
   CHARACTER(*),  INTENT(IN)           :: Ver      ! String containing the version and date info


      ! Print out program name, version, and date.

   CALL WrScr1 ( ' Running '//TRIM( Name )//' ('//Trim( Ver )//').' )


   RETURN
   END SUBROUTINE DispNVD2
!=======================================================================
   FUNCTION Flt2LStr ( FltNum )


      ! This function converts a floating point number to a left-aligned
      ! string.  It eliminates trailing zeroes and even the decimal
      ! point if it is not a fraction.
      ! This function remains here only for backward compatibility. New
      ! code should use Num2LStr instead.


      ! Function declaration.

   CHARACTER(15)                :: Flt2LStr                                        ! This function.


      ! Argument declarations.

   REAL(ReKi), INTENT(IN)       :: FltNum                                          ! The floating-point number to convert.



      ! Return a 0 if that's what we have.

   IF ( FltNum == 0.0 )  THEN
      Flt2LStr = '0'
      RETURN
   END IF


      ! Write the number into the string using G format and left justify it.

   WRITE (Flt2LStr,'(1PG15.5)')  FltNum

   CALL AdjRealStr( Flt2LStr )

   RETURN
   END FUNCTION Flt2LStr !  ( FltNum )
!=======================================================================
   SUBROUTINE GetNewUnit ( UnIn )

      ! This routine returns a unit number not currently in use.


      ! Argument declarations.

   INTEGER, INTENT(OUT)         :: UnIn                                         ! Logical unit for the file.


      ! Local declarations.

   INTEGER, SAVE                :: Un   = 10                                    ! Unit number; saved between calls (and a GLOBAL) variable
   LOGICAL                      :: Opened                                       ! Flag indicating whether or not a file is opened.



      ! See if unit is connected to an open file. Check the next largest number until it is not opened.

   DO

      INQUIRE ( UNIT=Un , OPENED=Opened )

      IF ( .NOT. Opened )  EXIT
      Un = Un + 1

!      IF ( Un > 99 ) Un = 10                                                     !some systems don't like unit numbers > 99, but we also don't want an infinite loop

   END DO

   UnIn = Un

   RETURN
   END SUBROUTINE GetNewUnit !  ( UnIn )
!=======================================================================
   FUNCTION GetNVD ( ProgInfo )
   
      ! This function converts the three strings contained in the ProgDesc
      ! data type into a single string listing the program name,
      ! version, and release date.
   
   
      ! Argument declarations.
      
   TYPE( ProgDesc ), INTENT(IN)        :: ProgInfo    ! Contains the name and version info
   
   
      ! Function delcaration
      
   CHARACTER(200)                      :: GetNVD      ! A single string containing the name, date, and version info
   
      
      ! Print all the version info into a nice string:
   
      GetNVD = TRIM( ProgInfo%Name )//' ('//Trim( ProgInfo%Ver )//', '//Trim( ProgInfo%Date )//')'

   END FUNCTION GetNVD 
!=======================================================================

   SUBROUTINE GetPath ( GivenFil, PathName )


      ! Let's parse the path name from the name of the given file.
      ! We'll count everything before (and including) the last "\" or "/".


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: GivenFil                                     ! The name of the given file.
   CHARACTER(*), INTENT(OUT)    :: PathName                                     ! The path name of the given file.


      ! Local declarations.

   INTEGER                      :: I                                            ! DO index for character position.


      ! Look for path separators

   I = INDEX( GivenFil, '\', BACK=.TRUE. )
   I = MAX( I, INDEX( GivenFil, '/', BACK=.TRUE. ) )

   IF ( I == 0 ) THEN
      ! we don't have a path specified, return '.'
      PathName = '.'//PathSep
   ELSE
      PathName = GivenFil(:I)
   END IF


   RETURN
   END SUBROUTINE GetPath ! ( GivenFil, PathName )
!=======================================================================
   SUBROUTINE GetRoot ( GivenFil, RootName )


      ! Let's parse the root file name from the name of the given file.
      ! We'll count everything after the last period as the extension.


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: GivenFil                                     ! The name of the given file.
   CHARACTER(*), INTENT(OUT)    :: RootName                                     ! The parsed root name of the given file.


      ! Local declarations.

   INTEGER                      :: I                                            ! DO index for character position.



      ! Deal with a couple of special cases.

   IF ( ( TRIM( GivenFil ) == "." ) .OR. (  TRIM( GivenFil ) == ".." ) )  THEN
      RootName = TRIM( GivenFil )
      RETURN
   END IF


      ! More-normal cases.

   DO I=LEN_TRIM( GivenFil ),1,-1


      IF ( GivenFil(I:I) == '.' )  THEN


         IF ( I < LEN_TRIM( GivenFil ) ) THEN                   ! Make sure the index I is okay
            IF ( INDEX( '\/', GivenFil(I+1:I+1)) == 0 ) THEN    ! Make sure we don't have the RootName in a different directory
               RootName = GivenFil(:I-1)
            ELSE
               RootName = GivenFil                              ! This does not have a file extension
            END IF
         ELSE
            IF ( I == 1 ) THEN
               RootName = ''
            ELSE
               RootName = GivenFil(:I-1)
            END IF
         END IF

         RETURN

      END IF
   END DO ! I

   RootName =  GivenFil


   RETURN
   END SUBROUTINE GetRoot ! ( GivenFil, RootName )
!=======================================================================
   SUBROUTINE GetTokens ( Line, NumTok, Tokens, Error )


      ! This routine will parse Line for NumTok "tokens" and return them in the Tokens array.
      ! THis routine differs from GetWords() in that it uses only spaces as token separators.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: NumTok                                       ! The number of "words" to look for.

   LOGICAL, INTENT(OUT)         :: Error                                        ! Error flag to indicate an insuffient number of tokens were found.

   CHARACTER(*), INTENT(INOUT)  :: Line                                         ! The string to search.
   CHARACTER(*), INTENT(OUT)    :: Tokens  (NumTok)                             ! The tokens that were found.


      ! Local declarations.

   INTEGER                      :: IT                                           ! Token index.
   INTEGER                      :: NextBlank                                    ! The location of the next blank character.



   NextBlank = 0

   DO IT=1,NumTok

      Line      = ADJUSTL( Line(NextBlank+1:) )
      NextBlank = INDEX  ( Line , ' ' )

      IF ( NextBlank == 0 )  THEN
        Error = .TRUE.
        RETURN
      END IF

      Tokens(IT) = Line(1:NextBlank-1)

   END DO ! IT

   Error = .FALSE.


   RETURN
   END SUBROUTINE GetTokens ! ( Line, NumTok, Tokens, Error )
!=======================================================================
   SUBROUTINE GetWords ( Line, Words, NumWords )


      ! This subroutine is used to get NumWords "words" from a line of text.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: NumWords                                     ! The number of words to look for.

   CHARACTER(*), INTENT(IN)     :: Line                                         ! The string to search.
   CHARACTER(*), INTENT(OUT)    :: Words(NumWords)                              ! The array of found words.


      ! Local declarations.

   INTEGER                      :: Ch                                           ! Character position within the string.
   INTEGER                      :: IW                                           ! Word index.
   INTEGER                      :: NextWhite                                    ! The location of the next whitespace in the string.



      ! Let's prefill the array with blanks.

   DO IW=1,NumWords
      Words(IW) = ' '
   END DO ! IW


      ! Let's make sure we have text on this line.

   IF ( LEN_TRIM( Line ) == 0 )  RETURN


      ! Parse words separated by any combination of spaces, tabs, commas,
      ! semicolons, single quotes, and double quotes ("whitespace").

   Ch = 0
   IW = 0

   DO

      NextWhite = SCAN( Line(Ch+1:) , ' ,;''"'//Tab )

      IF ( NextWhite > 1 )  THEN

         IW        = IW + 1
         Words(IW) = Line(Ch+1:Ch+NextWhite-1)

         IF ( IW == NumWords )  EXIT

         Ch = Ch + NextWhite

      ELSE IF ( NextWhite == 1 )  THEN

         Ch = Ch + 1

         CYCLE

      ELSE

         EXIT

      END IF

   END DO


   RETURN
   END SUBROUTINE GetWords ! ( Line, Words, NumWords )
!======================================================================= 
   FUNCTION Int2LStr ( Intgr )


      ! This function returns a left-adjusted string representing the passed integer.



   CHARACTER(11)                :: Int2LStr                                     ! This function.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Intgr                                        ! The integer to convert to a left-justified string.



   WRITE (Int2LStr,'(I11)')  Intgr

   Int2Lstr = ADJUSTL( Int2LStr )


   RETURN
   END FUNCTION Int2LStr ! ( Intgr )
!=======================================================================
   SUBROUTINE NameOFile ( InArg, OutExten, OutFile, ErrStat )


      ! Get the name of the input file from the InArgth command-line argument.
      ! Remove the extension if there is one, and append OutExten to the end.


      ! Argument declarations.

   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                     ! Error status; if present, program does not abort on error
   INTEGER, INTENT(IN)          :: InArg                                        ! The number of the command-line argument that should hold the input file name.

   CHARACTER(*), INTENT(IN)     :: OutExten                                     ! The requested extension for the output file.
   CHARACTER(*), INTENT(OUT)    :: OutFile                                      ! The name of the output file.


      ! Local declarations.

   CHARACTER(100)               :: InFile                                       ! The name of the input file.
   CHARACTER(100)               :: RootName                                     ! The root name of the input file.



      ! See if the command line has enough arguments.

   IF ( InArg > COMMAND_ARGUMENT_COUNT() )  THEN
      CALL ProgAbort ( 'Insufficient arguments on the command line (at least '//&
                         TRIM( Int2LStr( InArg ) )//' were expected).', PRESENT(ErrStat) )
      IF ( PRESENT( ErrStat ) ) ErrStat = 1
      RETURN
   END IF


      ! Get the root of the input file name (strip off the extension).

   CALL GET_COMMAND_ARGUMENT( InArg, InFile )
   CALL GetRoot ( TRIM( InFile ), RootName )

   OutFile = TRIM( RootName )//'.'//OutExten

   IF ( PRESENT( ErrStat ) ) ErrStat = 0

   RETURN
   END SUBROUTINE NameOFile ! ( InArg, OutExten, OutFile [, ErrStat])
!=======================================================================
   SUBROUTINE NormStop


      ! This routine performs a normal termination of the program.


   CALL WrScr1   ( ' '//TRIM( ProgName )//' terminated normally.' )
   CALL WrScr    ( '' )
   CALL ProgExit ( 0 )


   END SUBROUTINE NormStop
!=======================================================================
   SUBROUTINE OpenBin ( Un, OutFile, RecLen, ErrStat )

      ! This routine opens a binary output file.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the output file.
   INTEGER, INTENT(IN)          :: RecLen                                       ! Length of binary record.
   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                     ! Error status; if present, program does not abort on error


   CHARACTER(*), INTENT(IN)     :: OutFile                                      ! Name of the output file.


      ! Local declarations.

   LOGICAL                      :: Error                                        ! Flag to indicate the open failed.


      ! Open output file.  Make sure it worked.

   CALL OpenBinFile ( Un, OutFile, RecLen, Error )

   IF ( Error )  THEN
      CALL ProgAbort ( ' Cannot open file "'//TRIM( OutFile )// &
                       '".  Another program may have locked it for writing.', PRESENT(ErrStat) )
      IF ( PRESENT(ErrStat) ) ErrStat = 1
      RETURN
   ELSE
      IF ( PRESENT(ErrStat) ) ErrStat = 0
   ENDIF


   RETURN
   END SUBROUTINE OpenBin ! ( Un, OutFile, RecLen [, ErrStat] )
!=======================================================================
   SUBROUTINE OpenBInpFile ( Un, InFile, ErrStat )


      ! This routine opens a binary input file.

   IMPLICIT                        NONE



      ! Argument declarations.

   INTEGER, INTENT(IN)            :: Un                                          ! Logical unit for the input file.
   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)       :: InFile                                      ! Name of the input file.


      ! Local declarations.

      ! NOTE: Do not explicitly declare the precision of this variable [as in
      !       LOGICAL(1)] so that the statements using this variable work with
      !       any compiler:
   LOGICAL                      :: Exists                                       ! Flag indicating whether or not a file Exists.
   LOGICAL                      :: Error                                        ! Flag to indicate the open failed.



      ! See if input file Exists.

   INQUIRE ( FILE=TRIM( InFile ) , EXIST=Exists )

   IF ( .NOT. Exists )  THEN
      CALL ProgAbort ( ' The input file, "'//TRIM( InFile )//'", was not found.', PRESENT( ErrStat) )
      IF ( PRESENT( ErrStat) ) ErrStat = -1
      RETURN
   END IF


      ! Open input file.  Make sure it worked.

   CALL OpenBinInpFile ( Un, InFile, Error )

   IF ( Error )  THEN

      CALL ProgAbort ( ' Cannot open file "'//TRIM( InFile )//'".  Another program may have locked it.', PRESENT( ErrStat ) )
      IF ( PRESENT( ErrStat) ) ErrStat = 1
      RETURN

   ELSE

      IF ( PRESENT( ErrStat) ) ErrStat = 0

   END IF


   RETURN
   END SUBROUTINE OpenBInpFile
!=======================================================================
   SUBROUTINE OpenEcho ( Un, OutFile, ErrStat )


      ! This routine opens a formatted output file for the echo file.


      ! Argument declarations.

   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                   ! Error status; if present, program does not abort on error
   INTEGER, INTENT(IN)            :: Un                                        ! Logical unit for the input file.

   CHARACTER(*), INTENT(IN)       :: OutFile                                   ! Name of the input file.




   UnEc = Un

   IF ( PRESENT(ErrStat) ) THEN

      CALL OpenFOutFile( UnEc, OutFile, ErrStat )

   ELSE

      CALL OpenFOutFile( UnEc, OutFile )

   ENDIF

   Echo = .TRUE.

   RETURN
   END SUBROUTINE OpenEcho ! ( Un, OutFile [, ErrStat]  )
!=======================================================================
   SUBROUTINE OpenFInpFile ( Un, InFile, ErrStat )


      ! This routine opens a formatted input file.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                      ! Error status; if present, program does not abort on error
   CHARACTER(*), INTENT(IN)     :: InFile                                       ! Name of the input file.


      ! Local declarations.

   INTEGER                      :: IOS                                          ! I/O status of OPEN.

   LOGICAL                      :: Exists                                       ! Flag indicating whether or not a file Exists.



      ! See if input file Exists.

   INQUIRE ( FILE=TRIM( InFile ) , EXIST=Exists )

   IF ( .NOT. Exists )  THEN
      CALL ProgAbort ( ' The input file, "'//TRIM( InFile )//'", was not found.', PRESENT(ErrStat) )
      IF (PRESENT(ErrStat)) ErrStat = -1
      RETURN
   END IF


      ! Open input file.  Make sure it worked.

   OPEN( Un, FILE=TRIM( InFile ), STATUS='OLD', FORM='FORMATTED', IOSTAT=IOS, ACTION='READ' )

   IF ( IOS /= 0 )  THEN
      CALL ProgAbort ( ' Cannot open file "'//TRIM( InFile ) &
                      //'".  Another program like MS Excel may have locked it for writing.',PRESENT(ErrStat)  )
      IF (PRESENT(ErrStat)) ErrStat = 1
      RETURN
   ELSE
      IF (PRESENT(ErrStat)) ErrStat = 0
   END IF


   RETURN
   END SUBROUTINE OpenFInpFile ! ( Un, InFile [, ErrStat] )
!=======================================================================
   SUBROUTINE OpenFOutFile ( Un, OutFile, ErrStat )


      ! This routine opens a formatted output file.


      ! Argument declarations.

   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                    ! Error status; if present, program does not abort on error
   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the output file.

   CHARACTER(*), INTENT(IN)     :: OutFile                                      ! Name of the output file.


      ! Local declarations.

   INTEGER                      :: IOS                                          ! I/O status of OPEN.



      ! Open output file.  Make sure it worked.

   OPEN( Un, FILE=TRIM( OutFile ), STATUS='UNKNOWN', FORM='FORMATTED', IOSTAT=IOS, ACTION="WRITE" )



   IF ( PRESENT(ErrStat) ) ErrStat = IOS

   IF ( IOS /= 0 )  CALL ProgAbort( ' Cannot open file "'//TRIM( OutFile )// &
                                    '".  Another program like MS Excel may have locked it for writing.', PRESENT(ErrStat) )


   RETURN
   END SUBROUTINE OpenFOutFile ! ( Un, OutFile [, ErrStat] )
!=======================================================================
   SUBROUTINE OpenFUnkFile ( Un, OutFile, FailAbt, Failed, Exists, ErrStat )


      ! This routine opens a formatted output file and returns a flag telling if it already existed.


      ! Argument declarations.

   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                    ! Error status; if present, program does not abort on error
   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the output file.

   LOGICAL, INTENT(OUT)         :: Exists                                       ! Flag that indicates if the file already existedo.
   LOGICAL, INTENT(IN)          :: FailAbt                                      ! Flag that tells this routine to abort if the open fails.
   LOGICAL, INTENT(OUT)         :: Failed                                       ! Flag that indicates if the open failed.

   CHARACTER(*), INTENT(IN)     :: OutFile                                      ! Name of the output file.


      ! Local declarations.

   INTEGER                      :: IOS                                          ! I/O status of OPEN.



      ! Check to see if the file already exists.

   INQUIRE ( FILE=TRIM( OutFile ) , EXIST=Exists )

!bjj: should we be checking something here?


      ! Open output file.  Make sure it worked.

   OPEN( Un, FILE=TRIM( OutFile ), STATUS='UNKNOWN', FORM='FORMATTED', IOSTAT=IOS )

   IF ( PRESENT(ErrStat) ) ErrStat = IOS

   IF ( IOS /= 0 )  THEN
      Failed = .TRUE.
      IF ( FailAbt )  CALL ProgAbort ( ' Cannot open file "'//TRIM( OutFile ) &
                                 //'".  Another program like MS Excel may have locked it for writing.', PRESENT(ErrStat) )
   ELSE
      Failed = .FALSE.
   END IF


   RETURN
   END SUBROUTINE OpenFUnkFile ! ( Un, OutFile, FailAbt, Failed, Exists [,ErrStat] )
!=======================================================================
   SUBROUTINE OpenUInfile ( Un, InFile, ErrStat )


      !  This routine opens an unformatted input file.


      ! Argument declarations.

   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                    ! Error status; if present, program does not abort on error
   INTEGER, INTENT(IN)         ::  Un                                           ! Logical unit for the input file

   CHARACTER(*), INTENT(IN)    ::  InFile                                       ! Name of the input file


      ! Local declarations.

   INTEGER                     ::  IOS                                          ! Returned input/output status.

   LOGICAL                      :: Exists                                       ! Flag indicating whether or not a file Exists.



      ! See if input file Exists.

   INQUIRE ( FILE=TRIM( InFile ) , EXIST=Exists )

   IF ( .NOT. Exists )  THEN
      CALL ProgAbort ( ' The input file, "'//TRIM( InFile )//'", was not found.', PRESENT(ErrStat) )
      IF ( PRESENT(ErrStat) ) ErrStat = -1
      RETURN
   END IF


      ! Open the file.

   OPEN ( Un, FILE=TRIM( InFile ), STATUS='UNKNOWN', FORM=UnfForm, ACCESS='SEQUENTIAL', IOSTAT=IOS, ACTION='READ' )

   IF ( PRESENT(ErrStat) ) ErrStat = IOS

   IF ( IOS /= 0 )  CALL ProgAbort( ' Cannot open file "'//TRIM( InFile )// &
                                    '".  Another program may have locked it for writing.', PRESENT(ErrStat) )



   RETURN
   END SUBROUTINE OpenUInfile ! ( Un, InFile [,ErrStat] )
!=======================================================================
SUBROUTINE OpenUInBEFile( Un, InFile, RecLen, ErrStat )

      !  This routine opens an unformatted input file of RecLen-byte data records
      !  stored in Big Endian format.


      ! Argument declarations.

   INTEGER, INTENT(IN)           ::  Un                                         ! Logical unit for the input file
   CHARACTER(*), INTENT(IN)      ::  InFile                                     ! Name of the input file
   INTEGER, INTENT(IN)           ::  RecLen                                     ! The input file's record length in bytes
   INTEGER, INTENT(OUT),OPTIONAL ::  ErrStat                                    ! Error status; if present, program does not abort on error



      ! Local declarations.

   LOGICAL                       :: Exists                                       ! Flag to indicate if a file exists
   LOGICAL                       :: Error                                        ! Flag to indicate the open failed



      ! See if input file Exists.

   INQUIRE ( FILE=TRIM( InFile ) , EXIST=Exists )

   IF ( .NOT. Exists )  THEN
      CALL ProgAbort ( ' The input file, "'//TRIM( InFile )//'", was not found.', PRESENT(ErrStat) )
      IF ( PRESENT(ErrStat) ) ErrStat = -1
      RETURN
   END IF


      ! Open the file.

   CALL OpenUnfInpBEFile ( Un, InFile, RecLen, Error )

   IF ( Error )  THEN

      CALL ProgAbort ( ' Cannot open file "'//TRIM( InFile )//'".  Another program may have locked it.', PRESENT( ErrStat ) )
      IF ( PRESENT( ErrStat) ) ErrStat = 1
      RETURN

   ELSE

      IF ( PRESENT( ErrStat) ) ErrStat = 0

   END IF


   RETURN

END SUBROUTINE OpenUInBEFile !( Un, InFile, RecLen [, ErrStat] )
!=======================================================================
   SUBROUTINE OpenUOutfile ( Un, OutFile, ErrStat )


      !  This routine opens an unformatted output file.


      ! Argument declarations.

   INTEGER, INTENT(IN)            ::  Un                                        ! Logical unit for the output file
   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                    ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)       ::  OutFile                                   ! Name of the output file


      ! Local declarations.

   INTEGER                        ::  IOS                                       ! Returned input/output status.



      ! Open the file.

   OPEN ( Un, FILE=TRIM( OutFile ), STATUS='UNKNOWN', FORM=UnfForm, ACCESS='SEQUENTIAL', IOSTAT=IOS, ACTION='WRITE' )


   IF ( PRESENT( ErrStat ) )   ErrStat = IOS

   IF ( IOS /= 0 )  CALL ProgAbort( ' Cannot open file "'//TRIM( OutFile )// &
                                    '".  Another program may have locked it for writing.', PRESENT( ErrStat ) )


   RETURN
   END SUBROUTINE OpenUOutfile ! ( Un, InFile [,ErrStat] )
!=======================================================================
   FUNCTION PathIsRelative ( GivenFil )


      ! Let's determine in the given file name is absolute or relative.
      !
      ! We'll consider an absolute path one that satisfies one of the
      ! following four criteria:
      !     1) It contains ":/"
      !     2) It contains ":\"
      !     3) It starts with "/"
      !     4) It starts with "\"
      ! All others are considered relative.



      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: GivenFil                                            ! The name of the given file.
   LOGICAL                      :: PathIsRelative                                      ! The function return value


      ! Determine if file name begins with an absolute path name or if it is relative

   PathIsRelative = .FALSE.

   IF ( ( INDEX( GivenFil, ':/') == 0 ) .AND. ( INDEX( GivenFil, ':\') == 0 ) ) THEN   ! No drive is specified (by ':\' or ':/')

      IF ( INDEX( '/\', GivenFil(1:1) ) == 0 ) THEN                                    ! The file name doesn't start with '\' or '/'

         PathIsRelative = .TRUE.

      END IF

   END IF

   RETURN
   END FUNCTION PathIsRelative ! ( GivenFil )
!=======================================================================
   SUBROUTINE PremEOF ( Fil , Variable, TrapErrors )


      ! This routine prints out an EOF message and aborts the program.


      ! Argument declarations.

   LOGICAL, INTENT(IN), OPTIONAL:: TrapErrors                                   ! Determines if the program should abort or return to calling function
   LOGICAL                      :: TrapThisError                                ! The local version of TrapErrors

   CHARACTER(*), INTENT(IN)     :: Fil                                          ! The name of the file that ran out of data.
   CHARACTER(*), INTENT(IN)     :: Variable                                     ! The name of the variable we were trying to read at the time.


   IF ( PRESENT( TrapErrors ) ) THEN
      TrapThisError = TrapErrors
   ELSE
      TrapThisError = .FALSE.
   END IF

   CALL WrScr1 ( ' Premature EOF for file "'//TRIM( Fil )//'".' )

   CALL ProgAbort  ( ' The error occurred while trying to read '//TRIM( Variable )//'.', TrapThisError )


   RETURN
   END SUBROUTINE PremEOF ! ( Fil , Variable [, TrapErrors] )
!=======================================================================
   SUBROUTINE ProgAbort ( Message, TrapErrors )


      ! This routine outputs fatal error messages and stops the program.


      ! Argument declarations.

   LOGICAL, INTENT(IN), OPTIONAL:: TrapErrors                                   ! Determines if the program should abort or return to calling function
   CHARACTER(*), INTENT(IN)     :: Message                                      ! Error message.



   IF ( Beep )  CALL UsrAlarm

   CALL WrScr    ( Message )
   IF ( PRESENT(TrapErrors) )  THEN
      IF ( TrapErrors ) RETURN
   END IF

   IF ( LEN_TRIM(ProgName) > 0 ) THEN
      CALL WrScr1   ( ' Aborting '//TRIM( ProgName )//'.' )
   ELSE
      CALL WrScr1   ( ' Aborting program.' )
   END IF

   CALL WrScr1   ( ' Hit the <Enter> key to continue.' )
   READ (*,'()')
   CALL ProgExit ( 1 )


   END SUBROUTINE ProgAbort ! ( Message [, TrapErrors] )
!=======================================================================
   SUBROUTINE ProgWarn ( Message )


      ! This routine outputs non-fatal warning messages and returns to the calling routine.


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: Message                                      ! Warning message.



   IF ( Beep )  CALL UsrAlarm
   CALL WrScr ( ' WARNING:  '//Message )


   RETURN
   END SUBROUTINE ProgWarn ! ( Message )
!=======================================================================
   FUNCTION R2LStr4 ( FltNum )

      ! This function converts a 4-byte floating point number to
      ! a left-aligned string.  It eliminates trailing zeroes
      ! and even the decimal point if it is not a fraction.


      ! Function declaration.

   CHARACTER(15)                :: R2LStr4                                         ! This function.


      ! Argument declarations.

   REAL(SiKi), INTENT(IN)       :: FltNum                                          ! The floating-point number to convert.


      ! Return a 0 if that's what we have.

   IF ( FltNum == 0.0_SiKi )  THEN
      R2LStr4 = '0'
      RETURN
   END IF


      ! Write the number into the string using G format and left justify it.

   WRITE (R2LStr4,'(1PG15.5)')  FltNum

   CALL AdjRealStr( R2LStr4 )


   RETURN
   END FUNCTION R2LStr4 !  ( FltNum )
!=======================================================================
   FUNCTION R2LStr8 ( FltNum )

      ! This function converts a 8-byte floating point number to
      ! a left-aligned string.  It eliminates trailing zeroes
      ! and even the decimal point if it is not a fraction.


      ! Function declaration.

   CHARACTER(15)                :: R2LStr8                                         ! This function.


      ! Argument declarations.

   REAL(R8Ki), INTENT(IN)       :: FltNum                                          ! The floating-point number to convert.


      ! Return a 0 if that's what we have.

   IF ( FltNum == 0.0_R8Ki )  THEN
      R2LStr8 = '0'
      RETURN
   END IF


      ! Write the number into the string using G format and left justify it.

   WRITE (R2LStr8,'(1PG15.5)')  FltNum

   CALL AdjRealStr( R2LStr8 )


   RETURN
   END FUNCTION R2LStr8 !  ( FltNum )
!=======================================================================
   FUNCTION R2LStr16 ( FltNum )

      ! This function converts a 16-byte floating point number to
      ! a left-aligned string.  It eliminates trailing zeroes
      ! and even the decimal point if it is not a fraction.


      ! Function declaration.

   CHARACTER(15)                :: R2LStr16                                        ! This function.


      ! Argument declarations.

   REAL(QuKi), INTENT(IN)       :: FltNum                                          ! The floating-point number to convert.


      ! Return a 0 if that's what we have.

   IF ( FltNum == 0.0_QuKi )  THEN
      R2LStr16 = '0'
      RETURN
   END IF


      ! Write the number into the string using G format and left justify it.

   WRITE (R2LStr16,'(1PG15.5)')  FltNum

   CALL AdjRealStr( R2LStr16 )


   RETURN
   END FUNCTION R2LStr16 !  ( FltNum )

!======================================================================
   SUBROUTINE ReadCAry ( UnIn, Fil, CharAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a character array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(OUT)    :: CharAry(AryLen)                                 ! Real variable being read.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.
   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the string array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(44)                :: Frmt = "(15X,A,T30,' - ',A,/,2X,100('""',A,'""',:,1X))"    ! Output format for string parameters.



   READ (UnIn,*,IOSTAT=IOS)  ( CharAry(Ind), Ind=1,AryLen )

   CALL CheckIOS ( IOS, Fil, TRIM( AryName ), StrType, PRESENT(ErrStat) )

   IF (PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  TRIM( AryName ), AryDescr, ( TRIM( CharAry(Ind) ), Ind=1,AryLen )
   END IF


   RETURN
   END SUBROUTINE ReadCAry ! ( UnIn, Fil, CharAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadCAryLines ( UnIn, Fil, CharAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a real array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(OUT)    :: CharAry(AryLen)                                 ! Char variable being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the real array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(35)                :: Frmt = "( 15X, A, T30, ' - ', A, /, 2X, A )"    ! Output format for string parameters.


   IF ( PRESENT(ErrStat) ) ErrStat = 0

   DO Ind=1,AryLen
      READ (UnIn,*,IOSTAT=IOS)  CharAry(Ind)

      CALL CheckIOS ( IOS, Fil, TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', StrType, PRESENT(ErrStat) )

      IF (IOS /= 0) THEN
         IF ( PRESENT(ErrStat) ) ErrStat = IOS
         RETURN
      ENDIF

      IF ( Echo )  THEN
         WRITE (UnEc,Frmt)  TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', AryDescr, TRIM(CharAry(Ind))
      END IF
   END DO

   RETURN
   END SUBROUTINE ReadCAryLines ! ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadCom ( UnIn, Fil, ComName, ErrStat )

      ! This routine reads a comment from the next line of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)   :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)   :: ComName                                         ! Text string containing the comment name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(200)               :: Comment                                         ! Text string containing the comment.



   READ (UnIn,'(A)',IOSTAT=IOS)  Comment

   CALL CheckIOS ( IOS, Fil, ComName, StrType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      WRITE (UnEc,'(A)')  Comment
   END IF


   RETURN
   END SUBROUTINE ReadCom ! ( UnIn, Fil, ComName [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadCVar ( UnIn, Fil, CharVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single character variable from the next line of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(OUT)    :: CharVar                                         ! Integer variable being read.
   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: VarDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(35)                :: Frmt = "( 15X, A, T30, ' - ', A, /, 2X, A )"    ! Output format for string parameters.




   READ (UnIn,*,IOSTAT=IOS)  CharVar

   CALL CheckIOS ( IOS, Fil, VarName, StrType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  VarName, VarDescr, '"'//TRIM( CharVar )//'"'
   END IF


   RETURN
   END SUBROUTINE ReadCVar ! ( UnIn, Fil, CharVar, VarName, VarDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadFASTbin ( UnIn, FASTdata , ErrLev, ErrMsg )

      ! This routine reads the contents of a FAST binary output file (FASTbinFile) and stores it in FASTdata.
      ! It is assumed that the name of the binary file is preloaded into FASTdata%File by the calling procedure.


      ! Argument declarations.

   INTEGER(IntKi), OPTIONAL, INTENT(OUT)  :: ErrLev                  ! An optional error level to be returned to the calling routine.
   INTEGER(IntKi), INTENT(INOUT)          :: UnIn                    ! The IO unit for the FAST binary file.

   CHARACTER(*), OPTIONAL, INTENT(OUT)    :: ErrMsg                  ! An optional error message to be returned to the calling routine.

   TYPE (FASTdataType), INTENT(INOUT)     :: FASTdata                ! The derived type for holding FAST output data.


      ! Local declarations.

   REAL(R8Ki)                             :: TimeIncr                ! The increment for the time data when a time channel is not included.
   REAL(R8Ki)                             :: TimeOff                 ! The offset for the time data when a time channel is included.
   REAL(R8Ki)                             :: TimeOut1                ! The first output data when a time channel is not included.
   REAL(R8Ki)                             :: TimeScl                 ! The slope for the time data when a time channel is included.

   REAL(ReKi), ALLOCATABLE                :: ColMax(:)               ! The maximum value of the column data.
   REAL(ReKi), ALLOCATABLE                :: ColMin(:)               ! The minimum value of the column data.

   REAL(SiKi), ALLOCATABLE                :: ColOff(:)               ! The offset for the column data.
   REAL(SiKi), ALLOCATABLE                :: ColScl(:)               ! The slope for the column data.

   INTEGER(IntKi)                         :: IChan                   ! The channel index used for DO loops.
   INTEGER(IntKi)                         :: IChr                    ! The character index used for DO loops.
   INTEGER(IntKi)                         :: IRow                    ! The row index used for DO loops.
   INTEGER(IntKi)                         :: LenDesc                 ! The length of the description string, DescStr.
   INTEGER(IntKi), PARAMETER              :: MaxLenDesc = 1024       ! The maximum allowed length of the description string, DescStr.
   INTEGER(IntKi), PARAMETER              :: MaxChrLen  = 10         ! The maximum length for channel names and units.

   INTEGER(B4Ki), ALLOCATABLE             :: TmpTimeArray(:)         ! This array holds the normalized time channel that was read from the binary file.

   INTEGER(B2Ki)                          :: FileType                ! The type of FAST data file (1: Time channel included in file; 2: Time stored as start time and step).
   INTEGER(B2Ki), ALLOCATABLE             :: TmpInArray(:,:)         ! This array holds the normalized channels that were read from the binary file.

   INTEGER(B1Ki), ALLOCATABLE             :: DescStrASCII(:)         ! The ASCII equivalent of DescStr.
   INTEGER(B1Ki)                          :: TmpStrASCII(MaxChrLen)  ! The temporary ASCII equivalent of a channel name or units.


      !  Open data file.

   CALL OpenBInpFile ( UnIn, FASTdata%File, ErrLev )
   IF ( ErrLev /= 0 )  THEN
      RETURN
   ENDIF


      ! Process the requested data records of this file.

   CALL WrScr1 ( ' =======================================================' )
   CALL WrScr  ( ' Reading in data from file "'//TRIM( FASTdata%File )//'".' )
   CALL WrScr  ( ' ' )


      ! Read some of the header information.

   READ (UnIn, IOSTAT=ErrLev)  FileType
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading FileType in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF

   READ (UnIn, IOSTAT=ErrLev)  FASTdata%NumChans
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the number of channels in ReadFASTbin for file "' &
                                      //TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF

   READ (UnIn, IOSTAT=ErrLev)  FASTdata%NumRecs
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the number of records in ReadFASTbin for file "' &
                                          //TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF

   IF ( FileType == 1 )  THEN

      READ (UnIn, IOSTAT=ErrLev)  TimeScl
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading TimeScl in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF

      READ (UnIn, IOSTAT=ErrLev)  TimeOff
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading TimeOff in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF

   ELSE

      READ (UnIn, IOSTAT=ErrLev)  TimeOut1
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading TimeOut1 in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF

      READ (UnIn, IOSTAT=ErrLev)  TimeIncr
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading TimeIncr in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF

   END IF ! IF ( FileType == 1 )


      ! Allocate the necessary arrays.

   ALLOCATE ( ColMax( FASTdata%NumChans ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for ColMax array in ReadFASTbin.' )
      RETURN
   ENDIF

   ALLOCATE ( ColMin( FASTdata%NumChans ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for ColMin array in ReadFASTbin.' )
      RETURN
   ENDIF

   ALLOCATE ( ColOff( FASTdata%NumChans ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for ColOff array in ReadFASTbin.' )
      RETURN
   ENDIF

   ALLOCATE ( FASTdata%ChanNames( FASTdata%NumChans+1 ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for FASTdata%ChanNames array in ReadFASTbin.' )
      RETURN
   ENDIF

   ALLOCATE ( FASTdata%ChanUnits( FASTdata%NumChans+1 ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine( ErrID_Fatal, '>>Error allocating memory for FASTdata%ChanUnits array in ReadFASTbin.' )
      RETURN
   ENDIF

   ALLOCATE ( ColScl( FASTdata%NumChans ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for ColScl array in ReadFASTbin.' )
      RETURN
   ENDIF

   ALLOCATE ( TmpInArray( FASTdata%NumRecs, FASTdata%NumChans ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for the TmpInArray array in ReadFASTbin.' )
      RETURN
   ENDIF

   IF ( FileType == 1 ) THEN
      ALLOCATE ( TmpTimeArray( FASTdata%NumRecs ) , STAT=ErrLev )
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for the TmpTimeArray array in ReadFASTbin.' )
         RETURN
      ENDIF
   END IF

   ALLOCATE ( FASTdata%Data( FASTdata%NumRecs, FASTdata%NumChans+1 ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for the FASTdata%Data array in ReadFASTbin.' )
      RETURN
   ENDIF


      ! Read more of the header information.

   READ (UnIn, IOSTAT=ErrLev)  ColScl
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the ColScl array in ReadFASTbin for file "' &
                                          //TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF

   READ (UnIn, IOSTAT=ErrLev)  ColOff
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the ColOff array in ReadFASTbin for file "' &
                                          //TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF

   READ (UnIn, IOSTAT=ErrLev)  LenDesc
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading LenDesc in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF
   LenDesc = MIN( LenDesc, MaxLenDesc )

   ALLOCATE ( DescStrASCII( LenDesc ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for the DescStrASCII array in ReadFASTbin.' )
      RETURN
   ENDIF

   READ (UnIn, IOSTAT=ErrLev)  DescStrASCII
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the DescStrASCII array in ReadFASTbin for file "' &
                                      //TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF

   FASTdata%Descr = ''

   DO IChr=1,LenDesc
      FASTdata%Descr(IChr:IChr) = CHAR( DescStrASCII(IChr) )
   END DO

   TmpStrASCII(:) = ICHAR( ' ' )
   DO IChan=1,FASTdata%NumChans+1
      READ (UnIn, IOSTAT=ErrLev)  TmpStrASCII
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the title of Channel #'//Int2LStr(  IChan )// &
                                          ' in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF
      FASTdata%ChanNames(IChan) = ''
      DO IChr=1,MaxChrLen
         FASTdata%ChanNames(IChan)(IChr:IChr) = CHAR( TmpStrASCII(IChr) )
      END DO
   END DO

   TmpStrASCII(:) = ICHAR( ' ' )
   DO IChan=1,FASTdata%NumChans+1
      READ (UnIn, IOSTAT=ErrLev)  TmpStrASCII
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the units of Channel #'//Int2LStr(  IChan )// &
                                          ' in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF
      FASTdata%ChanUnits(IChan) = ''
      DO IChr=1,MaxChrLen
         FASTdata%ChanUnits(IChan)(IChr:IChr) = CHAR( TmpStrASCII(IChr) )
      END DO
   END DO


      ! If the file contains a time channel (as opposed to just initial time and time step), read it.
      ! There are four bytes per time value.

   IF ( FileType == 1 ) THEN

      READ (UnIn, IOSTAT=ErrLev)  TmpTimeArray                                 ! Time data stored in normalized 32-bit integers
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading time data from the FAST binary file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF

   END IF ! FileType


      ! Put time data in the data array.

   IF ( FileType == 1 )  THEN
      FASTdata%Data(:,1) = ( TmpTimeArray(:) - TimeOff )/TimeScl;
      FASTdata%TimeStep  = FASTdata%Data(2,1) - FASTdata%Data(1,1)
   ELSE
      FASTdata%Data(:,1) = REAL( TimeOut1, DbKi ) + REAL( TimeIncr, DbKi )*[ (IRow, IRow=0,FASTdata%NumRecs-1 ) ];
      FASTdata%TimeStep  = TimeIncr
   END IF


      ! Read the FAST channel data.

   DO IRow=1,FASTdata%NumRecs
      READ (UnIn, IOSTAT=ErrLev)  TmpInArray(IRow,:)
   END DO ! IRow=1,FASTdata%NumRecs


      ! Denormalize the data one row at a time and store it in the FASTdata%Data array.

   DO IRow=1,FASTdata%NumRecs
      FASTdata%Data(IRow,2:) = ( TmpInArray(IRow,:) - ColOff(:) )/ColScl(:)
   END DO ! IRow=1,FASTdata%NumRecs


   CALL ExitThisRoutine( ErrID_None, '' )
   RETURN

   !=======================================================================
   CONTAINS
   !=======================================================================
      SUBROUTINE ExitThisRoutine ( ErrID, Msg )

         ! This subroutine cleans up all the allocatable arrays, sets the error status/message and closes the binary file

            ! Passed arguments

         INTEGER(IntKi), INTENT(IN) :: ErrID       ! The error identifier (ErrLev)
         CHARACTER(*),   INTENT(IN) :: Msg         ! The error message (ErrMsg)


            ! Set error status/message

         ErrLev = ErrID
         ErrMsg  = Msg


            ! Deallocate arrays created in this routine.

         IF ( ALLOCATED( ColMax             ) ) DEALLOCATE( ColMax             )
         IF ( ALLOCATED( ColMin             ) ) DEALLOCATE( ColMin             )
         IF ( ALLOCATED( ColOff             ) ) DEALLOCATE( ColOff             )
         IF ( ALLOCATED( ColScl             ) ) DEALLOCATE( ColScl             )
         IF ( ALLOCATED( DescStrASCII       ) ) DEALLOCATE( DescStrASCII       )
         IF ( ALLOCATED( TmpInArray         ) ) DEALLOCATE( TmpInArray         )
         IF ( ALLOCATED( TmpTimeArray       ) ) DEALLOCATE( TmpTimeArray       )


            ! If there was an error, deallocate the arrays in the FASTdata structure.

         IF ( ErrLev /= 0 )  THEN
            IF ( ALLOCATED( FASTdata%ChanNames ) ) DEALLOCATE( FASTdata%ChanNames )
            IF ( ALLOCATED( FASTdata%ChanUnits ) ) DEALLOCATE( FASTdata%ChanUnits )
            IF ( ALLOCATED( FASTdata%Data      ) ) DEALLOCATE( FASTdata%Data      )
         END IF ! ( ErrLev /= 0 )


            ! Close file

         CLOSE ( UnIn )

      END SUBROUTINE ExitThisRoutine

   END SUBROUTINE ReadFASTbin ! ( FASTbinData [, ErrLev] )
!=======================================================================
   SUBROUTINE ReadIAry ( UnIn, Fil, IntAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into an integer array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(OUT)         :: IntAry(AryLen)                                  ! Integer array being read.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the integer array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, I11, 2X, A, T30, ' - ', A )"      ! Output format for integer array parameters



   READ (UnIn,*,IOSTAT=IOS)  ( IntAry(Ind), Ind=1,AryLen )

   CALL CheckIOS ( IOS, Fil, TRIM( AryName ), NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      DO Ind=1,AryLen
         WRITE (UnEc,Frmt)  IntAry(Ind), TRIM( AryName ), AryDescr
      END DO ! Ind
   END IF


   RETURN
   END SUBROUTINE ReadIAry ! ( UnIn, Fil, IntAry, AryLen, AryName, AryDescr [, ErrStat])
!=======================================================================
   SUBROUTINE ReadIVar ( UnIn, Fil, IntVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single integer variable from the next line of the input file.


      ! Argument declarations:

   INTEGER, INTENT(OUT)         :: IntVar                                          ! Integer variable being read.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: VarDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(33)                :: Frmt = "( 2X, I11, 2X, A, T30, ' - ', A )"      ! Output format for integer parameters.
   CHARACTER(30)                :: Word                                            ! String to hold the first word on the line.



   IF ( PRESENT(ErrStat) ) THEN
      CALL ReadNum ( UnIn, Fil, Word, VarName, ErrStat )
      IF (ErrStat /= 0) RETURN
   ELSE
      CALL ReadNum ( UnIn, Fil, Word, VarName )
   END IF

   READ (Word,*,IOSTAT=IOS)  IntVar

   CALL CheckIOS ( IOS, Fil, VarName, NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  IntVar, VarName, VarDescr
   END IF


   RETURN
   END SUBROUTINE ReadIVar ! ( UnIn, Fil, IntVar, VarName, VarDescr [, ErrStat])
!=======================================================================
   SUBROUTINE ReadLAry ( UnIn, Fil, LogAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into an logical array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   LOGICAL, INTENT(OUT)         :: LogAry(AryLen)                                  ! Logical array being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the integer array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, I11, 2X, A, T30, ' - ', A )"      ! Output format for integer array parameters



   READ (UnIn,*,IOSTAT=IOS)  ( LogAry(Ind), Ind=1,AryLen )

   CALL CheckIOS ( IOS, Fil, TRIM( AryName ), NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      DO Ind=1,AryLen
         WRITE (UnEc,Frmt)  LogAry(Ind), TRIM( AryName ), AryDescr
      END DO ! Ind
   END IF


   RETURN
   END SUBROUTINE ReadLAry ! ( UnIn, Fil, LogAry, AryLen, AryName, AryDescr [, ErrStat])
!=======================================================================
   SUBROUTINE ReadLVar ( UnIn, Fil, LogVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single logical variable from the next line of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   LOGICAL, INTENT(OUT)         :: LogVar                                          ! Logical variable being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: VarDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(33)                :: Frmt  = "( 2X, L11, 2X, A, T30, ' - ', A )"     ! Output format for logical parameters.
   CHARACTER( 4)                :: VName                                           ! Temporary holder for the variable name.




   READ (UnIn,*,IOSTAT=IOS)  LogVar

   CALL CheckIOS ( IOS, Fil, VarName, FlgType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   VName = VarName

   CALL Conv2UC ( VName )

   IF ( Echo .AND. ( VName /= 'ECHO' ) )  THEN
      WRITE (UnEc,Frmt)  LogVar, VarName, VarDescr
   END IF


   RETURN
   END SUBROUTINE ReadLVar ! ( UnIn, Fil, LogVar, VarName, VarDescr [, ErrStat])
!=======================================================================
   SUBROUTINE ReadNum ( UnIn, Fil, Word, VarName, ErrStat )


      ! This routine reads a single word from a file and tests to see if it's a pure number (no true or false).


      ! Argument declarations:

   INTEGER, INTENT(IN)            :: UnIn                                          ! I/O unit for input file.
   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                       ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)       :: Fil                                           ! Name of the input file.
   CHARACTER(*), INTENT(IN)       :: VarName                                       ! Text string containing the variable name.
   CHARACTER(*), INTENT(Out)      :: Word                                          ! Text string containing the first word from the input line.


      ! Local declarations:

   INTEGER                        :: IOS                                           ! I/O status returned from the read statement.


   IF ( PRESENT(ErrStat) ) ErrStat = 0


      ! Read in the first word of the input line.  Check I/O status.

   READ (UnIn,*,IOSTAT=IOS)  Word

   CALL CheckIOS ( IOS, Fil, VarName, NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF


      ! See if the word starts with a T or F.  If so, flag it as an invalid number.

   IF ( INDEX( 'FTft', Word(:1) ) > 0 )  THEN
      CALL WrScr ( '' )
      CALL ProgAbort( ' Invalid numeric input.  "'//TRIM( Word )//'" found when trying to read the number, '// &
                      TRIM( VarName )//'.', PRESENT(ErrStat) )

      IF ( PRESENT(ErrStat) ) ErrStat = 1
   END IF



   RETURN
   END SUBROUTINE ReadNum ! ( UnIn, Fil, Word, VarName [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadOutputList ( UnIn, Fil, CharAry, AryLenRead, AryName, AryDescr, ErrStat )


      ! This routine reads up to MaxAryLen values from an input file and store them in CharAry(:).
      ! These values represent the names of output channels, and they are specified in the format
      ! required for OutList(:) in FAST input files.
      ! The end of this list is specified with the line beginning with the 3 characters "END".


      ! Argument declarations:

   INTEGER, INTENT(OUT)         :: AryLenRead                                      ! Length of the array that was actually read.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(OUT)    :: CharAry(:)                                      ! Character array being read (calling routine dimensions it to max allowable size).

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: MaxAryLen                                       ! Maximum length of the array being read
   INTEGER                      :: NumWords                                        ! Number of words contained on a line


   CHARACTER(1000)              :: OutLine
   CHARACTER(3)                 :: EndOfFile


      ! Initialize some values

   IF ( PRESENT(ErrStat) ) ErrStat = 0
   MaxAryLen  = SIZE(CharAry)
   AryLenRead = 0

   CharAry = ''



      ! Read in all of the lines containing output parameters and store them in CharAry(:).
      ! The end of this list is specified with the line beginning with END.

   DO

      IF ( PRESENT(ErrStat) ) THEN
         CALL ReadVar ( UnIn, Fil, OutLine, AryName, AryDescr, ErrStat )
         IF ( ErrStat /= 0 ) RETURN
      ELSE
         CALL ReadVar ( UnIn, Fil, OutLine, AryName, AryDescr  )
      END IF

      EndOfFile = OutLine(1:3)            ! EndOfFile is the 1st 3 characters of OutLine
      CALL Conv2UC( EndOfFile )           ! Convert EndOfFile to upper case
      IF ( EndOfFile == 'END' )  EXIT     ! End of OutList has been reached; therefore, exit this DO

      NumWords = CountWords( OutLine )    ! The number of words in OutLine.

      AryLenRead = AryLenRead + NumWords  ! The total number of output channels read in so far.

         ! Check to see if the maximum # allowable in the array has been reached.

      IF ( AryLenRead > MaxAryLen )  THEN

         CALL ProgAbort ( ' The maximum number of output channels allowed is ' &
                     //TRIM( Int2LStr(MaxAryLen) )//'.', PRESENT(ErrStat)      )
         ErrStat = 1
         RETURN

      ELSE

         CALL GetWords ( OutLine, CharAry((AryLenRead - NumWords + 1):AryLenRead), NumWords )

      END IF

   END DO


   RETURN
   END SUBROUTINE ReadOutputList ! ( UnIn, Fil, CharAry, AryLenRead, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadRAry ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a real array separated by white space (possibly on the same line of the input file).


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   REAL(ReKi), INTENT(INOUT)    :: RealAry(AryLen)                                 ! Real array being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the real array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real array parameters



   READ (UnIn,*,IOSTAT=IOS)  ( RealAry(Ind), Ind=1,AryLen )

   CALL CheckIOS ( IOS, Fil, TRIM( AryName ), NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      DO Ind=1,AryLen
         WRITE (UnEc,Frmt)  RealAry(Ind), TRIM( AryName ), AryDescr
      END DO ! Ind
   END IF


   RETURN
   END SUBROUTINE ReadRAry ! ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadRAryLines ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a real array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   REAL(ReKi), INTENT(OUT)      :: RealAry(AryLen)                                 ! Real array being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the real array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real array parameters


   IF ( PRESENT(ErrStat) ) ErrStat = 0

   DO Ind=1,AryLen
      READ (UnIn,*,IOSTAT=IOS)  RealAry(Ind)

      CALL CheckIOS ( IOS, Fil, TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', NumType, PRESENT(ErrStat) )

      IF (IOS /= 0) THEN
         IF ( PRESENT(ErrStat) ) ErrStat = IOS
         RETURN
      ENDIF

      IF ( Echo )  THEN
         WRITE (UnEc,Frmt)  RealAry(Ind), TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', AryDescr
      END IF
   END DO

   RETURN
   END SUBROUTINE ReadRAryLines ! ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadRAryLines4 ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a real array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   REAL(SiKi), INTENT(OUT)      :: RealAry(AryLen)                                 ! Real (4-byte) array being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the real array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real array parameters


   IF ( PRESENT(ErrStat) ) ErrStat = 0

   DO Ind=1,AryLen
      READ (UnIn,*,IOSTAT=IOS)  RealAry(Ind)

      CALL CheckIOS ( IOS, Fil, TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', NumType, PRESENT(ErrStat) )

      IF (IOS /= 0) THEN
         IF ( PRESENT(ErrStat) ) ErrStat = IOS
         RETURN
      ENDIF

      IF ( Echo )  THEN
         WRITE (UnEc,Frmt)  RealAry(Ind), TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', AryDescr
      END IF
   END DO

   RETURN
   END SUBROUTINE ReadRAryLines4 ! ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadRAryLines8 ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a real array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   REAL(R8Ki), INTENT(OUT)      :: RealAry(AryLen)                                 ! Real (8-byte) array being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the real array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real array parameters


   IF ( PRESENT(ErrStat) ) ErrStat = 0

   DO Ind=1,AryLen
      READ (UnIn,*,IOSTAT=IOS)  RealAry(Ind)

      CALL CheckIOS ( IOS, Fil, TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', NumType, PRESENT(ErrStat) )

      IF (IOS /= 0) THEN
         IF ( PRESENT(ErrStat) ) ErrStat = IOS
         RETURN
      ENDIF

      IF ( Echo )  THEN
         WRITE (UnEc,Frmt)  RealAry(Ind), TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', AryDescr
      END IF
   END DO

   RETURN
   END SUBROUTINE ReadRAryLines8 ! ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadRAryLines16 ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a real array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   REAL(QuKi), INTENT(OUT)      :: RealAry(AryLen)                                 ! Real (16-byte) array being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the real array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real array parameters


   IF ( PRESENT(ErrStat) ) ErrStat = 0

   DO Ind=1,AryLen
      READ (UnIn,*,IOSTAT=IOS)  RealAry(Ind)

      CALL CheckIOS ( IOS, Fil, TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', NumType, PRESENT(ErrStat) )

      IF (IOS /= 0) THEN
         IF ( PRESENT(ErrStat) ) ErrStat = IOS
         RETURN
      ENDIF

      IF ( Echo )  THEN
         WRITE (UnEc,Frmt)  RealAry(Ind), TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', AryDescr
      END IF
   END DO

   RETURN
   END SUBROUTINE ReadRAryLines16 ! ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadRVar ( UnIn, Fil, RealVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single real variable from the next line of the input file.
      ! New code should use ReadVar instead of this routine.


      ! Argument declarations:

   REAL(ReKi), INTENT(OUT)      :: RealVar                                         ! Real variable being read.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.

   CHARACTER( *), INTENT(IN)    :: Fil                                             ! Name of the input file.
   CHARACTER( *), INTENT(IN)    :: VarDescr                                        ! Text string describing the variable.
   CHARACTER( *), INTENT(IN)    :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real parameters
   CHARACTER(30)                :: Word                                            ! String to hold the first word on the line.



   IF ( PRESENT(ErrStat) ) THEN
      CALL ReadNum ( UnIn, Fil, Word, VarName, ErrStat )
      IF (ErrStat /= 0) RETURN
   ELSE
      CALL ReadNum ( UnIn, Fil, Word, VarName )
   END IF

   READ (Word,*,IOSTAT=IOS)  RealVar

   CALL CheckIOS ( IOS, Fil, VarName, NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   END IF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  RealVar, VarName, VarDescr
   END IF


   RETURN
   END SUBROUTINE ReadRVar ! ( UnIn, Fil, RealVar, VarName, VarDescr [, ErrStat] )
!=======================================================================
  SUBROUTINE ReadR4Var ( UnIn, Fil, RealVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single double (real) variable from the next line of the input file.


      ! Argument declarations:

   REAL(SiKi), INTENT(OUT)      :: RealVar                                         ! Real (4-byte) variable being read.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.

   CHARACTER( *), INTENT(IN)    :: Fil                                             ! Name of the input file.
   CHARACTER( *), INTENT(IN)    :: VarDescr                                        ! Text string describing the variable.
   CHARACTER( *), INTENT(IN)    :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real parameters
   CHARACTER(30)                :: Word                                            ! String to hold the first word on the line.



   IF ( PRESENT(ErrStat) ) THEN
      CALL ReadNum ( UnIn, Fil, Word, VarName, ErrStat )
      IF (ErrStat /= 0) RETURN
   ELSE
      CALL ReadNum ( UnIn, Fil, Word, VarName )
   END IF

   READ (Word,*,IOSTAT=IOS)  RealVar

   CALL CheckIOS ( IOS, Fil, VarName, NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   END IF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  RealVar, VarName, VarDescr
   END IF


   RETURN
  END SUBROUTINE ReadR4Var ! ( UnIn, Fil, RealVar, VarName, VarDescr [, ErrStat] )
!=======================================================================
  SUBROUTINE ReadR8Var ( UnIn, Fil, RealVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single double (real) variable from the next line of the input file.


      ! Argument declarations:

   REAL(R8Ki), INTENT(OUT)      :: RealVar                                         ! Real (8-byte) variable being read.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.

   CHARACTER( *), INTENT(IN)    :: Fil                                             ! Name of the input file.
   CHARACTER( *), INTENT(IN)    :: VarDescr                                        ! Text string describing the variable.
   CHARACTER( *), INTENT(IN)    :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real parameters
   CHARACTER(30)                :: Word                                            ! String to hold the first word on the line.



   IF ( PRESENT(ErrStat) ) THEN
      CALL ReadNum ( UnIn, Fil, Word, VarName, ErrStat )
      IF (ErrStat /= 0) RETURN
   ELSE
      CALL ReadNum ( UnIn, Fil, Word, VarName )
   END IF

   READ (Word,*,IOSTAT=IOS)  RealVar

   CALL CheckIOS ( IOS, Fil, VarName, NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   END IF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  RealVar, VarName, VarDescr
   END IF


   RETURN
  END SUBROUTINE ReadR8Var ! ( UnIn, Fil, RealVar, VarName, VarDescr [, ErrStat] )
!=======================================================================
  SUBROUTINE ReadR16Var ( UnIn, Fil, RealVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single double (real) variable from the next line of the input file.


      ! Argument declarations:

   REAL(QuKi), INTENT(OUT)      :: RealVar                                         ! Real (16-byte) variable being read.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.

   CHARACTER( *), INTENT(IN)    :: Fil                                             ! Name of the input file.
   CHARACTER( *), INTENT(IN)    :: VarDescr                                        ! Text string describing the variable.
   CHARACTER( *), INTENT(IN)    :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real parameters
   CHARACTER(30)                :: Word                                            ! String to hold the first word on the line.



   IF ( PRESENT(ErrStat) ) THEN
      CALL ReadNum ( UnIn, Fil, Word, VarName, ErrStat )
      IF (ErrStat /= 0) RETURN
   ELSE
      CALL ReadNum ( UnIn, Fil, Word, VarName )
   END IF

   READ (Word,*,IOSTAT=IOS)  RealVar

   CALL CheckIOS ( IOS, Fil, VarName, NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   END IF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  RealVar, VarName, VarDescr
   END IF


   RETURN
   END SUBROUTINE ReadR16Var ! ( UnIn, Fil, RealVar, VarName, VarDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadStr ( UnIn, Fil, CharVar, VarName, VarDescr, ErrStat )


      ! This routine reads a string from the next line of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(OUT)    :: CharVar                                         ! Integer variable being read.
   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: VarDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(35)                :: Frmt = "( 15X, A, T30, ' - ', A, /, 2X, A )"    ! Output format for string parameters.




   READ (UnIn,'(A)',IOSTAT=IOS)  CharVar

   CALL CheckIOS ( IOS, Fil, VarName, StrType )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   END IF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  VarName, VarDescr, '"'//TRIM( CharVar )//'"'
   END IF


   RETURN
   END SUBROUTINE ReadStr ! ( UnIn, Fil, CharVar, VarName, VarDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE WaitTime ( WaitSecs )


      ! This routine writes out a prompt to the screen without
      ! following it with a new line, though a new line precedes it.


   IMPLICIT NONE


      ! Argument declarations:

   REAL(ReKi), INTENT(IN)       :: WaitSecs                                        ! The number of seconds to wait.


      ! Local declarations:

   REAL(ReKi)                   :: EndCounts                                       ! The number of counts when wait time is over.

   INTEGER                      :: Counts                                          ! Current number of counts on the system clock.
   INTEGER                      :: CountMax                                        ! Maximum number of counts possible on the system clock.
   INTEGER                      :: CountRate                                       ! Number of counts per second on the system clock.



   CALL SYSTEM_CLOCK ( Counts, CountRate, CountMax )
   EndCounts = Counts + INT( WaitSecs*CountRate )

   DO
      CALL SYSTEM_CLOCK ( Counts, CountRate, CountMax )
      IF ( Counts > EndCounts )  EXIT
   END DO


   RETURN
   END SUBROUTINE WaitTime ! ( Seconds )
!=======================================================================
   SUBROUTINE WrPr ( Str )


      ! This routine writes out a prompt to the screen without
      ! following it with a new line, though a new line precedes it.


      ! Argument declarations:

   CHARACTER(*), INTENT(IN)     :: Str                                          ! The prompt string to print.



   CALL WrScr ( ' ' )
   CALL WrNR  ( TRIM( Str )//' > ' )


   RETURN
   END SUBROUTINE WrPr ! ( Str )
!=======================================================================
   SUBROUTINE WrFileNR ( Unit, Str )


      ! This routine writes out a string to the file connected to Unit without following it with a new line.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Unit                                         ! I/O unit for input file.

   CHARACTER(*), INTENT(IN)     :: Str                                          ! String to be written without a newline at the end.



   WRITE (Unit,'(A)',ADVANCE='NO')  Str


   RETURN
   END SUBROUTINE WrFileNR ! ( Unit, Str )
!=======================================================================
   SUBROUTINE WrML ( Str )


      ! This routine writes out a string in the middle of a line.


      ! Argument declarations.

   CHARACTER(*)                 :: Str



   CALL WrNR ( Str )


   RETURN
   END SUBROUTINE WrML ! ( Str )
!=======================================================================
   SUBROUTINE WrScr1 ( Str )


      ! This routine writes out a string to the screen after a blank line.


      ! Argument declarations.

   CHARACTER(*)                 :: Str                                         ! The string to print.



   CALL WrScr ( ' ' )
   CALL WrScr ( TRIM( Str ) )


   RETURN
   END SUBROUTINE WrScr1 ! ( Str )
!=======================================================================

END MODULE NWTC_IO
MODULE NWTC_Num


   ! This module contains numeric-type routines with non-system-specific logic and references.


   ! It contains the following routines:

   !     SUBROUTINE AddOrSub2Pi   ( OldAngle, NewAngle )
   !     SUBROUTINE BSortReal     ( RealAry, NumPts )
   !     FUNCTION   CROSS_PRODUCT ( Vector1, Vector2 )
   !     FUNCTION   EqualRealNos  ( ReNum1, ReNum2 )
   !     SUBROUTINE GL_Pts        ( IPt, NPts, Loc, Wt [, ErrStat] )
   !     FUNCTION   IndexCharAry  ( CVal, CAry )
   !     FUNCTION   InterpBin     ( XVal, XAry, YAry, ILo, AryLen )             ! Generic interface for InterpBinComp and InterpBinReal.
   !     FUNCTION   InterpBinComp ( XVal, XAry, YAry, ILo, AryLen )
   !     FUNCTION   InterpBinReal ( XVal, XAry, YAry, ILo, AryLen )
   !     FUNCTION   InterpStp     ( XVal, XAry, YAry, ILo, AryLen )             ! Generic interface for InterpStpComp and InterpStpReal.
   !     FUNCTION   InterpStpComp ( XVal, XAry, YAry, Ind, AryLen )
   !     FUNCTION   InterpStpReal ( XVal, XAry, YAry, Ind, AryLen )
   !     SUBROUTINE LocateStp     ( XVal, XAry, Ind, AryLen )
   !     FUNCTION   Mean          ( Ary, AryLen )                               ! Function to calculate the mean value of a vector array.
   !     SUBROUTINE MPi2Pi        ( Angle )
   !     SUBROUTINE RombergInt    ( f, a, b, R, err, eps, ErrStat )
   !     SUBROUTINE SetConstants
   !     SUBROUTINE SmllRotTrans  ( RotationType, Theta1, Theta2, Theta3, TransMat, ErrTxt )
   !     SUBROUTINE SortUnion     ( Ary1, N1, Ary2, N2, Ary, N )
   !     FUNCTION   StdDevFn      ( Ary, AryLen, Mean )                         ! Function to calculate the standard deviation of a vector array.


   USE                             NWTC_IO

   IMPLICIT NONE

!=======================================================================


      ! Global numeric-related variables.

   REAL(DbKi)                   :: D2R_D                                        ! Factor to convert degrees to radians in double precision.
   REAL(DbKi)                   :: Inf_D                                        ! IEEE value for NaN (not-a-number) in double precision 
   REAL(DbKi)                   :: NaN_D                                        ! IEEE value for Inf (infinity) in double precision
   REAL(DbKi)                   :: Pi_D                                         ! Ratio of a circle's circumference to its diameter in double precision.
   REAL(DbKi)                   :: PiBy2_D                                      ! Pi/2 in double precision.
   REAL(DbKi)                   :: R2D_D                                        ! Factor to convert radians to degrees in double precision.
   REAL(DbKi)                   :: RPM2RPS_D                                    ! Factor to convert revolutions per minute to radians per second in double precision.
   REAL(DbKi)                   :: RPS2RPM_D                                    ! Factor to convert radians per second to revolutions per minute in double precision.
   REAL(DbKi)                   :: TwoByPi_D                                    ! 2/Pi in double precision.
   REAL(DbKi)                   :: TwoPi_D                                      ! 2*Pi in double precision.
   
   
   REAL(ReKi)                   :: D2R                                          ! Factor to convert degrees to radians.
   REAL(ReKi)                   :: Inf                                          ! IEEE value for NaN (not-a-number)
   REAL(ReKi)                   :: NaN                                          ! IEEE value for Inf (infinity)
   REAL(ReKi)                   :: Pi                                           ! Ratio of a circle's circumference to its diameter.
   REAL(ReKi)                   :: PiBy2                                        ! Pi/2.
   REAL(ReKi)                   :: R2D                                          ! Factor to convert radians to degrees.
   REAL(ReKi)                   :: RPM2RPS                                      ! Factor to convert revolutions per minute to radians per second.
   REAL(ReKi)                   :: RPS2RPM                                      ! Factor to convert radians per second to revolutions per minute.
   REAL(ReKi)                   :: TwoByPi                                      ! 2/Pi.
   REAL(ReKi)                   :: TwoPi                                        ! 2*Pi.

   INTEGER, ALLOCATABLE         :: IntIndx  (:,:)                               ! The array of indices holding that last index used for interpolation in IntBlade().


!=======================================================================

      ! Create interface for a generic EqualRealNos that uses specific routines.

   INTERFACE EqualRealNos
      MODULE PROCEDURE EqualRealNos4
      MODULE PROCEDURE EqualRealNos8
      MODULE PROCEDURE EqualRealNos16
   END INTERFACE
   

      ! Create interface for a generic InterpBin that actually uses specific routines.

   INTERFACE InterpBin
      MODULE PROCEDURE InterpBinComp
      MODULE PROCEDURE InterpBinReal
   END INTERFACE


      ! Create interface for a generic InterpStp that actually uses specific routines.

   INTERFACE InterpStp
      MODULE PROCEDURE InterpStpComp
      MODULE PROCEDURE InterpStpReal
   END INTERFACE


CONTAINS

!=======================================================================
   SUBROUTINE AddOrSub2Pi ( OldAngle, NewAngle )


      ! This routine is used to convert NewAngle to an angle within 2*Pi of
      !   OldAngle by adding or subtracting 2*Pi accordingly; it then sets
      !   OldAngle equal to NewAngle.  This routine is useful for converting
      !   angles returned from a call to the ATAN2() FUNCTION into angles that may
      !   exceed the -Pi to Pi limit of ATAN2().  For example, if the nacelle yaw
      !   angle was 179deg in the previous time step and the yaw angle increased
      !   by 2deg in the new time step, we want the new yaw angle returned from a
      !   call to the ATAN2() FUNCTION to be 181deg instead of -179deg.  This
      !   routine assumes that the angle change between calls is not more than
      !   2*Pi in absolute value.  OldAngle should be SAVEd in the calling
      !   routine.


      ! Argument declarations:

   REAL(ReKi), INTENT(INOUT)    :: OldAngle                                     ! Angle from which NewAngle will be converted to within 2*Pi of, rad.
   REAL(ReKi), INTENT(INOUT)    :: NewAngle                                     ! Angle to be converted to within 2*Pi of OldAngle, rad.


      ! Local declarations:

   REAL(ReKi)                   :: DelAngle                                     ! The difference between OldAngle and NewAngle, rad.



      ! Add or subtract 2*Pi in order to convert NewAngle two within 2*Pi of
      !   OldAngle:

   DelAngle = OldAngle - NewAngle

   DO WHILE ( ABS( DelAngle ) >= TwoPi )

      NewAngle = NewAngle + SIGN( TwoPi, DelAngle )
      DelAngle = OldAngle - NewAngle

   END DO


      ! Set OldAngle to equal NewAngle:

   OldAngle = NewAngle



   RETURN
   END SUBROUTINE AddOrSub2Pi
!=======================================================================
   SUBROUTINE BSortReal ( RealAry, NumPts )


      ! This routine sorts a list of real numbers.  It uses the buble sort algorithm,
      ! which is only suitable for short lists.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: NumPts                                       ! The length of the list to be sorted.

   REAL(ReKi), INTENT(INOUT)    :: RealAry(NumPts)                              ! The list of real numbers to be sorted.


      ! Local declarations:

   REAL(ReKi)                   :: Temp                                         ! Temporary variable to hold the current element.

   INTEGER                      :: I                                            ! Index into the array.

   LOGICAL                      :: Change                                       ! Flag to indicate if a change of order was made.


      ! Sort the list

   Change = .TRUE.

   DO WHILE ( Change )

      Change = .FALSE.

      DO I=2,NumPts
         IF ( RealAry(I) < RealAry(I-1) )  THEN
            Temp           = RealAry(I)
            RealAry(I)   = RealAry(I-1)
            RealAry(I-1) = Temp
            Change         = .TRUE.
         END IF
      END DO ! I

   END DO ! WHILE


   RETURN
   END SUBROUTINE BSortReal ! ( RealAry, NumPts )
!=======================================================================
   FUNCTION Cross_Product(Vector1, Vector2)

      ! This function computes the cross product of two 3-element arrays:
      ! Cross_Product = Vector1 X Vector2 (resulting in a vector)


      ! Argument declarations.

   REAL(ReKi), INTENT(IN )         :: Vector1       (3)
   REAL(ReKi), INTENT(IN )         :: Vector2       (3)

      ! Function definition
   REAL(ReKi)                      :: Cross_Product (3)        ! = Vector1 X Vector2 (resulting in a vector)


   Cross_Product(1) = Vector1(2)*Vector2(3) - Vector1(3)*Vector2(2)
   Cross_Product(2) = Vector1(3)*Vector2(1) - Vector1(1)*Vector2(3)
   Cross_Product(3) = Vector1(1)*Vector2(2) - Vector1(2)*Vector2(1)


   RETURN
   END FUNCTION Cross_Product
!=======================================================================
!   SUBROUTINE GetPermMat ( InpMat, PMat, ErrStat )
!
!      ! This subroutine computes a permutation matrix, PMat, for a given
!      ! input matrix, InpMat. It assumes that InpMat is of full rank
!      ! and for now, the matrices are 3 x 3.
!
!      ! passed variables
!
!   REAL(ReKi), INTENT(IN )         :: InpMat       (3,3)
!   REAL(ReKi), INTENT(OUT )        :: PMat         (3,3) !this could be integer, but we'll leave it real now
!   INTEGER,    INTENT(OUT )        :: ErrStat            ! a non-zero value indicates an error in the permutation matrix algorithm
!
!      ! local variables
!   INTEGER                         :: iCol               ! loop counter
!   INTEGER                         :: iRow               ! loop counter
!   INTEGER                         :: MaxCol             ! holds index of maximum value in a column
!
!   LOGICAL                         :: ChkCols     (3)    ! a check to make sure we have only one non-zero element per column
!
!      ! initialize some variables
!   PMat    = 0.0
!   ChkCols = .FALSE.
!   ErrStat = 0
!
!      ! find the pivots
!   DO iRow = 1,3
!
!      MaxCol = 1        ! initialize max index
!      DO iCol = 2,3
!         IF ( ABS(InpMat(iRow,iCol)) > ABS(InpMat(iRow,MaxCol)) ) &
!            MaxCol = iCol
!      END DO ! iCol
!
!      IF ( ChkCols(MaxCol) ) THEN   ! we can have only 1 non-zero entry per row and column, but we've just violated that!
!         CALL ProgAbort( ' Error in GetPermMat(): InpMat is not full rank.', TrapErrors = .TRUE. )
!         ErrStat = 1
!      END IF
!
!      PMat(MaxCol, iRow) = SIGN( 1.0_ReKi, InpMat(iRow,MaxCol) )  ! technically a permutation matrix would only have +1.0 (not -1.0)
!      ChkCols(MaxCol)    = .TRUE.
!
!   END DO ! iRow
!
!   RETURN
!   END SUBROUTINE GetPermMat ! ( InpMat, PMat, ErrStat )

!=======================================================================
   FUNCTION EqualRealNos4 ( ReNum1, ReNum2 )

      ! This function compares 2 real numbers and determines if they
      ! are "almost" equal, i.e. within some relative tolerance
      ! ("Safe Comparisons" suggestion from http://www.lahey.com/float.htm)

      ! passed variables

   REAL(SiKi), INTENT(IN )         :: ReNum1                            ! the first  real number to compare
   REAL(SiKi), INTENT(IN )         :: ReNum2                            ! the second real number to compare

   LOGICAL                         :: EqualRealNos4                     ! the function definition -- returns .true. if the numbers are almost equal

      ! local variables
   REAL(SiKi), PARAMETER           :: Eps = EPSILON(ReNum1)             ! machine precision
   REAL(SiKi), PARAMETER           :: Tol = 100.0_SiKi*Eps / 2.0_SiKi   ! absolute tolerance (ignore the last 2 significant digits)

   REAL(SiKi)                      :: Fraction


      ! make sure we're never trying to get more precision than Tol

   Fraction = MAX( ABS(ReNum1+ReNum2), 1.0_SiKi )



      ! determine if ReNum1 and ReNum2 are approximately equal

   IF ( ABS(ReNum1 - ReNum2) <= Fraction*Tol ) THEN  ! the relative error 
      EqualRealNos4 = .TRUE.
   ELSE
      EqualRealNos4 = .FALSE.
   ENDIF


   END FUNCTION EqualRealNos4
!=======================================================================
  FUNCTION EqualRealNos8 ( ReNum1, ReNum2 )

      ! This function compares 2 real numbers and determines if they
      ! are "almost" equal, i.e. within some relative tolerance
      ! ("Safe Comparisons" suggestion from http://www.lahey.com/float.htm)

      ! passed variables

   REAL(R8Ki), INTENT(IN )         :: ReNum1                            ! the first  real number to compare
   REAL(R8Ki), INTENT(IN )         :: ReNum2                            ! the second real number to compare

   LOGICAL                         :: EqualRealNos8                     ! the function definition -- returns .true. if the numbers are almost equal

      ! local variables
   REAL(R8Ki), PARAMETER           :: Eps = EPSILON(ReNum1)             ! machine precision
   REAL(R8Ki), PARAMETER           :: Tol = 100.0_R8Ki*Eps / 2.0_R8Ki   ! absolute tolerance (ignore the last 2 significant digits)

   REAL(R8Ki)                      :: Fraction


      ! make sure we're never trying to get more precision than Tol

   Fraction = MAX( ABS(ReNum1+ReNum2), 1.0_R8Ki )



      ! determine if ReNum1 and ReNum2 are approximately equal

   IF ( ABS(ReNum1 - ReNum2) <= Fraction*Tol ) THEN  ! the relative error
      EqualRealNos8 = .TRUE.
   ELSE
      EqualRealNos8 = .FALSE.
   ENDIF


  END FUNCTION EqualRealNos8
!=======================================================================
  FUNCTION EqualRealNos16 ( ReNum1, ReNum2 )

      ! This function compares 2 real numbers and determines if they
      ! are "almost" equal, i.e. within some relative tolerance
      ! ("Safe Comparisons" suggestion from http://www.lahey.com/float.htm)

      ! passed variables

   REAL(QuKi), INTENT(IN )         :: ReNum1                            ! the first  real number to compare
   REAL(QuKi), INTENT(IN )         :: ReNum2                            ! the second real number to compare

   LOGICAL                         :: EqualRealNos16                    ! the function definition -- returns .true. if the numbers are almost equal

      ! local variables
   REAL(QuKi), PARAMETER           :: Eps = EPSILON(ReNum1)             ! machine precision
   REAL(QuKi), PARAMETER           :: Tol = 100.0_QuKi*Eps / 2.0_QuKi   ! absolute tolerance (ignore the last 2 significant digits)

   REAL(QuKi)                      :: Fraction


      ! make sure we're never trying to get more precision than Tol

   Fraction = MAX( ABS(ReNum1+ReNum2), 1.0_QuKi )



      ! determine if ReNum1 and ReNum2 are approximately equal

   IF ( ABS(ReNum1 - ReNum2) <= Fraction*Tol ) THEN  ! the relative error
      EqualRealNos16 = .TRUE.
   ELSE
      EqualRealNos16 = .FALSE.
   ENDIF


  END FUNCTION EqualRealNos16
!=======================================================================
   FUNCTION GetSmllRotAngs ( DCMat, ErrStat )

      ! This subroutine computes the angles that make up the input
      ! direction cosine matrix, DCMat

      ! passed variables

   REAL(ReKi), INTENT(IN )         :: DCMat          (3,3)
   INTEGER,    INTENT(OUT )        :: ErrStat               ! a non-zero value indicates an error in the permutation matrix algorithm

   REAL(ReKi)                      :: GetSmllRotAngs ( 3 )

      ! local variables
   REAL(ReKi)                      :: denom                 ! the denominator of the resulting matrix
   REAL(ReKi), PARAMETER           :: LrgAngle  = 0.4       ! Threshold for when a small angle becomes large (about 23deg).  This comes from: COS(SmllAngle) ~ 1/SQRT( 1 + SmllAngle^2 ) and SIN(SmllAngle) ~ SmllAngle/SQRT( 1 + SmllAngle^2 ) results in ~5% error when SmllAngle = 0.4rad.
   REAL(ReKi), PARAMETER           :: TOL = EPSILON(TOL)    ! tolerance for division by zero



      ! initialize output angles (just in case there is an error that prevents them from getting set)

   GetSmllRotAngs = 0.0
   ErrStat        = 0


      ! calculate the small angles
   GetSmllRotAngs(1) = DCMat(2,3) - DCMat(3,2)
   GetSmllRotAngs(2) = DCMat(3,1) - DCMat(1,3)
   GetSmllRotAngs(3) = DCMat(1,2) - DCMat(2,1)

   denom             = DCMat(1,1) + DCMat(2,2) + DCMat(3,3) - 1

   IF ( ABS(denom) > TOL ) THEN
      GetSmllRotAngs = GetSmllRotAngs / denom

               ! check that the angles are, in fact, small
      IF ( ANY( ABS(GetSmllRotAngs) > LrgAngle ) ) THEN
         CALL ProgWarn( ' Angles in GetSmllRotAngs() are larger than '//TRIM(Num2LStr(LrgAngle))//' radians.' )
         ErrStat = 1
      END IF

   ELSE
            ! check that the angles are, in fact, small (denom should be close to 2 if angles are small)
      CALL ProgAbort( ' Denominator is zero in GetSmllRotAngs().', TrapErrors = .TRUE. )
      ErrStat = -1

   END IF


   END FUNCTION GetSmllRotAngs ! ( DCMat, PMat, ErrStat )
!=======================================================================
   SUBROUTINE GL_Pts ( IPt, NPts, Loc, Wt, ErrStat )

      ! This funtion returns the non-dimensional (-1:+1) location of the given Gauss-Legendre Quadrature point and its weight.
      ! The values came from Carnahan, Brice; Luther, H.A.; Wilkes, James O.  (1969)  "Applied Numerical Methods."


      ! Argument declarations.

   REAL(ReKi)                     :: Loc                                         ! The location of the specified point.
   REAL(ReKi)                     :: Wt                                          ! The weight for the specified point.

   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                     ! Error status; if present, program does not abort on error
   INTEGER, INTENT(INOUT)         :: IPt                                         ! The quadrature point in question.
   INTEGER, INTENT(INOUT)         :: NPts                                        ! The number of points used in the quadrature.


   IF ( PRESENT(ErrStat) ) ErrStat = 0


      ! Check to see if the number of points and the specific point are valid values.

   IF ( ( NPts < 1 ) .OR. ( NPts > 6 ) )  THEN
      CALL ProgAbort ( ' In function GL_Loc, the number of points used for Gauss-Legendre Quadrature must be between 1 and 6' &
                    //' (inclusive).  Instead, it is "'//TRIM( Int2LStr( NPts ) )//'".', PRESENT(ErrStat) )
      IF ( PRESENT(ErrStat) ) THEN ! this should always be true here
         ErrStat = 1
         RETURN
      END IF
   END IF

   IF ( ( Ipt < 1 ) .OR. ( Ipt > NPts ) )  THEN
      CALL ProgAbort ( ' In function GL_Loc, the point being used for Gauss-Legendre Quadrature must be between 1 and ' &
                   //TRIM( Int2LStr( NPts ) )//' (inclusive).  Instead, it is "'//TRIM( Int2LStr( Ipt ) )//'".', PRESENT(ErrStat) )
      IF ( PRESENT(ErrStat) ) THEN
         ErrStat = 1
         RETURN
      END IF
   END IF


      ! Set the location and weight of the point.

   SELECT CASE ( NPts )
      CASE ( 1 )                         ! Case 1 is really just rectangular integration.
         Loc = 0.0
         Wt  = 2.0
      CASE ( 2 )
         SELECT CASE ( Ipt )
            CASE ( 1 )
               Loc = -0.5773503
               Wt  =  1.0
            CASE ( 2 )
               Loc = 0.5773503
               Wt  = 1.0
          END SELECT ! Ipt
      CASE ( 3 )
         SELECT CASE ( Ipt )
            CASE ( 1 )
               Loc = -0.7745967
               Wt  =  0.5555556
            CASE ( 2 )
               Loc =  0.0
               Wt  =  0.8888889
            CASE ( 3 )
               Loc =  0.7745967
               Wt  =  0.5555556
         END SELECT ! Ipt
      CASE ( 4 )
         SELECT CASE ( Ipt )
            CASE ( 1 )
               Loc = -0.8611363
               Wt  =  0.3478548
            CASE ( 2 )
               Loc = -0.3399810
               Wt  =  0.6521452
            CASE ( 3 )
               Loc =  0.3399810
               Wt  =  0.6521452
            CASE ( 4 )
               Loc =  0.8611363
               Wt  =  0.3478548
         END SELECT ! Ipt
      CASE ( 5 )
         SELECT CASE ( Ipt )
            CASE ( 1 )
               Loc = -0.9061798
               Wt  =  0.2369269
            CASE ( 2 )
               Loc = -0.5384693
               Wt  =  0.4786287
            CASE ( 3 )
               Loc =  0.0
               Wt  =  0.5688889
            CASE ( 4 )
               Loc =  0.5384693
               Wt  =  0.4786287
            CASE ( 5 )
               Loc =  0.9061798
               Wt  =  0.2369269
         END SELECT ! Ipt
      CASE ( 6 )
         SELECT CASE ( Ipt )
            CASE ( 1 )
               Loc = -0.9324695
               Wt  =  0.1713245
            CASE ( 2 )
               Loc = -0.6612094
               Wt  =  0.3607616
            CASE ( 3 )
               Loc = -0.2386192
               Wt  =  0.4679139
            CASE ( 4 )
               Loc =  0.2386192
               Wt  =  0.4679139
            CASE ( 5 )
               Loc =  0.6612094
               Wt  =  0.3607616
            CASE ( 6 )
               Loc =  0.9324695
               Wt  =  0.1713245
         END SELECT ! Ipt
   END SELECT ! Npts

   RETURN
   END SUBROUTINE GL_Pts ! ( IPt, NPts, Loc, Wt [, ErrStat] )
!=======================================================================
   FUNCTION IndexCharAry( CVal, CAry )


      ! This funtion returns an integer index such that CAry(IndexCharAry) = CVal. If
      ! no element in the array matches CVal, the value -1 is returned.  The routine
      ! performs a binary search on the input array to determine if CVal is an
      ! element of the array; thus, CAry must be sorted and stored in increasing
      ! alphebetical (ASCII) order. The routine does not check that the array is
      ! sorted.  The routine assumes that CVal is type CHARACTER and CAry
      ! is an array of CHARACTERS.


      ! Function declaration.


   INTEGER                      :: IndexCharAry                                   ! This function

      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: CVal                                           ! String to find.
   CHARACTER(*), INTENT(IN)     :: CAry(:)                                        ! Array of strings to search.



      ! Local declarations.

   INTEGER                      :: IHi                                             ! The high index into the arrays.
   INTEGER                      :: IMid                                            ! The mid-point index between IHi and ILo.
   INTEGER                      :: ILo


      ! Initialize some variables

   ILo = 1
   IHi = SIZE(CAry)

   IF (     CVal == CAry(ILo) ) THEN
      IndexCharAry = ILo
   ELSEIF ( CVal == CAry(IHi) ) THEN
      IndexCharAry = IHi
   ELSE
      IndexCharAry = -1


         ! Let's search!

      DO WHILE ( IHi-ILo > 1 )

         IMid = ( IHi + ILo )/2

         IF( CVal > CAry(IMid) ) THEN
            ILo = IMid
         ELSEIF (CVal < CAry(IMid) ) THEN
            IHi = IMid
         ELSE !Found it
            IndexCharAry = IMid
            EXIT
         END IF

      END DO

   END IF


   RETURN

   END FUNCTION IndexCharAry
!=======================================================================
   FUNCTION InterpBinComp( XVal, XAry, YAry, ILo, AryLen )


      ! This funtion returns a y-value that corresponds to an input x-value by interpolating into the arrays.
      ! It uses a binary interpolation scheme that takes about log(AryLen)/log(2) steps to converge.
      ! It returns the first or last YAry() value if XVal is outside the limits of XAry().
      ! This routine assumes YAry is COMPLEX.


      ! Function declaration.


   COMPLEX(ReKi)                :: InterpBinComp                                   ! This function.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the arrays.
   INTEGER, INTENT(INOUT)       :: ILo                                             ! The low index into the arrays.

   REAL(ReKi), INTENT(IN)       :: XAry    (AryLen)                                ! Array of X values to be interpolated.
   REAL(ReKi), INTENT(IN)       :: XVal                                            ! X value to be interpolated.

   COMPLEX(ReKi), INTENT(IN)    :: YAry    (AryLen)                                ! Array of Y values to be interpolated.


      ! Local declarations.

   INTEGER                      :: IHi                                             ! The high index into the arrays.
   INTEGER                      :: IMid                                            ! The mid-point index between IHi and ILo.



      ! Let's check the limits first.

   IF ( XVal <= XAry(1) )  THEN
      InterpBinComp = YAry(1)
      ILo           = 1
      RETURN
   ELSE IF ( XVal >= XAry(AryLen) )  THEN
      InterpBinComp = YAry(AryLen)
      ILo           = AryLen - 1
      RETURN
   END IF


      ! Let's interpolate!

   ILo  = 1
   IHi  = AryLen

   DO WHILE ( IHi-ILo > 1 )

      IMid = ( IHi + ILo )/2

      IF ( XVal >= XAry(IMid) ) THEN
         ILo = IMid
      ELSE
         IHi = IMid
      END IF

   END DO

   InterpBinComp = YAry(ILo) + ( YAry(IHi) - YAry(ILo) )*( XVal - XAry(ILo) )/( XAry(IHi) - XAry(ILo) )


   RETURN
   END FUNCTION InterpBinComp ! ( XVal, XAry, YAry, ILo, AryLen )
!=======================================================================
   FUNCTION InterpBinReal( XVal, XAry, YAry, ILo, AryLen )


      ! This funtion returns a y-value that corresponds to an input x-value by interpolating into the arrays.
      ! It uses a binary interpolation scheme that takes about log(AryLen)/log(2) steps to converge.
      ! It returns the first or last YAry() value if XVal is outside the limits of XAry().
      ! This routine assumes YAry is REAL.


      ! Function declaration.


   REAL(ReKi)                   :: InterpBinReal                                   ! This function.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the arrays.
   INTEGER, INTENT(INOUT)       :: ILo                                             ! The low index into the arrays.

   REAL(ReKi), INTENT(IN)       :: XAry    (AryLen)                                ! Array of X values to be interpolated.
   REAL(ReKi), INTENT(IN)       :: XVal                                            ! X value to be interpolated.
   REAL(ReKi), INTENT(IN)       :: YAry    (AryLen)                                ! Array of Y values to be interpolated.


      ! Local declarations.

   INTEGER                      :: IHi                                             ! The high index into the arrays.
   INTEGER                      :: IMid                                            ! The mid-point index between IHi and ILo.



      ! Let's check the limits first.

   IF ( XVal <= XAry(1) )  THEN
      InterpBinReal = YAry(1)
      ILo           = 1
      RETURN
   ELSE IF ( XVal >= XAry(AryLen) )  THEN
      InterpBinReal = YAry(AryLen)
      ILo           = AryLen - 1
      RETURN
   END IF


      ! Let's interpolate!

   ILo  = 1
   IHi  = AryLen

   DO WHILE ( IHi-ILo > 1 )

      IMid = ( IHi + ILo )/2

      IF ( XVal >= XAry(IMid) ) THEN
         ILo = IMid
      ELSE
         IHi = IMid
      END IF

   END DO

   InterpBinReal = YAry(ILo) + ( YAry(IHi) - YAry(ILo) )*( XVal - XAry(ILo) )/( XAry(IHi) - XAry(ILo) )


   RETURN
   END FUNCTION InterpBinReal ! ( XVal, XAry, YAry, ILo, AryLen )
!=======================================================================
   FUNCTION InterpStpComp( XVal, XAry, YAry, Ind, AryLen )


      ! This funtion returns a y-value that corresponds to an input x-value by interpolating into the arrays.
      ! It uses the passed index as the starting point and does a stepwise interpolation from there.  This is
      ! especially useful when the calling routines save the value from the last time this routine was called
      ! for a given case where XVal does not change much from call to call.  When there is no correlation
      ! from one interpolation to another, InterpBin() may be a better choice.
      ! It returns the first or last YAry() value if XVal is outside the limits of XAry().
      ! This routine assumes YAry is COMPLEX.


      ! Function declaration.


   COMPLEX(ReKi)                :: InterpStpComp                                   ! This function.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the arrays.
   INTEGER, INTENT(INOUT)       :: Ind                                             ! Initial and final index into the arrays.

   REAL(ReKi), INTENT(IN)       :: XAry    (AryLen)                                ! Array of X values to be interpolated.
   REAL(ReKi), INTENT(IN)       :: XVal                                            ! X value to be interpolated.

   COMPLEX(ReKi), INTENT(IN)    :: YAry    (AryLen)                                ! Array of Y values to be interpolated.



      ! Let's check the limits first.

   IF ( XVal <= XAry(1) )  THEN
      InterpStpComp = YAry(1)
      Ind           = 1
      RETURN
   ELSE IF ( XVal >= XAry(AryLen) )  THEN
      InterpStpComp = YAry(AryLen)
      Ind           = AryLen - 1
      RETURN
   END IF


     ! Let's interpolate!

   Ind = MAX( MIN( Ind, AryLen-1 ), 1 )

   DO

      IF ( XVal < XAry(Ind) )  THEN

         Ind = Ind - 1

      ELSE IF ( XVal >= XAry(Ind+1) )  THEN

         Ind = Ind + 1

      ELSE

         InterpStpComp = ( YAry(Ind+1) - YAry(Ind) )*( XVal - XAry(Ind) )/( XAry(Ind+1) - XAry(Ind) ) + YAry(Ind)
         RETURN

      END IF

   END DO


   RETURN
   END FUNCTION InterpStpComp ! ( XVal, XAry, YAry, Ind, AryLen )
!=======================================================================
   FUNCTION InterpStpReal( XVal, XAry, YAry, Ind, AryLen )


      ! This funtion returns a y-value that corresponds to an input x-value by interpolating into the arrays.
      ! It uses the passed index as the starting point and does a stepwise interpolation from there.  This is
      ! especially useful when the calling routines save the value from the last time this routine was called
      ! for a given case where XVal does not change much from call to call.  When there is no correlation
      ! from one interpolation to another, InterpBin() may be a better choice.
      ! It returns the first or last YAry() value if XVal is outside the limits of XAry().
      ! This routine assumes YAry is REAL.


      ! Function declaration.

   REAL(ReKi)                   :: InterpStpReal                                   ! This function.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the arrays.
   INTEGER, INTENT(INOUT)       :: Ind                                             ! Initial and final index into the arrays.

   REAL(ReKi), INTENT(IN)       :: XAry    (AryLen)                                ! Array of X values to be interpolated.
   REAL(ReKi), INTENT(IN)       :: XVal                                            ! X value to be interpolated.
   REAL(ReKi), INTENT(IN)       :: YAry    (AryLen)                                ! Array of Y values to be interpolated.



      ! Let's check the limits first.

   IF ( XVal <= XAry(1) )  THEN
      InterpStpReal = YAry(1)
      Ind           = 1
      RETURN
   ELSE IF ( XVal >= XAry(AryLen) )  THEN
      InterpStpReal = YAry(AryLen)
      Ind           = AryLen - 1
      RETURN
   END IF


     ! Let's interpolate!

   Ind = MAX( MIN( Ind, AryLen-1 ), 1 )

   DO

      IF ( XVal < XAry(Ind) )  THEN

         Ind = Ind - 1

      ELSE IF ( XVal >= XAry(Ind+1) )  THEN

         Ind = Ind + 1

      ELSE

         InterpStpReal = ( YAry(Ind+1) - YAry(Ind) )*( XVal - XAry(Ind) )/( XAry(Ind+1) - XAry(Ind) ) + YAry(Ind)
         RETURN

      END IF

   END DO


   RETURN
   END FUNCTION InterpStpReal ! ( XVal, XAry, YAry, Ind, AryLen )
!=======================================================================
   SUBROUTINE LocateBin( XVal, XAry, Ind, AryLen )

      ! This subroutine finds the lower-bound index of an input x-value located in an array.
      ! On return, Ind has a value such that
      !           XAry(Ind) <= XVal < XAry(Ind+1), with the exceptions that
      !             Ind = 0 when XVal < XAry(1), and
      !          Ind = AryLen when XAry(AryLen) <= XVal.
      !
      ! It uses a binary interpolation scheme that takes about log(AryLen)/log(2) steps to converge.
      ! If the index doesn't change much between calls, LocateStp() may be a better option.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(OUT)         :: Ind                                             ! Final (low) index into the array.

   REAL(ReKi), INTENT(IN)       :: XAry    (AryLen)                                ! Array of X values to be interpolated.
   REAL(ReKi), INTENT(IN)       :: XVal                                            ! X value to be interpolated.


      ! Local declarations.

   INTEGER                      :: IHi                                             ! The high index into the arrays.
   INTEGER                      :: IMid                                            ! The mid-point index between IHi and Ind.



      ! Let's check the limits first.

   IF ( XVal < XAry(1) )  THEN
      Ind = 0
   ELSE IF ( XVal >= XAry(AryLen) )  THEN
      Ind = AryLen
   ELSE
         ! Let's interpolate!

      Ind  = 1
      IHi  = AryLen

      DO WHILE ( IHi-Ind > 1 )

         IMid = ( IHi + Ind )/2

         IF ( XVal >= XAry(IMid) ) THEN
            Ind = IMid
         ELSE
            IHi = IMid
         END IF

      END DO

   END IF

   RETURN
   END SUBROUTINE LocateBin
!=======================================================================
   SUBROUTINE LocateStp( XVal, XAry, Ind, AryLen )

      ! This subroutine finds the lower-bound index of an input x-value located in an array.
      ! On return, Ind has a value such that
      !           XAry(Ind) <= XVal < XAry(Ind+1), with the exceptions that
      !             Ind = 0 when XVal < XAry(1), and
      !          Ind = AryLen when XAry(AryLen) <= XVal.
      !
      ! It uses the passed index as the starting point and does a stepwise search from there.  This is
      ! especially useful when the calling routines save the value from the last time this routine was called
      ! for a given case where XVal does not change much from call to call.  When there is no correlation
      ! from one interpolation to another, a binary search may be a better choice.



      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(INOUT)       :: Ind                                             ! Initial and final index into the array.

   REAL(ReKi), INTENT(IN)       :: XAry    (AryLen)                                ! Array of X values to be interpolated.
   REAL(ReKi), INTENT(IN)       :: XVal                                            ! X value to be interpolated.



      ! Let's check the limits first.

   IF ( XVal < XAry(1) )  THEN
      Ind = 0
   ELSE IF ( XVal >= XAry(AryLen) )  THEN
      Ind = AryLen
   ELSE

      Ind = MAX( MIN( Ind, AryLen-1 ), 1 )

      DO

         IF ( XVal < XAry(Ind) )  THEN

            Ind = Ind - 1

         ELSE IF ( XVal >= XAry(Ind+1) )  THEN

            Ind = Ind + 1

         ELSE

            RETURN

         END IF

      END DO


   END IF

   RETURN

   END SUBROUTINE LocateStp
!=======================================================================
   FUNCTION Mean ( Ary, AryLen )


      ! This routine calculates the mean value of an array.


      ! Function declaration.

   REAL(ReKi)                   :: Mean                                         ! This function.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                       ! Length of the array.

   REAL(ReKi), INTENT(IN)       :: Ary  (AryLen)                                ! Input array.


      ! Local declarations.

   INTEGER                      :: I                                            ! The index into the array.



   Mean = 0.0

   DO I=1,AryLen
      Mean = Mean + Ary(I)
   END DO ! I

   Mean = Mean/AryLen


   RETURN
   END FUNCTION Mean ! ( Ary, AryLen )
!=======================================================================
   SUBROUTINE MPi2Pi ( Angle )


      ! This routine ensures that Angle lies between -pi and pi.


      ! Argument declarations:

   REAL(ReKi), INTENT(INOUT)    :: Angle



      ! Get the angle between 0 and 2Pi.

   Angle = MODULO( Angle, TwoPi )


      ! Get the angle between -Pi and Pi.

   IF ( Angle > Pi )  THEN
      Angle = Angle - TwoPi
   END IF


   RETURN
   END SUBROUTINE MPi2Pi
!=======================================================================
   SUBROUTINE RombergInt(f, a, b, R, err, eps, ErrStat)

      ! This routine is used to integrate funciton f over the interval [a, b]. This routine
      ! is useful for sufficiently smooth (e.g., analytic) integrands, integrated over
      ! intervals which contain no singularities, and where the endpoints are also nonsingular.
      !
      ! f is an external function. For example f(x) = 1 + x.
      !
      !   FUNCTION f(x)
      !      USE PRECISION
      !      IMPLICIT NONE
      !
      !      REAL(ReKi) f
      !      REAL(ReKi) x
      !
      !      f = 1 + x
      !
      !      RETURN
      !   END FUNCTION f

   IMPLICIT NONE

      ! Argument declarations:

   REAL(ReKi), EXTERNAL              :: f               ! Integrand function name
   REAL(ReKi), INTENT(IN)            :: a               ! Lower integration limit
   REAL(ReKi), INTENT(IN)            :: b               ! Upper integration limit
   REAL(ReKi), INTENT(IN)            :: eps             ! Absolute error bound
   REAL(ReKi), INTENT(OUT)           :: R               ! The result of integration
   REAL(ReKi), INTENT(OUT)           :: err             ! Actual absolute error
   INTEGER, INTENT(OUT), OPTIONAL    :: ErrStat         ! Error status; if present, program does not abort on error

      ! Local declarations:

   INTEGER                           :: m, i, j, k
   INTEGER, PARAMETER                :: mmax = 50       ! Maximum iteration number for m
   INTEGER, PARAMETER                :: imax = 50       ! Maximum iteration number for i

   REAL(ReKi), ALLOCATABLE           :: T(:,:)
   REAL(ReKi)                        :: h               ! Step length
   REAL(ReKi)                        :: sumf

      ! Initialize T
   ALLOCATE( T( mmax, imax ) )
   T = 0

   T(1, 1) = 0.5*(b - a)*( f(a) + f(b) )

   k = 2
   DO m = 1, mmax-2
      h = (b-a)*(0.5)**m

      sumf = 0
      DO i = 1, 2**(m-1)
         sumf = sumf + f(a + (2*i-1)*h)
         k = k + 1
      END DO


      T( m+1, 1) = 0.5*T( m, 1 )+ h * sumf

      DO j = 1, m
         T(m-j+1, j+1) = ( 4.0**j * T(m-j+2, j) - T(m-j+1, j) )/(4.0**j - 1.0)

            ! absolute error
         err = ABS( T(m-j+1, j+1) - T( m-j+2, j ) )

            ! set k >=9 to prevent early terminations
         IF( (err .LT. eps) .and. (k >= 9) ) THEN

               ! return the intergration result if the conditions are met
            R = T(m-j+1, j+1)

            IF( ALLOCATED(T) ) DEALLOCATE(T)

            RETURN
         END IF

      END DO

   END DO

   err = ABS( T(m-j+1, j+1) - T( m-j+2, j ) )
   R = T(m-j+1, j+1)

   IF( ALLOCATED(T) ) DEALLOCATE(T)

      ! Return error message if the maximum iteration number is reached.
   CALL ProgAbort ( ' In subroutine RombergInt, the iteration reaches the maximum number. The integration did NOT converge! ', &
                    PRESENT(ErrStat) )
   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = 1
      RETURN
   END IF

   RETURN
END SUBROUTINE RombergInt
!=======================================================================
   SUBROUTINE SetConstants( )

      ! This routine computes numeric constants stored in the NWTC Library

!   USE, INTRINSIC :: ieee_arithmetic  !use this for compilers that have implemented 

      ! local variables for getting values of NaN and Inf (not necessary when using ieee_arithmetic)
   REAL(DbKi)                          :: Neg_D          ! a negative real(DbKi) number
   REAL(ReKi)                          :: Neg            ! a negative real(ReKi) number                                        

      
      ! Constants based upon Pi:

   Pi_D      = ACOS( -1.0_DbKi )
   D2R_D     = Pi_D/180.0_DbKi
   R2D_D     = 180.0_DbKi/Pi_D
   PiBy2_D   = Pi_D/2.0_DbKi
   RPM2RPS_D = Pi_D/30.0_DbKi
   RPS2RPM_D = 30.0_DbKi/Pi_D
   TwoByPi_D = 2.0_DbKi/Pi_D
   TwoPi_D   = 2.0_DbKi*Pi_D

   Pi      = ACOS( -1.0_ReKi )
   D2R     = Pi/180.0_ReKi
   R2D     = 180.0_ReKi/Pi
   PiBy2   = Pi/2.0_ReKi
   RPM2RPS = Pi/30.0_ReKi
   RPS2RPM = 30.0_ReKi/Pi
   TwoByPi =  2.0_ReKi/Pi
   TwoPi   =  2.0_ReKi*Pi
   
   
      ! IEEE constants:
      
!   NaN_D = ieee_value(0.0_DbKi, ieee_quiet_nan)
!   Inf_D = ieee_value(0.0_DbKi, ieee_positive_inf)
!
!   NaN   = ieee_value(0.0_ReKi, ieee_quiet_nan)
!   Inf   = ieee_value(0.0_DbKi, ieee_positive_inf)
   
      ! set variables to negative numbers to calculate NaNs (compilers may complain when taking sqrt of negative constants)
   Neg   = -1.0_ReKi
   Neg_D = -1.0_DbKi
   
   NaN_D = SQRT ( Neg_D )
   Inf_D = Pi_D / 0.0_DbKi

   NaN   = SQRT ( Neg )
   Inf   = Pi / 0.0_ReKi
   
   
   RETURN
   END SUBROUTINE SetConstants
!=======================================================================
   SUBROUTINE SmllRotTrans( RotationType, Theta1, Theta2, Theta3, TransMat, ErrTxt )


      ! This routine computes the 3x3 transformation matrix, TransMat,
      !   to a coordinate system x (with orthogonal axes x1, x2, x3)
      !   resulting from three rotations (Theta1, Theta2, Theta3) about the
      !   orthogonal axes (X1, X2, X3) of coordinate system X.  All angles
      !   are assummed to be small, as such, the order of rotations does
      !   not matter and Euler angles do not need to be used.  This routine
      !   is used to compute the transformation matrix (TransMat) between
      !   undeflected (X) and deflected (x) coordinate systems.  In matrix
      !   form:
      !      {x1}   [TransMat(Theta1, ] {X1}
      !      {x2} = [         Theta2, ]*{X2}
      !      {x3}   [         Theta3 )] {X3}

      ! The transformation matrix, TransMat, is the closest orthonormal
      !   matrix to the nonorthonormal, but skew-symmetric, Bernoulli-Euler
      !   matrix:
      !          [   1.0    Theta3 -Theta2 ]
      !      A = [ -Theta3   1.0    Theta1 ]
      !          [  Theta2 -Theta1   1.0   ]
      !
      !   In the Frobenius Norm sense, the closest orthornormal matrix is:
      !      TransMat = U*V^T,
      !
      !   where the columns of U contain the eigenvectors of A*A^T and the
      !   columns of V contain the eigenvectors of A^T*A (^T = transpose).
      !   This result comes directly from the Singular Value Decomposition
      !   (SVD) of A = U*S*V^T where S is a diagonal matrix containing the
      !   singular values of A, which are SQRT( eigenvalues of A*A^T ) =
      !   SQRT( eigenvalues of A^T*A ).

      ! The algebraic form of the transformation matrix, as implemented
      !   below, was derived symbolically by J. Jonkman by computing U*V^T
      !   by hand with verification in Mathematica.



      ! Passed Variables:

   REAL(ReKi), INTENT(IN )             :: Theta1                                          ! The small rotation about X1, (rad).
   REAL(ReKi), INTENT(IN )             :: Theta2                                          ! The small rotation about X2, (rad).
   REAL(ReKi), INTENT(IN )             :: Theta3                                          ! The small rotation about X3, (rad).
   REAL(ReKi), INTENT(OUT)             :: TransMat (3,3)                                  ! The resulting transformation matrix from X to x, (-).

   CHARACTER(*), INTENT(IN)            :: RotationType                                    ! The type of rotation; used to inform the user where a large rotation is occuring upon such an event.
   CHARACTER(*), INTENT(IN ), OPTIONAL :: ErrTxt                                          ! an additional message to be displayed as a warning (typically the simulation time)


      ! Local Variables:

   REAL(ReKi)                          :: ComDenom                                        ! = ( Theta1^2 + Theta2^2 + Theta3^2 )*SQRT( 1.0 + Theta1^2 + Theta2^2 + Theta3^2 )
   REAL(ReKi), PARAMETER               :: LrgAngle  = 0.4                                 ! Threshold for when a small angle becomes large (about 23deg).  This comes from: COS(SmllAngle) ~ 1/SQRT( 1 + SmllAngle^2 ) and SIN(SmllAngle) ~ SmllAngle/SQRT( 1 + SmllAngle^2 ) results in ~5% error when SmllAngle = 0.4rad.
   REAL(ReKi)                          :: Theta11                                         ! = Theta1^2
   REAL(ReKi)                          :: Theta12S                                        ! = Theta1*Theta2*[ SQRT( 1.0 + Theta1^2 + Theta2^2 + Theta3^2 ) - 1.0 ]
   REAL(ReKi)                          :: Theta13S                                        ! = Theta1*Theta3*[ SQRT( 1.0 + Theta1^2 + Theta2^2 + Theta3^2 ) - 1.0 ]
   REAL(ReKi)                          :: Theta22                                         ! = Theta2^2
   REAL(ReKi)                          :: Theta23S                                        ! = Theta2*Theta3*[ SQRT( 1.0 + Theta1^2 + Theta2^2 + Theta3^2 ) - 1.0 ]
   REAL(ReKi)                          :: Theta33                                         ! = Theta3^2
   REAL(ReKi)                          :: SqrdSum                                         ! = Theta1^2 + Theta2^2 + Theta3^2
   REAL(ReKi)                          :: SQRT1SqrdSum                                    ! = SQRT( 1.0 + Theta1^2 + Theta2^2 + Theta3^2 )

   LOGICAL,    SAVE                    :: FrstWarn  = .TRUE.                              ! When .TRUE., indicates that we're on the first warning.



      ! Display a warning message if at least one angle gets too large in
      !   magnitude:

   IF ( ( ( ABS(Theta1) > LrgAngle ) .OR. ( ABS(Theta2) > LrgAngle ) .OR. ( ABS(Theta3) > LrgAngle ) ) .AND. FrstWarn )  THEN

               
      CALL ProgWarn(' Small angle assumption violated in SUBROUTINE SmllRotTrans() due to'// &
                     ' a large '//TRIM(RotationType)//'. The solution may be inaccurate.'// &
                     ' Simulation continuing, but future warnings will be suppressed.')
      IF ( PRESENT(ErrTxt) ) THEN
         CALL WrScr(' Additional debugging message from SUBROUTINE SmllRotTrans(): '//TRIM(ErrTxt) )
      END IF

      FrstWarn = .FALSE.   ! Don't enter here again!

   ENDIF



      ! Compute some intermediate results:

   Theta11      = Theta1*Theta1
   Theta22      = Theta2*Theta2
   Theta33      = Theta3*Theta3

   SqrdSum      = Theta11 + Theta22 + Theta33
   SQRT1SqrdSum = SQRT( 1.0 + SqrdSum )
   ComDenom     = SqrdSum*SQRT1SqrdSum

   Theta12S     = Theta1*Theta2*( SQRT1SqrdSum - 1.0 )
   Theta13S     = Theta1*Theta3*( SQRT1SqrdSum - 1.0 )
   Theta23S     = Theta2*Theta3*( SQRT1SqrdSum - 1.0 )


      ! Define the transformation matrix:

   IF ( ComDenom == 0.0 )  THEN  ! All angles are zero and matrix is ill-conditioned (the matrix is derived assuming that the angles are not zero); return identity

      TransMat(1,:) = (/ 1.0, 0.0, 0.0 /)
      TransMat(2,:) = (/ 0.0, 1.0, 0.0 /)
      TransMat(3,:) = (/ 0.0, 0.0, 1.0 /)

   ELSE                          ! At least one angle is nonzero

      TransMat(1,1) = ( Theta11*SQRT1SqrdSum + Theta22              + Theta33              )/ComDenom
      TransMat(2,2) = ( Theta11              + Theta22*SQRT1SqrdSum + Theta33              )/ComDenom
      TransMat(3,3) = ( Theta11              + Theta22              + Theta33*SQRT1SqrdSum )/ComDenom
      TransMat(1,2) = (  Theta3*SqrdSum + Theta12S )/ComDenom
      TransMat(2,1) = ( -Theta3*SqrdSum + Theta12S )/ComDenom
      TransMat(1,3) = ( -Theta2*SqrdSum + Theta13S )/ComDenom
      TransMat(3,1) = (  Theta2*SqrdSum + Theta13S )/ComDenom
      TransMat(2,3) = (  Theta1*SqrdSum + Theta23S )/ComDenom
      TransMat(3,2) = ( -Theta1*SqrdSum + Theta23S )/ComDenom

   ENDIF



   RETURN
   END SUBROUTINE SmllRotTrans
!=======================================================================
   SUBROUTINE SortUnion ( Ary1, N1, Ary2, N2, Ary, N )


      ! This routine takes two sorted arrays and finds the sorted union of the two.

      ! Note: If the same value is found in both arrays, only one is kept.  However, if either
      !       array as multiple occurances of the same value, the largest multiple will be
      !       kept.  Duplicates should be eliminated externally if this is not desirable.


      ! Argument declarations:

   INTEGER, INTENT(OUT)         :: N                                            ! The length of the output array.
   INTEGER, INTENT(IN)          :: N1                                           ! The length of the first input array.
   INTEGER, INTENT(IN)          :: N2                                           ! The length of the second input array.

   REAL(ReKi), INTENT(OUT)      :: Ary(N1+N2)                                   ! The sorted union.
   REAL(ReKi), INTENT(IN)       :: Ary1(N1)                                     ! The first list of sorted real numbers.
   REAL(ReKi), INTENT(IN)       :: Ary2(N2)                                     ! The second list of sorted real numbers.


      ! Local declarations:

   INTEGER                      :: I1                                           ! Index into the first array.
   INTEGER                      :: I2                                           ! Index into the second array.



   I1 = 1
   I2 = 1
   N  = 1

   DO WHILE ( ( I1 <= N1 ) .AND. ( I2 <= N2 ) )

      IF ( Ary1(I1) < Ary2(I2) )  THEN
         Ary(N) = Ary1(I1)
         I1 = I1 + 1
      ELSE IF ( Ary1(I1) > Ary2(I2) )  THEN
         Ary(N) = Ary2(I2)
         I2 = I2 + 1
      ELSE
         Ary(N) = Ary1(I1)
         I1 = I1 + 1
         I2 = I2 + 1
      END IF

      N  = N  + 1

   END DO ! WHILE


     ! We've reached the end of one array, but we need to add the end
     ! of the other array if we haven't reached the end of it yet.

   IF ( I1 <= N1 ) THEN
      Ary(N:N+N1-I1) = Ary1(I1:)
      N = N+N1-I1
   ELSEIF ( I2 <= N2 ) THEN
      Ary(N:N+N2-I2) = Ary2(I2:)
      N = N+N2-I2
   ELSE
      N = N - 1
   ENDIF


   RETURN
   END SUBROUTINE SortUnion ! ( Ary1, N1, Ary2, N2, Ary, N )
!=======================================================================
   FUNCTION StdDevFn ( Ary, AryLen, Mean )


      ! This routine calculates the standard deviation of a population contained in Ary.


      ! Function declaration.

   REAL(ReKi)                   :: StdDevFn                                     ! This function.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                       ! Length of the array.

   REAL(ReKi), INTENT(IN)       :: Ary  (AryLen)                                ! Input array.
   REAL(ReKi), INTENT(IN)       :: Mean                                         ! The previously calculated mean of the array.


      ! Local declarations.

   REAL(DbKi)                   :: Sum                                          ! A temporary sum.

   INTEGER                      :: I                                            ! The index into the array.



   Sum = 0.0_DbKi

   DO I=1,AryLen
      Sum = Sum + ( Ary(I) - Mean )**2
   END DO ! I

   StdDevFn = SQRT( Sum/( AryLen - 1 ) )


   RETURN
   END FUNCTION StdDevFn ! ( Ary, AryLen, Mean )
!=======================================================================

END MODULE NWTC_Num
MODULE ModMesh
! (c) 2012 National Renewable Energy Laboratory
!
!BJJ: This is a place holder for a module John Michalaches and Ilene Carpenter are writing.
! This will be part of the NWTC Subroutine Library.


 USE PRECISION

   INTEGER(IntKi), PARAMETER :: MESH_NEWCOPY    = 1
   INTEGER(IntKi), PARAMETER :: MESH_SIBLING    = 2
   INTEGER(IntKi), PARAMETER :: MESH_UPDATECOPY = 3


TYPE, PUBLIC :: MeshType
   LOGICAL                 :: committed             ! Indicate whether this mesh is committed
   INTEGER(IntKi)          :: ios                   ! COMPONENT_INPUT/OUTPUT/STATE/PARAMETER
   INTEGER(IntKi)          :: RemapFlag             ! Remap flag: zero=noaction/ignore
                                                    !             nonzero=module_defined
   INTEGER(IntKi)          :: Nnodes                ! Number of nodes (vertices) in mesh
   INTEGER(IntKi)          :: Nelements             ! Number of elements in mesh
   INTEGER(IntKi)          :: Npoint                ! Number of point elements
   INTEGER(IntKi)          :: Nline2                ! Number of 2-node line elements
   INTEGER(IntKi)          :: Nline3                ! Number of 3-node line elements
   INTEGER(IntKi)          :: Ntri3                 ! Number of 3-node triangle elements
   INTEGER(IntKi)          :: Ntri6                 ! Number of 6-node triangle elements
   INTEGER(IntKi)          :: Nquad4                ! Number of 4-node quadrilateral elements
   INTEGER(IntKi)          :: Nquad8                ! Number of 8-node quadrilateral elements
   INTEGER(IntKi)          :: Ntet4                 ! Number of 4-node tet elements
   INTEGER(IntKi)          :: Ntet10                ! Number of 10-node tet elements
   INTEGER(IntKi)          :: Nhex8                 ! Number of 8-node hex elements
   INTEGER(IntKi)          :: Nhex20                ! Number of 20-node hex elements
   INTEGER(IntKi)          :: Nwedge6               ! Number of 6-node wedge elements
   INTEGER(IntKi)          :: Nwedge15              ! Number of 15-node wedgeelements
   INTEGER(IntKi), POINTER :: element_point(:)      ! Point connectivity
   INTEGER(IntKi), POINTER :: element_line2(:,:)    ! 2-node line connectivity
   INTEGER(IntKi), POINTER :: element_line3(:,:)    ! 3-node line connectivity
   INTEGER(IntKi), POINTER :: element_tri3(:,:)     ! 3-node triangle connectivity
   INTEGER(IntKi), POINTER :: element_tri6(:,:)     ! 6-node triangle connectivity
   INTEGER(IntKi), POINTER :: element_quad4(:,:)    ! 4-node quad connectivity
   INTEGER(IntKi), POINTER :: element_quad8(:,:)    ! 8-node quad connectivity
   INTEGER(IntKi), POINTER :: element_tet4(:,:)     ! 4-node tet connectivity
   INTEGER(IntKi), POINTER :: element_tet10(:,:)   ! 10-node tet connectivity
   INTEGER(IntKi), POINTER :: element_hex8(:,:)     ! 8-node hex connectivity
   INTEGER(IntKi), POINTER :: element_hex20(:,:)   ! 20-node hex connectivity
   INTEGER(IntKi), POINTER :: element_wedge6(:,:)   ! 6-node wedge connectivity
   INTEGER(IntKi), POINTER :: element_wedge15(:,:) ! 15-node wedge connectivity
   REAL(ReKi),     POINTER :: Position(:,:)         ! XYZ coordinate of node
   REAL(ReKi),     POINTER :: Force(:,:)            ! Force vectors
   REAL(ReKi),     POINTER :: Moment(:,:)           ! Moment vectors
   REAL(ReKi),     POINTER :: Orientation(:,:,:)    ! Direction Cosine Matrix (DCM)
   REAL(ReKi),     POINTER :: Rotation(:,:)         ! Rotational Velocities
   REAL(ReKi),     POINTER :: Translation(:,:)      ! Translational Velocities
   REAL(ReKi),     POINTER :: AddedMass(:,:,:)      ! Added mass matrix
   REAL(ReKi),     POINTER :: Scalars(:,:)          ! Scalars (2nd Dim is over Scalars)
   TYPE(MeshType), POINTER :: YoungerSibling        ! Pointer to next sibling in list
   TYPE(MeshType), POINTER :: ElderSibling          ! Pointer to prev sibling in list
END TYPE MeshType


END MODULE
MODULE NWTC_Aero


   ! This module contains aerodynamics routines with non-system-specific logic and references.


   ! It contains the following routines:

   !     SUBROUTINE AeroInt  ( ISeg, Alpha, Re, AF_Table, IntData, DoCl, DoCd, DoCm, DoCpmin [, ErrStat] )
   !     SUBROUTINE CompDR   ( NumSeg, RLoc, HubRad, RotorRad, DimenInp, DelRLoc [, ErrStat] )
   !     SUBROUTINE GetAF    ( AF_File, AF_Table, ISeg )
   !     FUNCTION   GetCoef  ( ISeg, Alpha, AlfaTab, CoefTab, NumRows, Ind [, ErrStat] )
   !     SUBROUTINE GetCoefs ( ISeg, Alpha, Re, AF_Table, ClInt, CdInt, CmInt, CpminInt, DoCl, DoCd, DoCm, DoCpmin [, ErrStat] )


   USE                             NWTC_IO
   USE                             NWTC_Num
   
   IMPLICIT  NONE


!=======================================================================


      ! Global aerodynamics-related variables.

   TYPE                            :: AeroData                                  ! Declare new type that holds the interpolated aero data from the big tables.
      REAL(ReKi)                   :: AlfaStal                                  ! The stall AoA for this table.
      REAL(ReKi)                   :: AOD                                       ! The AoA for minimum CD.
      REAL(ReKi)                   :: AOL                                       ! The zero-lift AoA.
      REAL(ReKi)                   :: Cd0                                       ! The minimum Cd value.
      REAL(ReKi)                   :: CnA                                       ! The Cn slope for zero-lift.
      REAL(ReKi)                   :: CnS                                       ! The Cn at stall value for positive AoA.
      REAL(ReKi)                   :: CnSL                                      ! Cn at stall value for negative AoA.
      REAL(ReKi)                   :: Cl                                        ! The lift coefficient.
      REAL(ReKi)                   :: Cd                                        ! The drag coefficient.
      REAL(ReKi)                   :: Cm                                        ! The pitching-moment coefficient.
      REAL(ReKi)                   :: Cpmin                                     ! The minimum pressure coefficient.
      REAL(ReKi)                   :: FTB                                       ! The normal-coefficient divided by the Cn slope at zero lift.
      REAL(ReKi)                   :: FTBC                                      ! The chordwise-coefficient divided by the Cn slope at zero lift.
   ENDTYPE AeroData

   TYPE                            :: AeroTable                                 ! Declare new type that is an allocatable table of data.
      REAL(ReKi)                   :: AlfaStal                                  ! The stall AoA for this table.
      REAL(ReKi)                   :: AOD                                       ! The AoA for minimum CD.
      REAL(ReKi)                   :: AOL                                       ! The zero-lift AoA.
      REAL(ReKi)                   :: Cd0                                       ! The minimum Cd value.
      REAL(ReKi)                   :: CnA                                       ! The Cn slope for zero-lift.
      REAL(ReKi)                   :: CnS                                       ! The Cn at stall value for positive AoA.
      REAL(ReKi)                   :: CnSL                                      ! Cn at stall value for negative AoA.
      REAL(ReKi)                   :: Re                                        ! The Re for this table.
      REAL(ReKi)                   :: Ctrl                                      ! The control setting for this table.
      INTEGER                      :: Ind      = 0                              ! Last-used index into table.  Zero at beginning.
      INTEGER                      :: NumAlf                                    ! Number of angles of attack in the table.
      REAL(ReKi), ALLOCATABLE      :: Alpha    (:)                              ! The angle of attack vector.
      REAL(ReKi), ALLOCATABLE      :: Cl       (:)                              ! The lift-coefficient vector.
      REAL(ReKi), ALLOCATABLE      :: Cd       (:)                              ! The drag-coefficient vector.
      REAL(ReKi), ALLOCATABLE      :: Cm       (:)                              ! The pitching-moment-coefficient vector.
      REAL(ReKi), ALLOCATABLE      :: Cpmin    (:)                              ! The minimum-pressure-coefficient vector.
      REAL(ReKi), ALLOCATABLE      :: FTB      (:)                              ! The normal-coefficient divided by the Cn slope at zero lift.
      REAL(ReKi), ALLOCATABLE      :: FTBC     (:)                              ! The chordwise-coefficient divided by the Cn slope at zero lift.
   ENDTYPE AeroTable

   TYPE                            :: AlfIndx                                   ! Declare new type that is an allocatable table of alpha indices.
      INTEGER                      :: NumBld                                    ! Number of blades in the table.
      INTEGER                      :: NumElm                                    ! Number of segments in the table.
      INTEGER, ALLOCATABLE         :: Ind      (:,:)                            ! The tables in this supertable.
   ENDTYPE AlfIndx

   TYPE                            :: ElmTable                                  ! Declare new type that is an allocatable table of data.
      INTEGER                      :: NumTabs                                   ! Number of tables in the supertable for an element.
      TYPE(AeroTable), ALLOCATABLE :: Tab      (:)                              ! The tables in this supertable.
   ENDTYPE ElmTable

   LOGICAL                         :: UseCm    = .FALSE.                        ! Flag to tell if there are Cm data in the airfoil files.
   LOGICAL                         :: UseCpmin = .FALSE.                        ! Flag to tell if there are Cp,min data in the airfoil files.


CONTAINS

!=======================================================================
   SUBROUTINE AeroInt ( ISeg, Alpha, Re, AF_Table, IntData, DoCl, DoCd, DoCm, DoCpmin, ErrStat )

      ! This routine finds the Re-bounding tables and then calls GetCoef() to get the
      ! desired coefficients for the two tables and then interpolates between them.

!NOTE: This routine needs to be modified to account for various control settings.  mlb  1-May-2010

      ! Argument declarations.

   REAL(ReKi), INTENT(IN)            :: Alpha                                   ! Angle of attack to get the coefficient for.
   REAL(ReKi), INTENT(IN)            :: Re                                      ! Reynolds number.

   INTEGER, INTENT(OUT), OPTIONAL    :: ErrStat                                 ! Error status; if present, program does not abort on error
   INTEGER, INTENT(IN)               :: ISeg                                    ! The current segment.

   LOGICAL, INTENT(IN)               :: DoCd                                    ! Get Cd.
   LOGICAL, INTENT(IN)               :: DoCl                                    ! Get Cl.
   LOGICAL, INTENT(IN)               :: DoCm                                    ! Get Cm.
   LOGICAL, INTENT(IN)               :: DoCpmin                                 ! Get Cp,min.

   TYPE (ElmTable), INTENT(INOUT)    :: AF_Table                                ! The table of airfoil data for the current segment.
   TYPE (AeroData), INTENT(OUT)      :: IntData                                 ! The interpolated airfoil data for the current segment.


      ! Local declarations.

   REAL(ReKi)                        :: CdHi                                    ! The drag coefficient for the higher Re.
   REAL(ReKi)                        :: ClHi                                    ! The lift coefficient for the higher Re.
   REAL(ReKi)                        :: CmHi                                    ! The pitching-moment coefficient for the higher Re.
   REAL(ReKi)                        :: CpminHi                                 ! The minimum pressure coefficient for the higher Re.
   REAL(ReKi)                        :: Fract                                   ! The fractional distance between tables.

   INTEGER                           :: ITab                                    ! An index for table number.
   INTEGER                           :: ITabLo                                  ! The table number that is the lower bound for Re.
   INTEGER                           :: ITabHi                                  ! The table number that is the lower bound for Re.

   LOGICAL                           :: OneTable                                ! Flag that tells if we need to read only one table (no interpolation).



      ! Find the bounding tables (if multiple) for this Re.  If there is only one table
      ! or if we are outside the range of tables, we won't need to interpolate.

   IF ( Re <= AF_Table%Tab(1)%Re )  THEN
      ITabLo   = 1
      OneTable = .TRUE.
   ELSE IF ( Re >= AF_Table%Tab(AF_Table%NumTabs)%Re )  THEN
      ITabLo   = AF_Table%NumTabs
      OneTable = .TRUE.
   ELSE IF ( AF_Table%NumTabs > 1 )  THEN
      DO ITab=1,AF_Table%NumTabs-1
         IF ( Re <= AF_Table%Tab(ITab+1)%Re )  THEN
            ITabLo = ITab
            ITabHi = ITab + 1
            EXIT
         END IF
      END DO
      OneTable = .FALSE.
   ELSE
      ITabLo   = 1
      OneTable = .TRUE.
   END IF


      ! Get the coefficients for ITabLo.

   IF ( DoCl )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         IntData%Cl = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cl, AF_Table%Tab(ITabLo)%NumAlf &
                           , AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         IntData%Cl = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cl, AF_Table%Tab(ITabLo)%NumAlf &
                           , AF_Table%Tab(ITabLo)%Ind )
      END IF
   END IF

   IF ( DoCd )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         IntData%Cd  = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cd, AF_Table%Tab(ITabLo)%NumAlf &
                              , AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         IntData%Cd  = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cd, AF_Table%Tab(ITabLo)%NumAlf &
                              , AF_Table%Tab(ITabLo)%Ind )
      END IF
   END IF

   IF ( DoCm )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         IntData%Cm = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cm, AF_Table%Tab(ITabLo)%NumAlf &
                             , AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         IntData%Cm = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cm, AF_Table%Tab(ITabLo)%NumAlf &
                             , AF_Table%Tab(ITabLo)%Ind )
      END IF
   END IF

   IF ( DoCpmin )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         IntData%Cpmin = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cpmin, AF_Table%Tab(ITabLo)%NumAlf &
                                , AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         IntData%Cpmin = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cpmin, AF_Table%Tab(ITabLo)%NumAlf &
                                , AF_Table%Tab(ITabLo)%Ind )
      END IF
   END IF

   IntData%AlfaStal = AF_Table%Tab(ITabLo)%AlfaStal
   IntData%AOD      = AF_Table%Tab(ITabLo)%AOD
   IntData%AOL      = AF_Table%Tab(ITabLo)%AOL
   IntData%Cd0      = AF_Table%Tab(ITabLo)%Cd0
   IntData%CnA      = AF_Table%Tab(ITabLo)%CnA
   IntData%CnS      = AF_Table%Tab(ITabLo)%CnS
   IntData%CnSL     = AF_Table%Tab(ITabLo)%CnSL


      ! If we don't need to interpolate, we don't need to make a second call and we are done.

   IF ( OneTable )  RETURN


      ! Get the coefficients for ITabHi.  Use step-wise interpolation for all but the first coefficient called.

   Fract = ( Re - AF_Table%Tab(ITabLo)%Re )/( AF_Table%Tab(ITabHi)%Re - AF_Table%Tab(ITabLo)%Re )


   IF ( DoCl )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         ClHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cl, AF_Table%Tab(ITabHi)%NumAlf, &
                                      AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         ClHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cl, AF_Table%Tab(ITabHi)%NumAlf, &
                                      AF_Table%Tab(ITabHi)%Ind )
      END IF
      IntData%Cl  = IntData%Cl + Fract*( ClHi - IntData%Cl )
   END IF

   IF ( DoCd )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         CdHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cd, AF_Table%Tab(ITabHi)%NumAlf, &
                                      AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         CdHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cd, AF_Table%Tab(ITabHi)%NumAlf, &
                                      AF_Table%Tab(ITabHi)%Ind )
      END IF
      IntData%Cd = IntData%Cd + Fract*( CdHi - IntData%Cd )
   END IF

   IF ( DoCm )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         CmHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cm, AF_Table%Tab(ITabHi)%NumAlf, &
                                      AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         CmHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cm, AF_Table%Tab(ITabHi)%NumAlf, &
                                      AF_Table%Tab(ITabHi)%Ind )
      END IF
      IntData%Cm = IntData%Cm + Fract*( CmHi - IntData%Cm )
   END IF

   IF ( DoCpmin )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         CpminHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cpmin, AF_Table%Tab(ITabHi)%NumAlf, &
                                         AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         CpminHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cpmin, AF_Table%Tab(ITabHi)%NumAlf, &
                                         AF_Table%Tab(ITabHi)%Ind )
      END IF
      IntData%Cpmin = IntData%Cpmin + Fract*( CpminHi - IntData%Cpmin )
   END IF

   IntData%AlfaStal = IntData%AlfaStal + Fract*( AF_Table%Tab(ITabHi)%AlfaStal - IntData%AlfaStal )
   IntData%AOD      = IntData%AOD      + Fract*( AF_Table%Tab(ITabHi)%AOD      - IntData%AOD      )
   IntData%AOL      = IntData%AOL      + Fract*( AF_Table%Tab(ITabHi)%AOL      - IntData%AOL      )
   IntData%Cd0      = IntData%Cd0      + Fract*( AF_Table%Tab(ITabHi)%Cd0      - IntData%Cd0      )
   IntData%CnA      = IntData%CnA      + Fract*( AF_Table%Tab(ITabHi)%CnA      - IntData%CnA      )
   IntData%CnS      = IntData%CnS      + Fract*( AF_Table%Tab(ITabHi)%CnS      - IntData%CnS      )
   IntData%CnSL     = IntData%CnSL     + Fract*( AF_Table%Tab(ITabHi)%CnSL     - IntData%CnSL     )


   RETURN
   END SUBROUTINE AeroInt ! ( ISeg, Alpha, Re, AF_Table, IntData, ClInt, CdInt, CmInt )
!=======================================================================
   SUBROUTINE CompDR ( NumSeg, RLoc, HubRad, RotorRad, DimenInp, DelRLoc, ErrStat )


      ! This routine computes the segment lengths from the local radii and the rotor radius.
      ! It prints and error if the list of radii is not realizable.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: NumSeg                                       ! Number of blade segments.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                      ! Error status; if present, program does not abort on error

   REAL(ReKi), INTENT(OUT)      :: DelRLoc (NumSeg)                             ! The array of segment lengths.
   REAL(ReKi), INTENT(IN)       :: HubRad                                       ! The hub radius.
   REAL(ReKi), INTENT(IN)       :: RLoc    (NumSeg)                             ! The array of radii (segment centers).
   REAL(ReKi), INTENT(IN)       :: RotorRad                                     ! The rotor radius.

   LOGICAL, INTENT(IN)          :: DimenInp                                     ! Flag that tells if input is dimensional or not.


      ! Local declarations.

   REAL(ReKi)                   :: CompRad                                      ! The computed radius of the rotor.
   REAL(ReKi)                   :: ErrFact                                      ! The conversion to non-dimensional form if needed.
   REAL(ReKi)                   :: SegBeg                                       ! The beginning of the current segment.

   INTEGER                      :: ISeg                                         ! Segment index



   IF ( PRESENT(ErrStat) ) ErrStat = 0


      ! Determine the correct units for error messages.

   IF ( DimenInp )  THEN
      ErrFact = 1.0
   ELSE
      ErrFact = RotorRad
   END IF


      ! We will work our way from the root to the tip.

   SegBeg = HubRad

   DO ISeg=1,NumSeg

      IF ( RLoc(ISeg) <= SegBeg )  THEN
         ! START v1.03.00b-dcm  21-Jun-2010  D. Maniaci
         CALL WrScr1('Your analysis nodes are incorrectly defined.  Please review the following forum topic for an explaination' &
                    //' of this error:')
         CALL WrScr1('  https://wind.nrel.gov/forum/wind/viewtopic.php?f=4&t=241')
         ! END v1.03.00b-dcm  21-Jun-2010  D. Maniaci
         CALL ProgAbort ( ' The radius for blade segment #'//Trim( Int2LStr( ISeg ) )//' is too far inboard for a physically' &
                    //' realizable blade.  It must be greater than '//Trim( Num2LStr( SegBeg/ErrFact ) )//'.', PRESENT(ErrStat) )
         IF ( PRESENT(ErrStat) ) ErrStat = 1
         RETURN
      END IF

      DelRLoc(ISeg) = 2.0*( RLoc(ISeg) - SegBeg )
      SegBeg        = SegBeg + DelRLoc(ISeg)

   END DO ! ISeg


      ! Ensure that the segments (almost) exactly fill the blade.

   CompRad = RLoc(NumSeg) + 0.5*DelRLoc(NumSeg)

   IF ( ABS( CompRad - RotorRad )/RotorRad > 0.005 )  THEN
         ! START v1.03.00b-dcm  21-Jun-2010  D. Maniaci
         CALL WrScr1('Your analysis nodes are incorrectly defined.  Please review the following forum topic for an explaination' &
                    //' of this error:')
         CALL WrScr1('  https://wind.nrel.gov/forum/wind/viewtopic.php?f=4&t=241')
         ! END v1.03.00b-dcm  21-Jun-2010  D. Maniaci
         CALL ProgAbort ( ' The sum of the lengths of the blade segments does not match the rotor radius.  The segments add up' &
                    //' to a rotor radius of '//Trim( Num2LStr( CompRad ) )//' instead of the specified radius of ' &
                    //Trim( Num2LStr( RotorRad ) )//'.  They must agree within 0.5%', PRESENT(ErrStat) )
         IF ( PRESENT(ErrStat) ) ErrStat = 1
         RETURN
   ELSE IF ( ABS( CompRad - RotorRad )/RotorRad > 0.001 )  THEN
! Nice message, Marshall! ;-)  Thank you!  :-)  I don't even remember writing this.
         ! START v1.03.00b-dcm  21-Jun-2010  D. Maniaci
         CALL WrScr1('Your analysis nodes are incorrectly defined.  Please review the following forum topic for an explaination' &
                    //' of this error:')
         CALL WrScr1('  https://wind.nrel.gov/forum/wind/viewtopic.php?f=4&t=241')
         ! END v1.03.00b-dcm  21-Jun-2010  D. Maniaci
         CALL WrScr1 ( ' The sum of the lengths of the blade segments does not match the rotor radius.  The segments add up to a' &
                    //' rotor radius of '//Trim( Num2LStr( CompRad ) )//' instead of the specified radius of ' &
                    //Trim( Num2LStr( RotorRad ) )//'.  They really should agree within 0.1%, but I''ll let you slide.' )
!      IF ( Beep ) &
         CALL UsrAlarm
   END IF


   RETURN
   END SUBROUTINE CompDR ! ( NumSeg, RLoc, RotorRad, DimenInp, DelRLoc [, ErrStat] )
!=======================================================================
   SUBROUTINE GetAF ( AF_File, AF_Table, ISeg )
!bjj: note that this routine aborts instead of allowing an optional returned error code.

      ! Routine to get airfoil data from either a new NWTC-style or an old AeroDyn-style airfoil file.


      ! Argument declarations.

   TYPE (ElmTable), INTENT(OUT) :: AF_Table                                  ! The table of airfoil data for the current segment.

   INTEGER, INTENT(IN)          :: ISeg                                      ! The segment number.

   CHARACTER(*), INTENT(IN)     :: AF_File                                   ! Name of file containing AeroDyn-style airfoil data.


      ! Local declarations.

      ! Because of what seems to be a compiler bug, we cannot dynamically allocate the data arrays for the new-style
      ! airfoil files.  We really need to do it for the old-style files because there is no limit on the number of points.

!   TYPE                            :: DataRowO                                  ! Declare new type that is an allocatable table of data using a linked list.
!      REAL(ReKi), ALLOCATABLE      :: Data      (:)
!      TYPE(DataRowO), POINTER      :: Next            => NULL()
!   ENDTYPE DataRowO

   REAL(ReKi)                      :: AF_Data   (5)                             ! The values from one line of airfol data.
   REAL(ReKi), ALLOCATABLE         :: AF_DataO  (:)                             ! The values from one line of airfol data.
   REAL(ReKi), ALLOCATABLE         :: RnAry     (:)                             ! The temporary array for Re.
   REAL(ReKi), ALLOCATABLE         :: ASAry     (:)                             ! The temporary array for Stall AoA.
   REAL(ReKi), ALLOCATABLE         :: AOLAry    (:)                             ! The temporary array for zero-lift AoA.
   REAL(ReKi)                      :: Cc                                        ! The chordwise force coefficient.
   REAL(ReKi)                      :: Cn                                        ! The normal force coefficient.
   REAL(ReKi), ALLOCATABLE         :: CnAAry    (:)                             ! The temporary array for Cn slope for zero lift.
   REAL(ReKi), ALLOCATABLE         :: CnSAry    (:)                             ! The temporary array for Cn at stall value for positive AoA.
   REAL(ReKi), ALLOCATABLE         :: CnSLAry   (:)                             ! The temporary array for Cn at stall value for negative AoA.
   REAL(ReKi), ALLOCATABLE         :: AODAry    (:)                             ! The temporary array for AoA for minimum Cd.
   REAL(ReKi), ALLOCATABLE         :: CDOAry    (:)                             ! The temporary array for minimum Cd value.

   INTEGER                         :: IAlf                                      ! A generic array index for angle of attack.
   INTEGER                         :: Ind                                       ! A generic array index.
   INTEGER                         :: IOS                                       ! The status of an I/O operation.
   INTEGER                         :: ITab                                      ! The table index.
   INTEGER                         :: NumAlf                                    ! The number of lines in an old-style airfoil table.
   INTEGER                         :: NumAlpha                                  ! The number of non--blank lines in an old-style airfoil table.
   INTEGER                         :: NumCoef                                   ! The number of coefficiants in an airfoil table.
   INTEGER                         :: NumVals                                   ! The total number of values on one line of airfoil data.
   INTEGER                         :: Sttus                                     ! The status returned from the allocation.
   INTEGER                         :: UnAF     = 20                             ! I/O unit number for the airfoil file.

   CHARACTER( 15)                  :: Frmt = "(1000(F11.4,:))"                  ! Output format for a line of airfoil data.
   CHARACTER(999)                  :: Line                                      ! A line of text.
   CHARACTER(  3)                  :: Line3                                     ! The first three characters of a line of text.



      ! Open the airfoil data file.

   CALL OpenFInpFile ( UnAF, AF_File )


      ! Read the header block of the airfoil file.  Look to see if this is a new-format file.

   READ (UnAF,'(A)',IOSTAT=IOS)  Line

   CALL CheckIOS ( IOS, AF_File, 'FirstHead', StrType )

   IF ( Echo )  THEN
      WRITE (UnEc,"(15X,A,T30,' - ',A,/,2X,A)")  'FirstHead', 'First line in the airfoil file.', TRIM( Line )
   END IF

   CALL Conv2UC  ( Line )

   IF ( Line(:21) == 'AERODYN AIRFOIL FILE.' )  THEN


         ! This is new style of AeroDyn file.

      CALL ReadCom  ( UnAF, AF_File, 'the first title' )
      CALL ReadCom  ( UnAF, AF_File, 'the second title' )
      CALL ReadIVar ( UnAF, AF_File, AF_Table%NumTabs, 'NumTabs', 'Number of airfoil tables for segment #' &
                                                                 //TRIM( Int2LStr( ISeg ) )//'.' )

      IF ( AF_Table%NumTabs < 1 )  CALL ProgAbort ( ' Number of tables in airfoil file, "'//TRIM( AF_File ) &
                                              //'", must be > 0 for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )


         ! Are we expecting Cm data in the file?  Allocate the temporary data array.

      IF ( UseCm )  THEN
         NumVals = 4
      ELSE
         NumVals = 3
      END IF


         ! Are we expecting Cp,min data in the file?  Allocate the temporary data array.

      IF ( UseCpmin )  THEN
         NumVals = NumVals + 1
      END IF


         ! Allocate the AF_Table of pointers for this element.

      ALLOCATE ( AF_Table%Tab(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the Tab subtable of the AF_Table of pointers for segment #' &
                    //TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF


         ! Read the NumTabs airfoil tables.

      DO ITab=1,AF_Table%NumTabs


            ! Read in the Table ID (Re), control setting, and stall parameters for this table.

         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%Re      , 'Re('      //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'Reynolds number for this airfoil table.'    )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%Ctrl    , 'Ctrl('    //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'Control setting for this airfoil table.'    )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%AlfaStal, 'AlfaStal('//TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'stall AoA for this airfoil table.'          )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%AOL     , 'AOL('     //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'zero-lift AoA.'                             )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%CnA     , 'CnA('     //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'Cn slope for zero-lift.'                    )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%CnS     , 'CnS('     //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'Cn at stall value for positive AoA.'        )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%CnSL    , 'CnSL('    //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'Cn at stall value for negative AoA.'        )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%AOD     , 'AOD('     //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'AoA for minimum CD.'                        )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%Cd0     , 'Cd0('     //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'minimum Cd value.'                          )


            ! Convert to proper units.

         AF_Table%Tab(ITab)%AlfaStal = AF_Table%Tab(ITab)%AlfaStal*D2R
         AF_Table%Tab(ITab)%AOD      = AF_Table%Tab(ITab)%AOD     *D2R
         AF_Table%Tab(ITab)%AOL      = AF_Table%Tab(ITab)%AOL     *D2R
         AF_Table%Tab(ITab)%Re       = AF_Table%Tab(ITab)%Re      *1.0e6


            ! Find the length of this table.

         AF_Table%Tab(ITab)%NumAlf = 0

         DO

            READ (UnAF,'(A)',IOSTAT=IOS)  Line3

            IF ( IOS < 0 )  THEN
               CALL PremEOF ( AF_File , 'the "EOT" end-of-table mark for airfoil table #'//TRIM( Int2LStr( ITab ) ) &
                                      //' and segment #'//TRIM( Int2LStr( ISeg ) ) )
            ELSE IF ( IOS > 0 )  THEN
               CALL WrScr1 ( ' Invalid character input for file "'//TRIM( AF_File )//'.' )
               CALL ProgAbort  ( ' The error occurred while trying to read line #'//TRIM( Int2LStr( AF_Table%Tab(ITab)%NumAlf+1 ) )&
                           //' of airfoil table #'//TRIM( Int2LStr( ITab ) )//' for segment #'//TRIM( Int2LStr( ISeg ) )//'.' )
            END IF

            CALL Conv2UC ( Line3 )
            IF ( Line3 == 'EOT' )  EXIT
            AF_Table%Tab(ITab)%NumAlf = AF_Table%Tab(ITab)%NumAlf + 1

         END DO


            ! Rewind the file to the beginning of this table.

         DO IAlf=1,AF_Table%Tab(ITab)%NumAlf+1
            BACKSPACE UnAF
         END DO ! IAlf


            ! Let's allocate the permanent table.

         ALLOCATE ( AF_Table%Tab(ITab)%Alpha(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the Alpha subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%Cl(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the Cl subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%Cd(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the Cd subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
         END IF

         IF ( UseCm )  THEN
            ALLOCATE ( AF_Table%Tab(ITab)%Cm(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
            IF ( Sttus /= 0 )  THEN
               CALL ProgAbort ( ' Error allocating memory for the Cm subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
            END IF
         END IF

         IF ( UseCpmin )  THEN
            ALLOCATE ( AF_Table%Tab(ITab)%Cpmin(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
            IF ( Sttus /= 0 )  THEN
               CALL ProgAbort ( ' Error allocating memory for the Cpmin subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
            END IF
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%FTB(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the FTB subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%FTBC(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the FTBC subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
         END IF


            ! Read in the airfoil data for this table.

         DO IAlf=1,AF_Table%Tab(ITab)%NumAlf

            READ (UnAF,*,IOSTAT=IOS)  ( AF_Data(Ind), Ind=1,NumVals )

            CALL CheckIOS ( IOS, AF_File, 'AF_Data', NumType )

            IF ( Echo )  WRITE (UnEc,Frmt)  ( AF_Data(Ind), Ind=1,NumVals )

            AF_Table%Tab(ITab)%Alpha(IAlf) = AF_Data(1)

            AF_Table%Tab(ITab)%Cl(IAlf) = AF_Data(2)
            AF_Table%Tab(ITab)%Cd(IAlf) = AF_Data(3)

            IF ( ABS( AF_Table%Tab(ITab)%CnA ) .GT. 1.0e-6 )  THEN

               Cn = AF_Data(2)*COS( AF_Data(1) ) + ( AF_Data(3) - AF_Table%Tab(ITab)%Cd0 )*SIN( AF_Data(1) )
               Cc = AF_Data(2)*SIN( AF_Data(1) ) - ( AF_Data(3) - AF_Table%Tab(ITab)%Cd0 )*COS( AF_Data(1) )

               AF_Table%Tab(ITab)%FTB (IAlf) = Cn/AF_Table%Tab(ITab)%CnA
               AF_Table%Tab(ITab)%FTBC(IAlf) = Cc/AF_Table%Tab(ITab)%CnA

            ELSE

               AF_Table%Tab(ITab)%FTB (IAlf) = 1.0
               AF_Table%Tab(ITab)%FTBC(IAlf) = 1.0

            END IF

            IF ( UseCm )  THEN
               AF_Table%Tab(ITab)%Cm(IAlf) = AF_Data(4)
            END IF

            IF ( UseCpmin )  THEN
               AF_Table%Tab(ITab)%Cpmin(IAlf) = AF_Data(NumVals)
            END IF

         END DO ! IAlf


            ! Check AoA range.

         IF ( ( AF_Table%Tab(ITab)%Alpha(1)                         > -180.0 ) .OR. &
              ( AF_Table%Tab(ITab)%Alpha(AF_Table%Tab(ITab)%NumAlf) <  180.0 ) )  THEN
            CALL ProgAbort ( 'Angle of attack range for airfoil table #'//TRIM( Int2LStr( ITab ) )//' of segment #' &
                       //TRIM( Int2LStr( ISeg ) )//' must be from -180 to 180.' )
         END IF


            ! Skip this EOT mark.

         READ (UnAF,'()')

      END DO ! ITab

   ELSE


         ! This is old style of AeroDyn file.

      CALL ReadCom  ( UnAF, AF_File, 'the second title' )
      CALL ReadIVar ( UnAF, AF_File, AF_Table%NumTabs, 'NumTabs', 'Number of airfoil tables for segment #' &
                                                                //TRIM( Int2LStr( ISeg ) )//'.' )

      ALLOCATE ( RnAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the RnAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( ASAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the ASAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( AOLAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the AOLAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( CnAAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the CnAAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( CnSAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the CnSAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( CnSLAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the CnSLAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( AODAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the AODAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( CDOAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the CDOAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      CALL ReadRAry ( UnAF, AF_File, RnAry  , AF_Table%NumTabs, 'RnAry'  , 'Reynolds number values for the airfoil tables.' )
      CALL ReadRAry ( UnAF, AF_File, ASAry  , AF_Table%NumTabs, 'ASAry'  , 'Stall AoA for this airfoil table.'              )
      CALL ReadCom  ( UnAF, AF_File,                                       'the unused first obsolete stall parameter'      )
      CALL ReadCom  ( UnAF, AF_File,                                       'the unused second obsolete stall parameter'     )
      CALL ReadCom  ( UnAF, AF_File,                                       'the unused third obsolete stall parameter'      )
      CALL ReadRAry ( UnAF, AF_File, AOLAry , AF_Table%NumTabs, 'AOLAry' , 'zero-lift AoA'                                  )
      CALL ReadRAry ( UnAF, AF_File, CnAAry , AF_Table%NumTabs, 'CnAAry' , 'Cn slope for zero lift'                         )
      CALL ReadRAry ( UnAF, AF_File, CnSAry , AF_Table%NumTabs, 'CnSAry' , 'Cn at stall value for positive AoA'             )
      CALL ReadRAry ( UnAF, AF_File, CnSLAry, AF_Table%NumTabs, 'CnSLAry', 'Cn at stall value for negative AoA'             )
      CALL ReadRAry ( UnAF, AF_File, AODAry , AF_Table%NumTabs, 'AODAry' , 'AoA for minimum Cd'                             )
      CALL ReadRAry ( UnAF, AF_File, CDOAry , AF_Table%NumTabs, 'CDOAry' , 'minimum Cd value'                               )


         ! Are we expecting Cm data in the file?  Allocate the temporary data array.

      IF ( UseCm )  THEN
         NumCoef = 3
      ELSE
         NumCoef = 2
      END IF

      NumVals = 1 + NumCoef*AF_Table%NumTabs

      ALLOCATE ( AF_DataO(NumVals) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the AF_DataO array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF


         ! Allocate the AF_Table of pointers for this element.

      ALLOCATE ( AF_Table%Tab(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the AF_Table of pointers in GetAF.' )
      END IF


            ! Find the length of this table.

      NumAlf = 0

      DO
         READ (UnAF,'()',IOSTAT=IOS)
         IF ( IOS < 0 )  EXIT
         NumAlf = NumAlf + 1
      END DO


         ! Rewind the file to the beginning of this table.

      DO IAlf=1,NumAlf+1
         BACKSPACE UnAF
      END DO ! IAlf


         ! Let's allocate the tables.

      DO ITab=1,AF_Table%NumTabs

         ALLOCATE ( AF_Table%Tab(ITab)%Alpha(NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the Alpha vector of airfoil table #'//TRIM( Int2LStr( ITab) ) &
                       //' for element #'//TRIM( Int2LStr( ISeg) )//'.' )
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%Cl(NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the Cl vector of airfoil table #'//TRIM( Int2LStr( ITab) ) &
                       //' for element #'//TRIM( Int2LStr( ISeg) )//'.' )
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%Cd(NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the Cd vector of airfoil table #'//TRIM( Int2LStr( ITab) ) &
                       //' for element #'//TRIM( Int2LStr( ISeg) )//'.' )
         END IF

         IF ( UseCm )  THEN
            ALLOCATE ( AF_Table%Tab(ITab)%Cm(NumAlf) , STAT=Sttus )
            IF ( Sttus /= 0 )  THEN
               CALL ProgAbort ( ' Error allocating memory for the Cm vector of airfoil table #'//TRIM( Int2LStr( ITab) ) &
                          //' for element #'//TRIM( Int2LStr( ISeg) )//'.' )
            END IF
         END IF

!         ALLOCATE ( AF_Table%Tab(ITab)%FTB(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
         ALLOCATE ( AF_Table%Tab(ITab)%FTB(NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the FTB subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%FTBC(NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the FTBC subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                      //' and table #' //TRIM( Int2LStr( ITab) )//').' )
         END IF

      END DO ! ITab


         ! Let's read the data this time through.

      NumAlpha = NumAlf

      DO IAlf=1,NumAlf


            ! Let's skip blank lines.  Decrement the number of alphas when we find them.

         READ (UnAF,'(A)')  Line

         IF ( LEN_TRIM( Line ) == 0 )  THEN
            NumAlpha = NumAlpha - 1
            CYCLE
         END IF


            ! Let's get the data from the non-blank line.

         READ (Line,*,IOSTAT=IOS)  ( AF_DataO(Ind), Ind=1,NumVals )

         CALL CheckIOS ( IOS, AF_File, 'AF_DataO', NumType )

         IF ( Echo )  THEN
            WRITE (UnEc,Frmt)  ( AF_DataO(Ind), Ind=1,NumVals )
         END IF


            ! Let's move this good data into permanent storage.

         DO ITab=1,AF_Table%NumTabs

            AF_Table%Tab(ITab)%Alpha(IAlf) = AF_DataO(1)
            AF_Table%Tab(ITab)%Cl   (IAlf) = AF_DataO(NumCoef*(ITab-1)+2)
            AF_Table%Tab(ITab)%Cd   (IAlf) = AF_DataO(NumCoef*(ITab-1)+3)

            IF ( UseCm )  THEN
               AF_Table%Tab(ITab)%Cm(IAlf) = AF_DataO(NumCoef*(ITab-1)+4)
            END IF

            IF ( ABS( AF_Table%Tab(ITab)%CnA ) .GT. 1.0e-6 )  THEN

               Cn = AF_Data(2)*COS( AF_Data(1) ) + ( AF_Data(3) - AF_Table%Tab(ITab)%Cd0 )*SIN( AF_Data(1) )
               Cc = AF_Data(2)*SIN( AF_Data(1) ) - ( AF_Data(3) - AF_Table%Tab(ITab)%Cd0 )*COS( AF_Data(1) )

               AF_Table%Tab(ITab)%FTB (IAlf) = Cn/AF_Table%Tab(ITab)%CnA
               AF_Table%Tab(ITab)%FTBC(IAlf) = Cc/AF_Table%Tab(ITab)%CnA

            ELSE

               AF_Table%Tab(ITab)%FTB (IAlf) = 1.0
               AF_Table%Tab(ITab)%FTBC(IAlf) = 1.0

            END IF

         END DO ! ITab

      END DO ! IAlf


         ! Check AoA range.  AoAs are the same for all tables in a given segment.

      IF ( ( AF_Table%Tab(1)%Alpha(1)      > -180.0 ) .OR. &
           ( AF_Table%Tab(1)%Alpha(NumAlf) <  180.0 ) )  THEN
!           ( AF_Table%Tab(1)%Alpha(AF_Table%Tab(ITab)%NumAlf) <  180.0 ) )  THEN
         CALL ProgAbort ( 'Angle of attack range of airfoil tables for segment #'//TRIM( Int2LStr( ISeg ) ) &
                    //' must be from -180 to 180.' )
      END IF


           ! Store the header data in the permanent structure.

      DO ITab=1,AF_Table%NumTabs
         AF_Table%Tab(ITab)%AlfaStal = ASAry  (ITab)*D2R
         AF_Table%Tab(ITab)%Re       = RnAry  (ITab)*1.0e6
         AF_Table%Tab(ITab)%AOD      = AODAry (ITab)*D2R
         AF_Table%Tab(ITab)%AOL      = AOLAry (ITab)*D2R
         AF_Table%Tab(ITab)%Cd0      = CDOAry (ITab)
         AF_Table%Tab(ITab)%CnA      = CnAAry (ITab)
         AF_Table%Tab(ITab)%CnS      = CnSAry (ITab)
         AF_Table%Tab(ITab)%CnSL     = CnSLAry(ITab)
         AF_Table%Tab(ITab)%NumAlf   = NumAlpha
      END DO ! ITab


         ! Deallocate the temporary Re array.

      DEALLOCATE ( RnAry, STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error deallocating memory for the RnAry array in GetAF.' )
      END IF


         ! Deallocate the temporary data array.

      DEALLOCATE ( AF_DataO, STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error deallocating memory for the AF_DataO array in GetAF.' )
      END IF

   END IF

   CLOSE ( UnAF )


   RETURN
   END SUBROUTINE GetAF !  ( AF_File, AF_Table, ISeg )
!=======================================================================
   FUNCTION GetCoef( ISeg, Alpha, AlfaTab, CoefTab, NumRows, Ind, ErrStat )


      ! Interpolation routine for airfoil section coefficients.


      ! Function declaration.

   REAL(ReKi)                        :: GetCoef                                 ! The value returned by this function.


      ! Argument declarations.

   INTEGER, INTENT(INOUT)            :: Ind                                     ! The starting/resulting index into the tables.
   INTEGER, INTENT(IN)               :: ISeg                                    ! The current segment.
   INTEGER, INTENT(IN)               :: NumRows                                 ! The length of the arrays.
   INTEGER, INTENT(OUT), OPTIONAL    :: ErrStat                                 ! Error status; if present, program does not abort on error

   REAL(ReKi), INTENT(IN)            :: AlfaTab   (NumRows)                     ! Table of AoAs.
   REAL(ReKi), INTENT(IN)            :: Alpha                                   ! Angle of attack to get the coefficient for.
   REAL(ReKi), INTENT(IN)            :: CoefTab   (NumRows)                     ! Table of coefficients.


   IF ( PRESENT(ErrStat) ) ErrStat = 1


      ! If Alpha is to the outside the table, the user needs to make up some data.  Warn the user and stop the program.

   IF ( ( Alpha < AlfaTab(1) ) .OR. ( AlfaTab(NumRows) < Alpha ) )  THEN

      CALL ProgAbort ( ' For segment '//TRIM( Int2LStr( ISeg ) )//', the current angle of attack ('//TRIM( Num2LStr( Alpha ) ) &
                 //' degrees) is outside the domain of your data table (' //TRIM( Num2LStr( AlfaTab(1) ) )//' to ' &
                 //TRIM( Num2LStr( AlfaTab(NumRows) ) )//' degrees).  Please extend your data table.', PRESENT(ErrStat) )
      IF ( PRESENT(ErrStat) ) ErrStat = 1
      RETURN

   END IF


      ! Alpha is in range.  Interpolate.  Use binary interpolation if this is the first time to access this table.

   IF ( Ind == 0 )  THEN
      GetCoef = InterpBin( Alpha, AlfaTab, CoefTab, Ind, NumRows )
   ELSE
      GetCoef = InterpStp( Alpha, AlfaTab, CoefTab, Ind, NumRows )
   END IF


   RETURN
   END FUNCTION GetCoef ! ( ISeg, Alpha, AlfaTab, CoefTab, NumRows, Ind )
!=======================================================================
   SUBROUTINE GetCoefs ( ISeg, Alpha, Re, AF_Table, ClInt, CdInt, CmInt, CpminInt, DoCl, DoCd, DoCm, DoCpmin, ErrStat )


      ! This routine finds the Re-bounding tables and then calls GetCoef() to get the
      ! desired coefficients for the two tables and then interpolates between them.


      ! Argument declarations.

   TYPE (ElmTable), INTENT(INOUT)    :: AF_Table                                ! The table of airfoil data for the current segment.

   INTEGER, INTENT(IN)               :: ISeg                                    ! The current segment.
   INTEGER, INTENT(OUT), OPTIONAL    :: ErrStat                                 ! Error status; if present, program does not abort on error

   LOGICAL, INTENT(IN)               :: DoCd                                    ! Get Cd.
   LOGICAL, INTENT(IN)               :: DoCl                                    ! Get Cl.
   LOGICAL, INTENT(IN)               :: DoCm                                    ! Get Cm.
   LOGICAL, INTENT(IN)               :: DoCpmin                                 ! Get Cp,min.

   REAL(ReKi), INTENT(IN)            :: Alpha                                   ! Angle of attack to get the coefficient for.
   REAL(ReKi), INTENT(OUT)           :: CdInt                                   ! Interpolated drag coefficient.
   REAL(ReKi), INTENT(OUT)           :: ClInt                                   ! Interpolated lift coefficient.
   REAL(ReKi), INTENT(OUT)           :: CmInt                                   ! Interpolated pitching-moment coefficient.
   REAL(ReKi), INTENT(OUT)           :: CpminInt                                ! Interpolated minimum-pressure coefficient.
   REAL(ReKi), INTENT(IN)            :: Re                                      ! Reynolds number.


      ! Local declarations.

   REAL(ReKi)                        :: CdHi                                    ! The drag coefficient for the higher Re.
   REAL(ReKi)                        :: ClHi                                    ! The lift coefficient for the higher Re.
   REAL(ReKi)                        :: CmHi                                    ! The pitching-moment coefficient for the higher Re.
   REAL(ReKi)                        :: CpminHi                                 ! The minimum-pressure coefficient for the higher Re.
   REAL(ReKi)                        :: Fract                                   ! The fractional distance between tables.

   INTEGER                           :: ITab                                    ! An index for table number.
   INTEGER                           :: ITabLo                                  ! The table number that is the lower bound for Re.
   INTEGER                           :: ITabHi                                  ! The table number that is the lower bound for Re.

   LOGICAL                           :: OneTable                                ! Flag that tells if we need to read only one table (no interpolation).


   IF ( PRESENT(ErrStat) ) ErrStat = 0

      ! Find the bounding tables (if multiple) for this Re.  If there is only one table
      ! or if we are outside the range of tables, we won't need to interpolate.

   IF ( Re <= AF_Table%Tab(1)%Re )  THEN
      ITabLo   = 1
      OneTable = .TRUE.
   ELSE IF ( Re >= AF_Table%Tab(AF_Table%NumTabs)%Re )  THEN
      ITabLo   = AF_Table%NumTabs
      OneTable = .TRUE.
   ELSE IF ( AF_Table%NumTabs > 1 )  THEN
      DO ITab=1,AF_Table%NumTabs-1
         IF ( Re <= AF_Table%Tab(ITab+1)%Re )  THEN
            ITabLo = ITab
            ITabHi = ITab + 1
            EXIT
         END IF
      END DO
      OneTable = .FALSE.
   ELSE
      ITabLo   = 1
      OneTable = .TRUE.
   END IF


      ! Get the coefficients for ITabLo.


   IF ( PRESENT(ErrStat) ) THEN
      IF ( DoCl )  THEN
         ClInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cl, AF_Table%Tab(ITabLo)%NumAlf, &
                                       AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      END IF

      IF ( DoCd )  THEN
         CdInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cd, AF_Table%Tab(ITabLo)%NumAlf, &
                                       AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      END IF

      IF ( DoCm )  THEN
         CmInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cm, AF_Table%Tab(ITabLo)%NumAlf, &
                                       AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      END IF

      IF ( DoCpmin )  THEN
         CpminInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cpmin, AF_Table%Tab(ITabLo)%NumAlf, &
                                          AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      END IF

   ELSE  ! Abort the program when errors are found

      IF ( DoCl )  THEN
         ClInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cl, AF_Table%Tab(ITabLo)%NumAlf, &
                                       AF_Table%Tab(ITabLo)%Ind )
      END IF

      IF ( DoCd )  THEN
         CdInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cd, AF_Table%Tab(ITabLo)%NumAlf, &
                                       AF_Table%Tab(ITabLo)%Ind )
      END IF

      IF ( DoCm )  THEN
         CmInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cm, AF_Table%Tab(ITabLo)%NumAlf, &
                                       AF_Table%Tab(ITabLo)%Ind )
      END IF

      IF ( DoCpmin )  THEN
         CpminInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cpmin, AF_Table%Tab(ITabLo)%NumAlf, &
                                          AF_Table%Tab(ITabLo)%Ind )
      END IF

   END IF


      ! If we don't need to interpolate, we don't need to make a second call and we are done.

   IF ( OneTable )  RETURN                 ! We probably shouldn't do this.  We should probably do a block IF.  mlb


      ! Get the coefficients for ITabHi.  Use step-wise interpolation for all but the first coefficient called.

   Fract = ( Re - AF_Table%Tab(ITabLo)%Re )/( AF_Table%Tab(ITabHi)%Re - AF_Table%Tab(ITabLo)%Re )

   IF ( DoCl )  THEN
      IF ( PRESENT(ErrStat) ) THEN
         ClHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cl, AF_Table%Tab(ITabHi)%NumAlf, &
                                       AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      ELSE
         ClHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cl, AF_Table%Tab(ITabHi)%NumAlf, &
                                       AF_Table%Tab(ITabHi)%Ind )
      END IF
      ClInt = ClInt + Fract*( ClHi - ClInt )
   END IF

   IF ( DoCd )  THEN
      IF ( PRESENT(ErrStat) ) THEN
         CdHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cd, AF_Table%Tab(ITabHi)%NumAlf, &
                                       AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      ELSE
         CdHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cd, AF_Table%Tab(ITabHi)%NumAlf, &
                                       AF_Table%Tab(ITabHi)%Ind )
      END IF
      CdInt = CdInt + Fract*( CdHi - CdInt )
   END IF

   IF ( DoCm )  THEN
      IF ( PRESENT(ErrStat) ) THEN
         CmHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cm, AF_Table%Tab(ITabHi)%NumAlf, &
                                       AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      ELSE
         CmHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cm, AF_Table%Tab(ITabHi)%NumAlf, &
                                       AF_Table%Tab(ITabHi)%Ind )
      END IF
      CmInt = CmInt + Fract*( CmHi - CmInt )
   END IF

   IF ( DoCpmin )  THEN
      IF ( PRESENT(ErrStat) ) THEN
         CpminHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cpmin, AF_Table%Tab(ITabHi)%NumAlf, &
                                          AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      ELSE
         CpminHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cpmin, AF_Table%Tab(ITabHi)%NumAlf, &
                                          AF_Table%Tab(ITabHi)%Ind )
      END IF
      CpminInt = CpminInt + Fract*( CpminHi - CpminInt )
   END IF


   RETURN
   END SUBROUTINE GetCoefs ! ( ISeg, Alpha, Re, AF_Table, ClInt, CdInt, CmInt, CpminInt, DoCl, DoCd, DoCm, DoCpmin, ErrStat )
!=======================================================================

END MODULE NWTC_Aero
MODULE NWTC_Library


      ! Notes:

         ! Your project must include the following files:
         !     NWTC_Aero.f90
         !     NWTC_IO.f90
         !     NWTC_Library.f90
         !     NWTC_Num.f90
         !     ModMesh.f90

         ! Your project must include one, but not both, of the following files:
         !     DoubPrec.f90 - for double-precision arithmetic for floating-points variables.  You may have to set a compiler option to have constants use double precision.
         !     SingPrec.f90 - for single-precision arithmetic for floating-points variables.

         ! Your project must include one, and only one, of the following files:
         !     SysIVF.f90    - for Intel Visual Fortran for Windows compiler
         !     SysGnu.f90    - for Gnu Fortran for Linux compiler
         !     SysIFL.f90    - for Intel Fortran for Linux compiler
         !     SysMatlab.f90 - for Intel Visual Fortran for Windows compiler with Matlab's mex functions


         ! Compilation order for command-line compilation:
         !     SingPrec.f90 or DoubPrec.f90
         !     SysIVF.f90 (or other Sys*.f90 file)
         !     NWTC_IO.f90
         !     NWTC_Num.f90
         !     NWTC_Aero.f90
         !     ModMesh.f90
         !     NWTC_Library.f90

         ! Invoking programs should call NWTC_Init() to initialize data important to the use of the library.  Currently,
         !  this is used for the NaN, Inf, and Pi-based constants.


   USE NWTC_Aero   ! The other modules (NWTC_IO, NWTC_Num, Precision, SysSubs, and F2kCLI) are already included in NWTC_Aero.

   USE ModMesh  !BJJ update with JM/IC's Mesh module

   IMPLICIT  NONE


CONTAINS

!=======================================================================
   SUBROUTINE NWTC_Init( ProgNameIn, ProgVerIn )

      ! passed parameters

   CHARACTER(*), INTENT(IN), OPTIONAL :: ProgNameIn
   CHARACTER(*), INTENT(IN), OPTIONAL :: ProgVerIn



      ! Initialize ProgName and ProgVer if parameters have been passed

   IF ( PRESENT( ProgNameIN ) ) THEN
      ProgName = ProgNameIN
   END IF

   IF ( PRESENT( ProgVerIn ) ) THEN
      ProgVer = ProgVerIn
   END IF


      ! This routine calls all required initialization routines.

   CALL SetConstants()

!mlb Let's get rid of this once FLUSH works.
   CALL OpenCon( )


      ! Write the version of the NWTC subroutine library that we are running
   CALL DispNVD( NWTC_Ver )


   RETURN
   END SUBROUTINE NWTC_Init
!=======================================================================

END MODULE NWTC_Library
!----------------------------------------------------------------------------------------------------
MODULE SharedInflowDefns
! This module is used to define shared types and parameters that are used in the module InflowWind.
! 7 Oct 2009    B. Jonkman, NREL/NWTC
!----------------------------------------------------------------------------------------------------

   USE NWTC_Library                                               ! Precision module 

   !-------------------------------------------------------------------------------------------------
   ! Shared types
   !-------------------------------------------------------------------------------------------------

!   TYPE, PUBLIC :: InflLoc   
!      REAL(ReKi)                    :: Position(3)                ! X, Y, Z
!   END TYPE InflLoc
   
   
   TYPE, PUBLIC :: InflIntrpOut
      REAL(ReKi)                    :: Velocity(3)                ! U, V, W
   END TYPE InflIntrpOut

   !-------------------------------------------------------------------------------------------------
   ! Shared parameters, defining the wind types
   ! THEY MUST BE UNIQUE!
   !-------------------------------------------------------------------------------------------------

   INTEGER, PARAMETER, PUBLIC  :: DEFAULT_Wind = -1        ! Undetermined wind type; calls internal routine to guess what type of file it is.
   INTEGER, PARAMETER, PUBLIC  :: Undef_Wind   =  0        ! This is the code for an undefined WindType
   INTEGER, PARAMETER, PUBLIC  :: HH_Wind      =  1        ! Hub-Height wind file
   INTEGER, PARAMETER, PUBLIC  :: FF_Wind      =  2        ! Binary full-field wind file
   INTEGER, PARAMETER, PUBLIC  :: UD_Wind      =  3        ! User-defined wind
   INTEGER, PARAMETER, PUBLIC  :: FD_Wind      =  4        ! 4-dimensional wind (LES)
   INTEGER, PARAMETER, PUBLIC  :: CTP_Wind     =  5        ! Coherent turbulence wind field (superimpose KH billow on background wind)
   INTEGER, PARAMETER, PUBLIC  :: HAWC_Wind    =  6        ! Binary full-field wind file in HAWC format

END MODULE SharedInflowDefns
MODULE CTWind
! This module uses reads coherent turbulence parameter (CTP) files and processes the data in them
! to get coherent turbulence which is later superimposed on a background wind field (the super-
! positioning occurs elsewhere).  The turbulence in this module is part of the KH billow, which
! can be read using FDWind.  As a result, the scaling here should be similiar to FDWind.
!
! This module assumes that the origin, (0,0,0), is located at the tower centerline at ground level,
! and that all units are specified in the metric system (using meters and seconds).
! Data is shifted by half the grid width when used with FFWind.
!
!  Created 25-Sept-2009 by B. Jonkman, National Renewable Energy Laboratory
!     using subroutines and modules from AeroDyn v12.58
!
!----------------------------------------------------------------------------------------------------

   USE                     NWTC_Library
   USE                     SharedInflowDefns

   IMPLICIT                NONE
   PRIVATE
   
      
   INTEGER, PARAMETER           :: NumComps  = 3                              ! number of components
   
            ! CT_Wind
   REAL(ReKi)                   :: DelYCTgrid                                 ! The nondimensional distance between grid points in the y direction.
   REAL(ReKi)                   :: DelZCTgrid                                 ! The nondimensional distance between grid points in the z direction.
   REAL(ReKi)                   :: CTDistSc                                   ! Disturbance scale (ratio of wave height to rotor diameter).
   REAL(ReKi)                   :: CTOffset (NumComps)                        ! Offsets to convert integer data to actual wind speeds.
   REAL(ReKi)                   :: CTScale  (NumComps)                        ! Scaling factors to convert integer data to actual wind speeds.

   
   REAL(ReKi), ALLOCATABLE      :: CTvelU   (:,:,:)                         ! The y-z grid velocity data (U components) for the lower- and upper-bound time slices
   REAL(ReKi), ALLOCATABLE      :: CTvelV   (:,:,:)                         ! The y-z grid velocity data (V components) for the lower- and upper-bound time slices
   REAL(ReKi), ALLOCATABLE      :: CTvelW   (:,:,:)                         ! The y-z grid velocity data (W components) for the lower- and upper-bound time slices
   REAL(ReKi)                   :: CTLy                                       ! Fractional location of tower centerline from right (looking downwind) to left side of the dataset.
   REAL(ReKi)                   :: CTLz                                       ! Fractional location of hub height from bottom to top of dataset.
   REAL(ReKi)                   :: CTScaleVel                                 ! Scaling velocity, U0.  2*U0 is the difference in wind speed between the top and bottom of the wave.
   REAL(ReKi), ALLOCATABLE      :: Tdata    (:)                               ! The list of times for the CT-wind input files.  
   
   REAL(ReKi)                   :: CT_Zref                                    ! The reference height for the CT file (the bottom of the billow)
   REAL(ReKi)                   :: CTYHWid                                    ! The half the width of the background dataset, used to compute the CTwind time offset
   REAL(ReKi)                   :: CTYmax                                     ! The dimensional lateral width of the dataset.
   REAL(ReKi)                   :: CTYt                                       ! Distance of the tower from the right side of the dataset (looking downwind).
   REAL(ReKi)                   :: CTZmax                                     ! The dimensional vertical height of the dataset.
   REAL(ReKi)                   :: InvMCTWS                                   ! The multiplicative inverse of the mean hub height wind speed for the CT wind data

   INTEGER                      :: CT_DF_Y                                    ! The decimation factor for the CT wind data in the y direction.
   INTEGER                      :: CT_DF_Z                                    ! The decimation factor for the CT wind data in the z direction.
   INTEGER                      :: CTvel_files(2)                             ! Times for the CT wind files stored in CTvel arrays.

   INTEGER                      :: IndCT_hi                                   ! An index into the 3rd dimension of the CTvel arrays, indicating the upper time slice (allows us to avoid copying array)
   INTEGER                      :: IndCT_lo                                   ! An index into the 3rd dimension of the CTvel arrays, indicating the lower time slice (allows us to avoid copying array)
   
   INTEGER                      :: NumCTt                                     ! The number of CT wind grids, no more than one grid per time step.
   INTEGER                      :: NumCTy                                     ! The number of CT wind grid points in the y direction.
   INTEGER                      :: NumCTyD                                    ! The decimated number of CT wind grid points in the y direction.
   INTEGER                      :: NumCTyD1                                   ! The decimated number of CT wind grid points in the y direction minus 1.
   INTEGER                      :: NumCTz                                     ! The number of CT wind grid points in the z direction.
   INTEGER                      :: NumCTzD                                    ! The decimated number of CT wind grid points in the z direction.
   INTEGER                      :: NumCTzD1                                   ! The decimated number of CT wind grid points in the z direction minus 1.
   INTEGER, SAVE                :: TimeIndx  = 0                              ! Index into the time array
   INTEGER, ALLOCATABLE         :: TimeStpCT (:)                              ! The list of time steps from the original LE simulation, associated with the CT-wind times.

   INTEGER                      :: CTWindUnit                                 ! unit number used to read the wind files at each call to CT_GetWindSpeed()
   
   LOGICAL                      :: CTVertShft                                 ! Flag to indicate whether or not to shift the z values for the w component.

   CHARACTER(3)                 :: CText                                      ! The extension used for coherent turbulence data files. (usually "les" or "dns")
   CHARACTER(1024)              :: CTSpath                                    ! The path to the CT wind files.

   TYPE :: CTWindFiles
      CHARACTER(1024)           :: CTTSfile                                   ! The name of the file containing the time-step history of the wind files.
      CHARACTER(1024)           :: CTbackgr                                   ! The name of the background wind data
   END TYPE CTWindFiles


   TYPE, PUBLIC :: CT_Backgr
      CHARACTER(1024)           :: WindFile                                   ! The name of the background wind file
      INTEGER                   :: WindFileType                               ! The type of background wind file (currently only FF)
      LOGICAL                   :: CoherentStr                                ! If the coherent time step file is blank or doesn't exist, this is FALSE (use the background only)
   END TYPE CT_Backgr
            
   
   PUBLIC                       :: CT_Init
   PUBLIC                       :: CT_GetWindSpeed
   PUBLIC                       :: CT_SetRefVal
   PUBLIC                       :: CT_Terminate

CONTAINS
!====================================================================================================
SUBROUTINE CT_Init(UnWind, WindFile, BackGrndValues, ErrStat)
!  This subroutine is called at the beginning of a simulation.  It reads the CTP file to obtain
!  the name of the CTS file, the path locating the binary KH files, and decimation factors.
!  It returns the background wind file and type; it also returns a flag that determines if CT wind
!  files are ACTUALLY to be used (e.g., if the CTS file is blank or there is one line of zero in the
!  CTS time array).  
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: WindFile                     ! Name of the CTP (.ctp) wind file
   TYPE(CT_Backgr), INTENT(OUT)   :: BackGrndValues               ! output background values
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise


      ! Local Variables:
      
   TYPE(CTWindFiles)              :: CTP_files
   CHARACTER(3)                   :: CT_SC_ext                    ! extension of the scaling file
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( TimeIndx /= 0 ) THEN  
      CALL WrScr( ' CTWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Read the CTP file and set the background data info to be returned later
   !-------------------------------------------------------------------------------------------------
   
   CALL ReadCTP( UnWind, WindFile, CTP_files, ErrStat )
   IF (ErrStat /= 0) RETURN           
   
  
   BackGrndValues%WindFile     = CTP_files%CTbackgr
   BackGrndValues%WindFileType = FF_Wind             !bjj: perhaps we should check the wind type here
   
   !-------------------------------------------------------------------------------------------------
   ! Read the CTTS file to get the time step and file number arrays
   !-------------------------------------------------------------------------------------------------   
   CALL ReadCTTS( UnWind, CTP_files%CTTSfile, CT_SC_ext, ErrStat )

   IF (ErrStat == 0 .AND. NumCTt > 1) THEN    
      BackGrndValues%CoherentStr  = .TRUE.
      
      !-------------------------------------------------------------------------------------------------
      ! Read file containing scaling for the binary large-eddy files
      !-------------------------------------------------------------------------------------------------
      CALL ReadCTScales( UnWind, TRIM( CTSpath )//'\Scales.'//TRIM( CT_SC_ext ), ErrStat )
      IF (ErrStat /= 0) RETURN


      CTScale(:)  = CTScaleVel*CTScale(:)
      CTOffset(:) = CTScaleVel*CTOffset(:)

   ELSE              
      
      IF (ErrStat <= 0) THEN
         
            ! The file is missing, blank (or possibly incomplete), or has only 1 time step line (which  
            ! is zero); Go on without the CT file, using just the background

         CALL ProgWarn( ' Coherent turbulence wind file will be turned off.' )
         
         BackGrndValues%CoherentStr  = .FALSE.
         CALL CT_Terminate( ErrStat )          
         
      END IF

      RETURN
      
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Set some values that don't change during the run
   !-------------------------------------------------------------------------------------------------
      
   CTYHWid        = 0.0                                                    ! This value is used to perform a time shift (the equivalent distance of FFYHWid [approx. rotor radius])
   CT_Zref        = -1.0                                                   ! This value needs to be set after the corresponding background turbulence has been read (or the CTS file should be changed)

   NumCTyD        = ( NumCTy + CT_DF_Y - 1 )/CT_DF_Y                       ! The decimated number of CT wind grid points in the y direction.
   NumCTzD        = ( NumCTz + CT_DF_Z - 1 )/CT_DF_Z                       ! The decimated number of CT wind grid points in the z direction.
   NumCTyD1       = NumCTyD - 1                                            ! The decimated number of CT wind grid points in the y direction minus 1.
   NumCTzD1       = NumCTzD - 1                                            ! The decimated number of CT wind grid points in the z direction minus 1.

   CTYt           = CTYmax*CTLy                                            ! Distance of the tower from the right side of the dataset (looking downwind).
!   CTZt           = CTZmax*CTLz                                            ! Distance of the hub from the bottom of the dataset.
   DelYCTgrid     = 1.0/NumCTyD1                                           ! The nondimensional distance between grid points in the y direction.
   DelZCTgrid     = 1.0/NumCTzD1                                           ! The nondimensional distance between grid points in the z direction.
    

     
   !-------------------------------------------------------------------------------------------------
   ! Allocate the wind array and initialize it
   !-------------------------------------------------------------------------------------------------
   
   IF (.NOT. ALLOCATED(CTvelU) ) THEN
      ALLOCATE ( CTvelU(NumCTyD,NumCTzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the CTvelU array.' )
         RETURN
      END IF
   END IF   
   
   IF (.NOT. ALLOCATED(CTvelV) ) THEN
!      CALL AllocAry( CTvelV, NumCTyD, NumCTzD, 2, 'CTvelV', ErrStat ) !AllRAry3 AllocAry
      ALLOCATE ( CTvelV(NumCTyD,NumCTzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the CTvelV array.' )
         RETURN
      END IF
   END IF   
   
   IF (.NOT. ALLOCATED(CTvelW) ) THEN
!      CALL AllocAry( CTvelW, NumCTyD, NumCTzD, 2, 'CTvelW', ErrStat ) !AllRAry3 AllocAry
      ALLOCATE ( CTvelW(NumCTyD,NumCTzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the CTvelW array.' )
         RETURN
      END IF
   END IF   

   CTvelU(:,:,:) = 0.0                                                    ! the original velocity data      
   CTvelV(:,:,:) = 0.0                                                    ! the original velocity data      
   CTvelW(:,:,:) = 0.0                                                    ! the original velocity data      
      
   !-------------------------------------------------------------------------------------------------
   ! Initialize the arrays and set the initialization flag
   !-------------------------------------------------------------------------------------------------   
   CTvel_files(:) = 0                                                      ! the name of the files currently in the CTvel array
   CTWindUnit     = UnWind                                                 ! This unit is needed to open the binary files at each step
   TimeIndx       = 1
    
   RETURN

END SUBROUTINE CT_Init
!====================================================================================================
SUBROUTINE CT_SetRefVal(Height, HWidth, ErrStat)

   REAL(ReKi), INTENT(IN)           :: Height                                 ! a reference height (should be hub height)
   REAL(ReKi), INTENT(IN), OPTIONAL :: HWidth                                 ! a reference offset (should be half grid width [~rotor radius])
   INTEGER,    INTENT(OUT)          :: ErrStat                                ! returns 0 if no error; non-zero otherwise


   !-------------------------------------------------------------------------------------------------     
   ! Check that we've initialized everything first
   !-------------------------------------------------------------------------------------------------     
     
   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Initialialize the CTWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE IF ( CT_Zref >= 0 ) THEN
      CALL WrScr( ' Cannot reset the CTWind reference height in the middle of a simulation.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0         
   END IF      


   !-------------------------------------------------------------------------------------------------     
   ! Set the grid shift using the half-width
   !-------------------------------------------------------------------------------------------------     
   IF ( PRESENT( HWidth ) ) THEN
      CTYHWid = HWidth
        
      IF ( CTYHWid < 0 ) THEN
         CALL WrScr( ' Reference width in CTWind cannot be negative.')
         CTYHWid = 0
         ErrStat = 1
      END IF
   END IF
 
 
   !-------------------------------------------------------------------------------------------------     
   ! Set the reference height (bottom of the KH billow) using the input hub-height
   !-------------------------------------------------------------------------------------------------     
      ! CTZt = CTZmax*CTLz             ! the distance between the hub and the bottom of the dataset

   CT_Zref = Height - CTZmax*CTLz      ! the height of the bottom of the KH billow

   IF ( CT_Zref < 0 ) THEN
      CALL WrScr( ' Reference height in CTWind cannot be negative.')
      CT_Zref = 0
      ErrStat = 1
   END IF      

   
END SUBROUTINE CT_SetRefVal
!====================================================================================================
FUNCTION CT_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are are 
! requested.  It returns the velocities at the specified time and space that are superimposed on
! a background wind flow.  This function interpolates into the full-field CT wind arrays, performing
! a time shift based on the average windspeed. The modified time is used to decide which pair of time 
! slices to interpolate within and between. After finding the two time slices, it decides which four 
! grid points bound the (Y,Z) pair. It does a bilinear interpolation for (Y,Z) on each bounding time 
! slice, then linearly interpolates between the 2 time slices. This routine assumes that X is downwind, 
! Y is to the left when looking downwind and Z is up.  In the time (X) and Z directions, steady winds 
! are used when extrapolation is required.  The dataset is assumed to be periodic in the Y direction.
!----------------------------------------------------------------------------------------------------
 
      ! Passed variables:
      
   REAL(ReKi),        INTENT(IN) :: Time                                   ! the time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)                       ! the position (X,Y,Z)
   INTEGER,           INTENT(OUT):: ErrStat                                ! returns 0 if no error; non-zero otherwise
   TYPE(InflIntrpOut)            :: CT_GetWindSpeed                        ! the resultant wind speed
   
   
      ! Local Variables:

   REAL(ReKi)                    :: Iyz_th                                 ! Temporary interpolated value. (time hi, all y, all z)
   REAL(ReKi)                    :: Iyz_tl                                 ! Temporary interpolated value. (time lo, all y, all z)
   REAL(ReKi)                    :: Iyhz                                   ! Temporary interpolated value. (y hi, all z)
   REAL(ReKi)                    :: Iylz                                   ! Temporary interpolated value. (y lo, all z)
   REAL(ReKi)                    :: TimeShifted                            ! Shifted time (necessary because we're keeping x constant)
   REAL(ReKi)                    :: Tgrid                                  ! Fractional distance between time grids.
   REAL(ReKi)                    :: Ygrid                                  ! Fractional distance between grids in the y direction.
   REAL(ReKi)                    :: Ynorm                                  ! Nondimensional lateral distance of the analysis point from right side of dataset (looking downwind).
   REAL(ReKi)                    :: Zgrid(3)                               ! Fractional distance between grids in the z direction.
   REAL(ReKi)                    :: Znorm                                  ! Nondimensional vertical distance of the analysis point from bottom of dataset.

   INTEGER                       :: I
   INTEGER                       :: IYHi
   INTEGER                       :: IYLo
   INTEGER                       :: IZHi(3)
   INTEGER                       :: IZLo(3)


   !-------------------------------------------------------------------------------------------------     
   ! Check that we've initialized everything first
   !-------------------------------------------------------------------------------------------------     
     
   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Initialialize the CTWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE IF ( CT_Zref < 0 ) THEN
      CALL WrScr( ' Set the reference height in the CTWind module before calling CT_GetWindSpeed.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------     
   ! Perform the time shift. At time=0, a point half the grid width downstream will index into the zero 
   ! time slice.  CTYHWid is used to shift the CT wind the same as FF wind is shifted.
   ! This assumes that the coherent turbulence events are moving at MCTWS
   !-------------------------------------------------------------------------------------------------     

   TimeShifted = TIME + ( CTYHWid - InputPosition(1) )*InvMCTWS


   !-------------------------------------------------------------------------------------------------
   ! Find the bounding time slices:
   ! Linearly interpolate in time (or set to 0 before and/or after) 
   ! (compare with NWTC_Num.f90\InterpStpReal) 
   !-------------------------------------------------------------------------------------------------

      ! Let's check the limits first.

   IF ( TimeShifted <= Tdata(1) )  THEN
   
      TimeIndx = 1
      Tgrid    = 0.0
                     
!      CT_GetWindSpeed%Velocity(:) = 0.0
!      RETURN
                           
   ELSE IF ( TimeShifted >= Tdata(NumCTt) )  THEN
   
      TimeIndx = NumCTt - 1
      Tgrid    = 1.0

!      CT_GetWindSpeed%Velocity(:) = 0.0
!      RETURN
      
   ELSE
   
         ! Let's interpolate!

      TimeIndx = MAX( MIN( TimeIndx, NumCTt-1 ), 1 )


      DO 

         IF ( TimeShifted < Tdata(TimeIndx) )  THEN

            TimeIndx = TimeIndx - 1

         ELSE IF ( TimeShifted >= Tdata(TimeIndx+1) )  THEN

            TimeIndx = TimeIndx + 1

         ELSE
         
            Tgrid = MIN( MAX( ( TimeShifted - Tdata(TimeIndx) )/( Tdata(TimeIndx+1) - Tdata(TimeIndx) ), 0.0 ), 1.0 )
            EXIT

         END IF

      END DO
      
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Read the data at the two time steps, if necessary
   !-------------------------------------------------------------------------------------------------
     
   IF ( TimeStpCT(TimeIndx) == CTvel_files(2) ) THEN
      IndCT_lo = 2      
      IndCT_hi = 1
            
   ELSE
      IndCT_lo = 1
      IndCT_hi = 2 
        
      IF ( TimeStpCT(TimeIndx) /= CTvel_files(IndCT_lo) ) THEN         
         CTvel_files(IndCT_lo) = TimeStpCT(TimeIndx)
         CALL ReadCTData ( CTWindUnit, CTvel_files(IndCT_lo), IndCT_lo, ErrStat  )
      END IF
      
   END IF
   

   IF ( CTvel_files(IndCT_hi) /= TimeStpCT(TimeIndx+1) ) THEN
      
      CTvel_files(IndCT_hi) = TimeStpCT(TimeIndx+1)
      CALL ReadCTData ( CTWindUnit, CTvel_files(IndCT_hi), IndCT_hi, ErrStat  )

   END IF
         

   !-------------------------------------------------------------------------------------------------
   ! Calculate the y values;                   The lower-right corner is (1,1) when looking downwind.
   ! note that the KH data is periodic in this direction
   !-------------------------------------------------------------------------------------------------
   
   Ynorm = ( CTYt + InputPosition(2) )/CTYmax

      ! Ensure Ynorm is not negative.  The wave is periodic in y.

   IF ( Ynorm < 0.0 ) THEN
      Ynorm = 1.0 + MOD(Ynorm, 1.0)
   ENDIF

   Ygrid = MIN( MAX( MOD( Ynorm, DelYCTgrid ), 0.0 ), 1.0 )
   IYLo  = MAX( MOD( INT( Ynorm*NumCTyD1 ) + 1, NumCTyD1 ), 1 )
   IYHi =  MOD( IYLo, NumCTyD ) + 1


   !-------------------------------------------------------------------------------------------------
   ! Calculate the z values                   The lower-right corner is (1,1) when looking downwind.
   ! Note: the equivalent Znorm for the w-component may be shifted vertically by half the original
   ! grid spacing. (the K-H data staggers w differently than u & v).  We store IZLo, IZHi, and 
   ! Zgrid in an array to account for this difference.
   !-------------------------------------------------------------------------------------------------

   Znorm = MIN( MAX( ( InputPosition(3) - CT_Zref )/CTZmax, 0.0 ), 1.0 ) ! non-dimensional height (CT_Zref is the bottom of the billow)

      ! Find out fractionally how far we are between grids in time and between grid points in each direction.
      ! Limit values to avoid extrapolation.  We need this for interpolation later on.

   Zgrid(1:2)   = MIN( MAX( MOD( Znorm, DelZCTgrid ), 0.0 ), 1.0 )
   IZLo(1:2)    = MAX( INT( Znorm*NumCTzD1 ) + 1, 1 )            ! Make sure the lowest possible value is 1.

      ! If we are located at the upper end of the z dimension, decrement the index by one and set the grid coordinate to 1.

   IF ( IZLo(1) == NumCTzD )  THEN
      IZLo(1:2)  = NumCTzD1
      Zgrid(1:2) = 1.0
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Find the equivalent Znorm for the w-component, which may be shifted vertically by half 
   ! the original grid spacing. (This is necessary due to the fact that the K-H data staggers w 
   ! differently than u & v).  LES and DNS scale differently.
   !-------------------------------------------------------------------------------------------------

   IF ( CTVertShft )  THEN
      Znorm = MAX( Znorm - 0.5*DelZCTgrid/CT_DF_Z, 0.0 )
      
      Zgrid(3) = MIN( MAX( MOD( Znorm, DelZCTgrid ), 0.0 ), 1.0 )
      IZLo(3)  = MAX( INT( Znorm*NumCTzD1 ) + 1, 1 )       ! Make sure the lowest possible value is 1.


         ! If we are located at the upper end of the z dimension, decrement the index by one and set the grid coordinate to 1.

      IF ( IZLo(3) == NumCTzD )  THEN
         IZLo(3)  = NumCTzD1
         Zgrid(3) = 1.0
      ENDIF
                 
   ELSE
      IZLo(3) = IZLo(1)
      Zgrid(3)= Zgrid(1)          
   ENDIF

   IZHi(:) = IZLo(:) + 1
   
!bjj: old versions used Zgrid(3) = Zgrid(1) without regard to CTVertShft. It seemed wrong to me so I changed it.

   !-------------------------------------------------------------------------------------------------
   !  Interpolate for U component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

      I = 1
         ! linearaly interpolate in the lower time slice
      Iylz   = ( CTvelU(IYLo,IZHi(I),IndCT_lo) - CTvelU(IYLo,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelU(IYLo,IZLo(I),IndCT_lo)
      Iyhz   = ( CTvelU(IYHi,IZHi(I),IndCT_lo) - CTvelU(IYHi,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelU(IYHi,IZLo(I),IndCT_lo)     
      Iyz_tl = ( Iyhz - Iylz )*Ygrid + Iylz

         ! linearaly interpolate in the upper time slice
      Iylz   = ( CTvelU(IYLo,IZHi(I),IndCT_hi) - CTvelU(IYLo,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelU(IYLo,IZLo(I),IndCT_hi)
      Iyhz   = ( CTvelU(IYHi,IZHi(I),IndCT_hi) - CTvelU(IYHi,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelU(IYHi,IZLo(I),IndCT_hi)     
      Iyz_th = ( Iyhz - Iylz )*Ygrid + Iylz

      CT_GetWindSpeed%Velocity(I) = ( Iyz_th - Iyz_tl )*Tgrid + Iyz_tl


   !-------------------------------------------------------------------------------------------------
   !  Interpolate for V component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

      I = 2

         ! linearaly interpolate in the lower time slice
      Iylz   = ( CTvelV(IYLo,IZHi(I),IndCT_lo) - CTvelV(IYLo,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelV(IYLo,IZLo(I),IndCT_lo)
      Iyhz   = ( CTvelV(IYHi,IZHi(I),IndCT_lo) - CTvelV(IYHi,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelV(IYHi,IZLo(I),IndCT_lo)     
      Iyz_tl = ( Iyhz - Iylz )*Ygrid + Iylz

         ! linearaly interpolate in the upper time slice
      Iylz   = ( CTvelV(IYLo,IZHi(I),IndCT_hi) - CTvelV(IYLo,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelV(IYLo,IZLo(I),IndCT_hi)
      Iyhz   = ( CTvelV(IYHi,IZHi(I),IndCT_hi) - CTvelV(IYHi,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelV(IYHi,IZLo(I),IndCT_hi)     
      Iyz_th = ( Iyhz - Iylz )*Ygrid + Iylz

      CT_GetWindSpeed%Velocity(I) = ( Iyz_th - Iyz_tl )*Tgrid + Iyz_tl


   !-------------------------------------------------------------------------------------------------
   !  Interpolate for W component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

      I = 3

         ! linearaly interpolate in the lower time slice
      Iylz   = ( CTvelW(IYLo,IZHi(I),IndCT_lo) - CTvelW(IYLo,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelW(IYLo,IZLo(I),IndCT_lo)
      Iyhz   = ( CTvelW(IYHi,IZHi(I),IndCT_lo) - CTvelW(IYHi,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelW(IYHi,IZLo(I),IndCT_lo)     
      Iyz_tl = ( Iyhz - Iylz )*Ygrid + Iylz

         ! linearaly interpolate in the upper time slice
      Iylz   = ( CTvelW(IYLo,IZHi(I),IndCT_hi) - CTvelW(IYLo,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelW(IYLo,IZLo(I),IndCT_hi)
      Iyhz   = ( CTvelW(IYHi,IZHi(I),IndCT_hi) - CTvelW(IYHi,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelW(IYHi,IZLo(I),IndCT_hi)     
      Iyz_th = ( Iyhz - Iylz )*Ygrid + Iylz

      CT_GetWindSpeed%Velocity(I) = ( Iyz_th - Iyz_tl )*Tgrid + Iyz_tl


   RETURN

END FUNCTION CT_GetWindSpeed
!====================================================================================================
SUBROUTINE ReadCTData ( UnWind, CTFileNo, Itime, ErrStat )
!    This subroutine is used to read one time-step's worth of large-eddy
!    zero-mean wind data for each wind component from a file.
!----------------------------------------------------------------------------------------------------


      ! Passed variables.

   INTEGER,       INTENT(IN)     :: UnWind                                    ! The I/O unit of the input file
   INTEGER,       INTENT(IN)     :: CTFileNo                                  ! The number of the file to read
   INTEGER,       INTENT(IN)     :: Itime                                     ! The index of the time slice
   INTEGER,       INTENT(OUT)    :: ErrStat                                   ! returns 0 if no error; non-zero otherwise

      ! Local variables.

!   CHARACTER(1),PARAMETER        :: Comp(NumComps) = (/'u', 'v', 'w' /)       ! the wind components
   CHARACTER(5)                  :: CTnum                                     ! string equivalent of input variable CTFileNo
   CHARACTER(1024)               :: FileName                                  ! The name of the input data file
   
   
   IF ( CTFileNo == 0 ) THEN
   
      CTvelU(:,:,Itime) = 0.0
      CTvelV(:,:,Itime) = 0.0
      CTvelW(:,:,Itime) = 0.0
      
   ELSE
         ! Loop through the components

      WRITE( CTnum, '(I5.5)' ) CTFileNo


      FileName = TRIM( CTSpath )//'\u\u_16i_'//CTnum//'.'//TRIM( CText )
      CALL LoadCTData( UnWind, TRIM(FileName), Itime, 1, CTvelU, ErrStat )
      IF ( ErrStat /= 0 ) RETURN
      

      FileName = TRIM( CTSpath )//'\v\v_16i_'//CTnum//'.'//TRIM( CText )
      CALL LoadCTData( UnWind, TRIM(FileName), Itime, 2, CTvelV, ErrStat )
      IF ( ErrStat /= 0 ) RETURN
      
      
      FileName = TRIM( CTSpath )//'\w\w_16i_'//CTnum//'.'//TRIM( CText )
      CALL LoadCTData( UnWind, TRIM(FileName), Itime, 3, CTvelW, ErrStat )
      IF ( ErrStat /= 0 ) RETURN
      
   
   END IF

   RETURN
   
END SUBROUTINE ReadCTData
!====================================================================================================
SUBROUTINE LoadCTData( UnWind, FileName, ITime, IComp, Vel, ErrStat )
!  This function is used to read the input parameters for the coherent turbulence events, 
!  based on the large-eddy simulation.
!----------------------------------------------------------------------------------------------------

      ! Passed variables.

   INTEGER,       INTENT(IN)     :: UnWind                                    ! The I/O unit of the input file
   CHARACTER(*),  INTENT(IN)     :: FileName                                  ! The name of the file to open
   INTEGER,       INTENT(IN)     :: Itime                                     ! The index of the time slice
   INTEGER,       INTENT(IN)     :: IComp                                     ! The index of the component
   REAL(ReKi),    INTENT(INOUT)  :: Vel    (NumCTyD,NumCTzD,2)                ! returns the velocity array (don't use INTENT OUT!)  
   INTEGER,       INTENT(OUT)    :: ErrStat                                   ! returns 0 if no error; non-zero otherwise

   INTEGER(B2Ki)                 :: Com    (NumCTy)                           ! Temporary array to hold component's integer values for a given Z.
   INTEGER                       :: IY                                        ! A DO index for indexing the arrays in the y direction.
   INTEGER                       :: IYK                                       ! An index for the decimated arrays in the y direction.
   INTEGER                       :: IZ                                        ! A DO index for indexing the arrays in the z direction.
   INTEGER                       :: IZK                                       ! An index for the decimated arrays in the z direction.



   !-------------------------------------------------------------------------------------------------
   ! Open the input file
   !-------------------------------------------------------------------------------------------------

   CALL OpenUInBEFile( UnWind, TRIM(FileName), 2*NumCTy, ErrStat )
   IF (ErrStat /= 0) RETURN


   !-------------------------------------------------------------------------------------------------
   ! Read the data and fill the arrays
   !-------------------------------------------------------------------------------------------------
      
   IZK = 0                          ! the Z index into the array (necessary b/c of decimation factor)
   DO IZ=1,NumCTz,CT_DF_Z

      READ (UnWind,REC=IZ,IOSTAT=ErrStat)  Com

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Error reading record '//TRIM( Num2LStr( IZ ) )//' of the binary CT wind file, "' &
                           //TRIM( FileName )//'."')
         RETURN                           

      ENDIF

      IZK = IZK + 1
      IYK = 0                       ! the Y index into the array (necessary b/c of decimation factor)
      
      DO IY=1,NumCTy,CT_DF_Y
         IYK = IYK + 1
         Vel(IYK,IZK,ITime) = CTScale(IComp)*Com(IY) + CTOffset(IComp)
      ENDDO ! IY

   ENDDO ! IZ


   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
      CLOSE ( UnWind )

   RETURN


END SUBROUTINE LoadCTData
!====================================================================================================
SUBROUTINE ReadCTP( UnWind, FileName, CTPscaling, ErrStat )
!  This function is used to read the input parameters for the coherent turbulence events, 
!  based on the large-eddy simulation.
!----------------------------------------------------------------------------------------------------


      ! Passed variables.

   INTEGER,            INTENT(IN)  :: UnWind                                   ! The I/O unit of the input file
   CHARACTER(*),       INTENT(IN)  :: FileName                                 ! The name of the input data file
   TYPE(CTWindFiles),  INTENT(OUT) :: CTPscaling                               ! The file names contained in the CTP file
   INTEGER,            INTENT(OUT) :: ErrStat                                  ! returns 0 if no error; non-zero otherwise


      ! Local variables.
      
   CHARACTER(1024)                 :: HeaderLine                               ! The header text in the file
   CHARACTER(1024)                 :: TmpPath

   !-------------------------------------------------------------------------------------------------
   ! Open the CTP input file
   !-------------------------------------------------------------------------------------------------
   
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) RETURN


   !-------------------------------------------------------------------------------------------------
   ! Read the CTP input file
   !-------------------------------------------------------------------------------------------------
   CALL ReadStr( UnWind, TRIM( FileName ), HeaderLine, 'Header line', 'The header line in the CTP file', ErrStat )
   IF (ErrStat /= 0) RETURN   
   CALL WrScr ( ' Heading of the CT-wind-parameter file: "'//TRIM(HeaderLine)//'"' )


   CALL ReadCom( UnWind, TRIM( FileName ), 'parameter header line', ErrStat )
   IF (ErrStat /= 0) RETURN
   

   CALL ReadVar( UnWind, TRIM( FileName ), CTSpath,  'CTSpath',  & 
                  'Location (path) of the binary coherent turbulence dataset', ErrStat )
   IF (ErrStat /= 0) RETURN
                  

   CALL ReadVar( UnWind, TRIM( FileName ), CTPscaling%CTTSfile, 'CTTSfile', &
                  'File containing the time steps for the coherent turbulence events (.cts)', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   
   IF ( PathIsRelative( CTPscaling%CTTSfile ) ) THEN
      CALL GetPath( FileName, TmpPath ) 
      CTPscaling%CTTSfile = TRIM(TmpPath)//TRIM(CTPscaling%CTTSfile)
   END IF      

   CALL ReadVar( UnWind, TRIM( FileName ), CTPscaling%CTbackgr, 'CTbackgr', 'File containing the background wind', ErrStat )
   IF (ErrStat /= 0) RETURN

   IF ( PathIsRelative( CTPscaling%CTbackgr ) ) THEN
      CALL GetPath( FileName, TmpPath ) 
      CTPscaling%CTbackgr = TRIM(TmpPath)//TRIM(CTPscaling%CTbackgr)
   END IF      


   CALL ReadVar( UnWind, TRIM( FileName ), CT_DF_Y, 'CT_DF_Y', 'Decimation factor for wind data in the Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CT_DF_Z, 'CT_DF_Z', 'Decimation factor for wind data in the Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN

   
   !-------------------------------------------------------------------------------------------------
   ! Close the CTP input file
   !-------------------------------------------------------------------------------------------------
   
   CLOSE( UnWind )


END SUBROUTINE ReadCTP
!====================================================================================================
SUBROUTINE ReadCTTS ( UnWind, FileName, CT_SC_ext, ErrStat )
!  This subroutine is used to read the input parameters calculated in TurbSim for the scaling of 
!  coherent turbulence events.  It reads the .cts file and saves the time step and file number arrays.
!----------------------------------------------------------------------------------------------------


      ! Passed variables.

   INTEGER,            INTENT(IN)  :: UnWind                                   ! The I/O unit of the input file
   CHARACTER(*),       INTENT(IN)  :: FileName                                 ! The name of the input data file
   INTEGER,            INTENT(OUT) :: ErrStat                                  ! returns 0 if no error; -1 if the file is blank or can't be opened;                                                                               ! non-zero otherwise
   CHARACTER(3),       INTENT(OUT) :: CT_SC_ext                                ! The extension used for coherent turbulence scale files.(usually "les", "dns", or "dat")

      ! Local variables
   INTEGER                         :: IT                                       ! Loop counter

   !-------------------------------------------------------------------------------------------------
   ! Initialize variables
   !-------------------------------------------------------------------------------------------------

   NumCTt = 0

   !-------------------------------------------------------------------------------------------------
   ! Open the CTS input file
   !-------------------------------------------------------------------------------------------------
   
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) THEN
      ErrStat = -1
      RETURN
   END IF
   
   !-------------------------------------------------------------------------------------------------
   ! Read the header of the CTS input file
   !-------------------------------------------------------------------------------------------------
   
      ! Check to see if the first value is numeric (old) or the file type (new) and start again
      
   READ ( UnWind, *, IOSTAT=ErrStat ) CTScaleVel       
   REWIND( UnWind )  


   IF ( ErrStat /= 0 )  THEN   ! try again
            
      CALL ReadVar( UnWind, TRIM( FileName ), CText, 'CText', 'FileType ', ErrStat ) 
      IF ( ErrStat /= 0 ) THEN
         ErrStat = SIGN( 1, ErrStat)
         RETURN
      END IF
      CT_SC_ext = CText      
      
      CALL ReadVar( UnWind, TRIM( FileName ), CTScaleVel, 'CTScaleVel', ' ', ErrStat ) 
      IF ( ErrStat /= 0 ) RETURN
   ELSE  ! assume LES files
   
      CALL ReadVar( UnWind, TRIM( FileName ), CTScaleVel, 'CTScaleVel', ' ', ErrStat ) 

      CText     = 'les'
      CT_SC_ext = 'dat'
   END IF
   
   CALL ReadVar( UnWind, TRIM( FileName ), InvMCTWS, 'MeanCTWS', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   InvMCTWS = 1.0 / InvMCTWS
      

   CALL ReadVar( UnWind, TRIM( FileName ), CTYmax, 'CTYmax', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   

   CALL ReadVar( UnWind, TRIM( FileName ), CTZmax, 'CTZmax', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CTDistSc, 'CTDistSc', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CTLy, 'CTLy', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   
   
   CALL ReadVar( UnWind, TRIM( FileName ), CTLz, 'CTLz', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   
   
   CALL ReadVar( UnWind, TRIM( FileName ), NumCTt, 'NumCTt', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   !-------------------------------------------------------------------------------------------------
   ! Allocate space for the arrays
   !-------------------------------------------------------------------------------------------------

   IF (.NOT. ALLOCATED(Tdata) ) THEN
      ALLOCATE ( Tdata(NumCTt) , STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the Tdata array.' )
         RETURN
      END IF
   END IF

   IF (.NOT. ALLOCATED(TimeStpCT) ) THEN
      ALLOCATE ( TimeStpCT(NumCTt) , STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the TimeStpCT array.' )
         RETURN
      END IF
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Read the arrays from the CTS input file
   !-------------------------------------------------------------------------------------------------
   
   DO IT=1,NumCTt

      READ (UnWind,*,IOSTAT=ErrStat)  Tdata(IT), TimeStpCT(IT)

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error reading record '//TRIM( Num2LStr( IT ) )//' of the CT-wind time-steps file, "' &
                         //TRIM( FileName )//'."')

         NumCTt = IT - 1
         RETURN
      ENDIF

   ENDDO ! IT


   !-------------------------------------------------------------------------------------------------
   ! Close the CTS input file
   !-------------------------------------------------------------------------------------------------
   CLOSE( UnWind )


   RETURN
   
END SUBROUTINE ReadCTTS
!====================================================================================================
SUBROUTINE ReadCTScales ( UnWind, FileName, ErrStat )
!  This subroutine is used to read the input parameters for the coherent turbulence events, based
!  on the large-eddy simulation.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,            INTENT(IN)  :: UnWind                                   ! The I/O unit of the input file
   CHARACTER(*),       INTENT(IN)  :: FileName                                 ! The name of the input data file
   INTEGER,            INTENT(OUT) :: ErrStat                                  ! returns 0 if no error; non-zero otherwise


      ! Local variables
      
   INTEGER                         :: I                                        ! Array counter

   !-------------------------------------------------------------------------------------------------
   ! Open the file with the scales (les or dns)
   !-------------------------------------------------------------------------------------------------

   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) RETURN
   

   !-------------------------------------------------------------------------------------------------
   ! Read the file with the scales (les or dns)
   !-------------------------------------------------------------------------------------------------

   CALL ReadCom( UnWind, TRIM( FileName ), 'First line', ErrStat )
   IF (ErrStat /= 0) RETURN

   CALL ReadVar( UnWind, TRIM( FileName ), CTVertShft, 'CTVertShft', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN

   DO I = 1,3
      CALL ReadVar( UnWind, TRIM( FileName ), CTScale(I), 'CTScale('//TRIM(Num2LStr(I))//')', ' ', ErrStat ) 
      IF ( ErrStat /= 0 )  RETURN
   
      CALL ReadVar( UnWind, TRIM( FileName ), CTOffset(I), 'CTOffset('//TRIM(Num2LStr(I))//')', ' ', ErrStat ) 
      IF ( ErrStat /= 0 )  RETURN
   END DO !I

   CALL ReadVar( UnWind, TRIM( FileName ), NumCTy, 'NumCTy', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN

   CALL ReadVar( UnWind, TRIM( FileName ), NumCTz, 'NumCTz', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   !-------------------------------------------------------------------------------------------------
   ! Close the file with the scales (les or dns)
   !-------------------------------------------------------------------------------------------------
   
   CLOSE( UnWind )
   

   RETURN
   
END SUBROUTINE ReadCTScales
!====================================================================================================
SUBROUTINE CT_Terminate( ErrStat )
! This subroutine closes files, deallocates memory, and un-sets the initialization flag
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise


   CLOSE( CTWindUnit )
   
   ErrStat = 0

   IF ( ALLOCATED( CTvelU    ) )  DEALLOCATE( CTvelU,    STAT=ErrStat )
   IF ( ALLOCATED( CTvelV    ) )  DEALLOCATE( CTvelV,    STAT=ErrStat )
   IF ( ALLOCATED( CTvelW    ) )  DEALLOCATE( CTvelW,    STAT=ErrStat )
   IF ( ALLOCATED( Tdata     ) )  DEALLOCATE( Tdata,     STAT=ErrStat )
   IF ( ALLOCATED( TimeStpCT ) )  DEALLOCATE( TimeStpCT, STAT=ErrStat )

   TimeIndx = 0

END SUBROUTINE CT_Terminate
!====================================================================================================
END MODULE CTWind
MODULE FDWind
! This module reads and processes 4-dimensional wind fields.
! The subroutines were originally created by Marshall Buhl to read LES data provided by researchers
! at NCAR. It was later updated by Bonnie Jonkman to read DNS data provided by researchers at CoRA.
!
! Data are assumed to be in units of meters and seconds.
!
!  7 Oct 2009    B. Jonkman, NREL/NWTC using subroutines from AeroDyn 12.57
!----------------------------------------------------------------------------------------------------  

    USE                     NWTC_Library
    USE                     SharedInflowDefns

    IMPLICIT                NONE
   PRIVATE
  
      ! FD_Wind
      
   REAL(ReKi)                   :: DelXgrid                                   ! The nondimensional distance between grid points in the x direction.
   REAL(ReKi)                   :: DelYgrid                                   ! The nondimensional distance between grid points in the y direction.
   REAL(ReKi)                   :: DelZgrid                                   ! The nondimensional distance between grid points in the z direction.
   REAL(ReKi)                   :: FDper                                      ! Total time in dataset.
   REAL(ReKi)                   :: FDTime   (2)                               ! Times for the 4D wind files.
   REAL(ReKi), ALLOCATABLE      :: FDu      (:,:,:,:)                         ! The u-component array of 4D wind data.
   REAL(ReKi), ALLOCATABLE      :: FDv      (:,:,:,:)                         ! The v-component array of 4D wind data.
   REAL(ReKi), ALLOCATABLE      :: FDw      (:,:,:,:)                         ! The w-component array of 4D wind data.
   REAL(ReKi), ALLOCATABLE      :: FDuData  (:,:,:,:)                         ! The u-component array of all 4D wind data when used with advection.
   REAL(ReKi), ALLOCATABLE      :: FDvData  (:,:,:,:)                         ! The v-component array of all 4D wind data when used with advection.
   REAL(ReKi), ALLOCATABLE      :: FDwData  (:,:,:,:)                         ! The w-component array of all 4D wind data when used with advection.
   REAL(ReKi)                   :: Lx                                         ! Fractional location of tower centerline from upwind end to downwind end of the dataset.
   REAL(ReKi)                   :: Ly                                         ! Fractional location of tower centerline from right (looking downwind) to left side of the dataset.
   REAL(ReKi)                   :: Lz                                         ! Fractional location of hub height from bottom to top of dataset.
   REAL(ReKi)                   :: Offsets  (3)                               ! Offsets to convert integer data to actual wind speeds.
   REAL(ReKi), SAVE             :: PrevTime                                   ! The previous time this was called -- so we can go back in time if necessary
   REAL(ReKi)                   :: RotDiam                                    ! Rotor diameter.
   REAL(ReKi)                   :: ScalFact (3)                               ! Scaling factors to convert integer data to actual wind speeds.
   REAL(ReKi)                   :: ScaleVel                                   ! Scaling velocity, U0.  2*U0 is the difference in wind speed between the top and bottom of the wave.
   REAL(ReKi), ALLOCATABLE      :: Times4D  (:)                               ! The list of times for the 4D-wind input files.
   REAL(ReKi)                   :: Tm_max                                     ! The total nondimensional time of the dataset.
   REAL(ReKi)                   :: TSclFact                                   ! Scale factor for time (h/U0).
   REAL(ReKi)                   :: T_4D_En                                    ! Time at which the wave event ends.
   REAL(ReKi)                   :: T_4D_St                                    ! Time at which the wave event starts.
   REAL(ReKi)                   :: Xmax                                       ! The dimensional downwind length of the dataset.
   REAL(ReKi)                   :: Xt                                         ! Distance of the tower from the upwind end of the dataset.
   REAL(ReKi)                   :: Ymax                                       ! The dimensional lateral width of the dataset.
   REAL(ReKi)                   :: Yt                                         ! Distance of the tower from the right side of the dataset (looking downwind).
   REAL(ReKi)                   :: Zmax                                       ! The dimensional vertical height of the dataset.
   REAL(ReKi)                   :: Zt                                         ! Distance of the hub from the bottom of the dataset.
   REAL(ReKi)                   :: Zref                                       ! The reference height (hub height)

   INTEGER                      :: FD_DF_X                                    ! The decimation factor for the 4D wind data in the x direction.
   INTEGER                      :: FD_DF_Y                                    ! The decimation factor for the 4D wind data in the y direction.
   INTEGER                      :: FD_DF_Z                                    ! The decimation factor for the 4D wind data in the z direction.
   INTEGER                      :: FDFileNo                                   ! The 4D wind file number.
   INTEGER                      :: FDRecL                                     ! The length, in bytes, of the LE binary records.
   INTEGER                      :: Ind4DAdv                                   ! Index of the file to be used in advection
   INTEGER                      :: Ind4Dnew                                   ! Index of the newest 4D wind file.
   INTEGER                      :: Ind4Dold                                   ! Index of the older 4D wind file.
   INTEGER                      :: Num4Dt                                     ! The number of 4D wind grids, one grid per time step.
   INTEGER, PARAMETER           :: Num4DtD = 2                                ! The number of 4D wind grids stored in memory, normally 2
   INTEGER                      :: Num4Dx                                     ! The number of 4D wind grid points in the x direction.
   INTEGER                      :: Num4DxD                                    ! The decimated number of 4D wind grid points in the x direction.
   INTEGER                      :: Num4DxD1                                   ! The decimated number of 4D wind grid points in the x direction minus 1.
   INTEGER                      :: Num4Dy                                     ! The number of 4D wind grid points in the y direction.
   INTEGER                      :: Num4DyD                                    ! The decimated number of 4D wind grid points in the y direction.
   INTEGER                      :: Num4DyD1                                   ! The decimated number of 4D wind grid points in the y direction minus 1.
   INTEGER                      :: Num4Dz                                     ! The number of 4D wind grid points in the z direction.
   INTEGER                      :: Num4DzD                                    ! The decimated number of 4D wind grid points in the z direction.
   INTEGER                      :: Num4DzD1                                   ! The decimated number of 4D wind grid points in the z direction minus 1.
   INTEGER                      :: NumAdvect                                  ! Number of frozen timesteps to advect past the turbine
   INTEGER                      :: Shft4Dnew                                  ! Number of times the x-data needs to be shifted for advection
   INTEGER, ALLOCATABLE         :: Times4DIx (:)                              ! Index number of the 4D time files (used for advection)

   INTEGER                      :: FDUnit                                     ! Unit number for reading wind files

   LOGICAL                      :: Advect                                     ! Flag to indicate whether or not to advect a given data set or to just use the time step files 
   LOGICAL                      :: VertShft                                   ! Flag to indicate whether or not to shift the z values for the w component.

   LOGICAL, SAVE                :: Initialized = .FALSE.

   CHARACTER(5), ALLOCATABLE    :: AdvFiles (:)
   CHARACTER(1024)              :: FDSpath                                    ! The path to the 4D wind files.


   PUBLIC                       :: FD_Init
   PUBLIC                       :: FD_GetWindSpeed
   PUBLIC                       :: FD_Terminate
   PUBLIC                       :: FD_GetValue


CONTAINS
!====================================================================================================
SUBROUTINE FD_Init(UnWind, WindFile, RefHt, ErrStat)
!  This subroutine is called at the beginning of a simulation to initialize the module.  
!----------------------------------------------------------------------------------------------------

      ! Passed variables
      
   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: WindFile                     ! Name of the 4D wind parameter file (.fdp)
   REAL(ReKi),      INTENT(IN)    :: RefHt                        ! The reference height for the billow (should be hub height)
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors; non-zero otherwise

      ! Local variables

   CHARACTER(1024)                :: FDTSfile                     ! name of the 4D time step file
   REAL(ReKi)                     :: FDTimStp                     ! Average time step for 4D wind data.
   INTEGER                        :: IT
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' FDWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Set the reference height for the wind file (this takes the place of HH that was used earlier)
   !-------------------------------------------------------------------------------------------------

   ZRef = RefHt         
   
   !-------------------------------------------------------------------------------------------------
   ! Read the main 4D input file
   !-------------------------------------------------------------------------------------------------
   
   CALL ReadFDP( UnWind, WindFile, FDTSfile, ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   !-------------------------------------------------------------------------------------------------
   ! Get the times array, which must be scaled and shifted later using TSclFact and T_4D_St
   !-------------------------------------------------------------------------------------------------

   CALL Read4Dtimes ( UnWind, FDTSfile, ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   
   !-------------------------------------------------------------------------------------------------
   ! Calculate some values that don't change during the run.
   !-------------------------------------------------------------------------------------------------

   FDRecL      = 2*Num4Dx*Num4Dy                                           ! The length, in bytes, of the 4D binary records.
   Num4DxD     = ( Num4Dx + FD_DF_X - 1 )/FD_DF_X                          ! The decimated number of 4D wind grid points in the x direction.
   Num4DyD     = ( Num4Dy + FD_DF_Y - 1 )/FD_DF_Y                          ! The decimated number of 4D wind grid points in the y direction.
   Num4DzD     = ( Num4Dz + FD_DF_Z - 1 )/FD_DF_Z                          ! The decimated number of 4D wind grid points in the z direction.
   Num4DxD1    = Num4DxD - 1                                               ! The decimated number of 4D wind grid points in the x direction minus 1.
   Num4DyD1    = Num4DyD - 1                                               ! The decimated number of 4D wind grid points in the y direction minus 1.
   Num4DzD1    = Num4DzD - 1                                               ! The decimated number of 4D wind grid points in the z direction minus 1.

   Tm_max      = Times4D(Num4Dt)                                           ! Time of end of dataset.
   IF ( ADVECT ) THEN
      FDTimStp   = Xmax / ( ( Num4Dx - 1 )*( ScaleVel )*Num4Dt )           ! The timestep is calculated by the approximation dx/dt ~= U0 (divide by num4dt to get delta for a full timestep).
      FDper      = FDTimStp * Num4Dt                                       ! Total time in dataset. (We have periodic time, so multiply by number of time steps, without subtracting 1)
      TSclFact   = FDper / Tm_max                                          ! Equivalent scale factor for time.
   ELSE
      FDper       = TSclFact*Tm_max                                        ! Total time in dataset.
      FDTimStp    = FDper/( Num4Dt - 1 )                                   ! Average time step.
   ENDIF

   T_4D_En     = T_4D_St + FDper                                           ! Time for the end of the dataset.
   Xt          = Xmax*Lx                                                   ! Distance of the tower from the upwind end of the dataset.
   Yt          = Ymax*Ly                                                   ! Distance of the tower from the right side of the dataset (looking downwind).
   Zt          = Zmax*Lz                                                   ! Distance of the hub from the bottom of the dataset.
   DelXgrid    = 1.0/Num4DxD1                                              ! The nondimensional distance between grid points in the x direction.
   DelYgrid    = 1.0/Num4DyD1                                              ! The nondimensional distance between grid points in the y direction.
   DelZgrid    = 1.0/Num4DzD1                                              ! The nondimensional distance between grid points in the z direction.


   !-------------------------------------------------------------------------------------------------
   ! Scale and shift the times array using TSclFact and T_4D_St
   !-------------------------------------------------------------------------------------------------

   DO IT=1,Num4Dt
      
      Times4D(IT) = TSclFact*Times4D(IT) + T_4D_St

   ENDDO ! IT


   !-------------------------------------------------------------------------------------------------
   ! Allocate velocity arrays and fill Data arrays for advection (DNS files)
   !-------------------------------------------------------------------------------------------------

   IF (.NOT. ALLOCATED(FDu) ) THEN
!      CALL AllocAry ( FDu, Num4DxD, Num4DyD, Num4DzD, 2, 'U-component velocity array (FDu)', ErrStat)
      ALLOCATE ( FDu(Num4DxD,Num4DyD,Num4DzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the U-component velocity array (FDu) array.' )
         RETURN
      END IF
   END IF
   
   IF (.NOT. ALLOCATED(FDv) ) THEN
!      CALL AllocAry ( FDv, Num4DxD, Num4DyD, Num4DzD, 2, 'V-component velocity array (FDv)', ErrStat)
      ALLOCATE ( FDv(Num4DxD,Num4DyD,Num4DzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the V-component velocity array (FDv) array.' )
         RETURN
      END IF
   END IF

   IF (.NOT. ALLOCATED(FDw) ) THEN
!      CALL AllocAry ( FDw, Num4DxD, Num4DyD, Num4DzD, 2, 'W-component velocity array (FDw)', ErrStat)
      ALLOCATE ( FDw(Num4DxD,Num4DyD,Num4DzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the W-component velocity array (FDw) array.' )
         RETURN
      END IF
   END IF

   IF ( ADVECT ) THEN

      IF (.NOT. ALLOCATED(FDuData) ) THEN
!         CALL AllocAry ( FDuData, Num4DxD, Num4DyD, Num4DzD, Num4Dt, 'U-component velocity array (FDuData)', ErrStat)
         ALLOCATE ( FDuData(Num4DxD,Num4DyD,Num4DzD,Num4Dt), STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error allocating memory for the U-component velocity array (FDuData) array.' )
            RETURN
         END IF
      END IF

      IF (.NOT. ALLOCATED(FDvData) ) THEN
!         CALL AllocAry ( FDvData, Num4DxD, Num4DyD, Num4DzD, Num4Dt, 'V-component velocity array (FDvData)', ErrStat)
         ALLOCATE ( FDvData(Num4DxD,Num4DyD,Num4DzD,Num4Dt), STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error allocating memory for the V-component velocity array (FDvData) array.' )
            RETURN
         END IF
      END IF

      IF (.NOT. ALLOCATED(FDwData) ) THEN
!         CALL AllocAry ( FDwData, Num4DxD, Num4DyD, Num4DzD, Num4Dt, 'W-component velocity array (FDwData)', ErrStat)
         ALLOCATE ( FDwData(Num4DxD,Num4DyD,Num4DzD,Num4Dt), STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error allocating memory for the W-component velocity array (FDwData) array.' )
            RETURN
         END IF
      END IF

      CALL ReadAll4DData(UnWind, ErrStat) !This needs AdvFiles(:), which was is read in ReadFDP()
      IF ( ErrStat /= 0 ) RETURN

   ENDIF

     
   !-------------------------------------------------------------------------------------------------
   ! Determine the first file needed for this simulation.
   !-------------------------------------------------------------------------------------------------
   Ind4Dold  = 1                                                           ! Put the old stuff in the first part of the array.
   Ind4Dnew  = 2                                                           ! Put the new stuff in the second part of the array.

   Shft4Dnew = 0


   IF ( T_4D_St >= 0.0 )  THEN
      FDFileNo = 1
   ELSE
      FDFileNo = Num4Dt
      DO IT=1,Num4Dt
         IF ( Times4D(IT) > 0.0 )  THEN
            FDFileNo = IT - 1
            EXIT
         END IF
      END DO ! IT
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Open, read, and close the first set of files.
   !-------------------------------------------------------------------------------------------------
   FDTime(Ind4Dold) = Times4D(FDFileNo)                                 ! Set the time for this file.

   IF ( ADVECT ) THEN
      CALL Load4DData(Ind4Dold)     ! load data stored in FDuData, FDvData, and FDwData arrays
   ELSE
      CALL LoadLESData( UnWind, FDFileNo, Ind4Dold, ErrStat )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Open, read, and close the second set of files.
   !-------------------------------------------------------------------------------------------------
   FDFileNo  = FDFileNo + 1


   IF ( ADVECT ) THEN
      FDFileNo = MOD(FDFileNo-1,Num4Dt) + 1

      IF (FDFileNo == 1) THEN
         Shft4Dnew = Shft4Dnew + 1

         IF (Ind4DAdv <= NumAdvect) THEN                             ! Ind4DAdv was set in ReadFDP
            IF ( MOD( Shft4Dnew, Num4Dx ) == 0 ) THEN
               CALL ReadAll4DData(UnWind, ErrStat)
               IF ( ErrStat /= 0 ) RETURN
            END IF
         END IF

      ENDIF

      FDTime(Ind4Dnew) = Times4D(FDFileNo) + Shft4Dnew*FDPer         ! Set the time for this file.

      CALL Load4DData( Ind4Dnew )    ! shift the data

   ELSE   
      FDTime(Ind4Dnew) = Times4D(FDFileNo)                                           ! Set the time for this file.

      CALL LoadLESData( UnWind, FDFileNo, Ind4Dnew, ErrStat )
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Set the initialization flag
   !-------------------------------------------------------------------------------------------------
   FDUnit      = UnWind
   PrevTime    = 0.0
   
   Initialized = .TRUE.
   
   RETURN

END SUBROUTINE FD_Init
!====================================================================================================
SUBROUTINE ReadFDP ( UnWind, FileName, FDTSfile, ErrStat )
!  This subroutine is used to read the input parameters for the large-eddy simulation.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: FileName                     ! Then name of the LE data file.
   CHARACTER(*),    INTENT(OUT)   :: FDTSfile                     ! The name of the file containing the time-step history of the wind files.
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise


      ! Local variables

   CHARACTER(1024)                :: HeaderLine
   CHARACTER(1),PARAMETER         :: Comp(3) = (/'U', 'V', 'W' /) ! the wind components

   REAL(ReKi)                     :: CoefTE                       ! Coefficient of thermal expansion.
   REAL(ReKi)                     :: DistScal                     ! Disturbance scale (ratio of wave height to rotor diameter) from input file.
   REAL(ReKi)                     :: Grav                         ! Gravitational acceleration.
   REAL(ReKi)                     :: LenScale                     ! Length scale (h).
   REAL(ReKi)                     :: Ri                           ! Richardson number.
   REAL(ReKi)                     :: Ubot                         ! Steady u-component wind speed at the bottom of the wave.
   REAL(ReKi)                     :: Zm_maxo                      ! The nondimensional vertical height of the untrimmed dataset.

   REAL(ReKi)                     :: Xm_max                       ! The nondimensional downwind length of the dataset.
   REAL(ReKi)                     :: Ym_max                       ! The nondimensional lateral width of the dataset.
   REAL(ReKi)                     :: Zm_max                       ! The nondimensional vertical height of the dataset.

   INTEGER                        :: I

   !-------------------------------------------------------------------------------------------------
   ! Open the 4D parameter file for reading
   !-------------------------------------------------------------------------------------------------
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) RETURN   


   !-------------------------------------------------------------------------------------------------
   ! Read the 4D parameter input file
   !-------------------------------------------------------------------------------------------------

      !..............................................................................................
      ! Read the 4D wind parameters specific to this turbine simulation.  
      !..............................................................................................

   CALL ReadStr( UnWind, TRIM( FileName ), HeaderLine, 'Header line', 'The header line in the FTP file', ErrStat )
   IF (ErrStat /= 0) RETURN   
   CALL WrScr ( ' Heading of the 4D-wind-parameter file: "'//TRIM(HeaderLine)//'"' )


   CALL ReadCom( UnWind, TRIM( FileName ), 'Header line', ErrStat )
   IF (ErrStat /= 0) RETURN
      

   CALL ReadVar( UnWind, TRIM( FileName ), FDSpath,  'FDSpath', 'Location (path) of the binary dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FDTSfile,  'FDTSfile', & 
                                  'Name of the file containing the time-step history of the wind files', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ubot,  'Ubot', 'Steady u-component wind speed at the bottom of the wave', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), DistScal,  'DistScal', 'Disturbance scale', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Lx,  'Lx', &
                            'Fractional location of tower centerline from upwind end to downwind end of the dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ly,  'Ly', &
                 'Fractional location of tower centerline from right (looking downwind) to left side of the dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Lz,  'Lz', &
                                          'Fractional location of hub height from bottom to top of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), T_4D_St,  'T_4D_St', 'Time at which the wave event starts', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), ScaleVel,  'ScaleVel', &
                 'Scaling velocity, U0: half the difference in wind speed between the top and bottom of the billow.', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), RotDiam,  'RotDiam', 'Rotor diameter', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FD_DF_X,  'FD_DF_X', 'Decimation factor in X direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FD_DF_Y,  'FD_DF_Y', 'Decimation factor in Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FD_DF_Z,  'FD_DF_Z', 'Decimation factor in Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadCom( UnWind, TRIM( FileName ), 'blank line', ErrStat )
   IF (ErrStat /= 0) RETURN

      !..............................................................................................
      ! Read the 4D wind parameters specific to the K-H billow simulation being used.  
      !..............................................................................................

   CALL ReadCom( UnWind, TRIM( FileName ), 'LES parameters specific to the K-H billow simulation being used', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), VertShft,  'VertShft', & 
                           'Flag to indicate whether or not to shift the z values for the w component', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Xm_max,  'Xm_max', & 
                           'Maximum nondimensional downwind distance from center of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ym_max,  'Ym_max', & 
                           'Maximum nondimensional lateral distance from center of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Zm_max,  'Zm_max', & 
                           'Maximum nondimensional vertical distance from center of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Zm_maxo,  'Zm_maxo', & 
                 'Maximum nondimensional vertical distance from center of untrimmed dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   DO I = 1,3

      CALL ReadVar( UnWind, TRIM( FileName ), ScalFact(I),  Comp(I)//'Scl', & 
                    Comp(I)//'-component scale factor for converting from integers to reals', ErrStat )
      IF (ErrStat /= 0) RETURN
      ScalFact(I) = ScalFact(I) * ScaleVel


      CALL ReadVar( UnWind, TRIM( FileName ), Offsets(I), Comp(I)//'Off', & 
                    Comp(I)//'-component offset for converting from integers to reals', ErrStat )
      IF (ErrStat /= 0) RETURN
      Offsets(I) = Offsets(I) * ScaleVel
      
   END DO   
   Offsets (1) = Offsets (1) + ScaleVel + Ubot                           ! u-component offset to convert integer data to actual wind speeds.


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dt, 'Num4Dt', 'The number of LE grids, one grid per time step', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dx, 'Num4Dx', 'The number of LE grid points in the x direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dy, 'Num4Dy', 'The number of LE grid points in the y direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dz, 'Num4Dz', 'The number of LE grid points in the z direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ri, 'Ri', 'Richardson number', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CoefTE, 'CoefTE', 'Coefficient of thermal expansion', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Grav, 'Grav', 'Gravitational acceleration', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Advect, 'Advect', 'Advection flag', ErrStat )
   
   IF (ErrStat /= 0) THEN
   
      Advect   = .FALSE.
      Ind4DAdv = 0
      ErrStat  = 0
      CALL WrScr( ' Advection will not be used.')
      
   ELSE
   
      IF (Advect) THEN
         IF ( FD_DF_X /= 1 ) THEN
            CALL WrScr( ' FD_DF_X must be 1 when using advection. ' )
            FD_DF_X = 1            
         ENDIF

         CALL ReadVar( UnWind, TRIM( FileName ), NumAdvect, 'NumAdvect', 'Number of 4D files for advection', ErrStat )
         IF (ErrStat /= 0) RETURN
         

         IF ( NumAdvect < 1 ) THEN
            CALL WrScr( ' NumAdvect in 4D-wind-parameter file, "'//TRIM( FileName )//'," must be at least 1.' )
            ErrStat = 1
            RETURN
         ENDIF

         IF ( .NOT. ALLOCATED( AdvFiles ) ) THEN
!            CALL AllocAry( AdvFiles, NumAdvect, 'AdvFiles array', ErrStat )
            ALLOCATE ( AdvFiles(NumAdvect), STAT=ErrStat )

            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error allocating memory for the AdvFiles array.' )
               RETURN
            END IF
         ENDIF

         CALL ReadAryLines( UnWind, TRIM( FileName ), AdvFiles, NumAdvect, 'AdvFiles', 'Advection file names', ErrStat )
         IF (ErrStat /= 0) RETURN
         Ind4DAdv = 1
         
      ELSE
         Ind4DAdv = 0
      ENDIF !Advect == .TRUE.
   
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Close the 4D parameter input file
   !-------------------------------------------------------------------------------------------------
   CLOSE ( UnWind )
   
   !-------------------------------------------------------------------------------------------------
   ! Close the 4D parameter input file
   !-------------------------------------------------------------------------------------------------

   LenScale    = RotDiam*DistScal/Zm_max                             ! Length scale (h).
   Xmax        = Xm_max*LenScale                                     ! The dimensional length of the dataset.
   Ymax        = Ym_max*LenScale                                     ! The dimensional width of the dataset
   Zmax        = Zm_max*LenScale                                     ! The dimensional vertical height of the dataset.
   TSclFact    = LenScale/ScaleVel                                   ! Scale factor for time (h/U0).

   

   RETURN

END SUBROUTINE ReadFDP
!====================================================================================================
SUBROUTINE Read4Dtimes ( UnWind, FileName, ErrStat )
!  This subroutine is used to read the time array for the 4D data.  The times in the file are 
!  non-dimensional and non-uniformly spaced. They are scaled using TSclFact to obtain units of seconds
!  and T_4D_St is added to allow the billow to start at non-zero time.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: FileName                     ! Then name of the LE data file.
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise


      ! Local variables

   INTEGER                        :: I                            ! Loop counter

   !-------------------------------------------------------------------------------------------------
   ! Allocate arrays to store the data in
   !-------------------------------------------------------------------------------------------------
   
   IF (.NOT. ALLOCATED( Times4D) ) THEN
!      CALL AllocAry( Times4D, Num4Dt, '4D time array', ErrStat)
      ALLOCATE ( Times4D(Num4Dt), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the Times4D array.' )
         RETURN
      END IF
   END IF
      
   IF (.NOT. ALLOCATED( Times4DIx) ) THEN
!      CALL AllocAry( Times4DIx, Num4Dt, '4D time array', ErrStat)
      ALLOCATE ( Times4DIx(Num4Dt), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the Times4DIx array.' )
         RETURN
      END IF
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Open the 4D times file
   !-------------------------------------------------------------------------------------------------
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   !-------------------------------------------------------------------------------------------------
   ! Read the 4D times file
   !-------------------------------------------------------------------------------------------------
   CALL ReadCom( UnWind, TRIM( FileName ), 'first line', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   DO I=1,Num4Dt

      READ (UnWind,*,IOSTAT=ErrStat)  Times4DIx(I), Times4D(I)

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Error reading line '//TRIM( Num2LStr( I+1 ) )// &
                        ' of the 4D-wind time-steps file, "'//TRIM( FileName )//'."')
         RETURN                        

      ENDIF
      
   ENDDO ! I

   
   !-------------------------------------------------------------------------------------------------
   ! Close the 4D times file
   !-------------------------------------------------------------------------------------------------
   
   CLOSE ( UnWind )  
   
   RETURN     
   
END SUBROUTINE Read4Dtimes
!====================================================================================================
SUBROUTINE ReadAll4DData(UnWind, ErrStat)
! This subroutine reads the data into one array to be accessed later when ADVECT=.TRUE. Since there 
! are just a few time steps, we'll load them into memory to (hopefully) save I/O time.
!----------------------------------------------------------------------------------------------------

   INTEGER, INTENT(IN)        :: UnWind
   INTEGER, INTENT(OUT)       :: ErrStat                            ! 
   INTEGER                    :: IT

   CHARACTER(1)               :: FDNum
   CHARACTER(20)              :: DNSFileName                        ! String containing part of the current file name.


   DO IT = 1,Num4Dt

      WRITE(FDNum,'(I1.1)') Times4DIx(IT)
      DNSFileName = TRIM(AdvFiles(Ind4DAdv))//'_'//TRIM(FDNum)//'.dns'

      CALL Read4DData ( UnWind, TRIM( FDSpath )//'\u\u_16i_'//TRIM(DNSFileName), FDuData, IT, ScalFact(1), Offsets(1), ErrStat )
      IF ( ErrStat /= 0 ) RETURN

      CALL Read4DData ( UnWind, TRIM( FDSpath )//'\v\v_16i_'//TRIM(DNSFileName), FDvData, IT, ScalFact(2), Offsets(2), ErrStat )
      IF ( ErrStat /= 0 ) RETURN

      CALL Read4DData ( UnWind, TRIM( FDSpath )//'\w\w_16i_'//TRIM(DNSFileName), FDwData, IT, ScalFact(3), Offsets(3), ErrStat )
      IF ( ErrStat /= 0 ) RETURN

   ENDDO ! IT

   Ind4DAdv = Ind4DAdv + 1

   RETURN

END SUBROUTINE ReadAll4DData
!====================================================================================================
SUBROUTINE LoadLESData( UnWind, FileNo, Indx, ErrStat )
! This subroutine reads binary data from the U, V, and W files and stores them in the arrays FDu,
! FDv, and FDw (by calling Read4DData).
!----------------------------------------------------------------------------------------------------
      ! Passed variables

   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,         INTENT(IN)    :: FileNo                       ! current file number to read
   INTEGER,         INTENT(IN)    :: Indx                         ! index into the data arrays
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise
   
      ! local variables
   CHARACTER(5)                   :: FDNum
   CHARACTER(20)                  :: LESFileName                  ! String containing part of the current file name.      
   
      
      ! get the file name for the file number
      
   WRITE(FDNum,'(I5.5)', IOStat=ErrStat) FileNo
   IF ( ErrStat /= 0 ) RETURN
   
   LESFileName = TRIM(FDNum)//'.les'


      ! set the paths and read the data for each component
      
   CALL Read4DData ( UnWind, TRIM( FDSpath )//'\u\u_16i_'//TRIM(LESFileName), FDu, Indx, ScalFact(1), Offsets(1), ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   CALL Read4DData ( UnWind, TRIM( FDSpath )//'\v\v_16i_'//TRIM(LESFileName), FDv, Indx, ScalFact(2), Offsets(2), ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   CALL Read4DData ( UnWind, TRIM( FDSpath )//'\w\w_16i_'//TRIM(LESFileName), FDw, Indx, ScalFact(3), Offsets(3), ErrStat )


END SUBROUTINE LoadLESData
!====================================================================================================
SUBROUTINE Read4DData ( UnWind, FileName, Comp, Indx4, Scale, Offset,  ErrStat)
! This subroutine is used to read one time-step's worth of large-eddy wind data for one component 
! from a file.
!----------------------------------------------------------------------------------------------------

      ! Passed variables
      
   INTEGER,     INTENT(IN)    :: UnWind               ! The I/O unit of the LE file.
   CHARACTER(*),INTENT(IN)    :: FileName             ! Then name of the LE data file.

   REAL(ReKi),  INTENT(INOUT) :: Comp (:,:,:,:)       ! The velocity array [do NOT make this INTENT(OUT): other parts of the array may become undefined]
   INTEGER,     INTENT(IN)    :: Indx4                ! The index of the 4th dimension of Comp, which is to be read.
   REAL(ReKi),  INTENT(IN)    :: Scale                ! The scale factor for converting from intergers to non-normalized reals.
   REAL(ReKi),  INTENT(IN)    :: Offset               ! The offset for converting from intergers to non-normalized reals.

   INTEGER,     INTENT(OUT)   :: ErrStat              ! The returned status of a READ.
      
      ! Local variables

   INTEGER                    :: IX                   ! A DO index for indexing the arrays in the x direction.
   INTEGER                    :: IXK                  ! An index for the decimated arrays in the x direction.
   INTEGER                    :: IY                   ! A DO index for indexing the arrays in the y direction.
   INTEGER                    :: IYK                  ! An index for the decimated arrays in the y direction.
   INTEGER                    :: IZ                   ! A DO index for indexing the arrays in the z direction.
   INTEGER                    :: IZK                  ! An index for the decimated arrays in the z direction.

   INTEGER(B2Ki)              :: Com (Num4Dx,Num4Dy)  ! Temporary array to hold component's integer values for a given Z.


   !-------------------------------------------------------------------------------------------------
   ! Open the binary input file
   !-------------------------------------------------------------------------------------------------
   CALL OpenUInBEFile( UnWind, TRIM( FileName ), FDRecL, ErrStat )
   IF ( ErrStat /= 0 ) RETURN


   !-------------------------------------------------------------------------------------------------
   ! Read the input file
   !-------------------------------------------------------------------------------------------------

   IZK = 0
   DO IZ=1,Num4Dz,FD_DF_Z

      READ (UnWind,REC=IZ,IOSTAT=ErrStat)  Com

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Error reading record '//TRIM( Num2LStr( IZ ) )// & 
                                            ' of the binary 4D wind file, "'//TRIM( FileName )//'".')
         RETURN

      ENDIF

      IZK = IZK + 1                                ! IZK = ( IZ - 1 + FD_DF_Z )/FD_DF_Z
      IYK = 0
      
      DO IY=1,Num4Dy,FD_DF_Y
         
         IYK = IYK + 1                             ! IYK = ( IY - 1 + FD_DF_Y )/FD_DF_Y
         
         DO IX=1,Num4Dx,FD_DF_X
         
               ! shift the x-index, if necessary, to perform Advection
               
            !IXK = ( IX + FD_DF_X - 1 )/FD_DF_X
            IXK = ( MOD(IX+Shft4Dnew-1,Num4Dx) + FD_DF_X )/FD_DF_X
         
            Comp(IXK,IYK,IZK,Indx4) = Scale*Com(IX,IY) + Offset
         
         ENDDO ! IX
         
      ENDDO ! IY

   ENDDO ! IZ


   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
   CLOSE ( UnWind )

   RETURN

END SUBROUTINE Read4DData
!====================================================================================================
SUBROUTINE Load4DData( InpIndx )
! This subroutine takes the data from the storage array (used when ADVECT=.TRUE., shifts it if necessary, 
! and loads it into the array for the time slice indexed by InpIndx.
!----------------------------------------------------------------------------------------------------

   INTEGER, INTENT(IN) :: InpIndx

   INTEGER             :: IX
   INTEGER             :: IXK


   DO IX=1,Num4Dx,FD_DF_X

         ! shift the x-index, if necessary, to perform Advection
      IXK = ( MOD(IX+Shft4Dnew-1,Num4Dx) + FD_DF_X )/FD_DF_X

      FDu(IXK,:,:,InpIndx) = FDuData(IX,:,:,FDFileNo)
      FDv(IXK,:,:,InpIndx) = FDvData(IX,:,:,FDFileNo)
      FDw(IXK,:,:,InpIndx) = FDwData(IX,:,:,FDFileNo)

   ENDDO ! IX


   RETURN

END SUBROUTINE Load4DData
!====================================================================================================
FUNCTION FD_GetValue(RVarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the RVarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------

   CHARACTER(*),   INTENT(IN)    :: RVarName
   INTEGER,        INTENT(OUT)   :: ErrStat
   REAL(ReKi)                    :: FD_GetValue

   
   CHARACTER(20)                 :: VarNameUC
   

   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FDWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = RVarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
            
      CASE ('ROTDIAM' )
         FD_GetValue = RotDiam         
         
      CASE DEFAULT
         CALL WrScr( ' Invalid variable name in FD_GetRValue().' )
         ErrStat = 1
         
   END SELECT

END FUNCTION FD_GetValue
!====================================================================================================
FUNCTION FD_GetWindSpeed(Time, InputPosition, ErrStat)
! This function is used to interpolate into the 4D wind arrays.  It receives X, Y, Z and TIME from the 
! calling routine.  The time since the start of the 4D data is used to decide which pair of time slices 
! to interpolate within and between.  After finding the two time slices, it decides which eight grid 
! points bound the (X,Y,Z) pair. It does a trilinear interpolation for each time slice. Linear 
! interpolation is then used to interpolate between time slices.  This routine assumes that X is 
! downwind, Y is to the left when looking downwind and Z is up.  It also assumes that no 
! extrapolation will be needed except in time and the Z direction.  In those cases, the appropriate
! steady winds are used.
!----------------------------------------------------------------------------------------------------

      ! Passed variables:
      
   REAL(ReKi),        INTENT(IN) :: Time                                   ! the time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)                       ! structure that contains the position
   INTEGER,           INTENT(OUT):: ErrStat                                ! returns 0 if no error; non-zero otherwise
   TYPE(InflIntrpOut)            :: FD_GetWindSpeed                        ! the resultant wind speed


      ! Local Variables:

   REAL(ReKi)                 :: Ixhyz                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Ixlyz                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Ixyzo                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Iyhz                                      ! Temporary interpolated value.
   REAL(ReKi)                 :: Iylz                                      ! Temporary interpolated value.
   REAL(ReKi)                 :: Ixyzn                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Tgrid                                     ! Fractional distance between time grids.
   REAL(ReKi)                 :: Xgrid                                     ! Fractional distance between grids in the x direction.
   REAL(ReKi)                 :: Xnorm                                     ! Nondimensional downwind distance of the analysis point from upwind end of dataset.
   REAL(ReKi)                 :: Ygrid                                     ! Fractional distance between grids in the y direction.
   REAL(ReKi)                 :: Ynorm                                     ! Nondimensional lateral distance of the analysis point from right side of dataset (looking downwind).
   REAL(ReKi)                 :: Zgrid                                     ! Fractional distance between grids in the z direction.
   REAL(ReKi)                 :: Zgrid_w                                   ! Fractional distance between grids in the z direction for the w component.
   REAL(ReKi)                 :: Znorm                                     ! Nondimensional vertical distance of the analysis point from bottom of dataset.
   REAL(ReKi)                 :: Znorm_w                                   ! Nondimensional vertical distance of the analysis point from bottom of dataset for the w component.

   INTEGER                    :: IT                                        ! Index for do loop
   INTEGER                    :: IXHI                                      ! Index for the more-positive x value.
   INTEGER                    :: IXLO                                      ! Index for the more-negative x value.
   INTEGER                    :: IYHI                                      ! Index for the more-positive y value.
   INTEGER                    :: IYLO                                      ! Index for the more-negative y value.
   INTEGER                    :: IZHI                                      ! Index for the more-positive z value.
   INTEGER                    :: IZHI_w                                    ! Index for the more-positive z value for the w component.
   INTEGER                    :: IZLO                                      ! Index for the more-negative z value.
   INTEGER                    :: IZLO_w                                    ! Index for the more-negative z value for the w component.

   !-------------------------------------------------------------------------------------------------     
   ! Check that we've initialized everything first
   !-------------------------------------------------------------------------------------------------     
     
   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FDWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE 
      ErrStat = 0   
   END IF      

   !-------------------------------------------------------------------------------------------------     
   ! If the TIME is greater than the time for the last file read, read another set of files until we straddle the current time.
   ! Stick with the last file if we've exhausted the data.
   ! We're assuming here that the simulation time step is smaller than the wind-file time step.
   !-------------------------------------------------------------------------------------------------     

   IF ( Time < PrevTime .AND. Time < FDTime(Ind4Dold) ) THEN  ! bjj: GET THE CORRECT TIME if we're going backward!
     
      !----------------------------------------------------------------------------------------------
      ! Determine the first file needed for this simulation.
      !----------------------------------------------------------------------------------------------
      Ind4Dold  = 1                                                           ! Put the old stuff in the first part of the array.
      Ind4Dnew  = 2                                                           ! Put the new stuff in the second part of the array.
      
      FDFileNo  = Num4Dt
      DO IT=1,Num4Dt
         IF ( Times4D(IT) > Time )  THEN
            FDFileNo = IT - 1
            EXIT
         END IF
      END DO ! IT
         
      !----------------------------------------------------------------------------------------------
      ! Open, read, and close the first set of files.
      !----------------------------------------------------------------------------------------------
      FDTime(Ind4Dold) = Times4D(FDFileNo)                                 ! Set the time for this file.

      IF ( ADVECT ) THEN
         CALL Load4DData(Ind4Dold)     ! load data stored in FDuData, FDvData, and FDwData arrays
      ELSE
         CALL LoadLESData( FDUnit, FDFileNo, Ind4Dold, ErrStat )
      END IF
            
      !----------------------------------------------------------------------------------------------
      ! Open, read, and close the second set of files.
      !----------------------------------------------------------------------------------------------
      FDFileNo  = MIN(FDFileNo + 1, Num4Dt)
      Shft4Dnew = 0
      
      IF ( ADVECT ) THEN
         FDFileNo = MOD(FDFileNo-1,Num4Dt) + 1

         IF (FDFileNo == 1) THEN
            Shft4Dnew = Shft4Dnew + 1

            IF (Ind4DAdv <= NumAdvect) THEN                             ! Ind4DAdv was set in ReadFDP
               IF ( MOD( Shft4Dnew, Num4Dx ) == 0 ) THEN
                  CALL ReadAll4DData(FDUnit, ErrStat)
                  IF ( ErrStat /= 0 ) RETURN
               END IF
            END IF

         ENDIF

         FDTime(Ind4Dnew) = Times4D(FDFileNo) + Shft4Dnew*FDPer         ! Set the time for this file.

         CALL Load4DData( Ind4Dnew )    ! shift the data

      ELSE   
         FDTime(Ind4Dnew) = Times4D(FDFileNo)                                           ! Set the time for this file.
!
         CALL LoadLESData( FDUnit, FDFileNo, Ind4Dnew, ErrStat )
      ENDIF
                     
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Move forward in time
   !-------------------------------------------------------------------------------------------------

   DO WHILE ( Time > FDTime(Ind4Dnew) .AND. ( Time < T_4D_En .OR. ADVECT ) )

      Ind4Dnew         = Ind4Dold                                          ! Reverse array indices (1 or 2).
      Ind4Dold         = 3 - Ind4Dnew
      FDFileNo         = FDFileNo + 1                                      ! Increment file number.


      IF ( ADVECT ) THEN
         FDFileNo = MOD(FDFileNo-1,Num4Dt) + 1

         IF (FDFileNo == 1) THEN
               Shft4Dnew = Shft4Dnew + 1

               IF (Ind4DAdv <= NumAdvect) THEN
                  IF ( MOD( Shft4Dnew, Num4Dx ) == 0 ) THEN
                     CALL ReadAll4DData(FDUnit, ErrStat)
                     IF ( ErrStat /= 0 ) RETURN
                  END IF                  
               ENDIF

         ENDIF

         FDTime(Ind4Dnew) = Times4D(FDFileNo) + Shft4Dnew*FDPer

         CALL Load4DData( Ind4Dnew )  ! shift the data
      ELSE
         FDTime(Ind4Dnew) = Times4D(FDFileNo)

         CALL LoadLESData( FDUnit, FDFileNo, Ind4Dnew, ErrStat )
      ENDIF

   ENDDO


   !.................................................................................................
   ! Find the bounding rows, columns, and planes for the X,Y,Z position.  The near, lower-right  
   ! corner is (1,1,1) when looking downwind. Make sure the lowest possible value is 1.
   !.................................................................................................


   !-------------------------------------------------------------------------------------------------
   ! get values of Time for interpolation. Linear interpolation; Nearest-neighbor extrapolation.
   !-------------------------------------------------------------------------------------------------

      ! Find out fractionally how far we are between grids in time and between grid points in each direction.
      !  Limit values to avoid extrapolation.  We need this for interpolation later on.

   Tgrid = MIN( MAX( ( Time - FDTime(Ind4Dold) )/( FDTime(Ind4Dnew) - FDTime(Ind4Dold) ), 0.0 ), 1.0 )


   !-------------------------------------------------------------------------------------------------
   ! get values of X for interpolation. Grid is periodic in X.
   !-------------------------------------------------------------------------------------------------
   Xnorm = ( Xt + InputPosition(1) )/Xmax

   DO WHILE ( Xnorm < 0.0 )   ! Ensure Xnorm is not negative.  The wave is periodic in x.
      Xnorm = Xnorm + 1.0
   ENDDO

   Xgrid = MIN( MAX( MOD( Xnorm, DelXgrid ), 0.0 ), 1.0 )
   IXLo  = MAX( MOD( INT( Xnorm*Num4DxD1 ) + 1, Num4DxD1 ), 1 )
   IXHi  = MOD( IXLo, Num4DxD ) + 1

   !-------------------------------------------------------------------------------------------------
   ! get values of Y for interpolation. Grid is periodic in Y.
   !-------------------------------------------------------------------------------------------------
   Ynorm = ( Yt + InputPosition(2) )/Ymax

   DO WHILE ( Ynorm < 0.0 )  ! Ensure Ynorm is not negative.  The wave is periodic in y.
      Ynorm = Ynorm + 1.0
   ENDDO

   Ygrid = MIN( MAX( MOD( Ynorm, DelYgrid ), 0.0 ), 1.0 )
   IYLo  = MAX( MOD( INT( Ynorm*Num4DyD1 ) + 1, Num4DyD1 ), 1 )
   IYHi  = MOD( IYLo, Num4DyD ) + 1

   !-------------------------------------------------------------------------------------------------
   ! get values of Z for interpolation.  Linear interpolation; Nearest-neighbor extrapolation.  
   !-------------------------------------------------------------------------------------------------
   Znorm = MIN( MAX( ( Zt + InputPosition(3) - ZRef )/Zmax, 0.0 ), 1.0 ) !bjj: define ZRef

   Zgrid = MIN( MAX( MOD( Znorm, DelZgrid ), 0.0 ), 1.0 )
   IZLo  = MAX( INT( Znorm*Num4DzD1 ) + 1, 1 )

      ! If we are located at the upper end of the z dimension, decrement the index by one and set the grid coordinate to 1.

   IF ( IZLo == Num4DzD )  THEN
      IZLo  = Num4DzD1
      Zgrid = 1.0
   ENDIF
   IZHi = IZLo + 1

      !..............................................................................................
      ! Find the equivalent Znorm (Znorm_w) for the w-component, which may be shifted vertically
      ! by half the original grid spacing.
      !..............................................................................................

   IF ( VertShft ) THEN
      Znorm_w = MAX( Znorm - 0.5*DelZgrid/FD_DF_Z, 0.0 )
   ELSE
      Znorm_w = Znorm
   ENDIF

   Zgrid_w = MIN( MAX( MOD( Znorm_w, DelZgrid ), 0.0 ), 1.0 )
   IZLo_w  = MAX( INT( Znorm_w*Num4DzD1 ) + 1, 1 )

   IF ( IZLo_w == Num4DzD )  THEN
      IZLo_w  = Num4DzD1
      Zgrid_w = 1.0
   ENDIF

   IZHi_w = IZLo_w + 1


   !-------------------------------------------------------------------------------------------------
   ! Interpolate for u component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

   Iylz  = ( FDu(IXLo,IYLo,IZHi,Ind4Dold) - FDu(IXLo,IYLo,IZLo,Ind4Dold) )*Zgrid + FDu(IXLo,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDu(IXLo,IYHi,IZHi,Ind4Dold) - FDu(IXLo,IYHi,IZLo,Ind4Dold) )*Zgrid + FDu(IXLo,IYHi,IZLo,Ind4Dold)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDu(IXHi,IYLo,IZHi,Ind4Dold) - FDu(IXHi,IYLo,IZLo,Ind4Dold) )*Zgrid + FDu(IXHi,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDu(IXHi,IYHi,IZHi,Ind4Dold) - FDu(IXHi,IYHi,IZLo,Ind4Dold) )*Zgrid + FDu(IXHi,IYHi,IZLo,Ind4Dold)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzo = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   Iylz  = ( FDu(IXLo,IYLo,IZHi,Ind4Dnew) - FDu(IXLo,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDu(IXLo,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDu(IXLo,IYHi,IZHi,Ind4Dnew) - FDu(IXLo,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDu(IXLo,IYHi,IZLo,Ind4Dnew)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDu(IXHi,IYLo,IZHi,Ind4Dnew) - FDu(IXHi,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDu(IXHi,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDu(IXHi,IYHi,IZHi,Ind4Dnew) - FDu(IXHi,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDu(IXHi,IYHi,IZLo,Ind4Dnew)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzn = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   FD_GetWindSpeed%Velocity(1) = ( Ixyzn - Ixyzo )*Tgrid + Ixyzo

   !-------------------------------------------------------------------------------------------------
   ! Interpolate for v component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

   Iylz  = ( FDv(IXLo,IYLo,IZHi,Ind4Dold) - FDv(IXLo,IYLo,IZLo,Ind4Dold) )*Zgrid + FDv(IXLo,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDv(IXLo,IYHi,IZHi,Ind4Dold) - FDv(IXLo,IYHi,IZLo,Ind4Dold) )*Zgrid + FDv(IXLo,IYHi,IZLo,Ind4Dold)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDv(IXHi,IYLo,IZHi,Ind4Dold) - FDv(IXHi,IYLo,IZLo,Ind4Dold) )*Zgrid + FDv(IXHi,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDv(IXHi,IYHi,IZHi,Ind4Dold) - FDv(IXHi,IYHi,IZLo,Ind4Dold) )*Zgrid + FDv(IXHi,IYHi,IZLo,Ind4Dold)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzo = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   Iylz  = ( FDv(IXLo,IYLo,IZHi,Ind4Dnew) - FDv(IXLo,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDv(IXLo,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDv(IXLo,IYHi,IZHi,Ind4Dnew) - FDv(IXLo,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDv(IXLo,IYHi,IZLo,Ind4Dnew)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDv(IXHi,IYLo,IZHi,Ind4Dnew) - FDv(IXHi,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDv(IXHi,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDv(IXHi,IYHi,IZHi,Ind4Dnew) - FDv(IXHi,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDv(IXHi,IYHi,IZLo,Ind4Dnew)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzn = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   FD_GetWindSpeed%Velocity(2) = ( Ixyzn - Ixyzo )*Tgrid + Ixyzo

   !-------------------------------------------------------------------------------------------------
   ! Interpolate for w component of wind within the grid.
   !-------------------------------------------------------------------------------------------------
   !bjj: should Zgrid actually be Zgrid_w here?  I changed it so that it's consistent
   
   Iylz  = ( FDw(IXLo,IYLo,IZHi_w,Ind4Dold) - FDw(IXLo,IYLo,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXLo,IYLo,IZLo_w,Ind4Dold)
   Iyhz  = ( FDw(IXLo,IYHi,IZHi_w,Ind4Dold) - FDw(IXLo,IYHi,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXLo,IYHi,IZLo_w,Ind4Dold)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDw(IXHi,IYLo,IZHi_w,Ind4Dold) - FDw(IXHi,IYLo,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXHi,IYLo,IZLo_w,Ind4Dold)
   Iyhz  = ( FDw(IXHi,IYHi,IZHi_w,Ind4Dold) - FDw(IXHi,IYHi,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXHi,IYHi,IZLo_w,Ind4Dold)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzo = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   Iylz  = ( FDw(IXLo,IYLo,IZHi_w,Ind4Dnew) - FDw(IXLo,IYLo,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXLo,IYLo,IZLo_w,Ind4Dnew)
   Iyhz  = ( FDw(IXLo,IYHi,IZHi_w,Ind4Dnew) - FDw(IXLo,IYHi,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXLo,IYHi,IZLo_w,Ind4Dnew)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDw(IXHi,IYLo,IZHi_w,Ind4Dnew) - FDw(IXHi,IYLo,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXHi,IYLo,IZLo_w,Ind4Dnew)
   Iyhz  = ( FDw(IXHi,IYHi,IZHi_w,Ind4Dnew) - FDw(IXHi,IYHi,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXHi,IYHi,IZLo_w,Ind4Dnew)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzn = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   FD_GetWindSpeed%Velocity(3) = ( Ixyzn - Ixyzo )*Tgrid + Ixyzo


   !-------------------------------------------------------------------------------------------------
   ! Set the previous time here to compare with later...
   !-------------------------------------------------------------------------------------------------
   PrevTime = Time

   RETURN
   
END FUNCTION FD_GetWindSpeed
!====================================================================================================
SUBROUTINE FD_Terminate( ErrStat )
! This subroutine deallocates arrays, closes files, and un-sets the initialization flag.
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise


   CLOSE( FDunit )

   ErrStat = 0

   IF ( ALLOCATED( FDu       ) )   DEALLOCATE( FDu,       STAT=ErrStat )
   IF ( ALLOCATED( FDv       ) )   DEALLOCATE( FDv,       STAT=ErrStat )
   IF ( ALLOCATED( FDw       ) )   DEALLOCATE( FDw,       STAT=ErrStat )
   IF ( ALLOCATED( FDuData   ) )   DEALLOCATE( FDuData,   STAT=ErrStat )  
   IF ( ALLOCATED( FDvData   ) )   DEALLOCATE( FDvData,   STAT=ErrStat )
   IF ( ALLOCATED( FDwData   ) )   DEALLOCATE( FDwData,   STAT=ErrStat )
   IF ( ALLOCATED( Times4D   ) )   DEALLOCATE( Times4D,   STAT=ErrStat )
   IF ( ALLOCATED( Times4DIx ) )   DEALLOCATE( Times4DIx, STAT=ErrStat )
   IF ( ALLOCATED( AdvFiles  ) )   DEALLOCATE( AdvFiles,  STAT=ErrStat )

   Initialized = .FALSE.

END SUBROUTINE FD_Terminate
!====================================================================================================
END MODULE FDWind
MODULE FFWind
!
!  This module uses full-field binary wind files to determine the wind inflow.
!  This module assumes that the origin, (0,0,0), is located at the tower centerline at ground level,
!  and that all units are specified in the metric system (using meters and seconds).
!  Data is shifted by half the grid width to account for turbine yaw (so that data in the X 
!  direction actually starts at -1*FFYHWid meters).
!
!  Created 25-Sept-2009 by B. Jonkman, National Renewable Energy Laboratory
!     using subroutines and modules from AeroDyn v12.58
!
!----------------------------------------------------------------------------------------------------

   USE      NWTC_Library
   USE      SharedInflowDefns

   IMPLICIT NONE

   PRIVATE                                                        ! By default, everything in FFWind is private (methods, data, types, etc.)
   
      ! former FF_Wind module
      
   REAL(ReKi), ALLOCATABLE          :: FFData  (:,:,:,:)          ! Array of FF data
   REAL(ReKi), ALLOCATABLE          :: FFtower (:,:,:)            ! Array of data along the tower, below the FF array

   REAL(ReKi)                       :: FFDTime                    ! delta time
   REAL(ReKi)                       :: FFRate                     ! data rate in Hz (1/FFDTime)
   REAL(ReKi)                       :: FFYHWid                    ! half the grid width
   REAL(ReKi)                       :: FFZHWid                    ! half the grid height
   REAL(ReKi)                       :: RefHt                      ! the reference (hub) height of the grid in meters 
   REAL(ReKi)                       :: GridBase                   ! the height of the bottom of the grid in meters
   REAL(ReKi)                       :: InitXPosition              ! the initial x location of the wind file (distance the FF file will be offset)
   REAL(ReKi)                       :: InvFFYD                    ! reciprocal of delta y
   REAL(ReKi)                       :: InvFFZD                    ! reciprocal of delta z
   REAL(ReKi)                       :: InvMFFWS                   ! reciprocal of the mean wind speed (MeanFFWS)
   REAL(ReKi)                       :: MeanFFWS                   ! the mean wind speed (as defined in the FF file), not necessarially the mean of the portion of the wind used
   REAL(ReKi)                       :: TotalTime                  ! the total time in the simulation

   INTEGER                          :: NFFComp                    ! number of wind components
   INTEGER                          :: NFFSteps                   ! number of time steps in the FF array
   INTEGER                          :: NYGrids                    ! number of points in the lateral (y) direction of the grids
   INTEGER                          :: NZGrids                    ! number of points in the vertical (z) direction of the grids
   INTEGER                          :: NTGrids                    ! number of points in the vertical (z) direction on the tower (below the grids)
         
   LOGICAL, SAVE                    :: Initialized = .FALSE.      ! flag that determines if the module has been initialized
   LOGICAL                          :: Periodic    = .FALSE.      ! flag that determines if the wind is periodic


   INTERFACE FF_GetValue
      MODULE PROCEDURE FF_GetRValue                               ! routine to return scalar real values 
   END INTERFACE


   PUBLIC                           :: FF_Init                    ! initialization subroutine to read the FF grids
   PUBLIC                           :: FF_GetWindSpeed            ! interpolation function that returns velocities at specified time and space
   PUBLIC                           :: FF_GetValue                ! interface to return requested values
   PUBLIC                           :: FF_Terminate               ! subroutine that deallocates memory stored in the FFWind module

CONTAINS
!====================================================================================================
SUBROUTINE FF_Init ( UnWind, BinFile, ErrStat )
!  This routine is used read the full-field turbulence data.
!  09/25/97 - Created by M. Buhl from GETFILES in ViewWind.
!  09/23/09 - modified by B. Jonkman: this subroutine was split into several subroutines (was ReadFF)
!----------------------------------------------------------------------------------------------------

   IMPLICIT                       NONE


      ! Passed Variables:
      
   INTEGER,      INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered
   
   CHARACTER(*), INTENT(IN)    :: BinFile                      ! Name of the binary FF wind file

      ! Local Variables:

   REAL(ReKi)                  :: TI      (3)                  ! turbulence intensities of the wind components as defined in the FF file, not necessarially the actual TI
   REAL(ReKi)                  :: BinTI   (3)                  ! turbulence intensities of the wind components as defined in the FF binary file, not necessarially the actual TI
   REAL(ReKi)                  :: UBar
   REAL(ReKi)                  :: ZCenter
   
   INTEGER(B2Ki)               :: Dum_Int2
   INTEGER                     :: DumInt
   INTEGER                     :: I
   LOGICAL                     :: CWise
   LOGICAL                     :: Exists
   CHARACTER( 1028 )           :: SumFile                      ! length is LEN(BinFile) + the 4-character extension.
   CHARACTER( 1028 )           :: TwrFile                      ! length is LEN(BinFile) + the 4-character extension.


      !----------------------------------------------------------------------------------------------
      ! Check that the module hasn't already been initialized.
      !----------------------------------------------------------------------------------------------   
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' FFWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF   


      !----------------------------------------------------------------------------------------------
      ! Open the binary file, read its "header" (first 2-byte integer) to determine what format
      ! binary file it is, and close it.
      !----------------------------------------------------------------------------------------------

   CALL OpenBInpFile (UnWind, TRIM(BinFile), ErrStat)
   IF (ErrStat /= 0) RETURN
      
   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2
   CLOSE( UnWind )
   
   IF (ErrStat /= 0) THEN
      CALL WrScr( ' Error reading first binary integer from file "'//TRIM(BinFile)//'."' )
      RETURN
   END IF
   
      !----------------------------------------------------------------------------------------------
      ! Read the files to get the required FF data.
      !----------------------------------------------------------------------------------------------   
   DumInt = Dum_Int2  ! change to default INTEGER, instead of INT(2) to compare in SELECT below
    
   SELECT CASE (DumInt)  
   
      CASE ( 7, 8 )                                                    ! TurbSim binary format
         
         CALL Read_TurbSim_FF(UnWind, TRIM(BinFile), ErrStat)
         
      CASE ( -1, -2, -3, -99 )                                         ! Bladed-style binary format
      
         !...........................................................................................
         ! Create full-field summary file name from binary file root name.  Also get tower file
         ! name.
         !...........................................................................................

            CALL GetRoot(BinFile, SumFile)
            
            TwrFile = TRIM(SumFile)//'.twr'
            SumFile = TRIM(SumFile)//'.sum'
      
         !...........................................................................................
         ! Read the summary file to get necessary scaling information
         !...........................................................................................
   
            CALL Read_Summary_FF (UnWind, TRIM(SumFile), CWise, ZCenter, TI, ErrStat ) 
            IF (ErrStat /= 0) RETURN
            
            UBar = MeanFFWS      ! temporary storage .... this is our only check to see if the summary and binary files "match"

         !...........................................................................................
         ! Open the binary file and read its header
         !...........................................................................................
         
            CALL OpenBInpFile (UnWind, TRIM(BinFile), ErrStat)

            IF (ErrStat /= 0) RETURN

            IF ( Dum_Int2 == -99 ) THEN                                       ! Newer-style BLADED format
               CALL Read_Bladed_FF_Header1 (UnWind, BinTI, ErrStat)    
               
                  ! If the TIs are also in the binary file (BinTI > 0), 
                  ! use those numbers instead of ones from the summary file
                  
               DO I =1,NFFComp                  
                  IF ( BinTI(I) > 0 ) TI(I) = BinTI(I)
               END DO
               
            ELSE
               CALL Read_Bladed_FF_Header0 (UnWind, ErrStat)                  ! Older-style BLADED format
            END IF

            IF (ErrStat /= 0) RETURN

         !...........................................................................................
         ! Let's see if the summary and binary FF wind files go together before continuing.
         !...........................................................................................
               
            IF ( ABS( UBar - MeanFFWS ) > 0.1 )  THEN
               CALL WrScr( ' Error: Incompatible mean hub-height wind speeds in FF wind files. '//&
                           '(Check that the .sum and .wnd files were generated together.)' )
               ErrStat = 1
               RETURN
            ENDIF

         !...........................................................................................
         ! Calculate the height of the bottom of the grid
         !...........................................................................................

            GridBase = ZCenter - FFZHWid         ! the location, in meters, of the bottom of the grid

         !...........................................................................................
         ! Read the binary grids (converted to m/s) and close the file
         !...........................................................................................

            CALL Read_Bladed_Grids( UnWind, CWise, TI, ErrStat) 
            CLOSE ( UnWind )
                           
            IF ( ErrStat /= 0 ) RETURN
   
         !...........................................................................................
         ! Read the tower points file
         !...........................................................................................
   
            INQUIRE ( FILE=TRIM(TwrFile) , EXIST=Exists )

            IF (  Exists )  THEN  
               CALL Read_FF_Tower( UnWind, TRIM(TwrFile), ErrStat  )
            ELSE
               NTgrids = 0            
            END IF                        

                               
      CASE DEFAULT
         
         CALL WrScr( ' Error: Unrecognized binary wind file type.' )
         ErrStat = 1
         RETURN
                  
   END SELECT


   IF (Periodic) THEN
      InitXPosition = 0                ! start at the hub
      TotalTime     = NFFSteps*FFDTime
   ELSE
      InitXPosition = FFYHWid          ! start half the grid with ahead of the turbine
      TotalTime     = (NFFSteps-1)*FFDTime      
   END IF
      
   Initialized = .TRUE.
   
   RETURN
   
END SUBROUTINE FF_Init
!====================================================================================================
SUBROUTINE Read_Bladed_FF_Header0 (UnWind, ErrStat)
!   Reads the binary headers from the turbulence files of the old Bladed variety.  Note that
!   because of the normalization, neither NZGrids or NYGrids are larger than 32 points.
!   21-Sep-2009 - B. Jonkman, NREL/NWTC.
!----------------------------------------------------------------------------------------------------


   IMPLICIT                      NONE


      ! Passed Variables:
      
   INTEGER,   INTENT(IN)      :: UnWind
   INTEGER,   INTENT(OUT)     :: ErrStat

      ! Local Variables:

   REAL(ReKi)                 :: FFXDelt
   REAL(ReKi)                 :: FFYDelt
   REAL(ReKi)                 :: FFZDelt

   INTEGER(B2Ki)              :: Dum_Int2

   INTEGER                    :: I

   !-------------------------------------------------------------------------------------------------
   ! Read the header (file has just been opened)
   !-------------------------------------------------------------------------------------------------

   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! -NFFC (file ID)

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading number of wind components from binary FF file.' )
         RETURN
      END IF
      NFFComp = -1*Dum_Int2
         

   READ (UnWind, IOSTAT=ErrStat) Dum_Int2                                                    ! delta z (mm)
    
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dz from binary FF file.' )
         RETURN
      END IF
      FFZDelt = 0.001*Dum_Int2
      InvFFZD = 1.0/FFZDelt


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! delta y (mm)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dy from binary FF file.' )
         RETURN
      END IF
      FFYDelt = 0.001*Dum_Int2
      InvFFYD = 1.0/FFYDelt


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! delta x (mm)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dx from binary FF file.' )
         RETURN
      END IF
      FFXDelt = 0.001*Dum_Int2


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! half the number of time steps
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading number of time steps from binary FF file.' )
         RETURN
      END IF
      NFFSteps = 2*Dum_Int2


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! 10 times the mean full-field wind speed
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading mean full-field wind speed from binary FF file.' )
         RETURN
      END IF
      MeanFFWS = 0.1*Dum_Int2
      InvMFFWS = 1.0/MeanFFWS
      FFDTime  = FFXDelt/MeanFFWS
      FFRate   = 1.0/FFDTime

      
   DO I = 1,5   
   
      READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                ! unused variables: zLu, yLu, xLu, dummy, random seed

         IF (ErrStat /= 0) THEN
            CALL WrScr( ' Error reading 2-byte integers from binary FF file.' )
            RETURN
         END IF
         
   END DO


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! 1000*nz

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading nz from binary FF file.' )
         RETURN
      END IF
      NZGrids  = Dum_Int2/1000
      FFZHWid  = 0.5*FFZDelt*( NZGrids - 1 )    ! half the vertical size of the grid


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! 1000*ny
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading ny from binary FF file.' )
         RETURN
      END IF   
      NYGrids  = Dum_Int2/1000
      FFYHWid  = 0.5*FFYDelt*( NYGrids - 1 )


   IF (NFFComp == 3) THEN
   
      DO I=1,6
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                             ! unused variables: zLv, yLv, xLv, zLw, yLw, xLw
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 2-byte length scales from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I
      
   END IF !NFFComp


   RETURN
   
END SUBROUTINE Read_Bladed_FF_Header0
!====================================================================================================
SUBROUTINE Read_Bladed_FF_Header1 (UnWind, TI, ErrStat)
!   Reads the binary headers from the turbulence files of the new Bladed variety.
!   16-May-2002 - Windward Engineering.
!   21-Sep-2009 - B. Jonkman, NREL.  updated to trap errors and add extra parameters for MANN model
!----------------------------------------------------------------------------------------------------


   IMPLICIT                      NONE


      ! Passed Variables:
      
   INTEGER,   INTENT(IN)      :: UnWind
   REAL(ReKi), INTENT(OUT)    :: TI(3)
   INTEGER,   INTENT(OUT)     :: ErrStat

      ! Local Variables:

   REAL(ReKi)                 :: FFXDelt
   REAL(ReKi)                 :: FFYDelt
   REAL(ReKi)                 :: FFZDelt

   REAL(SiKi)                 :: Dum_Real4
   INTEGER(B2Ki)              :: Dum_Int2
   INTEGER(B4Ki)              :: Dum_Int4

   INTEGER                    :: I
   INTEGER                    :: TurbType


   TI(:) = -1                                                                                !Initialize to -1 (not all models contain TI)

   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! -99 (file ID)

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading integer from binary FF file.' )
         RETURN
      END IF

   
   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! turbulence type

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading turbulence type from binary FF file.' )
         RETURN
      END IF
      TurbType = Dum_Int2


   SELECT CASE (TurbType)
      CASE(1, 2) 
         !----------------------------------------
         !1-component Von Karman (1) or Kaimal (2)
         !----------------------------------------
            NFFComp = 1
                  
      CASE(3, 5) 
         !----------------------------------------
         !3-component Von Karman (3) or IEC-2 
         ! Kaimal (5)
         !----------------------------------------
            NFFComp = 3
         
      CASE(4) 
         !----------------------------------------
         !improved Von Karman
         !----------------------------------------
      
            READ (UnWind, IOSTAT=ErrStat) Dum_Int4                                           ! number of components (should be 3)
            
               IF (ErrStat /= 0) THEN           
                  CALL WrScr( ' Error reading number of components from binary FF file.' )
                  RETURN
               END IF
               NFFComp = Dum_Int4
            
            READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                          ! Latitude (deg)
            
               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading latitude from binary FF file.' )  
                  RETURN
               END IF

            READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                          ! Roughness length (m)

               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading roughness length from binary FF file.' )
                  RETURN
               END IF
            
            READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                          ! Reference height (m) = Z(1) + GridHeight / 2.0

               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading reference height from binary FF file.' )
                  RETURN
               END IF
            
            
            DO I = 1,3
               READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                       ! TI(u, v, w) (%)
               
                  IF (ErrStat /= 0) THEN
                     CALL WrScr( ' Error reading TI('//'TRIM(Num2LStr(I))'//') from binary FF file.' )
                     RETURN
                  END IF
                  TI(I) = Dum_Real4                                                          ! This overwrites the TI read in the summary file
                  
            END DO !I            
                             
                  
      CASE (7, 8)
         !----------------------------------------
         ! General Kaimal (7) or  Mann model (8)
         !----------------------------------------
      
            READ (UnWind, IOSTAT=ErrStat) Dum_Int4                                           ! number of bytes in header
            
               IF (ErrStat /= 0) THEN           
                  CALL WrScr( ' Error reading number of header records from binary FF file.' )
                  RETURN
               END IF

            READ (UnWind, IOSTAT=ErrStat) Dum_Int4                                           ! number of components
            
               IF (ErrStat /= 0) THEN           
                  CALL WrScr( ' Error reading number of data from binary FF file.' )
                  RETURN
               END IF
               NFFComp = Dum_Int4

                                  
      CASE DEFAULT
      
         CALL ProgWarn( ' AeroDyn does not recognize the full-field turbulence file type ='//TRIM(Num2LStr(TurbType))//'.' )
                  
   END SELECT !TurbType


   READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                                   ! delta z (m)
    
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dz from binary FF file.' )
         RETURN
      END IF
      FFZDelt = Dum_Real4
      InvFFZD = 1.0/FFZDelt


   READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                                  ! delta y (m)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dy from binary FF file.' )
         RETURN
      END IF
      FFYDelt = Dum_Real4
      InvFFYD = 1.0/FFYDelt

   READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                                  ! delta x (m)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dx from binary FF file.' )
         RETURN
      END IF
      FFXDelt = Dum_Real4


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                   ! half the number of time steps
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading number of time steps from binary FF file.' )
         RETURN
      END IF
      NFFSteps = 2*Dum_Int4


   READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                                  ! mean full-field wind speed
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading mean full-field wind speed from binary FF file.' )
         RETURN
      END IF
      MeanFFWS = Dum_Real4
      InvMFFWS = 1.0/MeanFFWS
      FFDTime  = FFXDelt/MeanFFWS
      FFRate   = 1.0/FFDTime

      
   DO I = 1,3   
   
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                               ! unused variables: zLu, yLu, xLu

         IF (ErrStat /= 0) THEN
            CALL WrScr( ' Error reading 4-byte length scales from binary FF file.' )
            RETURN
         END IF
         
   END DO
   
   
   DO I = 1,2
   
      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                ! unused variables: dummy, random seed
      
         IF (ErrStat /= 0) THEN
            CALL WrScr( ' Error reading 4-byte integers from binary FF file.' )
            RETURN
         END IF
         
   END DO


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                   ! nz

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading nz from binary FF file.' )
         RETURN
      END IF
      NZGrids  = Dum_Int4
      FFZHWid  = 0.5*FFZDelt*( NZGrids - 1 )    ! half the vertical size of the grid


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                   ! ny
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading ny from binary FF file.' )
         RETURN
      END IF   
      NYGrids  = Dum_Int4
      FFYHWid  = 0.5*FFYDelt*( NYGrids - 1 )


   IF (NFFComp == 3) THEN
   
      DO I=1,6
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables: zLv, yLv, xLv, zLw, yLw, xLw
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte length scales from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I
      
   END IF !NFFComp



   IF ( TurbType == 7 ) THEN     ! General Kaimal model
   
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variable: coherence decay constant
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading coherence decay constant from binary FF file.' )
               RETURN
            END IF

         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables: coherence scale parameter in m
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading coherence scale parameter from binary FF file.' )
               RETURN
            END IF
         
   ELSE IF ( TurbType == 8 ) THEN     ! Mann model
      
      DO I=1,2
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables: shear parameter (gamma), scale length
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,4
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,3
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,2
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,3
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,2
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I


   END IF !TurbType


   RETURN
   
END SUBROUTINE Read_Bladed_FF_Header1
!====================================================================================================
SUBROUTINE Read_Bladed_Grids ( UnWind, CWise, TI, ErrStat )
! This subroutine continues reading UnWind, starting after the headers have been read.
! It reads the grids and converts the data to un-normalized wind speeds in m/s.
!----------------------------------------------------------------------------------------------------

   INTEGER,     INTENT(IN)    :: UnWind
   LOGICAL,     INTENT(IN)    :: CWise
   REAL(ReKi),  INTENT(IN)    :: TI      (3)                  ! turbulence intensities of the wind components as defined in the FF file, not necessarially the actual TI
   INTEGER,     INTENT(OUT)   :: ErrStat

   REAL(ReKi), PARAMETER      :: FF_Offset(3) = (/ 1.0, 0.0, 0.0 /)  ! used for "un-normalizing" the data

   INTEGER                    :: CFirst
   INTEGER                    :: CLast
   INTEGER                    :: CStep
   INTEGER(B2Ki)              :: Dum_Int2
   INTEGER                    :: I
   INTEGER                    :: IC
   INTEGER                    :: IR
   INTEGER                    :: IT
   
   INTEGER                    :: TmpNumSteps


   !-------------------------------------------------------------------------------------------------
   ! Generate an informative message.
   !-------------------------------------------------------------------------------------------------
      
   CALL WrScr1( ' Reading a '//TRIM( Num2LStr(NYGrids) )//'x'//TRIM( Num2LStr(NZGrids) )//  &
            ' grid ('//TRIM( Num2LStr(FFYHWid*2) )//' m wide, '// &
            TRIM( Num2LStr(GridBase) )//' m to '//TRIM( Num2LStr(GridBase+FFZHWid*2) )//&
            ' m above ground) with a characterstic wind speed of '//TRIM( Num2LStr(MeanFFWS) )//' m/s. ' )

   !-------------------------------------------------------------------------------------------------
   ! Allocate space for the FF array 
   !-------------------------------------------------------------------------------------------------

   TmpNumSteps = NFFSteps + 1       ! add another step, just in case there is an odd number of steps.

!bjj: should we reorganize this FFData array so we access the data faster?
   
   IF ( .NOT. ALLOCATED( FFData ) ) THEN
      ALLOCATE ( FFData(NZGrids,NYGrids,NFFComp,TmpNumSteps),STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Cannot allocate the full-field wind data array.' )
         RETURN

      ENDIF
      
   ELSE
      IF (SIZE(FFDATA,1) /= NZGrids .OR. SIZE(FFDATA,2) /= NYGrids .OR. &
          SIZE(FFDATA,3) /= NFFComp .OR. SIZE(FFDATA,3) /= TmpNumSteps ) THEN
          
            ! Let's make the array the correct size (we should never get here, but you never know)
            
         DEALLOCATE( FFData )
          
         ALLOCATE ( FFData(NZGrids,NYGrids,NFFComp,TmpNumSteps),STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN

            CALL WrScr( ' Cannot allocate the full-field wind data array.' )
            RETURN

         END IF ! Error
          
      END IF !Incorrect size
   END IF ! allocated

   !-------------------------------------------------------------------------------------------------
   ! Initialize the data and set column indexing to account for direction of turbine rotation (CWise)
   !-------------------------------------------------------------------------------------------------
   
   FFData(:,:,:,:) = 0.0                        ! we may have only one component
   
   IF ( CWise )  THEN
      CFirst    = NYGrids
      CLast     = 1
      CStep     = -1
   ELSE
      CFirst    = 1
      CLast     = NYGrids
      CStep     = 1
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Loop through all the time steps, reading the data and converting to m/s
   !-------------------------------------------------------------------------------------------------
!bjj: should we reorganize this FFData array so we access the data faster?
  
   NFFSteps = TmpNumSteps
  
TIME_LOOP:  DO IT=1,TmpNumSteps     ! time (add 1 to see if there is an odd number of grids)
   
      DO IR=1,NZGrids               ! the rows (vertical)
      
         DO IC=CFirst,CLast,CStep   ! the columns (lateral)
         
            DO I=1,NFFComp          ! wind components (U, V, W)
            
               READ (UnWind,IOStat=ErrStat)  Dum_Int2
               IF (ErrStat /= 0) THEN
                  IF ( IT == TmpNumSteps ) THEN ! There really were an even number of steps
                     NFFSteps = TmpNumSteps - 1
                     ErrStat  = 0
                     EXIT TIME_LOOP       
                  ELSE               
                     CALL WrScr( ' Error reading binary data file. ic = '//TRIM(Num2LStr(ic))// &
                                    ', ir = '//TRIM(Num2LStr(ir))//', it = '//TRIM(Num2LStr(it))// &
                                    ', nffsteps = '//TRIM(Num2LStr(nffsteps)) )
                     ErrStat = 1
                     RETURN
                  END IF
               ELSE               
                  FFData(IR,IC,I,IT) = MeanFFWS*(FF_Offset(I)+0.00001*TI(I)*Dum_Int2) 
               END IF
               
            END DO !I

         END DO !IC

      END DO !IR

   END DO TIME_LOOP !IT
   
   IF ( Periodic ) THEN
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data (period of '//TRIM( Num2LStr( FFDTime*NFFSteps ) )//' seconds).' )
   ELSE                     
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data ('//TRIM( Num2LStr( FFDTime*( NFFSteps - 1 ) ) )//' seconds).' )
   END IF

END SUBROUTINE Read_Bladed_Grids
!====================================================================================================
SUBROUTINE Read_Summary_FF ( UnWind, FileName, CWise, ZCenter, TI, ErrStat )
! This subroutine reads the text summary file to get normalizing parameters, the location of the
! grid, and the direction the grid was written to the binary file
!----------------------------------------------------------------------------------------------------

   INTEGER,     INTENT(IN)    :: UnWind         ! unit number for the file to open
   CHARACTER(*),INTENT(IN)    :: FileName       ! name of the summary file
   LOGICAL,     INTENT(OUT)   :: CWise          ! rotation (for reading the order of the binary data)
   REAL(ReKi),  INTENT(OUT)   :: ZCenter        ! the height at the center of the grid
   REAL(ReKi),  INTENT(OUT)   :: TI      (3)    ! turbulence intensities of the wind components as defined in the FF file, not necessarially the actual TI
   INTEGER,     INTENT(OUT)   :: ErrStat        ! returns 0 if no error encountered in the subroutine
   
   REAL(ReKi)                 :: ZGOffset       ! The vertical offset of the turbine on rectangular grid (allows turbulence not centered on turbine hub)

   
   INTEGER, PARAMETER         :: NumStrings = 6 ! number of strings to be looking for in the file

   INTEGER                    :: FirstIndx      ! The first character of a line where data is located
   INTEGER                    :: I              ! A loop counter
   INTEGER                    :: LastIndx       ! The last  character of a line where data is located
   INTEGER                    :: LineCount      ! Number of lines that have been read in the file
   INTEGER                    :: Status         ! Status from I/O calls
   
   LOGICAL                    :: StrNeeded(NumStrings)   ! if the string has been found
   
   CHARACTER(1024)            :: LINE           ! temporary storage for reading a line from the file
   
      !----------------------------------------------------------------------------------------------
      ! Initialize some variables
      !----------------------------------------------------------------------------------------------

   ErrStat      = 0
   LineCount    = 0
   StrNeeded(:) = .TRUE.
   ZGOffset     = 0.0
   RefHt        = 0.0
   Periodic     = .FALSE.
   
      !----------------------------------------------------------------------------------------------
      ! Open summary file.
      !----------------------------------------------------------------------------------------------
      
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat) 


      !----------------------------------------------------------------------------------------------
      ! Read the summary file.
      !----------------------------------------------------------------------------------------------

   DO WHILE ( ( ErrStat == 0 ) .AND. StrNeeded(NumStrings) )

      LineCount = LineCount + 1

      READ ( UnWind, '(A)', IOSTAT=ErrStat ) LINE
      IF ( ErrStat /= 0 ) THEN
      
         IF ( StrNeeded(NumStrings-1) ) THEN  ! the "HEIGHT OFFSET" StrNeeded(NumStrings) parameter is not necessary.  We'll assume it's zero if we didn't find it.
            CALL WrScr( ' Error reading line #'//TRIM(Num2LStr(LineCount))//' of the summary file, "'//TRIM(FileName)//'"' )
            CALL WrScr( 'Could not find all of the required parameters.' )
            ErrStat = NumStrings+1
            RETURN
         ELSE           
            EXIT
         ENDIF
         
      END IF
      
      CALL Conv2UC ( LINE )
            

      IF ( StrNeeded(1) ) THEN
      
         !-------------------------------------------------------------------------------------------
         ! #1: Get the rotation direction, using the string "CLOCKWISE" 
         !-------------------------------------------------------------------------------------------
            
         IF ( INDEX( LINE, 'CLOCKWISE' ) > 0 ) THEN
            
            READ (LINE, *, IOSTAT = Status)  CWise          ! Look for True/False values

            IF ( Status /= 0 ) THEN                         ! Look for Yes/No values instead

               LINE = ADJUSTL ( LINE )                      ! Remove leading spaces from input line

               SELECT CASE (LINE(1:1) )
                  CASE ('Y')
                     CWise = .TRUE.
                  CASE ('N')
                     CWise = .FALSE.
                  CASE DEFAULT                  
                     CALL WrScr( ' Error reading rotation direction (CLOCKWISE) from FF summary file.' )
                     ErrStat = 1
                     RETURN
               END SELECT
               
            END IF ! Status /= 0
            StrNeeded(1) = .FALSE.
            
         END IF   ! INDEX for "CLOCKWISE"
         
      ELSEIF ( StrNeeded(2) ) THEN
      
         !-------------------------------------------------------------------------------------------
         ! #2: Get the hub height, using the strings "HUB HEIGHT" or "ZHUB"
         !-------------------------------------------------------------------------------------------

         IF ( INDEX( LINE, 'HUB HEIGHT' ) > 0 .OR. INDEX( LINE, 'ZHUB' ) > 0 ) THEN
         
            READ (LINE, *, IOSTAT = Status) RefHt
         
            IF ( Status /= 0 ) THEN
               CALL WrScr( ' Error reading hub height from FF summary file.' )
               ErrStat = 2
               RETURN
            END IF ! Status /= 0
            StrNeeded(2) = .FALSE.
                  
         END IF !INDEX for "HUB HEIGHT" or "ZHUB"
         
         
!      ELSEIF ( StrNeeded(3) ) THEN
!
!         !-------------------------------------------------------------------------------------------
!         ! #3: Get the grid width (& height, if available), using the strings "GRID WIDTH" or "RDIAM"
!         !    If GRID HEIGHT is specified, use it, too. -- THIS IS UNNECESSARY AS IT'S STORED IN THE BINARY FILE
!         !-------------------------------------------------------------------------------------------         

      ELSEIF ( StrNeeded(4) ) THEN
      
         !-------------------------------------------------------------------------------------------
         ! #4: Get the mean wind speed "UBAR" and turbulence intensities from following lines for 
         !     scaling Bladed-style FF binary files
         !-------------------------------------------------------------------------------------------         

         IF ( INDEX( LINE, 'UBAR') > 0 ) THEN

            FirstIndx = INDEX( LINE, '=' ) + 1        ! Look for the equal siqn to find the number we're looking for

            READ ( LINE( FirstIndx:LEN(LINE) ), *, IOSTAT=Status ) MeanFFWS

            IF ( Status /= 0 ) THEN
               CALL WrScr( ' Error reading UBar binary data normalizing parameter from FF summary file.' )
               ErrStat = 4
               RETURN
            END IF ! Status /= 0      

            DO I = 1,3

               LineCount = LineCount + 1

               READ ( UnWind, '(A)', IOSTAT=Status ) LINE
               IF ( Status /= 0 ) THEN
                  CALL WrScr( ' Error reading line #'//TRIM(Num2LStr(LineCount))//' of the summary file, "'//TRIM(FileName)//'"' )
                  CALL WrScr( 'Could not find all of the required parameters.' )
                  ErrStat = Status
                  RETURN
               END IF

               FirstIndx = INDEX( LINE, '=' ) + 1     ! Read the number between the = and % signs
               LastIndx  = INDEX( LINE, '%' ) - 1

               IF ( LastIndx <= FirstIndx ) LastIndx = LEN( LINE )   ! If there's no % sign, read to the end of the line

               READ ( LINE( FirstIndx:LastIndx ), *, IOSTAT=Status ) TI(I)
               IF ( Status /= 0 ) THEN
                  CALL WrScr( ' Error reading TI('//TRIM(Num2LStr(I))//') binary data normalizing parameter from FF summary file.' )
                  ErrStat = 4
                  RETURN
               END IF ! Status /= 0      

            END DO !I

            StrNeeded(4) = .FALSE.            

          END IF
      
      ELSEIF ( StrNeeded(5) ) THEN
         
         !-------------------------------------------------------------------------------------------
         ! #5: Get the grid "HEIGHT OFFSET", if it exists (in TurbSim). Otherwise, assume it's zero 
         !           ZGOffset = HH - GridBase - FFZHWid
         !-------------------------------------------------------------------------------------------         
         IF ( INDEX( LINE, 'HEIGHT OFFSET' ) > 0  ) THEN
         
            FirstIndx = INDEX ( LINE, '=' ) + 1

            READ ( LINE( FirstIndx:LEN(LINE) ), *, IOSTAT=Status ) ZGOffset            
                  
            IF ( Status /= 0 ) THEN
               CALL WrScr( ' Error reading height offset from FF summary file.' )
               ErrStat = 5
               RETURN
            END IF ! Status /= 0
                  
            StrNeeded(5) = .FALSE.
            
         END IF !INDEX for "HEIGHT OFFSET"

      ELSEIF ( StrNeeded(6) ) THEN
         
         !-------------------------------------------------------------------------------------------
         ! #5: Get the grid "PERIODIC", if it exists (in TurbSim). Otherwise, assume it's  
         !        not a periodic file
         !-------------------------------------------------------------------------------------------         
         IF ( INDEX( LINE, 'PERIODIC' ) > 0  ) THEN
         
            Periodic     = .TRUE.                  
            StrNeeded(6) = .FALSE.
            
         END IF !INDEX for "PERIODIC"
         
      END IF ! StrNeeded
      
      
   END DO !WHILE

   ErrStat = 0    ! We made it to the end of the file
   
   !-------------------------------------------------------------------------------------------------
   ! Close the summary file
   !-------------------------------------------------------------------------------------------------         
   
   CLOSE ( UnWind )


   !-------------------------------------------------------------------------------------------------
   ! Calculate the height of the grid center
   !-------------------------------------------------------------------------------------------------         

    ZCenter  = RefHt - ZGOffset


END SUBROUTINE Read_Summary_FF
!====================================================================================================
SUBROUTINE Read_TurbSim_FF(UnWind,WindFile, ErrStat)
! This subroutine reads the binary TurbSim-format FF file (.bts).  It fills the FFData array with
! velocity data for the grids and fills the FFtower array with velocities at points on the tower 
! (if data exists).
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,      INTENT(IN)   :: UnWind            ! unit number for the wind file
   CHARACTER(*), INTENT(IN)   :: WindFile          ! name of the binary TurbSim file
   INTEGER,      INTENT(OUT)  :: ErrStat           ! error status return value (0=no error; non-zero is error)

      ! Local Variables:

   REAL(SiKi)                 :: Dum_Real4         ! dummy 4-byte real number
   INTEGER(B1Ki)              :: Dum_Int1          ! dummy 1-byte integer
   INTEGER(B2Ki)              :: Dum_Int2          ! dummy 2-byte integer
   INTEGER(B4Ki)              :: Dum_Int4          ! dummy 4-byte integer

   INTEGER                    :: IC                ! loop counter for wind components
   INTEGER                    :: IT                ! loop counter for time
   INTEGER                    :: IY                ! loop counter for y
   INTEGER                    :: IZ                ! loop counter for z
   INTEGER                    :: NChar             ! number of characters in the description string
   
   REAL(SiKi)                 :: Vslope(3)         ! slope  for "un-normalizing" data
   REAL(SiKi)                 :: Voffset(3)        ! offset for "un-normalizing" data
            
   CHARACTER(1024)            :: DescStr           ! description string contained in the file


   NFFComp = 3                                              ! this file contains 3 wind components
         
   !-------------------------------------------------------------------------------------------------
   ! Open the file
   !-------------------------------------------------------------------------------------------------

   CALL OpenBInpFile (UnWind, TRIM(WindFile), ErrStat)
   IF (ErrStat /= 0) RETURN
      
   !-------------------------------------------------------------------------------------------------
   ! Read the header information
   !-------------------------------------------------------------------------------------------------
      READ (UnWind, IOSTAT=ErrStat)  Dum_Int2               ! the file identifier, INT(2)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the file identifier in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF         
         Periodic = Dum_Int2 == INT( 8, B2Ki) ! the number 7 is used for non-periodic wind files; 8 is periodic wind


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4               ! the number of grid points vertically, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of z grid points in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NZgrids = Dum_Int4       

     
      READ (UnWind, IOSTAT=ErrStat) Dum_Int4                ! the number of grid points laterally, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of y grid points in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NYgrids = Dum_Int4


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4               ! the number of tower points, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of tower points in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NTgrids = Dum_Int4
         

      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4               ! the number of time steps, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of time steps in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NFFSteps = Dum_Int4


      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! grid spacing in vertical direction (dz), REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dz in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         InvFFZD = 1.0/Dum_Real4                            ! 1/dz
         FFZHWid = 0.5*(NZgrids-1)*Dum_Real4                ! half the grid height


      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! grid spacing in lateral direction (dy), REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dy in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         InvFFYD = 1.0 / Dum_Real4                          ! 1/dy
         FFYHWid = 0.5*(NYgrids-1)*Dum_Real4                ! half grid grid width


      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! grid spacing in time (dt), REAL(4), in m/s
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dt in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         FFDTime = Dum_Real4
         FFRate  = 1.0/FFDTime
                  
                  
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! the mean wind speed at hub height, REAL(4), in m/s
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading mean wind speed in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         MeanFFWS = Dum_Real4
         InvMFFWS = 1.0 / MeanFFWS
         
         
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! height of the hub, REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading zHub in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         RefHt = Dum_Real4
         
         
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! height of the bottom of the grid, REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading GridBase in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         GridBase = Dum_Real4

 !        ZGOffset = RefHt - GridBase  - FFZHWid
         
         
      !----------------------------------------------------------------------------------------------
      ! Read the binary scaling factors
      !----------------------------------------------------------------------------------------------         
         
         DO IC = 1,NFFComp         
            READ (UnWind, IOSTAT=ErrStat)  Vslope(IC)       ! the IC-component slope for scaling, REAL(4)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr ( ' Error reading Vslope('//Num2LStr(IC)//') in the FF binary file "'//TRIM( WindFile )//'."' )
                  RETURN
               ENDIF


            READ (UnWind, IOSTAT=ErrStat)  Voffset(IC)      ! the IC-component offset for scaling, REAL(4)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr ( ' Error reading Voffset('//Num2LStr(IC)//') in the FF binary file "'//TRIM( WindFile )//'."' )
                  RETURN
               ENDIF
               
         END DO !IC


      !----------------------------------------------------------------------------------------------
      ! Read the description string: "Generated by TurbSim (vx.xx, dd-mmm-yyyy) on dd-mmm-yyyy at hh:mm:ss."
      !----------------------------------------------------------------------------------------------

         READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                ! the number of characters in the description string, max 200, INT(4)
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error reading NCHAR in the FF binary file "'//TRIM( WindFile )//'."' )
               RETURN
            ENDIF
            nchar = Dum_Int4
            
         DescStr = ''                                       ! Initialize the description string
         
         DO IC=1,nchar

            READ (UnWind, IOSTAT=ErrStat) Dum_Int1          ! the ASCII integer representation of the character, INT(1)
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error reading description line in the FF binary file "'//TRIM( WindFile )//'."' )
               RETURN
            ENDIF
            
            IF ( LEN(DescStr) >= IC ) THEN
               DescStr(IC:IC) = ACHAR( Dum_Int1 )              ! converted ASCII characters
            ELSE
               CALL WrScr ( ' Description string too long.' )
               EXIT
            END IF

         ENDDO !IC


   !-------------------------------------------------------------------------------------------------
   ! Get the grid and tower velocities
   !-------------------------------------------------------------------------------------------------

   CALL WrScr1( ' Reading a '//TRIM( Num2LStr(NYGrids) )//'x'//TRIM( Num2LStr(NZGrids) )//  &
            ' grid ('//TRIM( Num2LStr(FFYHWid*2) )//' m wide, '// &
            TRIM( Num2LStr(GridBase) )//' m to '//TRIM( Num2LStr(GridBase+FFZHWid*2) )//&
            ' m above ground) with a characterstic wind speed of '//TRIM( Num2LStr(MeanFFWS) )//' m/s. '//TRIM(DescStr) )
               
               
   !----------------------------------------------------------------------------------------------
   ! Allocate arrays for the FF grid as well as the tower points, if they exist
   !----------------------------------------------------------------------------------------------
            
      IF ( .NOT. ALLOCATED( FFData ) ) THEN
         ALLOCATE ( FFData(NZGrids,NYGrids,NFFComp,NFFSteps), STAT=ErrStat )
               
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr( ' Cannot allocate the full-field wind data array.' )
            RETURN
         ENDIF         
      ENDIF
         
     
      IF ( NTgrids > 0 ) THEN
      
         IF ( .NOT. ALLOCATED( FFtower ) ) THEN
            ALLOCATE( FFtower( NFFComp, NTgrids, NFFSteps ), STAT=ErrStat )
            
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Cannot allocate the tower wind data array.' )
               RETURN
            ENDIF            
         ENDIF
         
      ENDIF         
      
   !-------------------------------------------------------------------------------------------------
   ! Read the 16-bit data and scale it to 32-bit reals
   !-------------------------------------------------------------------------------------------------
               
      ! Loop through time.

      DO IT=1,NFFSteps
      
         !...........................................................................................
         ! Read grid data at this time step.
         !...........................................................................................

         DO IZ=1,NZgrids
            ! Zgrid(IZ) = Z1 + (IZ-1)*dz                 ! Vertical location of grid data point, in m relative to ground

            DO IY=1,NYgrids
               ! Ygrid(IY) = -0.5*(ny-1)*dy + (IY-1)*dy  ! Horizontal location of grid data point, in m relative to tower centerline
            
               DO IC=1,NFFComp                           ! number of wind components (U, V, W)

                  READ (UnWind, IOSTAT=ErrStat)  Dum_Int2      ! normalized wind-component, INT(2)
                  IF ( ErrStat /= 0 )  THEN
                     CALL WrScr ( ' Error reading grid wind components in the FF binary file "'//TRIM( WindFile )//'."' )
                     RETURN
                  ENDIF
                  
                  FFData(IZ,IY,IC,IT) = ( Dum_Int2 - Voffset(IC) ) / VSlope(IC)

               ENDDO !IC

            ENDDO !IY
            
         ENDDO ! IZ


         !...........................................................................................
         ! Read the tower data at this time step.
         !...........................................................................................
            
         DO IZ=1,NTgrids         ! If NTgrids<1, there are no tower points & FFtower is not allocated

            ! Ytower     = 0               ! Lateral location of the tower data point, in m relative to tower centerline
            ! Ztower(IZ) = Z1 - (IZ-1)*dz  ! Vertical location of tower data point, in m relative to ground

            DO IC=1,NFFComp   ! number of wind components

               READ (UnWind, IOSTAT=ErrStat)  Dum_Int2      ! normalized wind-component, INT(2)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr ( ' Error reading tower wind components in the FF binary file "'//TRIM( WindFile )//'."' )
                  RETURN
               ENDIF
               
               FFtower(IC,IZ,IT) = ( Dum_Int2 - Voffset(IC) ) / VSlope(IC)  ! wind-component scaled to m/s

            ENDDO !IC

         ENDDO ! IZ


      ENDDO ! IT

   !-------------------------------------------------------------------------------------------------
   ! close the file and return
   !-------------------------------------------------------------------------------------------------
   
   CLOSE ( UnWind )


   IF ( Periodic ) THEN
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data (period of '//TRIM( Num2LStr( FFDTime*( NFFSteps ) ) )//' seconds).' )
   ELSE
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data ('//TRIM( Num2LStr( FFDTime*( NFFSteps - 1 ) ) )//' seconds).' )
   END IF                  

   RETURN

END SUBROUTINE READ_TurbSim_FF
!====================================================================================================
SUBROUTINE Read_FF_Tower( UnWind, WindFile, ErrStat )
! This subroutine reads the binary tower file that corresponds with the Bladed-style FF binary file.
! The FF grid must be read before this subroutine is called! (many checks are made to ensure the
! files belong together)
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,      INTENT(IN)   :: UnWind            ! unit number for the wind file
   CHARACTER(*), INTENT(IN)   :: WindFile          ! name of the binary TurbSim file
   INTEGER,      INTENT(OUT)  :: ErrStat           ! error status return value (0=no error; non-zero is error)

      ! Local Variables:

   REAL(SiKi)                 :: Dum_Real4         ! dummy 4-byte real number
   INTEGER(B2Ki)              :: Dum_Int2          ! dummy 2-byte integer
   INTEGER(B4Ki)              :: Dum_Int4          ! dummy 4-byte integer

   INTEGER                    :: IC                ! loop counter for wind components
   INTEGER                    :: IT                ! loop counter for time
   INTEGER                    :: IZ                ! loop counter for z
   
   REAL(ReKi), PARAMETER      :: TOL = 1E-4        ! tolerence for wind file comparisons

   REAL(ReKi), PARAMETER      :: FF_Offset(3) = (/ 1.0, 0.0, 0.0 /)  ! used for "un-normalizing" the data
   REAL(SiKi)                 :: TI       (3)      ! scaling values for "un-normalizing the data" [approx. turbulence intensities of the wind components]

   !-------------------------------------------------------------------------------------------------
   ! 
   !-------------------------------------------------------------------------------------------------

   NTgrids = 0

   IF ( NFFComp /= 3 ) THEN
      CALL WrScr( ' Error: Tower binary files require 3 wind components.' )
      ErrStat = 1
      RETURN
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Open the file
   !-------------------------------------------------------------------------------------------------

   CALL OpenBInpFile (UnWind, TRIM(WindFile), ErrStat)
   IF (ErrStat /= 0) THEN
      ErrStat = -1
      RETURN
   END IF
      
   !-------------------------------------------------------------------------------------------------
   ! Read the header information and check that it's compatible with the FF Bladed-style binary
   ! parameters already read.
   !-------------------------------------------------------------------------------------------------
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! dz, in meters [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dz in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( ABS(Dum_Real4*InvFFZD-1) > TOL ) THEN
            CALL WrScr ( ' Resolution in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF
         
         
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! dx, in meters [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dx in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         
         IF ( ABS(Dum_Real4*InvMFFWS/FFDTime-1) > TOL ) THEN
            CALL WrScr ( ' Time resolution in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF
         

      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! Zmax, in meters [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading GridBase in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( ABS(Dum_Real4/GridBase-1) > TOL ) THEN
            CALL WrScr ( ' Height in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                  ! NumOutSteps [4-byte INTEGER]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading NumOutSteps in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( Dum_Int4 /= NFFSteps ) THEN
            CALL WrScr ( ' Number of time steps in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                  ! NumZ      [4-byte INTEGER]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading NumZ in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NTgrids = Dum_Int4
         

      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! UHub      [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading UHub in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( ABS(Dum_Real4*InvMFFWS - 1) > TOL ) THEN
            CALL WrScr ( ' Mean wind speed in the FF binary file does not match the tower file.' )
            ErrStat = 1
            NTgrids = 0
            RETURN
         END IF


      DO IC=1,3
         READ (UnWind, IOSTAT=ErrStat)  TI(IC)               ! TI(u), TI(v), TI(w)  [4-byte REAL]
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error reading TI('//TRIM(Num2LStr(IC))//') in the binary tower file "' &
                               //TRIM( WindFile )//'."' )
               NTgrids = 0                               
               RETURN
            ENDIF
      END DO      

   !----------------------------------------------------------------------------------------------
   ! Allocate arrays for the tower points
   !----------------------------------------------------------------------------------------------        
     
      IF ( NTgrids > 0 ) THEN
      
         IF ( .NOT. ALLOCATED( FFtower ) ) THEN
!            CALL AllocAry( FFtower, NFFComp, NTgrids, NFFSteps, 'tower wind data', ErrStat )            
            ALLOCATE ( FFtower(NFFComp,NTgrids,NFFSteps), STAT=ErrStat )

            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error allocating memory for the tower wind data array.' )
               NTgrids = 0
               RETURN
            END IF

         ELSE
            ! Check sizes here!
         ENDIF
         
      ENDIF         
      
   !-------------------------------------------------------------------------------------------------
   ! Read the 16-bit time-series data and scale it to 32-bit reals
   !-------------------------------------------------------------------------------------------------
               
      ! Loop through time.

      DO IT=1,NFFSteps

         DO IZ=1,NTgrids         ! If NTgrids<1, there are no tower points & FFtower is not allocated

            ! Ytower     = 0               ! Lateral location of the tower data point, in m relative to tower centerline
            ! Ztower(IZ) = Z1 - (IZ-1)*dz  ! Vertical location of tower data point, in m relative to ground

            DO IC=1,NFFComp   ! number of wind components

               READ (UnWind, IOSTAT=ErrStat)  Dum_Int2      ! normalized wind-component, INT(2)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr( ' Error reading binary tower data file. it = '//TRIM(Num2LStr(it))// &
                                 ', nffsteps = '//TRIM(Num2LStr(nffsteps)) )
                  ErrStat = 1  
                  NTgrids = 0            
                  RETURN
               ENDIF
               
               FFtower(IC,IZ,IT) = MeanFFWS*(FF_Offset(IC)+0.00001*TI(IC)*Dum_Int2)   ! wind-component scaled to m/s

            ENDDO !IC

         ENDDO ! IZ


      ENDDO ! IT   

   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
   CLOSE ( UnWind )


   CALL WrScr ( ' Processed '//TRIM( Num2LStr(NFFSteps) )//' time steps of '//TRIM( Num2LStr(NTgrids) )//'x1 tower data grids.')


   RETURN

END SUBROUTINE Read_FF_Tower
!====================================================================================================
FUNCTION FF_GetRValue(RVarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the RVarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------

   CHARACTER(*),   INTENT(IN)    :: RVarName
   INTEGER,        INTENT(OUT)   :: ErrStat
   REAL(ReKi)                    :: FF_GetRValue

   
   CHARACTER(20)                 :: VarNameUC
   

   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FFWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = RVarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
   
      CASE ('HUBHEIGHT', 'REFHEIGHT' )
         FF_GetRValue = RefHt
         
      CASE ('GRIDWIDTH', 'FFYWID' )
         FF_GetRValue = FFYHWid*2

      CASE ('GRIDHEIGHT', 'FFZWID' )
         FF_GetRValue = FFZHWid*2
         
      CASE ('MEANFFWS' )
         FF_GetRValue = MeanFFWS         
         
      CASE DEFAULT
         CALL WrScr( ' Invalid variable name in FF_GetRValue().' )
         ErrStat = 1
         
   END SELECT

END FUNCTION FF_GetRValue
!====================================================================================================
FUNCTION FF_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are are 
! requested.  It determines if the point is on the FF grid or tower points and calls the
! corresponding interpolation routine, which returns the velocities at the specified time and space.
!----------------------------------------------------------------------------------------------------
   
   REAL(ReKi),        INTENT(IN) :: Time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)
   INTEGER,           INTENT(OUT):: ErrStat
   TYPE(InflIntrpOut)            :: FF_GetWindSpeed
   
   REAL(ReKi), PARAMETER         :: TOL = 1E-3
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   
   
   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FFWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      

   
   !-------------------------------------------------------------------------------------------------
   ! Find out if the location is on the grid on on tower points; interpolate and return the value.
   !-------------------------------------------------------------------------------------------------   

    FF_GetWindSpeed%Velocity = FF_Interp(Time,InputPosition, ErrStat)


!   IF ( InputPosition(3) >= GridBase - TOL ) THEN  
!   
!         ! Get the velocities interpolated on the FF grid
!      
!      FF_GetWindSpeed%Velocity = FF_Interp(Time,InputPosition, ErrStat)
!      
!   ELSE
!   
!         ! Get the velocities interpolated below the FF grid, on the tower points
!
!      IF ( NTgrids < 1 ) THEN
!      
!         CALL WrScr( ' Error: FF interpolation height is below the grid and no tower points have been defined.' )
!         ErrStat = 1
!         RETURN
!         
!      ELSE
!      
!         FF_GetWindSpeed%Velocity = FF_TowerInterp(Time,InputInfo%Position, ErrStat)
!         
!      END IF   ! NTgrids < 1
!      
!   
!   END IF      ! InputInfo%Position(3)>= GridBase


END FUNCTION FF_GetWindSpeed
!====================================================================================================
FUNCTION FF_Interp(Time, Position, ErrStat)
!    This function is used to interpolate into the full-field wind array or tower array if it has   
!    been defined and is necessary for the given inputs.  It receives X, Y, Z and
!    TIME from the calling routine.  It then computes a time shift due to a nonzero X based upon 
!    the average windspeed.  The modified time is used to decide which pair of time slices to interpolate
!    within and between.  After finding the two time slices, it decides which four grid points bound the 
!    (Y,Z) pair.  It does a bilinear interpolation for each time slice. Linear interpolation is then used 
!    to interpolate between time slices.  This routine assumes that X is downwind, Y is to the left when  
!    looking downwind and Z is up.  It also assumes that no extrapolation will be needed.
!    
!    If tower points are used, it assumes the velocity at the ground is 0.  It interpolates between
!    heights and between time slices, but ignores the Y input.
!
!    11/07/94 - Created by M. Buhl from the original TURBINT.
!    09/25/97 - Modified by M. Buhl to use f90 constructs and new variable names.  Renamed to FF_Interp.
!    09/23/09 - Modified by B. Jonkman to use arguments instead of modules to determine time and position.  
!               Height is now relative to the ground
!
!----------------------------------------------------------------------------------------------------

   IMPLICIT                      NONE

   REAL(ReKi),      INTENT(IN) :: Position(3)       ! takes the place of XGrnd, YGrnd, ZGrnd
   REAL(ReKi),      INTENT(IN) :: Time
   REAL(ReKi)                  :: FF_Interp(3)      ! The U, V, W velocities

   INTEGER,         INTENT(OUT):: ErrStat

      ! Local Variables:

   REAL(ReKi)                  :: TimeShifted
   REAL(ReKi),PARAMETER        :: Tol = 1.0E-3      ! a tolerance for determining if two reals are the same (for extrapolation)
   REAL(ReKi)                  :: W_YH_Z
   REAL(ReKi)                  :: W_YH_ZH
   REAL(ReKi)                  :: W_YH_ZL
   REAL(ReKi)                  :: W_YL_Z
   REAL(ReKi)                  :: W_YL_ZH
   REAL(ReKi)                  :: W_YL_ZL
   REAL(ReKi)                  :: Wnd      (2)
   REAL(ReKi)                  :: T
   REAL(ReKi)                  :: TGRID
   REAL(ReKi)                  :: Y
   REAL(ReKi)                  :: YGRID
   REAL(ReKi)                  :: Z
   REAL(ReKi)                  :: ZGRID

   INTEGER                    :: IDIM
   INTEGER                    :: IG
   INTEGER                    :: IT
   INTEGER                    :: ITHI
   INTEGER                    :: ITLO
   INTEGER                    :: IYHI
   INTEGER                    :: IYLO
   INTEGER                    :: IZHI
   INTEGER                    :: IZLO
   
   LOGICAL                    :: OnGrid
   
   !-------------------------------------------------------------------------------------------------
   ! Initialize variables
   !-------------------------------------------------------------------------------------------------

   FF_Interp(:)          = 0.0                         ! the output velocities (in case NFFComp /= 3)
   Wnd(:)                = 0.0                         ! just in case we're on an end point

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding time slices.
   !-------------------------------------------------------------------------------------------------

   ! Perform the time shift.  At time=0, a point half the grid width downstream (FFYHWid) will index into the zero time slice.  
   ! If we did not do this, any point downstream of the tower at the beginning of the run would index outside of the array.   
   ! This all assumes the grid width is at least as large as the rotor.  If it isn't, then the interpolation will not work.


   TimeShifted = TIME + ( InitXPosition - Position(1) )*InvMFFWS    ! in distance, X: InputInfo%Position(1) - InitXPosition - TIME*MeanFFWS
      

   IF ( Periodic ) THEN ! translate TimeShifted to ( 0 <= TimeShifted < TotalTime )

      TimeShifted = MODULO( TimeShifted, TotalTime )
   
      TGRID = TimeShifted*FFRate
      ITLO  = INT( TGRID )             ! convert REAL to INTEGER (add 1 later because our grids start at 1, not 0) 
      T     = TGRID - ITLO             ! a value between 0 and 1 that indicates a relative location between ITLO and ITHI   
      
      ITLO = ITLO + 1
      IF ( ITLO == NFFSteps ) THEN
         ITHI = 1
      ELSE
         ITHI = ITLO + 1
      END IF
      
      
   ELSE
   
      TGRID = TimeShifted*FFRate
      ITLO  = INT( TGRID )             ! convert REAL to INTEGER (add 1 later because our grids start at 1, not 0) 
      T     = TGRID - ITLO             ! a value between 0 and 1 that indicates a relative location between ITLO and ITHI   
   
      ITLO = ITLO + 1                  ! add one since our grids start at 1, not 0 
      ITHI = ITLO + 1   

      IF ( ITLO >= NFFSteps .OR. ITLO < 1 ) THEN
         IF ( ITLO == NFFSteps  ) THEN
            ITHI = ITLO   
            IF ( T <= TOL ) THEN ! we're on the last point
               T = 0.0
            ELSE  ! We'll extrapolate one dt past the last value in the file
               ITLO = ITHI - 1
            END IF         
         ELSE                 
            CALL WrScr( ' Error: FF wind array was exhausted at '//TRIM( Num2LStr( REAL( TIME,   ReKi ) ) )// & 
                           ' seconds (trying to access data at '//TRIM( Num2LStr( REAL( TimeShifted, ReKi ) ) )//' seconds).'  )
            ErrStat = 1   
            RETURN
         END IF
      ENDIF

   END IF


   !-------------------------------------------------------------------------------------------------
   ! Find the bounding rows for the Z position. [The lower-left corner is (1,1) when looking upwind.]
   !-------------------------------------------------------------------------------------------------

   ZGRID = ( Position(3) - GridBase )*InvFFZD

   IF (ZGRID > -1*TOL) THEN
      OnGrid = .TRUE.
      
      IZLO = INT( ZGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
      IZHI = IZLO + 1

      Z = ZGRID - ( IZLO - 1 )            ! a value between 0 and 1 that indicates a relative location between IZLO and IZHI

      IF ( IZLO < 1 ) THEN
         IF ( IZLO == 0 .AND. Z >= 1.0-TOL ) THEN
            Z    = 0.0 
            IZLO = 1
         ELSE
            CALL WrScr( ' Error: FF wind array boundaries violated. Grid too small in Z direction (Z='//&
                        TRIM(Num2LStr(Position(3)))//' m is below the grid).' )
            ErrStat = 1   
            RETURN
         END IF
      ELSEIF ( IZLO >= NZGrids ) THEN
         IF ( IZLO == NZGrids .AND. Z <= TOL ) THEN
            Z    = 0.0
            IZHI = IZLO                   ! We're right on the last point, which is still okay
         ELSE      
            CALL WrScr( ' Error: FF wind array boundaries violated. Grid too small in Z direction (Z='//&
                        TRIM(Num2LStr(Position(3)))//' m is above the grid).' )
            ErrStat = 3   
            RETURN
         END IF         
      ENDIF

   ELSE
   
      OnGrid = .FALSE.  ! this is on the tower
      
      IF ( NTGrids < 1 ) THEN
         CALL WrScr ( ' Error: FF wind array boundaries violated. Grid too small in Z direction '// &
                       '(height (Z='//TRIM(Num2LStr(Position(3)))//' m) is below the grid and no tower points are defined).' )
         ErrStat = 1
         RETURN
      END IF

      IZLO = INT( -1.0*ZGRID ) + 1            ! convert REAL to INTEGER, then add one since our grids start at 1, not 0      
      

      IF ( IZLO >= NTGrids ) THEN  !our dz is the difference between the bottom tower point and the ground
         IZLO = NTGrids
         
         Z    = 1.0 - Position(3) / (GridBase - (IZLO-1)/InvFFZD) !check that this isn't 0         
      ELSE
         Z    = ABS(ZGRID) - (IZLO - 1)
      END IF
      IZHI = IZLO + 1
            
   END IF


   IF ( OnGrid ) THEN      ! The tower points don't use this

      !-------------------------------------------------------------------------------------------------
      ! Find the bounding columns for the Y position. [The lower-left corner is (1,1) when looking upwind.]
      !-------------------------------------------------------------------------------------------------

         YGRID = ( Position(2) + FFYHWid )*InvFFYD    ! really, it's (Position(2) - -1.0*FFYHWid)

         IYLO = INT( YGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
         IYHI = IYLO + 1

         Y    = YGRID - ( IYLO - 1 )         ! a value between 0 and 1 that indicates a relative location between IYLO and IYHI
         
         IF ( IYLO >= NYGrids .OR. IYLO < 1 ) THEN
            IF ( IYLO == 0 .AND. Y >= 1.0-TOL ) THEN
               Y    = 0.0 
               IYLO = 1
            ELSE IF ( IYLO == NYGrids .AND. Y <= TOL ) THEN
               Y    = 0.0
               IYHI = IYLO                   ! We're right on the last point, which is still okay      
            ELSE
               CALL WrScr( ' Error FF wind array boundaries violated: Grid too small in Y direction. Y=' &
                             //TRIM(Num2LStr(Position(2)))//'; Y boundaries = ['//TRIM(Num2LStr(-1.0*FFYHWid)) &
                             //', '//TRIM(Num2LStr(FFYHWid))//']' )
               ErrStat = 2   
               RETURN
            END IF
         ENDIF

      !-------------------------------------------------------------------------------------------------
      ! Interpolate on the grid 
      !-------------------------------------------------------------------------------------------------

      DO IDIM=1,NFFComp       ! all the components

         IT = ITLO            ! Start using the ITLO slice
   
         DO IG=1,2            ! repeat for 2 time slices (by changing the value of IT. note that we can't loop from IXLO to IXHI because they could be NFFSteps and 1 respectively)

            !-------------------------------------------------------------------------------------------
            ! Get the wind velocity values for the four corners of the grid for this time.
            !-------------------------------------------------------------------------------------------

            W_YL_ZL = FFData( IZLO, IYLO, IDIM, IT )
            W_YL_ZH = FFData( IZHI, IYLO, IDIM, IT )
            W_YH_ZL = FFData( IZLO, IYHI, IDIM, IT )
            W_YH_ZH = FFData( IZHI, IYHI, IDIM, IT )


            !-------------------------------------------------------------------------------------------
            ! Interpolate within the grid for this time.
            !-------------------------------------------------------------------------------------------

            W_YL_Z  = ( W_YL_ZH - W_YL_ZL )*Z + W_YL_ZL
            W_YH_Z  = ( W_YH_ZH - W_YH_ZL )*Z + W_YH_ZL
            Wnd(IG) = ( W_YH_Z  - W_YL_Z  )*Y + W_YL_Z

            IT = ITHI            ! repeat for the using the ITHI slice

         END DO !IG

         !----------------------------------------------------------------------------------------------
         ! Interpolate between the two times.
         !----------------------------------------------------------------------------------------------
         
         FF_Interp(IDIM) = ( Wnd(2) - Wnd(1) ) * T + Wnd(1)    ! interpolated velocity
         
      END DO !IDIM

   ELSE
   
   !-------------------------------------------------------------------------------------------------
   ! Interpolate on the tower array
   !-------------------------------------------------------------------------------------------------
      
      DO IDIM=1,NFFComp    ! all the components

         IT = ITLO            ! Start using the ITLO slice

         DO IG=1,2            ! repeat for 2 time slices (by changing the value of IT. note that we can't loop from IXLO to IXHI because they could be NFFSteps and 1 respectively)

            !-------------------------------------------------------------------------------------------
            ! Get the wind velocity values for the two corners of the grid for this time.
            !-------------------------------------------------------------------------------------------

            W_YH_ZL = FFTower( IDIM, IZLO, IT )
            
            IF ( IZHI > NTGrids ) THEN
               W_YH_ZH = 0.0
            ELSE
               W_YH_ZH = FFTower( IDIM, IZHI, IT )
            END IF


            !-------------------------------------------------------------------------------------------
            ! Interpolate within the grid for this time.
            !-------------------------------------------------------------------------------------------

            Wnd(IG) = ( W_YH_ZH - W_YH_ZL )*Z + W_YH_ZL

            IT = ITHI            ! repeat for the using the ITHI slice

         END DO !IG

         !----------------------------------------------------------------------------------------------
         ! Interpolate between the two times.
         !----------------------------------------------------------------------------------------------
         
         FF_Interp(IDIM) = ( Wnd(2) - Wnd(1) ) * T + Wnd(1)    ! interpolated velocity
         
      END DO !IDIM
   
   END IF ! OnGrid

   RETURN
   
END FUNCTION FF_Interp
!====================================================================================================
SUBROUTINE FF_Terminate( ErrStat )
!  This subroutine cleans up any data that is still allocated.  The (possibly) open files are 
!  closed in InflowWindMod.
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   ErrStat = 0

   IF ( ALLOCATED( FFData  ) )   DEALLOCATE( FFData,  STAT=ErrStat )   
   IF ( ALLOCATED( FFTower ) )   DEALLOCATE( FFTower, STAT=ErrStat )   
   
   Initialized = .FALSE.


END SUBROUTINE FF_Terminate
!====================================================================================================
END MODULE FFWind

MODULE HAWCWind
!
!  This module uses full-field binary wind files to determine the wind inflow.
!  This module assumes that the origin, (0,0,0), is located at the tower centerline at ground level,
!  and that all units are specified in the metric system (using meters and seconds).
!  Data is assumed periodic in the X direction (and thus not shifted like FFWind files are).
!
!  Created 25-June-2010 by B. Jonkman, National Renewable Energy Laboratory
!     using subroutines and modules from AeroDyn v12.58
!
!----------------------------------------------------------------------------------------------------

   USE      NWTC_Library
   USE      SharedInflowDefns

   IMPLICIT NONE

   PRIVATE                                                        ! By default, everything in HAWCWind is private (methods, data, types, etc.)
   
      
   REAL(ReKi), ALLOCATABLE          :: WindData  (:,:,:,:)        ! Array of FF data for all 3 wind components

   REAL(ReKi)                       :: deltaXInv                  ! multiplicative inverse of delta X
   REAL(ReKi)                       :: deltaYInv                  ! multiplicative inverse of delta Y
   REAL(ReKi)                       :: deltaZInv                  ! multiplicative inverse of delta Z

   INTEGER, PARAMETER               :: NC = 3                     ! number of wind components
   INTEGER                          :: NX                         ! number of points in the X direction
   INTEGER                          :: NY                         ! number of points in the Y direction
   INTEGER                          :: NZ                         ! number of points in the Z direction

   REAL(ReKi)                       :: GridBase                   ! the height of the bottom of the grid (Z direction) in meters
   REAL(ReKi)                       :: LengthX                    ! the grid length in the X direction (distance between point 1 and the next point 1 [because it is periodic])
   REAL(ReKi)                       :: LengthYHalf                ! half the grid width
   REAL(ReKi)                       :: RefHt                      ! the reference (hub) height of the grid in meters 
   REAL(ReKi)                       :: URef                       ! the mean wind speed in m/s at height RefHt meters (as defined in the input file)

         
   LOGICAL, SAVE                    :: Initialized = .FALSE.      ! flag that determines if the module has been initialized


   PUBLIC                           :: HW_Init                    ! initialization subroutine to read the FF grids
   PUBLIC                           :: HW_GetWindSpeed            ! interpolation function that returns velocities at specified time and space
   PUBLIC                           :: HW_GetValue                ! interface to return requested values
   PUBLIC                           :: HW_Terminate               ! subroutine that deallocates memory stored in the FFWind module

CONTAINS
!====================================================================================================
SUBROUTINE HW_Init ( UnWind, InpFileName, ErrStat )
!  This routine is used read the full-field turbulence data stored in HAWC format.
!----------------------------------------------------------------------------------------------------

   IMPLICIT                       NONE


      ! Passed Variables:
      
   INTEGER,      INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered
   
   CHARACTER(*), INTENT(IN)    :: InpFileName                  ! Name of the input text file

      ! Local Variables:

   REAL(SiKi)                  :: DumReal                      ! real variable to temporarially store values read from binary file

   REAL(ReKi)                  :: dx
   REAL(ReKi)                  :: dy
   REAL(ReKi)                  :: dz
   REAL(ReKi)                  :: PLExp                        ! Power law exponent, for the PL mean wind profile type
   REAL(ReKi)                  :: U                            ! The mean wind speed
   REAL(ReKi)                  :: Z                            ! The height above ground/sea level
   REAL(ReKi)                  :: Z0                           ! Surface layer roughness length in meters, used for LOG profile type
    
  
   INTEGER                     :: IC                           ! Loop counter for the number of wind components
   INTEGER                     :: IX                           ! Loop counter for the number of grid points in the X direction
   INTEGER                     :: IY                           ! Loop counter for the number of grid points in the Y direction
   INTEGER                     :: IZ                           ! Loop counter for the number of grid points in the Z direction

   CHARACTER( 1024 )           :: DataFiles ( 3 )              ! Names of the files containing the 3 wind components   
   CHARACTER(3)                :: WindProfileType              ! character code of mean wind profile type


   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' HAWCWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF   

! bjj: this (reading the file) should perhaps be in a subroutine...

   !-------------------------------------------------------------------------------------------------
   ! Open the text file 
   !-------------------------------------------------------------------------------------------------

   CALL OpenFInpFile ( UnWind, TRIM(InpFileName), ErrStat )
   IF (ErrStat /= 0) RETURN

   
   !-------------------------------------------------------------------------------------------------
   ! Read some header information in the text file 
   !-------------------------------------------------------------------------------------------------
   
   CALL ReadCom( UnWind, InpFileName, 'Header 1', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Header 2', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Header 3', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Header 4', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Parameters for HAWC-format binary files', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   
   !-------------------------------------------------------------------------------------------------
   ! Read file names and scaling info from the file
   !-------------------------------------------------------------------------------------------------

   CALL ReadVar( UnWind, InpFileName, DataFiles(1), 'FileName_u', 'Name of the u-component binary file', ErrStat )
   IF (ErrStat /= 0) RETURN

   CALL ReadVar( UnWind, InpFileName, DataFiles(2), 'FileName_v', 'Name of the v-component binary file', ErrStat )
   IF (ErrStat /= 0) RETURN

   CALL ReadVar( UnWind, InpFileName, DataFiles(3), 'FileName_w', 'Name of the w-component binary file', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, InpFileName, NX, 'nx', 'Number of grid points in the X direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( NX < 1 ) THEN
      CALL WrScr ( ' HAWCWind error reading "nx": number of grid points in the X direction must be at least 1.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, NY, 'ny', 'Number of grid points in the Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( NY < 1 ) THEN
      CALL WrScr ( ' HAWCWind error reading "ny": number of grid points in the Y direction must be at least 1.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, NZ, 'nz', 'Number of grid points in the Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( NZ < 1 ) THEN
      CALL WrScr ( ' HAWCWind error reading "nz": number of grid points in the Z direction must be at least 1.')
      ErrStat = 1
      RETURN
   END IF
   

   CALL ReadVar( UnWind, InpFileName, dx, 'dx', 'Distance between two points in the X direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( DX < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "dx": the grid spacing in the X direction must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, dy, 'dy', 'Distance between two points in the Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( DY < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "dy": the grid spacing in the Y direction must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, dz, 'dz', 'Distance between two points in the Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( DZ < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "dz": the grid spacing in the Z direction must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, RefHt, 'RefHt', 'Grid reference height', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( RefHt < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "RefHt": the grid reference height must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF

 
   !-------------------------------------------------------------------------------------------------
   ! Read the section to determine the mean wind profile
   !-------------------------------------------------------------------------------------------------
 
   CALL ReadCom( UnWind, InpFileName, 'mean wind profile parameters (added to HAWC-format files)', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, InpFileName, WindProfileType, 'WindProfileType', 'Wind profile type', ErrStat )
   IF (ErrStat /= 0) RETURN

    
   CALL ReadVar( UnWind, InpFileName, URef, 'URef', 'Reference wind speed', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( URef < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error: the reference wind speed, URef, must not be negative.' )
      ErrStat = 1
      RETURN   
   END IF

    
   CALL ReadVar( UnWind, InpFileName, PLExp, 'PLExp', 'Power law exponent', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, InpFileName, Z0, 'Z0', 'Surface roughness length', ErrStat )   
   IF (ErrStat /= 0) RETURN  
   
   IF ( Z0 <= EPSILON(Z0) ) THEN
      CALL WrScr ( ' HAWCWind error: the surface roughness length, Z0, must be greater than zero.' )
      ErrStat = 1
      RETURN   
   END IF
   
   !-------------------------------------------------------------------------------------------------
   ! Close the file.
   !-------------------------------------------------------------------------------------------------

   CLOSE ( UnWind )


   !-------------------------------------------------------------------------------------------------
   ! Set some internal module parameters based on input file values
   !-------------------------------------------------------------------------------------------------

   LengthX     = dx*nx !(nx-1)   !because the turbulence box is periodic in the X direction, we need to consider the length between point 1 and the next point 1 (instead of between points 1 and nx)
   LengthYHalf = 0.5*dy*(ny-1)
   GridBase    = RefHt - 0.5*(nz-1)*dz

   IF ( GridBase <= 0.0 ) THEN
      CALL WrScr( ' HAWCWind error: the bottom of the grid is located at a height of '//&
                      TRIM( Num2LStr(GridBase) )//' meters, which is below the ground.' )
      ErrStat = 1
      RETURN
   END IF 


   deltaXInv   = 1.0 / dx
   deltaYInv   = 1.0 / dy
   deltaZInv   = 1.0 / dz
   
   
   !-------------------------------------------------------------------------------------------------
   ! Allocate space for the wind arrays.
   !-------------------------------------------------------------------------------------------------

   IF (.NOT. ALLOCATED(WindData) ) THEN
      ALLOCATE( WindData( NZ, NY, NX, NC ), STAT=ErrStat )
      IF ( ErrStat /= 0 ) THEN
         CALL WrScr ( " Error allocating space for HAWCWind's WindData array." )
         RETURN
      END IF
   END IF
      

   !-------------------------------------------------------------------------------------------------
   ! Read the 3 files containg the turbulent wind speeds.
   !-------------------------------------------------------------------------------------------------
!bjj: check these indices... they do not seem to be very consistant between the WAsP IEC Turbulence
!     simulator and documentation of OC3 file formats... the current implementation is from the 
!     OC3/Kenneth Thompson documentation.

      ! The array must be filled so that x(i) < x(i+1), y(i) < y(i+1), and z(i) < z(i+1)
      ! Also, note that the time axis is the negative x axis.

   DO IC = 1,NC
   
      CALL OpenBInpFile ( UnWind, DataFiles(IC), ErrStat )
   
      DO IX = NX,1,-1                  ! Time is the opposite of X ....
         DO IY = NY,1,-1
            DO IZ = 1,NZ 
            
               READ( UnWind, IOSTAT=ErrStat ) DumReal
               
               WindData( IZ, IY, IX, IC ) = DumReal    ! possible type conversion here
               
               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading binary data from "'//TRIM(DataFiles(IC))//'".' )
                  CALL WrScr( ' I/O error '//TRIM(Num2LStr(ErrStat))//' occurred at IZ='//TRIM(Num2LStr(IZ))//&
                                                   ', IY='//TRIM(Num2LStr(IY))//', IX='//TRIM(Num2LStr(IX))//'.' )
                  CLOSE ( UnWind )
                  RETURN
               END IF
                              
            END DO
         END DO
      END DO
      
      CLOSE ( UnWind )
      
   END DO

   
   !-------------------------------------------------------------------------------------------------
   ! Add the mean wind speed to the u component.
   !-------------------------------------------------------------------------------------------------

   CALL Conv2UC( WindProfileType )
                 
   
   IF ( RefHt > 0.0 ) THEN
   
      DO IZ = 1,NZ

         Z = GridBase  + ( IZ - 1 )*dz
         
         SELECT CASE ( TRIM(WindProfileType) )
   
            CASE ( 'PL' )         
               U = URef*( Z / RefHt )**PLExp      ! [IEC 61400-1 6.3.1.2 (10)]
      
            CASE ( 'LOG' )
            
               IF ( Z /= Z0 ) THEN
                  U = URef*( LOG( Z / Z0 ) )/( LOG( RefHt / Z0 ) )
               ELSE
                  U = 0.0
               ENDIF
            
            CASE DEFAULT
            
               CALL WrScr( ' Invalid wind profile type in HAWCWind.' )
               ErrStat = 1
               RETURN
      
         END SELECT
   
         WindData( IZ, :, :, 1 ) = WindData( IZ, :, :, 1 ) + U
            

      END DO ! IZ
   END IF ! RefHt
   
   
   !-------------------------------------------------------------------------------------------------
   ! Set initialized flag and return
   !-------------------------------------------------------------------------------------------------
   
   Initialized = .TRUE.

   RETURN
   
END SUBROUTINE HW_Init
!====================================================================================================
FUNCTION HW_GetValue(RVarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the RVarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------

   CHARACTER(*),   INTENT(IN)    :: RVarName
   INTEGER,        INTENT(OUT)   :: ErrStat
   REAL(ReKi)                    :: HW_GetValue

   
   CHARACTER(20)                 :: VarNameUC
   

   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the HAWCWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = RVarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
   
      CASE ( 'REFHEIGHT' )
         HW_GetValue = RefHt
         
      CASE ('GRIDWIDTH' )
         HW_GetValue = LengthYHalf*2

      CASE ('GRIDHEIGHT' )
         HW_GetValue = NZ/deltaZInv
         
      CASE ('UREF' )
         HW_GetValue = URef        
         
      CASE DEFAULT
         CALL WrScr( ' HAWCWind error: invalid variable name in HW_GetRValue().' )
         ErrStat = 1
         
   END SELECT

END FUNCTION HW_GetValue
!!====================================================================================================
FUNCTION HW_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are are 
! requested.  It determines if the point is on the FF grid or tower points and calls the
! corresponding interpolation routine, which returns the velocities at the specified time and space.
!----------------------------------------------------------------------------------------------------
   
   REAL(ReKi),        INTENT(IN) :: Time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)
   INTEGER,           INTENT(OUT):: ErrStat
   TYPE(InflIntrpOut)            :: HW_GetWindSpeed
     
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   
   
   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FFWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      

   
   !-------------------------------------------------------------------------------------------------
   ! interpolate and return the value.
   !-------------------------------------------------------------------------------------------------   

    HW_GetWindSpeed%Velocity = HW_LinearInterp(Time,InputPosition, ErrStat)


END FUNCTION HW_GetWindSpeed
!====================================================================================================
FUNCTION HW_LinearInterp(Time, Position, ErrStat)
!    This function is used to interpolate into the full-field wind array for the given inputs. It receives 
!    X, Y, Z and TIME from the calling routine.  It then computes a time shift in the X axis based upon 
!    the average windspeed.  The modified position is used to decide which pair of X grids to interpolate
!    within and between.  After finding the two X slices, it decides which four grid points bound the 
!    (Y,Z) pair.  It does a bilinear interpolation for each X slice. Linear interpolation is then used 
!    to interpolate between the X slices.  This routine assumes that X is downwind, Y is to the left when  
!    looking downwind and Z is up.  It also assumes that no extrapolation will be needed.
!    
!    If tower points are used, it assumes the velocity at the ground is 0.  It interpolates between
!    heights and between time slices, but ignores the Y input.
!
!    09/23/09 - Modified by B. Jonkman to use arguments instead of modules to determine time and position.  
!               Height is now relative to the ground
!
!----------------------------------------------------------------------------------------------------

   IMPLICIT                      NONE

   REAL(ReKi),      INTENT(IN) :: Position(3)       ! takes the place of XGrnd, YGrnd, ZGrnd
   REAL(ReKi),      INTENT(IN) :: Time
   REAL(ReKi)                  :: HW_LinearInterp(3)      ! The U, V, W velocities

   INTEGER,         INTENT(OUT):: ErrStat

      ! Local Variables:

   REAL(ReKi)                  :: ShiftedXPosition
   REAL(ReKi),PARAMETER        :: Tol = 1.0E-3      ! a tolerance for determining if two reals are the same (for extrapolation)
   REAL(ReKi)                  :: W_YH_Z
   REAL(ReKi)                  :: W_YH_ZH
   REAL(ReKi)                  :: W_YH_ZL
   REAL(ReKi)                  :: W_YL_Z
   REAL(ReKi)                  :: W_YL_ZH
   REAL(ReKi)                  :: W_YL_ZL
   REAL(ReKi)                  :: Wnd      (2)
   REAL(ReKi)                  :: X                 ! a value between 0 and 1 that indicates a relative location between IXLO and IXHI
   REAL(ReKi)                  :: XGRID             ! the position in the X direction relative to the first grid point
   REAL(ReKi)                  :: Y                 ! a value between 0 and 1 that indicates a relative location between IYLO and IYHI
   REAL(ReKi)                  :: YGRID             ! the position in the Y direction relative to the first grid point
   REAL(ReKi)                  :: Z                 ! a value between 0 and 1 that indicates a relative location between IZLO and IZHI
   REAL(ReKi)                  :: ZGRID             ! the position in the Z direction relative to the first grid point             

   INTEGER                     :: IC                ! loop counter for number of grid points
   INTEGER                     :: IG                ! loop counter for X grids
   INTEGER                     :: IX                ! variable to store IXLO and IXHI while looping
   INTEGER                     :: IXHI              ! high index into the array in the X dimension
   INTEGER                     :: IXLO              ! low  index into the array in the X dimension
   INTEGER                     :: IYHI              ! high index into the array in the Y dimension
   INTEGER                     :: IYLO              ! low  index into the array in the Y dimension
   INTEGER                     :: IZHI              ! high index into the array in the Z dimension
   INTEGER                     :: IZLO              ! low  index into the array in the Z dimension
   
   
   !-------------------------------------------------------------------------------------------------
   ! Initialize variables
   !-------------------------------------------------------------------------------------------------

   HW_LinearInterp(:)    = 0.0                         ! the output velocities (in case NFFComp /= 3)
   Wnd(:)                = 0.0                         ! just in case we're on an end point

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding X slices.
   !-------------------------------------------------------------------------------------------------

! bjj: should we shift by MIN(YHalfWid,FFZHWid)?
         
         ! Assume Taylor's Frozen Turbulence Hypothesis applies: u(X,Y,Z,t) = u( X-U*t, Y, Z, 0)

   ShiftedXPosition = Position(1) - TIME*URef      !this puts the first X grid point at the undeflected tower centerline

   
      ! The wind file is periodic so we'll translate this position to ( 0 <= ShiftedXPosition < LengthX )
   
   ShiftedXPosition = MODULO( ShiftedXPosition, LengthX )
    
   XGrid            = ShiftedXPosition*deltaXInv
   
   IXLO = INT( XGrid ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
   
   IF ( IXLO == NX ) THEN
      IXHI = 1
   ELSE
      IXHI = IXLO + 1
      
! BJJ: assuming LengthX and NX have been correctly defined, this cannot happen:      
!      IF ( IXLO > NX .OR. IXLO < 1 ) THEN
!            CALL WrScr( ' HAWCWind error: wind array was exhausted at '//TRIM( Num2LStr( REAL( TIME,   ReKi ) ) )//' seconds '//& 
!                        '(trying to access X data at '//TRIM( Num2LStr( REAL( ShiftedXPosition, ReKi ) ) )//' m).'  )
!            ErrStat = 1   
!            RETURN
!      ENDIF
      
   END IF
   
   X = XGrid - ( IXLO - 1 )         ! a value between 0 and 1 that indicates a relative location between IXLO and IXHI

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding rows for the Z position. [The lower-left corner is (1,1) when looking upwind.]
   !-------------------------------------------------------------------------------------------------

   ZGRID = ( Position(3) - GridBase )*deltaZInv

     
   IZLO = INT( ZGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
   IZHI = IZLO + 1

   Z = ZGRID - ( IZLO - 1 )            ! a value between 0 and 1 that indicates a relative location between IZLO and IZHI

   IF ( IZLO < 1 ) THEN
      IF ( IZLO == 0 .AND. Z >= 1.0-TOL ) THEN
         Z    = 0.0 
         IZLO = 1
      ELSE
         CALL WrScr( ' HAWCWind error: wind array boundaries violated. Grid too small in Z direction (Z='//&
                     TRIM(Num2LStr(Position(3)))//' m is below the grid).' )
         ErrStat = 1   
         RETURN
      END IF
   ELSEIF ( IZLO >= NZ ) THEN
      IF ( IZLO == NZ .AND. Z <= TOL ) THEN
         Z    = 0.0
         IZHI = IZLO                   ! We're right on the last point, which is still okay
      ELSE      
         CALL WrScr( ' HAWCWind error: wind array boundaries violated. Grid too small in Z direction (Z='//&
                     TRIM(Num2LStr(Position(3)))//' m is above the grid).' )
         ErrStat = 3   
         RETURN
      END IF         
   ENDIF
   

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding columns for the Y position. [The lower-left corner is (1,1) when looking upwind.]
   !-------------------------------------------------------------------------------------------------

   YGRID = ( Position(2) + LengthYHalf )*deltaYInv    ! really, it's (Position(2) - -1.0*YHalfWid)

   IYLO = INT( YGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
   IYHI = IYLO + 1

   Y    = YGRID - ( IYLO - 1 )         ! a value between 0 and 1 that indicates a relative location between IYLO and IYHI
   
   IF ( IYLO >= NY .OR. IYLO < 1 ) THEN
      IF ( IYLO == 0 .AND. Y >= 1.0-TOL ) THEN
         Y    = 0.0 
         IYLO = 1
      ELSE IF ( IYLO == NY .AND. Y <= TOL ) THEN
         Y    = 0.0
         IYHI = IYLO                   ! We're right on the last point, which is still okay      
      ELSE
         CALL WrScr( ' HAWCWind error: wind array boundaries violated: Grid too small in Y direction. Y=' &
                        //TRIM(Num2LStr(Position(2)))//'; Y boundaries = ['//TRIM(Num2LStr(-1.0*LengthYHalf)) &
                        //', '//TRIM(Num2LStr(LengthYHalf))//']' )
         ErrStat = 2   
         RETURN
      END IF
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Interpolate on the Y-Z grid for each X (time) slice
   !-------------------------------------------------------------------------------------------------

   DO IC=1,NC            ! all the components

      IX = IXLO          ! start using the first time (X) slice

      DO IG = 1,2        ! repeat for 2 time slices (by changing the value of IX. note that we can't loop from IXLO to IXHI because they could be NX and 1 respectively)

         !-------------------------------------------------------------------------------------------
         ! Get the wind velocity values for the four corners of the grid for this time.
         !-------------------------------------------------------------------------------------------

         W_YL_ZL = WindData( IZLO, IYLO, IX, IC )
         W_YL_ZH = WindData( IZHI, IYLO, IX, IC )
         W_YH_ZL = WindData( IZLO, IYHI, IX, IC )
         W_YH_ZH = WindData( IZHI, IYHI, IX, IC )


         !-------------------------------------------------------------------------------------------
         ! Interpolate within the grid for this time.
         !-------------------------------------------------------------------------------------------

         W_YL_Z  = ( W_YL_ZH - W_YL_ZL )*Z + W_YL_ZL
         W_YH_Z  = ( W_YH_ZH - W_YH_ZL )*Z + W_YH_ZL
         Wnd(IG) = ( W_YH_Z  - W_YL_Z  )*Y + W_YL_Z

         IX = IXHI  ! repeat for the second time (X) slice

      END DO !IX

      !----------------------------------------------------------------------------------------------
      ! Interpolate between the two times.
      !----------------------------------------------------------------------------------------------
      
      HW_LinearInterp( IC ) = ( Wnd(2) - Wnd(1) ) * X + Wnd(1)    ! interpolated velocity
      
   END DO !IDIM


   RETURN
   
END FUNCTION HW_LinearInterp
!====================================================================================================
SUBROUTINE HW_Terminate( ErrStat )
!  This subroutine cleans up any data that is still allocated.  The (possibly) open files are 
!  closed in InflowWindMod.
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   ErrStat = 0

   IF ( ALLOCATED( WindData  ) )   DEALLOCATE( WindData,  STAT=ErrStat )   
   
   Initialized = .FALSE.


END SUBROUTINE HW_Terminate
!====================================================================================================
END MODULE HAWCWind
MODULE HHWind
! This module contains all the data and procedures that define hub-height wind files. This could 
! more accurately be called a point wind file since the wind speed at any point is calculated by 
! shear applied to the point where wind is defined.  It is basically uniform wind over the rotor disk.
! The entire file is read on initialization, then the columns that make up the wind file are
! interpolated to the time requested, and wind is calculated based on the location in space.
!
! the file contains header information (rows that contain "!"), followed by numeric data stored in
! 8 columns:   (1) Time                                  [s]
!              (2) Horizontal wind speed       (V)       [m/s]
!              (3) Wind direction              (Delta)   [deg]
!              (4) Vertical wind speed         (VZ)      [m/s]
!              (5) Horizontal linear shear     (HLinShr) [-]
!              (6) Vertical power-law shear    (VShr)    [-]
!              (7) Vertical linear shear       (VLinShr) [-]
!              (8) Gust (horizontal) velocity  (VGust)   [m/s]
!
! The horizontal wind speed at (X, Y, Z) is then calculated using the interpolated columns by
!   Vh = V * ( Z/RefHt ) ** VShr                                        ! power-law wind shear
!      + V * HLinShr/RefWid * ( Y * COS(Delta) + X * SIN(Delta) )       ! horizontal linear shear
!      + V * VLinShr/RefWid * ( Z-RefHt )                               ! vertical linear shear
!      + VGust                                                          ! gust speed
!----------------------------------------------------------------------------------------------------

   USE                     NWTC_Library
   USE                     SharedInflowDefns
   
   IMPLICIT                NONE
   PRIVATE

      
   REAL(ReKi), ALLOCATABLE      :: Tdata  (:)                              ! Time array from the HH wind file
   REAL(ReKi), ALLOCATABLE      :: DELTA  (:)                              ! HH Wind direction (angle)
   REAL(ReKi), ALLOCATABLE      :: V      (:)                              ! HH horizontal wind speed
   REAL(ReKi), ALLOCATABLE      :: VZ     (:)                              ! wind, including tower shadow, along the Z axis
   REAL(ReKi), ALLOCATABLE      :: HSHR   (:)                              ! HH Horizontal linear shear
   REAL(ReKi), ALLOCATABLE      :: VSHR   (:)                              ! HH vertical shear exponent
   REAL(ReKi), ALLOCATABLE      :: VLINSHR(:)                              ! HH vertical linear shear
   REAL(ReKi), ALLOCATABLE      :: VGUST  (:)                              ! HH wind gust

   REAL(ReKi)                   :: LinearizeDels(7)                        ! The delta values for linearization -- perhaps at some point, this could be T/F and we determine the deltas by sqrt(eps) or something similar
   REAL(ReKi)                   :: RefHt                                   ! reference height; was HH (hub height); used to center the wind
   REAL(ReKi)                   :: RefWid                                  ! reference width; was 2*R (=rotor diameter); used to scale the linear shear
   
   INTEGER                      :: NumDataLines
   INTEGER, SAVE                :: TimeIndx = 0                            ! An index into the Tdata array (to allow us faster searching, starting search from previous one)

   LOGICAL, SAVE                :: Linearize = .FALSE.                     ! If this is TRUE, we are linearizing
   
   TYPE, PUBLIC                 :: HH_Info
      REAL(ReKi)                :: ReferenceHeight
      REAL(ReKi)                :: Width
   END TYPE HH_Info
      
   PUBLIC                       :: HH_Init
   PUBLIC                       :: HH_GetWindSpeed
   PUBLIC                       :: HH_Terminate
   PUBLIC                       :: HH_SetLinearizeDels
   PUBLIC                       :: HH_Get_ADhack_WindSpeed                  ! REMOVE THIS!!!!

CONTAINS
!====================================================================================================
SUBROUTINE HH_Init(UnWind, WindFile, WindInfo, ErrStat)
! A subroutine to initialize the HHWind module.  It reads the HH file and stores the data in an
! array to use later.  It requires an initial reference height (hub height) and width (rotor diameter),
! both in meters, which are used to define the volume where wind velocities will be calculated.  This
! information is necessary because of the way the shears are defined.
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,      INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered
   TYPE(HH_Info),INTENT(IN)    :: WindInfo                     ! Additional information needed to initialize this wind type
   
   CHARACTER(*), INTENT(IN)    :: WindFile                     ! Name of the text HH wind file

      ! local variables
            
   INTEGER, PARAMETER          :: NumCols = 8                  ! Number of columns in the HH file
   REAL(ReKi)                  :: TmpData(NumCols)             ! Temp variable for reading all columns from a line 
   REAL(ReKi)                  :: DelDiff                      ! Temp variable for storing the direction difference

   INTEGER                     :: I
   INTEGER                     :: NumComments
   INTEGER                     :: ILine                        ! Counts the line number in the file
   INTEGER, PARAMETER          :: MaxTries = 100
   CHARACTER(1024)             :: Line                         ! Temp variable for reading whole line from file

    
   !-------------------------------------------------------------------------------------------------
   ! Check that it's not already initialized
   !-------------------------------------------------------------------------------------------------
      
   IF ( TimeIndx /= 0 ) THEN  
      CALL WrScr( ' HHWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
      
      LinearizeDels(:) = 0.0
      Linearize        = .FALSE.
   END IF   

  
   !-------------------------------------------------------------------------------------------------
   ! Open the file for reading
   !-------------------------------------------------------------------------------------------------
   CALL OpenFInpFile (UnWind, TRIM(WindFile), ErrStat)
   
   IF ( ErrStat /= 0 ) RETURN

   !-------------------------------------------------------------------------------------------------
   ! Find the number of comment lines
   !-------------------------------------------------------------------------------------------------
   LINE = '!'                          ! Initialize the line for the DO WHILE LOOP
   NumComments = -1
   
   DO WHILE (INDEX( LINE, '!' ) > 0 ) ! Lines containing "!" are treated as comment lines
      NumComments = NumComments + 1
      
      READ(UnWind,'( A )',IOSTAT=ErrStat) LINE
            
      IF ( ErrStat /=0 ) THEN
         CALL WrScr ( ' Error reading from HH wind file on line '//TRIM(Num2LStr(NumComments))//'.' )
         RETURN
      END IF
      
   END DO !WHILE
   
   !-------------------------------------------------------------------------------------------------
   ! Find the number of data lines
   !-------------------------------------------------------------------------------------------------
   NumDataLines = 0
   
   READ(LINE,*,IOSTAT=ErrStat) ( TmpData(I), I=1,NumCols )

   DO WHILE (ErrStat == 0)  ! read the rest of the file (until an error occurs)
      NumDataLines = NumDataLines + 1               
      
      READ(UnWind,*,IOSTAT=ErrStat) ( TmpData(I), I=1,NumCols )

   END DO !WHILE


   IF (NumDataLines < 1) THEN
      CALL WrScr ( ' Error reading data from HH wind file on line '//TRIM(Num2LStr(NumDataLines+NumComments))//'.' )
      RETURN
   ELSE
      CALL WrScr ( ' Reading '//TRIM(Num2LStr(NumDataLines))//' lines of data from the HH wind file.' )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Allocate arrays for the HH data
   !-------------------------------------------------------------------------------------------------
   ! BJJ note: If the subroutine AllocAry() is called, the CVF compiler with A2AD does not work
   !   properly.  The arrays are not properly read even though they've been allocated.
   !-------------------------------------------------------------------------------------------------
   
   IF (.NOT. ALLOCATED(Tdata) ) THEN
      ALLOCATE ( Tdata(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH time array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(V) ) THEN
      ALLOCATE ( V(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH horizontal wind speed array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(Delta) ) THEN
      ALLOCATE ( Delta(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH wind direction array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VZ) ) THEN
      ALLOCATE ( VZ(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH vertical wind speed array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(HShr) ) THEN
      ALLOCATE ( HShr(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH horizontal linear shear array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VShr) ) THEN
      ALLOCATE ( VShr(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH vertical power-law shear exponent array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VLinShr) ) THEN
      ALLOCATE ( VLinShr(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH vertical linear shear array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VGust) ) THEN
      ALLOCATE ( VGust(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH gust velocity array.' )
         RETURN
      END IF   
   END IF
   

   !-------------------------------------------------------------------------------------------------
   ! Rewind the file (to the beginning) and skip the comment lines
   !-------------------------------------------------------------------------------------------------
   REWIND( UnWind )
   
   DO I=1,NumComments
      CALL ReadCom( UnWind, TRIM(WindFile), 'Header line #'//TRIM(Num2LStr(I)), ErrStat )
      IF ( ErrStat /= 0 ) RETURN
   END DO !I


   !-------------------------------------------------------------------------------------------------
   ! Read the data arrays
   !-------------------------------------------------------------------------------------------------

   DO I=1,NumDataLines
         
      CALL ReadAry( UnWind, TRIM(WindFile), TmpData(1:NumCols), NumCols, 'TmpData', & 
                'Data from HH line '//TRIM(Num2LStr(NumComments+I)), ErrStat )
      IF (ErrStat /= 0) RETURN
                 
      Tdata(  I) = TmpData(1)
      V(      I) = TmpData(2)
      Delta(  I) = TmpData(3)*D2R 
      VZ(     I) = TmpData(4)
      HShr(   I) = TmpData(5)
      VShr(   I) = TmpData(6)
      VLinSHR(I) = TmpData(7)
      VGust(  I) = TmpData(8)           
      
   END DO !I


   !-------------------------------------------------------------------------------------------------
   ! Make sure the wind direction isn't jumping more than 180 degrees between any 2 consecutive
   ! input times.  (Avoids interpolation errors with modular arithemetic.)
   !-------------------------------------------------------------------------------------------------

   DO I=2,NumDataLines
   
      ILine = 1
      
      DO WHILE ( ILine < MaxTries )
     
         DelDiff = ( Delta(I) - Delta(I-1) )

         IF ( ABS( DelDiff ) < Pi ) EXIT  ! exit inner loop

         Delta(I) = Delta(I) - SIGN( TwoPi, DelDiff )
         
         ILine = ILine + 1

      END DO
      
      IF ( ILine >= MaxTries ) THEN
         CALL WrScr( ' Error calculating wind direction from HH file. Delta(' &
               // TRIM(Num2LStr(I  )) // ') = ' // TRIM(Num2LStr(Delta(I))) // '; Delta(' & 
               // TRIM(Num2LStr(I+1)) // ') = ' // TRIM(Num2LStr(Delta(I+1))) )
         ErrStat = 1
      END IF
           

   END DO !I


   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
   
   CLOSE( UnWind )
   

   !-------------------------------------------------------------------------------------------------
   ! Print warnings and messages
   !-------------------------------------------------------------------------------------------------
!   CALL WrScr ( ' Processed '//TRIM( Num2LStr( NumDataLines ) )//' records of HH data' )
   
   
   IF ( Tdata(1) > 0.0 ) THEN
      CALL ProgWarn( 'The hub-height wind file : "'//TRIM(ADJUSTL(WindFile))//'" starts at a time '// & 
                     'greater than zero. Interpolation errors may result.')
   ENDIF
   
   IF ( NumDataLines == 1 ) THEN
      CALL WrScr( ' Only 1 line in HH wind file. Steady, hub-height horizontal wind speed = '//TRIM(Num2LStr(V(1)))//' m/s.' )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Set the initial index into the time array (it indicates that we've initialized the module, too)
   ! and initialize the spatial scaling for the wind calculations
   !-------------------------------------------------------------------------------------------------
   TimeIndx = 1            

   RefHt  = WindInfo%ReferenceHeight
   RefWid = WindInfo%Width   


   RETURN
     
END SUBROUTINE HH_Init
!====================================================================================================
FUNCTION HH_GetWindSpeed(Time, InputPosition, ErrStat)
! This subroutine linearly interpolates the columns in the HH input file to get the values for 
! the requested time, then uses the interpolated values to calclate the wind speed at a point
! in space represented by InputPosition.
!----------------------------------------------------------------------------------------------------

   REAL(ReKi),        INTENT(IN) :: Time                 ! time from the start of the simulation
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)     ! input information: positions X,Y,Z
   INTEGER,           INTENT(OUT):: ErrStat              ! error status
   TYPE(InflIntrpOut)            :: HH_GetWindSpeed      ! return velocities (U,V,W)
   
   REAL(ReKi)                    :: CosDelta             ! cosine of Delta_tmp
   REAL(ReKi)                    :: Delta_tmp            ! interpolated Delta   at input TIME
   REAL(ReKi)                    :: HShr_tmp             ! interpolated HShr    at input TIME
   REAL(ReKi)                    :: P                    ! temporary storage for slope (in time) used in linear interpolation
   REAL(ReKi)                    :: SinDelta             ! sine of Delta_tmp
   REAL(ReKi)                    :: V_tmp                ! interpolated V       at input TIME
   REAL(ReKi)                    :: VGust_tmp            ! interpolated VGust   at input TIME
   REAL(ReKi)                    :: VLinShr_tmp          ! interpolated VLinShr at input TIME
   REAL(ReKi)                    :: VShr_tmp             ! interpolated VShr    at input TIME
   REAL(ReKi)                    :: VZ_tmp               ! interpolated VZ      at input TIME
   REAL(ReKi)                    :: V1                   ! temporary storage for horizontal velocity
   

   !-------------------------------------------------------------------------------------------------
   ! verify the module was initialized first
   !-------------------------------------------------------------------------------------------------

   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Error: Call HH_Init() before getting wind speed.')
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
      
   !-------------------------------------------------------------------------------------------------
   ! Linearly interpolate in time (or used nearest-neighbor to extrapolate) 
   ! (compare with NWTC_Num.f90\InterpStpReal)
   !-------------------------------------------------------------------------------------------------

    IF ( Linearize ) THEN  !get the perturbed wind speed

      TimeIndx      = 1
      V_tmp         = V      (1) + LinearizeDels(1)
      Delta_tmp     = Delta  (1) + LinearizeDels(2)
      VZ_tmp        = VZ     (1) + LinearizeDels(3)
      HShr_tmp      = HShr   (1) + LinearizeDels(4)
      VShr_tmp      = VShr   (1) + LinearizeDels(5)
      VLinShr_tmp   = VLinShr(1) + LinearizeDels(6)
      VGust_tmp     = VGust  (1) + LinearizeDels(7)

      ! Let's check the limits.
   ELSE IF ( Time <= Tdata(1) .OR. NumDataLines == 1 )  THEN
   
      TimeIndx      = 1
      V_tmp         = V      (1)
      Delta_tmp     = Delta  (1)
      VZ_tmp        = VZ     (1)
      HShr_tmp      = HShr   (1)
      VShr_tmp      = VShr   (1)
      VLinShr_tmp   = VLinShr(1)
      VGust_tmp     = VGust  (1)   
         
   ELSE IF ( Time >= Tdata(NumDataLines) )  THEN
   
      TimeIndx      = NumDataLines - 1
      V_tmp         = V      (NumDataLines)
      Delta_tmp     = Delta  (NumDataLines)
      VZ_tmp        = VZ     (NumDataLines)
      HShr_tmp      = HShr   (NumDataLines)
      VShr_tmp      = VShr   (NumDataLines)
      VLinShr_tmp   = VLinShr(NumDataLines)
      VGust_tmp     = VGust  (NumDataLines)
      
   ELSE
   
         ! Let's interpolate!

      TimeIndx = MAX( MIN( TimeIndx, NumDataLines-1 ), 1 )

      DO

         IF ( Time < Tdata(TimeIndx) )  THEN

            TimeIndx = TimeIndx - 1

         ELSE IF ( Time >= Tdata(TimeIndx+1) )  THEN

            TimeIndx = TimeIndx + 1

         ELSE
            P           = ( Time - Tdata(TimeIndx) )/( Tdata(TimeIndx+1) - Tdata(TimeIndx) )
            V_tmp       = ( V(      TimeIndx+1) - V(      TimeIndx) )*P + V(      TimeIndx)
            Delta_tmp   = ( Delta(  TimeIndx+1) - Delta(  TimeIndx) )*P + Delta(  TimeIndx)
            VZ_tmp      = ( VZ(     TimeIndx+1) - VZ(     TimeIndx) )*P + VZ(     TimeIndx)
            HShr_tmp    = ( HShr(   TimeIndx+1) - HShr(   TimeIndx) )*P + HShr(   TimeIndx)
            VShr_tmp    = ( VShr(   TimeIndx+1) - VShr(   TimeIndx) )*P + VShr(   TimeIndx)
            VLinShr_tmp = ( VLinShr(TimeIndx+1) - VLinShr(TimeIndx) )*P + VLinShr(TimeIndx)
            VGust_tmp   = ( VGust(  TimeIndx+1) - VGust(  TimeIndx) )*P + VGust(  TimeIndx)
            EXIT

         END IF

      END DO
      
   END IF

   
   !-------------------------------------------------------------------------------------------------
   ! calculate the wind speed at this time
   !-------------------------------------------------------------------------------------------------
   
   CosDelta = COS( Delta_tmp )
   SinDelta = SIN( Delta_tmp )
   
   V1 = V_tmp * ( ( InputPosition(3)/RefHt ) ** VShr_tmp &                                  ! power-law wind shear
        + ( HShr_tmp   * ( InputPosition(2) * CosDelta + InputPosition(1) * SinDelta ) &    ! horizontal linear shear
        +  VLinShr_tmp * ( InputPosition(3)-RefHt ) )/RefWid  ) &                           ! vertical linear shear
        + VGUST_tmp                                                                         ! gust speed
   
   HH_GetWindSpeed%Velocity(1) =  V1 * CosDelta
   HH_GetWindSpeed%Velocity(2) = -V1 * SinDelta
   HH_GetWindSpeed%Velocity(3) =  VZ_tmp      


   RETURN

END FUNCTION HH_GetWindSpeed
!====================================================================================================
FUNCTION HH_Get_ADHack_WindSpeed(Time, InputPosition, ErrStat)
! This subroutine linearly interpolates the columns in the HH input file to get the values for 
! the requested time, then uses the interpolated values to calclate the wind speed at a point
! in space represented by InputPosition. THIS FUNCTION SHOULD BE REMOVED!!!!! (used for DISK VEL ONLY)
!----------------------------------------------------------------------------------------------------

   REAL(ReKi),        INTENT(IN) :: Time                 ! time from the start of the simulation
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)     ! input information: positions X,Y,Z   -   NOT USED HERE!!!
   INTEGER,           INTENT(OUT):: ErrStat              ! error status
   TYPE(InflIntrpOut)            :: HH_Get_ADHack_WindSpeed      ! return velocities (U,V,W)
   
   REAL(ReKi)                    :: Delta_tmp            ! interpolated Delta   at input TIME
   REAL(ReKi)                    :: P                    ! temporary storage for slope (in time) used in linear interpolation
   REAL(ReKi)                    :: V_tmp                ! interpolated V       at input TIME
   REAL(ReKi)                    :: VZ_tmp               ! interpolated VZ      at input TIME
   

   !-------------------------------------------------------------------------------------------------
   ! verify the module was initialized first
   !-------------------------------------------------------------------------------------------------

   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Error: Call HH_Init() before getting wind speed.')
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
      
   !-------------------------------------------------------------------------------------------------
   ! Linearly interpolate in time (or use nearest-neighbor to extrapolate) 
   ! (compare with NWTC_Num.f90\InterpStpReal)
   !-------------------------------------------------------------------------------------------------

     ! Let's check the limits.

   IF ( Time <= Tdata(1) .OR. NumDataLines == 1)  THEN
   
      TimeIndx      = 1
      V_tmp         = V      (1)
      Delta_tmp     = Delta  (1)
      VZ_tmp        = VZ     (1)
         
   ELSE IF ( Time >= Tdata(NumDataLines) )  THEN
   
      TimeIndx      = NumDataLines - 1
      V_tmp         = V      (NumDataLines)
      Delta_tmp     = Delta  (NumDataLines)
      VZ_tmp        = VZ     (NumDataLines)
      
   ELSE
   
         ! Let's interpolate!

      TimeIndx = MAX( MIN( TimeIndx, NumDataLines-1 ), 1 )

      DO

         IF ( Time < Tdata(TimeIndx) )  THEN

            TimeIndx = TimeIndx - 1

         ELSE IF ( Time >= Tdata(TimeIndx+1) )  THEN

            TimeIndx = TimeIndx + 1

         ELSE
            P           = ( Time - Tdata(TimeIndx) )/( Tdata(TimeIndx+1) - Tdata(TimeIndx) )
            V_tmp       = ( V(      TimeIndx+1) - V(      TimeIndx) )*P + V(      TimeIndx)
            Delta_tmp   = ( Delta(  TimeIndx+1) - Delta(  TimeIndx) )*P + Delta(  TimeIndx)
            VZ_tmp      = ( VZ(     TimeIndx+1) - VZ(     TimeIndx) )*P + VZ(     TimeIndx)
            EXIT

         END IF

      END DO
      
   END IF
   
   !-------------------------------------------------------------------------------------------------
   ! calculate the wind speed at this time
   !-------------------------------------------------------------------------------------------------
      
   HH_Get_ADHack_WindSpeed%Velocity(1) =  V_tmp * COS( Delta_tmp )
   HH_Get_ADHack_WindSpeed%Velocity(2) = -V_tmp * SIN( Delta_tmp )
   HH_Get_ADHack_WindSpeed%Velocity(3) =  VZ_tmp      


   RETURN

END FUNCTION HH_Get_ADHack_WindSpeed
!====================================================================================================
SUBROUTINE HH_SetLinearizeDels( Perturbations, ErrStat )
! This subroutine sets the perturbation values for the linearization scheme.
!----------------------------------------------------------------------------------------------------

   REAL(ReKi),       INTENT(IN)  :: Perturbations(7)     ! purturbations for each of the 7 input parameters
   INTEGER,          INTENT(OUT) :: ErrStat              ! time from the start of the simulation

   !-------------------------------------------------------------------------------------------------
   ! verify the module was initialized first
   !-------------------------------------------------------------------------------------------------

   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Error: Call HH_Init() before getting wind speed.')
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF

   Linearize = .TRUE.
   LinearizeDels(:) = Perturbations(:)

   RETURN

END SUBROUTINE HH_SetLinearizeDels
!====================================================================================================
SUBROUTINE HH_Terminate(ErrStat)

   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered

   INTEGER                     :: SumErrs
   
   SumErrs = 0

   IF ( ALLOCATED(Tdata  ) ) DEALLOCATE( Tdata,   STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(DELTA  ) ) DEALLOCATE( DELTA,   STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(V      ) ) DEALLOCATE( V,       STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VZ     ) ) DEALLOCATE( VZ,      STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(HSHR   ) ) DEALLOCATE( HSHR,    STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VSHR   ) ) DEALLOCATE( VSHR,    STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VGUST  ) ) DEALLOCATE( VGUST,   STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VLINSHR) ) DEALLOCATE( VLINSHR, STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)

   ErrStat  = SumErrs
   TimeIndx = 0            
   
END SUBROUTINE HH_Terminate   
!====================================================================================================
END MODULE HHWind
MODULE UserWind
!  The purpose of this module is to allow user-defined wind.  
!----------------------------------------------------------------------------------------------------

   USE                           NWTC_Library
   USE                           SharedInflowDefns

   IMPLICIT                      NONE
   PRIVATE
    
    
      ! define variables for UserWind here
      
   LOGICAL, SAVE              :: Initialized = .FALSE.         ! This variable indicates if the initialization routine has been run
   
   REAL(ReKi)                 :: UWmeanU                       ! Possibly instantaneous, disk-averaged wind speeds.
   REAL(ReKi)                 :: UWmeanV                       !
   REAL(ReKi)                 :: UWmeanW                       !   
   

      ! allow the initialization and termination routines to be public (called from outside)

   PUBLIC                     :: UsrWnd_Init
   PUBLIC                     :: UsrWnd_Terminate
   PUBLIC                     :: UsrWnd_GetValue
   PUBLIC                     :: UsrWnd_GetWindSpeed

CONTAINS
!====================================================================================================
SUBROUTINE UsrWnd_Init(ErrStat)
!  This subroutine is called at the beginning of
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' UserWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Perform any initialization steps here (read input files, etc.)
   !-------------------------------------------------------------------------------------------------
   
   CALL WrScr( '***** NOTE: User-defined wind employed *****' )


      ! Set the disk-average wind vector.
   
   UWmeanU = 10.0
   UWmeanV =  0.0
   UWmeanW =  0.0

   
   !-------------------------------------------------------------------------------------------------
   ! Set the initialization flag
   !-------------------------------------------------------------------------------------------------
   
   Initialized = .TRUE.
   
   RETURN

END SUBROUTINE UsrWnd_Init
!====================================================================================================
FUNCTION UsrWnd_GetValue(VarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the VarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------
   
   CHARACTER(*),   INTENT(IN)    :: VarName
   INTEGER,        INTENT(OUT)   :: ErrStat           ! return 0 if no errors; non-zero otherwise
   REAL(ReKi)                    :: UsrWnd_GetValue

   
   CHARACTER(20)                 :: VarNameUC         ! upper-case VarName
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN   
      CALL WrScr( 'Initialize UserWind before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = VarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
   
      CASE ('MEANU' )
         UsrWnd_GetValue = UWmeanU
         
      CASE ('MEANV' )
         UsrWnd_GetValue = UWmeanV

      CASE ('MEANW' )
         UsrWnd_GetValue = UWmeanW
         
      CASE DEFAULT
         CALL WrScr( ' Invalid variable name in UsrWnd_GetValue().' )
         ErrStat = 1
         
   END SELECT
      
   

END FUNCTION UsrWnd_GetValue
!====================================================================================================
FUNCTION UsrWnd_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are 
! requested. It returns the velocities at the specified time and space.
!----------------------------------------------------------------------------------------------------
   
   REAL(ReKi),        INTENT(IN) :: Time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)        ! X,Y,Z (z is 0 at ground level)
   INTEGER,           INTENT(OUT):: ErrStat                 ! return 0 if no errors; non-zero otherwise
   TYPE(InflIntrpOut)            :: UsrWnd_GetWindSpeed
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   
   IF ( .NOT. Initialized ) THEN   
      CALL WrScr( 'Initialize UserWind before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Calculate the wind speed at this time and position.
   !-------------------------------------------------------------------------------------------------   
   !     Time
   !     X = InputPosition(1)           ! relative to the undeflected tower centerline (positive downwind)
   !     Y = InputPosition(2)           ! relative to the undeflected tower centerline (positive left when looking downwind)
   !     Z = InputPosition(3)           ! relative to the ground (0 is ground level)
   !-------------------------------------------------------------------------------------------------

      ! We'll test this with steady winds for now.

   UsrWnd_GetWindSpeed%Velocity(1) = 10.0    ! U velocity (along positive X)
   UsrWnd_GetWindSpeed%Velocity(2) =  0.0    ! V velocity (along positive Y)
   UsrWnd_GetWindSpeed%Velocity(3) =  0.0    ! V velocity (along positive Z)
   

END FUNCTION UsrWnd_GetWindSpeed
!====================================================================================================
SUBROUTINE UsrWnd_Terminate(ErrStat)
!  This subroutine is called at the end of program execution (including after fatal errors occur).  
!  It should close any files that could be open and deallocate any arrays that have been allocated.
!----------------------------------------------------------------------------------------------------
      
   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   ErrStat = 0

   !-------------------------------------------------------------------------------------------------
   ! Close files
   !-------------------------------------------------------------------------------------------------
      
      
   !-------------------------------------------------------------------------------------------------
   ! Deallocate arrays
   !-------------------------------------------------------------------------------------------------

      
   !-------------------------------------------------------------------------------------------------
   ! Set the initialization flag
   !-------------------------------------------------------------------------------------------------
   
   Initialized = .FALSE.

END SUBROUTINE UsrWnd_Terminate
!====================================================================================================
END MODULE UserWind
MODULE InflowWind
! This module is used to read and process the (undisturbed) inflow winds.  It must be initialized
! using WindInf_Init() with the name of the file, the file type, and possibly reference height and
! width (depending on the type of wind file being used).  This module calls appropriate routines
! in the wind modules so that the type of wind becomes seamless to the user.  WindInf_Terminate()
! should be called when the program has finshed.
!
! Data are assumed to be in units of meters and seconds.  Z is measured from the ground (NOT the hub!).
!
!  7 Oct 2009    Initial Release with AeroDyn 13.00.00      B. Jonkman, NREL/NWTC
! 14 Nov 2011    v1.00.01b-bjj                              B. Jonkman
!  1 Aug 2012    v1.01.00a-bjj                              B. Jonkman
! 10 Aug 2012    v1.01.00b-bjj                              B. Jonkman
!----------------------------------------------------------------------------------------------------

   USE                              NWTC_Library
   USE                              SharedInflowDefns

   !-------------------------------------------------------------------------------------------------
   ! The included wind modules
   !-------------------------------------------------------------------------------------------------

   USE                              FFWind               ! full-field binary wind files
   USE                              HHWind               ! hub-height text wind files
   USE                              FDWind               ! 4-D binary wind files
   USE                              CTWind               ! coherent turbulence from KH billow - binary file superimposed on another wind type
   USE                              UserWind             ! user-defined wind module
   USE                              HAWCWind             ! full-field binary wind files in HAWC format


   IMPLICIT                         NONE
   PRIVATE

   !-------------------------------------------------------------------------------------------------
   ! Private internal variables
   !-------------------------------------------------------------------------------------------------

   INTEGER, SAVE                  :: WindType = Undef_Wind  ! Wind Type Flag

   INTEGER                        :: UnWind   = 91          ! The unit number used for wind inflow files

   LOGICAL, SAVE                  :: CT_Flag  = .FALSE.     ! determines if coherent turbulence is used

   !-------------------------------------------------------------------------------------------------
   ! Definitions of public types and routines
   !-------------------------------------------------------------------------------------------------

   TYPE, PUBLIC :: InflInitInfo
      CHARACTER(1024)             :: WindFileName
      INTEGER                     :: WindFileType
      REAL(ReKi)                  :: ReferenceHeight        ! reference height for HH and/or 4D winds (was hub height), in meters
      REAL(ReKi)                  :: Width                  ! width of the HH file (was 2*R), in meters
   END TYPE InflInitInfo

   PUBLIC                         :: WindInf_Init           ! Initialization subroutine
   PUBLIC                         :: WindInf_GetVelocity    ! function to get wind speed at point in space and time
   PUBLIC                         :: WindInf_Terminate      ! subroutine to clean up

   PUBLIC                         :: WindInf_ADhack_diskVel ! used to keep old AeroDyn functionality--remove soon!
   PUBLIC                         :: WindInf_ADhack_DIcheck ! used to keep old AeroDyn functionality--remove soon!
   PUBLIC                         :: WindInf_LinearizePerturbation !used for linearization; should be modified
!!----Removed during conversion to new framework
!!       PUBLIC                         :: WindInf_GetMean        ! function to get the mean wind speed at a point in space
!!       PUBLIC                         :: WindInf_GetStdDev      ! function to calculate standard deviation at a point in space
!!       PUBLIC                         :: WindInf_GetTI          ! function to get TI at a point in space

   CHARACTER(99),PARAMETER        :: WindInfVer = 'InflowWind (v1.01.00b-bjj, 10-Aug-2012)'

CONTAINS
!====================================================================================================
SUBROUTINE WindInf_Init( FileInfo, ErrStat )
!  Open and read the wind files, allocating space for necessary variables
!
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   TYPE(InflInitInfo), INTENT(IN)   :: FileInfo
   INTEGER,            INTENT(OUT)  :: ErrStat

      ! Local variables

   TYPE(HH_Info)                    :: HHInitInfo
   TYPE(CT_Backgr)                  :: BackGrndValues

   REAL(ReKi)                       :: Height
   REAL(ReKi)                       :: HalfWidth
   CHARACTER(1024)                  :: FileName


   IF ( WindType /= Undef_Wind ) THEN
      CALL WrScr( ' Wind inflow has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      WindType = FileInfo%WindFileType
      FileName = FileInfo%WindFileName
      CALL NWTC_Init()
      CALL WrScr1( ' Using '//TRIM( WindInfVer ) )

   END IF

   !-------------------------------------------------------------------------------------------------
   ! Get default wind type, based on file name, if requested
   !-------------------------------------------------------------------------------------------------
   IF ( FileInfo%WindFileType == DEFAULT_Wind ) THEN
      WindType = GetWindType( FileName, ErrStat )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Check for coherent turbulence file (KH superimposed on a background wind file)
   ! Initialize the CTWind module and initialize the module of the other wind type.
   !-------------------------------------------------------------------------------------------------

   IF ( WindType == CTP_Wind ) THEN

      CALL CT_Init(UnWind, FileName, BackGrndValues, ErrStat)
      IF (ErrStat /= 0) THEN
         CALL WindInf_Terminate( ErrStat )
         WindType = Undef_Wind
         ErrStat  = 1
         RETURN
      END IF

      FileName = BackGrndValues%WindFile
      WindType = BackGrndValues%WindFileType
      CT_Flag  = BackGrndValues%CoherentStr

   ELSE

      CT_Flag  = .FALSE.

   END IF


   !-------------------------------------------------------------------------------------------------
   ! Initialize based on the wind type
   !-------------------------------------------------------------------------------------------------

   SELECT CASE ( WindType )

      CASE (HH_Wind)

         HHInitInfo%ReferenceHeight = FileInfo%ReferenceHeight
         HHInitInfo%Width           = FileInfo%Width

         CALL HH_Init( UnWind, FileName, HHInitInfo, ErrStat )

!        IF (CT_Flag) CALL CT_SetRefVal(FileInfo%ReferenceHeight, 0.5*FileInfo%Width, ErrStat)
         IF (ErrStat == 0 .AND. CT_Flag) CALL CT_SetRefVal(FileInfo%ReferenceHeight, REAL(0.0, ReKi), ErrStat)


      CASE (FF_Wind)

         CALL FF_Init( UnWind, FileName, ErrStat )


            ! Set CT parameters

         IF ( ErrStat == 0 .AND. CT_Flag ) THEN
            Height     = FF_GetValue('HubHeight', ErrStat)
            IF ( ErrStat /= 0 ) Height = FileInfo%ReferenceHeight

            HalfWidth  = 0.5*FF_GetValue('GridWidth', ErrStat)
            IF ( ErrStat /= 0 ) HalfWidth = 0

            CALL CT_SetRefVal(Height, HalfWidth, ErrStat)
         END IF


      CASE (UD_Wind)

         CALL UsrWnd_Init(ErrStat)


      CASE (FD_Wind)

         CALL FD_Init(UnWind, FileName, FileInfo%ReferenceHeight, ErrStat)

      CASE (HAWC_Wind)

         CALL HW_Init( UnWind, FileName, ErrStat )

      CASE DEFAULT

         CALL WrScr(' Error: Undefined wind type in WindInflow_Init()' )
         ErrStat = 1
         RETURN

   END SELECT

   IF ( ErrStat /= 0 ) THEN
      CALL WindInf_Terminate( ErrStat )  !Just in case we've allocated something
      WindType = Undef_Wind
      ErrStat  = 1
   END IF

   RETURN

END SUBROUTINE WindInf_Init
!====================================================================================================
FUNCTION WindInf_GetVelocity(Time, InputPosition, ErrStat)
! Get the wind speed at a point in space and time
!----------------------------------------------------------------------------------------------------

      ! passed variables
   REAL(ReKi),       INTENT(IN)  :: Time
   REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
   INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise

      ! local variables
   TYPE(InflIntrpOut)            :: WindInf_GetVelocity     ! U, V, W velocities
   TYPE(InflIntrpOut)            :: CTWindSpeed             ! U, V, W velocities to superimpose on background wind


   ErrStat = 0

   SELECT CASE ( WindType )
      CASE (HH_Wind)
         WindInf_GetVelocity = HH_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE (FF_Wind)
         WindInf_GetVelocity = FF_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE (UD_Wind)
         WindInf_GetVelocity = UsrWnd_GetWindSpeed( Time, InputPosition, ErrStat )

      CASE (FD_Wind)
         WindInf_GetVelocity = FD_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE (HAWC_Wind)
         WindInf_GetVelocity = HW_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in WindInf_GetVelocity(). ' &
                   //'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1
         WindInf_GetVelocity%Velocity(:) = 0.0

   END SELECT


   IF (ErrStat /= 0) THEN

      WindInf_GetVelocity%Velocity(:) = 0.0

   ELSE

         ! Add coherent turbulence to background wind

      IF (CT_Flag) THEN

         CTWindSpeed = CT_GetWindSpeed(Time, InputPosition, ErrStat)
         IF (ErrStat /=0 ) RETURN

         WindInf_GetVelocity%Velocity(:) = WindInf_GetVelocity%Velocity(:) + CTWindSpeed%Velocity(:)

      ENDIF

   ENDIF

END FUNCTION WindInf_GetVelocity
!====================================================================================================
!!    !====================================================================================================
FUNCTION GetWindType( FileName, ErrStat )
!  This subroutine checks the file FileName to see what kind of wind file we are using.  Used when
!  the wind file type is unknown.
!----------------------------------------------------------------------------------------------------


   IMPLICIT             NONE


      ! Passed Variables:

   CHARACTER(*),INTENT(INOUT) :: FileName
   INTEGER, INTENT(OUT)       :: ErrStat

      ! Function definition
   INTEGER                    :: GetWindType

      ! Local Variables:

   INTEGER                    :: IND
   LOGICAL                    :: Exists

   CHARACTER(  3)             :: FileNameEnd
   CHARACTER(  8)             :: WndFilNam

   CHARACTER(1024)            :: FileRoot


   ErrStat = 0

   !-------------------------------------------------------------------------------------------------
   ! Check for user-defined wind file first; file starts with "USERWIND"
   !-------------------------------------------------------------------------------------------------

   WndFilNam = FileName
   CALL Conv2UC( WndFilNam )

   IF ( WndFilNam == 'USERWIND' )  THEN

      CALL WrScr1( ' Detected user-defined wind file.' )
      GetWindType = UD_Wind

      RETURN
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Get the file extension (or at least what we expect the extension to be)
   !-------------------------------------------------------------------------------------------------
   CALL GetRoot ( FileName, FileRoot )                      ! Get the root name

   IND = LEN_TRIM( FileRoot ) + 1
   IF ( IND < LEN_TRIM( FileName ) ) THEN
      FileNameEnd = FileName(IND+1:)                        ! Get the extenstion, starting at first character past (may not be the whole "extension")
      CALL Conv2UC (FileNameEnd)
   ELSE
      FileNameEnd = ""
      IND = 0
   END IF


   !-------------------------------------------------------------------------------------------------
   ! If there was no '.' in the file name, assume FF, and add a .wnd extension
   !-------------------------------------------------------------------------------------------------
   IF ( IND == 0 ) THEN
      CALL WrScr1(' No file extension found. Assuming '//TRIM(FileName)// &
                  ' is a binary FF wind file with a ".wnd" extension.')
      GetWindType = FF_Wind
      FileName = TRIM(FileName)//'.wnd'
      RETURN
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Base the file type on the extension
   !-------------------------------------------------------------------------------------------------
   SELECT CASE ( TRIM(FileNameEnd) )
      CASE ('WND')

            ! If a summary file exists, assume FF; otherwise, assume HH file.

         INQUIRE ( FILE=FileName(1:IND)//'sum' , EXIST=Exists )
         IF (Exists) THEN
            CALL WrScr1(' Assuming '//TRIM(FileName)//' is a binary FF wind file.')
            GetWindType = FF_Wind
         ELSE
            CALL WrScr1(' Assuming '//TRIM(FileName)//' is a formatted HH wind file.')
            GetWindType = HH_Wind
         END IF

      CASE ('BTS')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a binary FF wind file.')
         GetWindType = FF_Wind

      CASE ('CTP')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a coherent turbulence wind file.')
         GetWindType = CTP_Wind

      CASE ('FDP')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a binary 4-dimensional wind file.')
         GetWindType = FD_Wind

      CASE ('HWC')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' contains full-field wind parameters in HAWC format.')
         GetWindType = HAWC_Wind

      CASE DEFAULT
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a formatted HH wind file.')
         GetWindType = HH_Wind

   END SELECT


RETURN
END FUNCTION GetWindType
!====================================================================================================
SUBROUTINE WindInf_LinearizePerturbation( LinPerturbations, ErrStat )
! This function is used in FAST's linearization scheme.  It should be fixed at some point.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,    INTENT(OUT)    :: ErrStat

   REAL(ReKi), INTENT(IN)     :: LinPerturbations(7)

      ! Local variables


   ErrStat = 0

   SELECT CASE ( WindType )
      CASE (HH_Wind)

         CALL HH_SetLinearizeDels( LinPerturbations, ErrStat )

      CASE ( FF_Wind, UD_Wind, FD_Wind, HAWC_Wind )

         CALL WrScr( ' Error: Linearization is valid only with HH wind files.' )
         ErrStat = 1

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in WindInf_LinearizePerturbation(). '// &
                     'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1

   END SELECT


END SUBROUTINE WindInf_LinearizePerturbation
!====================================================================================================
FUNCTION WindInf_ADhack_diskVel( Time, InpPosition, ErrStat )
! This function should be deleted ASAP.  It's purpose is to reproduce results of AeroDyn 12.57;
! when a consensus on the definition of "average velocity" is determined, this function will be
! removed.  InpPosition(2) should be the rotor radius; InpPosition(3) should be hub height
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   REAL(ReKi), INTENT(IN)     :: Time
   REAL(ReKi), INTENT(IN)     :: InpPosition(3)
   INTEGER, INTENT(OUT)       :: ErrStat

      ! Function definition
   REAL(ReKi)                 :: WindInf_ADhack_diskVel(3)

      ! Local variables
   TYPE(InflIntrpOut)         :: NewVelocity             ! U, V, W velocities
   REAL(ReKi)                 :: Position(3)
   INTEGER                    :: IY
   INTEGER                    :: IZ


   ErrStat = 0

   SELECT CASE ( WindType )
      CASE (HH_Wind)

!      VXGBAR =  V * COS( DELTA )
!      VYGBAR = -V * SIN( DELTA )
!      VZGBAR =  VZ

         Position    = (/ REAL(0.0, ReKi), REAL(0.0, ReKi), InpPosition(3) /)
         NewVelocity = HH_Get_ADHack_WindSpeed(Time, Position, ErrStat)

         WindInf_ADhack_diskVel(:) = NewVelocity%Velocity(:)


      CASE (FF_Wind)
!      VXGBAR = MeanFFWS
!      VYGBAR = 0.0
!      VZGBAR = 0.0

         WindInf_ADhack_diskVel(1)   = FF_GetValue('MEANFFWS', ErrStat)
         WindInf_ADhack_diskVel(2:3) = 0.0

      CASE (UD_Wind)
!      VXGBAR = UWmeanU
!      VYGBAR = UWmeanV
!      VZGBAR = UWmeanW

         WindInf_ADhack_diskVel(1)   = UsrWnd_GetValue('MEANU', ErrStat)
         IF (ErrStat /= 0) RETURN
         WindInf_ADhack_diskVel(2)   = UsrWnd_GetValue('MEANV', ErrStat)
         IF (ErrStat /= 0) RETURN
         WindInf_ADhack_diskVel(3)   = UsrWnd_GetValue('MEANW', ErrStat)

      CASE (FD_Wind)
!      XGrnd = 0.0
!      YGrnd = 0.5*RotDiam
!      ZGrnd = 0.5*RotDiam
!      CALL FD_Interp
!      VXGBAR = FDWind( 1 )
!      VYGBAR = FDWind( 2 )
!      VZGBAR = FDWind( 3 )
!
!      XGrnd =  0.0
!      YGrnd = -0.5*RotDiam
!      ZGrnd =  0.5*RotDiam
!      CALL FD_Interp
!      VXGBAR = VXGBAR + FDWind( 1 )
!      VYGBAR = VYGBAR + FDWind( 2 )
!      VZGBAR = VZGBAR + FDWind( 3 )
!
!      XGrnd =  0.0
!      YGrnd = -0.5*RotDiam
!      ZGrnd = -0.5*RotDiam
!      CALL FD_Interp
!      VXGBAR = VXGBAR + FDWind( 1 )
!      VYGBAR = VYGBAR + FDWind( 2 )
!      VZGBAR = VZGBAR + FDWind( 3 )
!
!      XGrnd =  0.0
!      YGrnd =  0.5*RotDiam
!      ZGrnd = -0.5*RotDiam
!      CALL FD_Interp
!      VXGBAR = 0.25*( VXGBAR + FDWind( 1 ) )
!      VYGBAR = 0.25*( VYGBAR + FDWind( 2 ) )
!      VZGBAR = 0.25*( VZGBAR + FDWind( 3 ) )


         Position(1) = 0.0
         WindInf_ADhack_diskVel(:) = 0.0

         DO IY = -1,1,2
            Position(2)  =  IY*FD_GetValue('RotDiam',ErrStat)

            DO IZ = -1,1,2
               Position(3)  = IZ*InpPosition(2) + InpPosition(3)

               NewVelocity = WindInf_GetVelocity(Time, Position, ErrStat)
               WindInf_ADhack_diskVel(:) = WindInf_ADhack_diskVel(:) + NewVelocity%Velocity(:)
            END DO
         END DO
         WindInf_ADhack_diskVel(:) = 0.25*WindInf_ADhack_diskVel(:)

      CASE (HAWC_Wind)
         WindInf_ADhack_diskVel(1)   = HW_GetValue('UREF', ErrStat)
         WindInf_ADhack_diskVel(2:3) = 0.0

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in WindInf_ADhack_diskVel(). '// &
                    'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1

   END SELECT

   RETURN

END FUNCTION WindInf_ADhack_diskVel
!====================================================================================================
FUNCTION WindInf_ADhack_DIcheck( ErrStat )
! This function should be deleted ASAP.  It's purpose is to reproduce results of AeroDyn 12.57;
! it performs a wind speed check for the dynamic inflow initialization
! it returns MFFWS for the FF wind files; for all others, a sufficiently large number is used ( > 8 m/s)
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER, INTENT(OUT)       :: ErrStat

      ! Function definition
   REAL(ReKi)                 :: WindInf_ADhack_DIcheck


   ErrStat = 0

   SELECT CASE ( WindType )
      CASE (HH_Wind, UD_Wind, FD_Wind )

         WindInf_ADhack_DIcheck = 50  ! just return something greater than 8 m/s

      CASE (FF_Wind)

         WindInf_ADhack_DIcheck = FF_GetValue('MEANFFWS', ErrStat)

      CASE (HAWC_Wind)

         WindInf_ADhack_DIcheck = HW_GetValue('UREF', ErrStat)

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in WindInf_ADhack_DIcheck(). '// &
                    'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1

   END SELECT

   RETURN

END FUNCTION WindInf_ADhack_DIcheck
!====================================================================================================
SUBROUTINE WindInf_Terminate( ErrStat )
! Clean up the allocated variables and close all open files.  Reset the initialization flag so
! that we have to reinitialize before calling the routines again.
!----------------------------------------------------------------------------------------------------

   INTEGER, INTENT(OUT)       :: ErrStat     !bjj: do we care if there's an error on cleanup?


      ! Close the wind file, if it happens to be open

   CLOSE( UnWind )


      ! End the sub-modules (deallocates their arrays and closes their files):

   SELECT CASE ( WindType )

      CASE (HH_Wind)
         CALL HH_Terminate(     ErrStat )

      CASE (FF_Wind)
         CALL FF_Terminate(     ErrStat )

      CASE (UD_Wind)
         CALL UsrWnd_Terminate( ErrStat )

      CASE (FD_Wind)
         CALL FD_Terminate(     ErrStat )

      CASE (HAWC_Wind)
         CALL HW_Terminate(     ErrStat )

      CASE ( Undef_Wind )
         ! Do nothing

      CASE DEFAULT  ! keep this check to make sure that all new wind types have a terminate function
         CALL WrScr(' Undefined wind type in WindInf_Terminate().' )
         ErrStat = 1

   END SELECT

!   IF (CT_Flag) CALL CT_Terminate( ErrStat )
   CALL CT_Terminate( ErrStat )


      ! Reset the wind type so that the initialization routine must be called
  WindType = Undef_Wind
   CT_Flag  = .FALSE.


END SUBROUTINE WindInf_Terminate
!====================================================================================================
END MODULE InflowWind





!!----Remove this functionality for now. Might put it back in sometime after the conversion to the new framework ----
!!    FUNCTION WindInf_GetMean(StartTime, EndTime, delta_time, InputPosition,  ErrStat )
!!    !  This function returns the mean wind speed
!!    !----------------------------------------------------------------------------------------------------
!!
!!          ! passed variables
!!       REAL(ReKi),       INTENT(IN)  :: StartTime
!!       REAL(ReKi),       INTENT(IN)  :: EndTime
!!       REAL(ReKi),       INTENT(IN)  :: delta_time
!!       REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
!!       INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise
!!
!!          ! function definition
!!       REAL(ReKi)                    :: WindInf_GetMean(3)      ! MEAN U, V, W
!!
!!          ! local variables
!!       REAL(ReKi)                    :: Time
!!       REAL(DbKi)                    :: SumVel(3)
!!       INTEGER                       :: I
!!       INTEGER                       :: Nt
!!
!!       TYPE(InflIntrpOut)            :: NewVelocity             ! U, V, W velocities
!!
!!
!!       Nt = (EndTime - StartTime) / delta_time
!!
!!       SumVel(:) = 0.0
!!       ErrStat   = 0
!!
!!
!!       DO I=1,Nt
!!
!!          Time = StartTime + (I-1)*delta_time
!!
!!          NewVelocity = WindInf_GetVelocity(Time, InputPosition, ErrStat)
!!          IF ( ErrStat /= 0 ) THEN
!!             WindInf_GetMean(:) = SumVel(:) / REAL(I-1, ReKi)
!!             RETURN
!!          ELSE
!!             SumVel(:) = SumVel(:) + NewVelocity%Velocity(:)
!!          END IF
!!
!!       END DO
!!
!!       WindInf_GetMean(:) = SumVel(:) / REAL(Nt, ReKi)
!!
!!
!!    END FUNCTION WindInf_GetMean
!!    !====================================================================================================
!!    FUNCTION WindInf_GetStdDev(StartTime, EndTime, delta_time, InputPosition,  ErrStat )
!!    !  This function returns the mean wind speed (mean, std, TI, etc)
!!    !----------------------------------------------------------------------------------------------------
!!
!!          ! passed variables
!!       REAL(ReKi),       INTENT(IN)  :: StartTime
!!       REAL(ReKi),       INTENT(IN)  :: EndTime
!!       REAL(ReKi),       INTENT(IN)  :: delta_time
!!       REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
!!       INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise
!!
!!          ! function definition
!!       REAL(ReKi)                    :: WindInf_GetStdDev(3)    ! STD U, V, W
!!
!!          ! local variables
!!       REAL(ReKi)                    :: Time
!!       REAL(ReKi), ALLOCATABLE       :: Velocity(:,:)
!!       REAL(DbKi)                    :: SumAry(3)
!!       REAL(DbKi)                    :: MeanVel(3)
!!       INTEGER                       :: I
!!       INTEGER                       :: Nt
!!
!!       TYPE(InflIntrpOut)            :: NewVelocity             ! U, V, W velocities
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Initialize
!!       !-------------------------------------------------------------------------------------------------
!!
!!       WindInf_GetStdDev(:) = 0.0
!!
!!       Nt = (EndTime - StartTime) / delta_time
!!
!!       IF ( Nt < 2 ) RETURN    ! StdDev is 0
!!
!!
!!       IF (.NOT. ALLOCATED(Velocity)) THEN
!!    !      CALL AllocAry( Velocity, 3, Nt, 'StdDev velocity', ErrStat)
!!          ALLOCATE ( Velocity(3, Nt), STAT=ErrStat )
!!
!!          IF ( ErrStat /= 0 )  THEN
!!             CALL WrScr ( ' Error allocating memory for the StdDev velocity array.' )
!!             RETURN
!!          END IF
!!       END IF
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the mean, storing the velocity for later
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          Time = StartTime + (I-1)*delta_time
!!
!!          NewVelocity = WindInf_GetVelocity(Time, InputPosition, ErrStat)
!!          IF ( ErrStat /= 0 ) RETURN
!!          Velocity(:,I) = NewVelocity%Velocity(:)
!!          SumAry(:)     = SumAry(:) + NewVelocity%Velocity(:)
!!
!!       END DO
!!
!!       MeanVel(:) = SumAry(:) / REAL(Nt, ReKi)
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the standard deviation
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          SumAry(:) = SumAry(:) + ( Velocity(:,I) - MeanVel(:) )**2
!!
!!       END DO ! I
!!
!!       WindInf_GetStdDev(:) = SQRT( SumAry(:) / ( Nt - 1 ) )
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Deallocate
!!       !-------------------------------------------------------------------------------------------------
!!       IF ( ALLOCATED(Velocity) ) DEALLOCATE( Velocity )
!!
!!
!!    END FUNCTION WindInf_GetStdDev
!!    !====================================================================================================
!!    FUNCTION WindInf_GetTI(StartTime, EndTime, delta_time, InputPosition,  ErrStat )
!!    !  This function returns the TI of the wind speed.  It's basically a copy of WindInf_GetStdDev,
!!    !  except the return value is divided by the mean U-component wind speed.
!!    !----------------------------------------------------------------------------------------------------
!!
!!          ! passed variables
!!       REAL(ReKi),       INTENT(IN)  :: StartTime
!!       REAL(ReKi),       INTENT(IN)  :: EndTime
!!       REAL(ReKi),       INTENT(IN)  :: delta_time
!!       REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
!!       INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise
!!
!!          ! function definition
!!       REAL(ReKi)                    :: WindInf_GetTI(3)        ! TI U, V, W
!!
!!          ! local variables
!!       REAL(ReKi)                    :: Time
!!       REAL(ReKi), ALLOCATABLE       :: Velocity(:,:)
!!       REAL(DbKi)                    :: SumAry(3)
!!       REAL(DbKi)                    :: MeanVel(3)
!!       INTEGER                       :: I
!!       INTEGER                       :: Nt
!!
!!       TYPE(InflIntrpOut)            :: NewVelocity             ! U, V, W velocities
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Initialize
!!       !-------------------------------------------------------------------------------------------------
!!
!!       WindInf_GetTI(:) = 0.0
!!
!!       Nt = (EndTime - StartTime) / delta_time
!!
!!       IF ( Nt < 2 ) RETURN    ! StdDev is 0
!!
!!
!!       IF (.NOT. ALLOCATED(Velocity)) THEN
!!    !      CALL AllocAry( Velocity, 3, Nt, 'TI velocity', ErrStat)
!!          ALLOCATE ( Velocity(3, Nt), STAT=ErrStat )
!!
!!          IF ( ErrStat /= 0 )  THEN
!!             CALL WrScr ( ' Error allocating memory for the TI velocity array.' )
!!             RETURN
!!          END IF
!!       END IF
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the mean, storing the velocity for later
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          Time = StartTime + (I-1)*delta_time
!!
!!          NewVelocity = WindInf_GetVelocity(Time, InputPosition, ErrStat)
!!          IF ( ErrStat /= 0 ) RETURN
!!          Velocity(:,I) = NewVelocity%Velocity(:)
!!          SumAry(:)     = SumAry(:) + NewVelocity%Velocity(:)
!!
!!       END DO
!!
!!       MeanVel(:) = SumAry(:) / REAL(Nt, ReKi)
!!
!!       IF ( ABS(MeanVel(1)) <= EPSILON(MeanVel(1)) ) THEN
!!          CALL WrScr( ' Wind speed is small in WindInf_GetTI(). TI is undefined.' )
!!          ErrStat = 1
!!          RETURN
!!       END IF
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the standard deviation
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          SumAry(:) = SumAry(:) + ( Velocity(:,I) - MeanVel(:) )**2
!!
!!       END DO ! I
!!
!!       WindInf_GetTI(:) = SQRT( SumAry(:) / ( Nt - 1 ) ) / MeanVel(1)
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Deallocate
!!       !-------------------------------------------------------------------------------------------------
!!       IF ( ALLOCATED(Velocity) ) DEALLOCATE( Velocity )
!!
!!
!!    END FUNCTION WindInf_GetTI
!****************************************************************************
!
!  PROGRAM: InflowWind_Test  - This program tests the inflow wind module
!
!****************************************************************************

PROGRAM InflowWind_Test
    
   USE InflowWind
   USE SharedInflowDefns
          
   IMPLICIT NONE
    
   INTEGER ErrStat
   TYPE(InflInitInfo)  :: InitWindData         ! data to initialize the module; TYPE defined in InflowWindMod.f90
    
   REAL(ReKi)          :: InpPosition(3)
   TYPE(InflIntrpOut)  :: MyWindSpeed
   REAL(ReKi)          :: Time

   REAL(ReKi)          :: dt
   INTEGER             :: I


   !-------------------------------------------------------------------------------------------------
   ! Send the data required for initialization
   !-------------------------------------------------------------------------------------------------
    
!      InitWindData%WindFileName     = "D:\DATA\Fortran\IVF Projects\AeroDyn\Update\Source\InflowWind\TestData\GPLLJ_DNS\InOut.wnd"
!      InitWindData%WindFileName     = "../TestRoutines/TestData/Periodic_Winds.wnd"    !! ff wind
!      InitWindData%WindFileName     = "Test-Data/InOut.wnd"    !! ff wind
!      InitWindData%WindFileName     = "../Samples/Steady.wnd"  !! HH wind
      InitWindData%WindFileName     = "../Samples/les.fdp"  !! 4 D -- points to some other files.
      InitWindData%ReferenceHeight  = 80.   ! meters
      InitWindData%Width            = 100.  ! meters

!     InitWindData%WindFileType     = FF_Wind  
      InitWindData%WindFileType     = DEFAULT_Wind      ! let the module figure out what type of file it is...
      

      CALL WindInf_Init( InitWindData, ErrStat )    


      IF (errstat /=0) CALL ProgAbort('Error in Initialization routine')
      
   
   !-------------------------------------------------------------------------------------------------
   ! Get the wind speeds at various times and positions
   !-------------------------------------------------------------------------------------------------
      dt     = 0.05 ! seconds   
   
      InpPosition(1) = 0.0                            ! longitudinal position front/back of tower
      InpPosition(2) = 0.0                            ! lateral position left/right of tower
      InpPosition(3) = InitWindData%ReferenceHeight   ! height relative to the ground
    
      DO I = 1,3 !time
          
         Time = 0.0 + (I-1)*dt
          
         MyWindSpeed = WindInf_GetVelocity( Time, InpPosition, ErrStat )
         
         !IF (ErrStat /=0) CALL ProgAbort('Error in getting wind speed')
            
         WRITE(*,*) TRIM(Num2LStr(ErrStat)), ' V(t=', TRIM(Num2LStr(Time)), ') = ', MyWindSpeed

      END DO
    
   !-------------------------------------------------------------------------------------------------
   ! Clean up the variables and close files
   !-------------------------------------------------------------------------------------------------
    CALL WindInf_Terminate( ErrStat )


END PROGRAM InflowWind_Test

!=======================================================================
MODULE Precision


   ! This module stores constants to specify the KIND of variables.

IMPLICIT                           NONE

   ! These values should not vary from DoubPrec.f90:
   
INTEGER, PARAMETER              :: B1Ki     = SELECTED_INT_KIND(  2 )           ! Kind for one-byte whole numbers
INTEGER, PARAMETER              :: B2Ki     = SELECTED_INT_KIND(  4 )           ! Kind for two-byte whole numbers
INTEGER, PARAMETER              :: B4Ki     = SELECTED_INT_KIND(  9 )           ! Kind for four-byte whole numbers
INTEGER, PARAMETER              :: B8Ki     = SELECTED_INT_KIND( 18 )           ! Kind for eight-byte whole numbers

INTEGER, PARAMETER              :: QuKi     = SELECTED_REAL_KIND( 20, 500 )     ! Kind for 16-byte, floating-point numbers
INTEGER, PARAMETER              :: R8Ki     = SELECTED_REAL_KIND( 14, 300 )     ! Kind for eight-byte floating-point numbers
INTEGER, PARAMETER              :: SiKi     = SELECTED_REAL_KIND(  6,  30 )     ! Kind for four-byte, floating-point numbers


      ! The default kinds for reals and integers:
      
INTEGER, PARAMETER              :: IntKi    = B4Ki                              ! Default kind for integers
INTEGER, PARAMETER              :: ReKi     = SiKi                              ! Default kind for floating-point numbers
INTEGER, PARAMETER              :: DbKi     = R8Ki                              ! Default kind for double floating-point numbers


      ! The number of bytes in the default variables

INTEGER(IntKi), PARAMETER       :: BytesPerReKi  = 4                            ! Number of bytes per ReKi number     - use SIZEOF()           
INTEGER(IntKi), PARAMETER       :: BytesPerDbKi  = 8                            ! Number of bytes per DbKi number     - use SIZEOF()          
INTEGER(IntKi), PARAMETER       :: BytesPerIntKi = 4                            ! Number of bytes per IntKi number    - use SIZEOF()           


END MODULE Precision
MODULE SysSubs


   ! This module contains routines with system-specific logic and references.
   ! It also contains standard (but not system-specific) routines it uses.

   ! SysGnu.f90 is specifically for the GNU Fortran (gfortran) compiler on Linux. This should also work for gfortran on MAC.


   ! It contains the following routines:

   !     FUNCTION    COMMAND_ARGUMENT_COUNT()
   !     SUBROUTINE  FileSize ( FileName, Size )
   !     SUBROUTINE  FindLine ( Str , MaxLen , StrEnd )
   !     SUBROUTINE  FlushOut ( Unit )
   !     SUBROUTINE  Get_Arg ( Arg_Num , Arg , Error )                                      ! Please use GET_COMMAND_ARGUMENT() instead.
   !     SUBROUTINE  Get_Arg_Num ( Arg_Num )                                                ! Please use COMMAND_ARGUMENT_COUNT() instead.
   !     SUBROUTINE  GET_COMMAND ( Command, Length, Status )
   !     SUBROUTINE  GET_COMMAND_ARGUMENT ( Number, Value, Length, Status )
   !     SUBROUTINE  GET_CWD( DirName, Status )
   !     FUNCTION    Get_Env( EnvVar )                                                      ! Please use GET_ENVIRONMENT_VARIABLE() instead.
   !     FUNCTION    GET_ENVIRONMENT_VARIABLE( Name, Value, Length, Status, Trim_Name )
   !     FUNCTION    Is_NaN( DblNum )                                                       ! Please use IEEE_IS_NAN() instead
   !     SUBROUTINE  OpenBinFile ( Un, OutFile, RecLen, Error )
   !     SUBROUTINE  OpenBinInpFile( Un, InFile, Error )
   !     SUBROUTINE  OpenCon
   !     SUBROUTINE  OpenUnfInpBEFile ( Un, InFile, RecLen, Error )
   !     SUBROUTINE  ProgExit ( StatCode )
   !     SUBROUTINE  UsrAlarm
   !     FUNCTION    UserTime()                                                             ! Removed: Replace by F95 intrinsic, CPU_TIME().
   !     SUBROUTINE  WrNR ( Str )
   !     SUBROUTINE  WrOver ( Str )
   !     SUBROUTINE  WrScr ( Str )




   USE                             Precision

   IMPLICIT                        NONE


!=======================================================================


   INTEGER                      :: ConRecL  = 120                               ! The record length for console output.
   INTEGER                      :: CU       = 6 !7                                 ! The I/O unit for the console.
   INTEGER                      :: NL_Len   = 2                                 ! The number of characters used for a new line.

   CHARACTER(10)                :: Endian   = 'BIG_ENDIAN'                      ! The internal format of numbers.
   CHARACTER( 1)                :: PathSep  = '\'                               ! The path separater.
   CHARACTER( 1)                :: SwChar   = '/'                               ! The switch character for command-line options.
!20110512 jm changed from 'BINARY' to 'UNFORMATTED' because 'BINARY' is not
!standard and caused problems in OPEN statements in NWTC_iO.f90 that use
!this definition
   CHARACTER(11)                :: UnfForm  = 'UNFORMATTED'                     ! The string to specify unformatted I/O files.


CONTAINS

!=======================================================================
   FUNCTION COMMAND_ARGUMENT_COUNT()


      ! This routine returns the number of argumenta entered on the command line..

      ! Note: This routine will be available intrinsically in Fortran 2000.


      ! Function declaration.

   INTEGER                      :: COMMAND_ARGUMENT_COUNT                       ! This function.  The command line.



      ! Determine the mumber of arguments.  Load the program name into the result.

   COMMAND_ARGUMENT_COUNT = IArgC()


   RETURN
   END FUNCTION COMMAND_ARGUMENT_COUNT ! ()
!=======================================================================
   SUBROUTINE FileSize ( FileName, Size )


      ! This routine calls the routine Stat to obtain the file size
      ! corresponding to a file name or returns -1 on error.

      ! mlb: WARNING!!!
      ! The standard version of the routine uses the file unit instead of file name.
      ! We need fix the routines that call this one.


      ! Argument declarations:

   INTEGER, INTENT(OUT)         :: Size

   CHARACTER(*), INTENT(IN)     :: FileName


      ! Intrinsic declarations:

   INTEGER(KIND=1)              :: Stat


      ! Local declarations:

   INTEGER                      :: StatArray(12)
   INTEGER                      :: Status



   Status = Stat( FileName, StatArray )

   IF ( Status /= 0 ) THEN
     Size = -1
   ELSE
     Size = StatArray(8)
   END IF


   RETURN
   END SUBROUTINE FileSize ! ( FileName, Size )
!=======================================================================
   SUBROUTINE FindLine ( Str , MaxLen , StrEnd )


      ! This routine finds one line of text with a maximum length of MaxLen from the Str.
      ! It tries to break the line at a blank.

      ! This routine isn't system specific, but it is called by WrScr(), which is, so it must be here.


   IMPLICIT                        NONE


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: MaxLen                                       ! The maximum length of the string.
   INTEGER, INTENT(OUT)         :: StrEnd                                       ! The location of the end of the string.

   CHARACTER(*), INTENT(IN)     :: Str                                          ! The string to search.


      ! Local declarations:

   INTEGER         IC



   StrEnd = MaxLen

   IF ( LEN_TRIM( Str ) > MaxLen )  THEN

      IC = INDEX( Str(1:MaxLen), ' ', BACK = .TRUE. ) ! Find the last space in the line

      IF ( IC > 1 ) THEN ! We don't want to return just one character that's a space, or do we?

         StrEnd = IC-1    ! StrEnd > 0
         DO WHILE ( Str(StrEnd:StrEnd) == ' ' )
            StrEnd = StrEnd - 1
            IF ( StrEnd <= 0 ) THEN  ! This occurs if everything before IC is a space
               StrEnd = IC
               EXIT
            ENDIF
         ENDDO

      ENDIF ! IC > 1

   ENDIF ! LEN_TRIM( Str ) > MaxLen


   RETURN
   END SUBROUTINE FindLine ! ( Str , MaxLen , StrEnd )
!=======================================================================
   SUBROUTINE FlushOut ( Unit )


      ! This subroutine flushes the buffer on the specified Unit.
      ! It is especially useful when printing "running..." type messages.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: Unit                                         ! The unit number of the file being flushed.



  ! CALL FLUSH ( Unit )


   RETURN
   END SUBROUTINE FlushOut ! ( Unit )
!=======================================================================
   SUBROUTINE Get_Arg ( Arg_Num , Arg , Error )


      ! This routine gets Arg_Num'th argument from the command line.

   ! Note: The functionality in this routine was replaced by GET_COMMAND_ARGUMENT(), which is available intrinsically in Fortran 2000.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Arg_Num                                      ! The argument number to get.

   LOGICAL, INTENT(OUT)         :: Error                                        ! The Error flag returned to the calling program.

   CHARACTER(*), INTENT(OUT)    :: Arg                                          ! The argument string returned to the calling program.


      ! Local declarations.

   INTEGER                      :: Status                                       ! The status of the attempt to get an argument.



   CALL GETARG ( Arg_Num, Arg )  !20110512 jm remove 3rd arg for Linux port

   IF ( LEN_TRIM( Arg ) > 0 )  THEN
      Error = .FALSE.
   ELSE
      Error = .TRUE.
   END IF


   RETURN
   END SUBROUTINE Get_Arg ! ( Arg_Num , Arg , Error )
!=======================================================================
   SUBROUTINE Get_Arg_Num ( Arg_Num )


      ! This routine gets the number of command line arguments.

   ! Note: The functionality in this routine was replaced by COMMAND_ARGUMENT_COUNT(), which will be available intrinsically in Fortran 2000.


      ! Argument declarations.

   INTEGER, INTENT(OUT)         :: Arg_Num                                      ! The argument to get from the command line.



   Arg_Num = IARGC()


   RETURN
   END SUBROUTINE Get_Arg_Num ! ( Arg_Num )
!=======================================================================
   SUBROUTINE GET_COMMAND ( Command, Length, Status )


      ! This routine returns the string associated with the full command line.
      ! It tries as best it can to mimic the Fortran 2000 intrinsic subroutine by the same name.


      ! Argument declarations.

   INTEGER, OPTIONAL, INTENT(OUT)      :: Length                                ! The length of the value of the environment variable.
   INTEGER, OPTIONAL, INTENT(OUT)      :: Status                                ! The status indication what happened.

   CHARACTER(*), OPTIONAL, INTENT(OUT) :: Command                               ! The command line.


      ! Local parameter declarations.

   INTEGER, PARAMETER                  :: MaxLen = 500                          ! The maximum length permitted for an environment variable value.


      ! Local declarations.

   INTEGER                             :: CallStat                              ! Status of the call.
   INTEGER                             :: IArg                                  ! Argument index.

   CHARACTER(MaxLen)                   :: Arg                                   ! The current argument.
   CHARACTER(MaxLen)                   :: ReturnVal                             ! The value that will be returned.



      ! Initialize the result with the program name.

   CALL GETARG ( 0, ReturnVal )  !20110512 jm remove 3rd arg for Linux port


      ! Loop through all the arguments and build the total command line.

   DO IArg=1,IArgC()
      CALL GETARG ( IArg, Arg )  !20110512 jm remove 3rd arg for Linux port
      ReturnVal = TRIM( ReturnVal )//' '//TRIM( Arg )
   END DO ! IArg


      ! When asking the OS about the variable, trim the name unless Trim_Name is false.

   IF ( PRESENT( Command ) )  Command = ReturnVal
   IF ( PRESENT( Length  ) )  Length  = LEN_TRIM( ReturnVal )
   IF ( PRESENT( Status  ) )  Status  = 0


   RETURN
   END SUBROUTINE GET_COMMAND ! ( Command, Length, Status )
!=======================================================================
   SUBROUTINE GET_COMMAND_ARGUMENT ( Number, Value, Length, Status )


      ! This routine returns the string associated with the Numberth command-line argument.
      ! It tries as best it can to mimic the Fortran 2000 intrinsic function by the same name.


      ! Argument declarations.

   INTEGER, OPTIONAL, INTENT(OUT)      :: Length                                ! The length of the value of the environment variable.
   INTEGER, INTENT(IN)                 :: Number                                ! The number of the argument desired.
   INTEGER, OPTIONAL, INTENT(OUT)      :: Status                                ! The status indication what happened.

   CHARACTER(*), OPTIONAL, INTENT(OUT) :: Value                                 ! The command line argument.


      ! Local parameter declarations.

   INTEGER, PARAMETER                  :: MaxLen = 500                          ! The maximum length permitted for an environment variable value.


      ! Local declarations.

   INTEGER                             :: CallStat                              ! The status of the intrinsic call.

   CHARACTER(MaxLen)                   :: ReturnVal                             ! The value that will be returned.



      ! Get the argument.

   CALL GETARG ( Number, ReturnVal )  !20110512 jm remove 3rd arg for Linux port


      ! Load up the return values.

   IF ( PRESENT( Value  ) )  Value  = ReturnVal
   IF ( PRESENT( Length ) )  Length = LEN_TRIM( ReturnVal )
   IF ( PRESENT( Status ) )  Status = CallStat


   RETURN
   END SUBROUTINE GET_COMMAND_ARGUMENT ! ( Number, Value, Length, Status )
!=======================================================================
!bjj note: this subroutine is not tested for this compiler
   SUBROUTINE Get_CWD ( DirName, Status )


      ! This routine retrieves the path of the current working directory.


   IMPLICIT                        NONE


      ! Passed variables.

   CHARACTER(*), INTENT(OUT)    :: DirName                                         ! A CHARACTER string containing the path of the current working directory.
   INTEGER,      INTENT(OUT)    :: Status                                          ! Status returned by the call to a portability routine.


   Status = GETCWD ( DirName )

   RETURN
   END SUBROUTINE Get_CWD
!=======================================================================
   FUNCTION Get_Env( EnvVar )


      ! This routine returns the string associated with the EnvVar environment variable in the OS.
      ! It returns the null string of the variable is not found.

   ! Note: The functionality in this routine was replaced by GET_ENVIRONMENT_VARIABLE(), which will be available intrinsically in Fortran 2000.


      ! Function declaration.

   CHARACTER(500)               :: Get_Env                                      ! This function.  The value of the environment variable.


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: EnvVar                                       ! The environment variable to look up.



   CALL GetEnv ( EnvVar, Get_Env )


   RETURN
   END FUNCTION Get_Env ! ( EnvVar )
!=======================================================================
   FUNCTION GET_ENVIRONMENT_VARIABLE( Name, Value, Length, Status, Trim_Name )


      ! This routine returns the string associated with the Name environment variable in the OS.
      ! It tries as best it can to mimic the Fortran 2000 intrinsic function by the same name.


      ! Argument declarations.

   INTEGER, OPTIONAL, INTENT(OUT)      :: Length                                ! The length of the value of the environment variable.
   INTEGER, OPTIONAL, INTENT(OUT)      :: Status                                ! The status indication what happened.

   LOGICAL, OPTIONAL, INTENT(IN)       :: Trim_Name                             ! Treat trailing blanks in Name as significant if true.

   CHARACTER(*), INTENT(IN)            :: Name                                  ! The environment variable to look up.
   CHARACTER(*), OPTIONAL, INTENT(OUT) :: Value                                 ! The found value of the environment variable, Name.


      ! Local parameter declarations.

   INTEGER, PARAMETER                  :: MaxLen = 500                          ! The maximum length permitted for an environment variable value.


      ! Function declaration.

   CHARACTER(MaxLen)                   :: GET_ENVIRONMENT_VARIABLE              ! This function.  The value of the environment variable.


      ! Local declarations.

   CHARACTER(MaxLen)                   :: ReturnVal                             ! The value that will be returned.



      ! When asking the OS about the variable, trim the name unless Trim_Name is false.

   IF ( PRESENT( Trim_Name ) )  THEN
      IF ( Trim_Name )  THEN
         CALL GetEnv ( TRIM( Name ), ReturnVal )
      ELSE
         CALL GetEnv ( Name, ReturnVal )
      END IF
   ELSE
      CALL GetEnv ( TRIM( Name ), ReturnVal )
   END IF

   IF ( PRESENT( Value ) )  Value = ReturnVal

   IF ( PRESENT( Length ) )  Length = LEN_TRIM( ReturnVal )


      ! If requested, set the status of the OS request.

      ! Because the VF-specific GetEnv() is less capable than the Fortran 2000 intrinsic, we can't distinguish
      ! between a variable whose value is all blanks and one that is not set.

   IF ( PRESENT( Status ) )  THEN
      IF ( LEN_TRIM( ReturnVal ) == 0 )  THEN
         Status = 1
      ELSE
         Status = 0
      END IF
   END IF

   GET_ENVIRONMENT_VARIABLE = ReturnVal


   RETURN
   END FUNCTION GET_ENVIRONMENT_VARIABLE ! ( Name, Value, Length, Status, Trim_Name )
!=======================================================================
   FUNCTION Is_NaN( DblNum )


      ! This routine determines if a REAL(DbKi) variable holds a proper number.
      ! BJJ: this routine is used in CRUNCH.
      ! Note that IsNaN does not exist in earlier versions of gfortran (e.g., 4.2.1), 
      ! but does exist in version 4.4. It should be replaced with the standard 
      ! IEEE_IS_NAN when gfortran implements it.


      ! Argument declarations.

   REAL(DbKi), INTENT(IN)       :: DblNum


      ! Function declaration.

   LOGICAL                      :: Is_Nan



   Is_NaN = IsNaN( DblNum )


   RETURN
   END FUNCTION Is_NaN ! ( DblNum )
!=======================================================================
   SUBROUTINE OpenBinFile ( Un, OutFile, RecLen, Error )


      ! This routine opens a binary output file.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the output file.
   INTEGER, INTENT(IN)          :: RecLen                                       ! Length of binary record.

   LOGICAL, INTENT(OUT)         :: Error                                        ! Flag to indicate the open failed.

   CHARACTER(*), INTENT(IN)     :: OutFile                                      ! Name of the output file.


      ! Local declarations.

   INTEGER                      :: IOS                                          ! I/O status of OPEN.



      ! Open output file.  Make sure it worked.

!20110512 jm Change ACCESS from Sequential to F03std 'stream' to avoid reading/writing record block control words
   OPEN( Un, FILE=TRIM( OutFile ), STATUS='UNKNOWN', FORM='UNFORMATTED' , ACCESS='STREAM', IOSTAT=IOS )

   IF ( IOS /= 0 )  THEN
      Error = .TRUE.
   ELSE
      Error = .FALSE.
   END IF


   RETURN
   END SUBROUTINE OpenBinFile ! ( Un, OutFile, RecLen, Error )
!=======================================================================
   SUBROUTINE OpenBinInpFile ( Un, InFile, Error )


      ! This routine opens a binary input file.

   IMPLICIT                        NONE



      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the input file.

   CHARACTER(*), INTENT(IN)     :: InFile                                       ! Name of the input file.

   LOGICAL, INTENT(OUT)         :: Error                                        ! Flag to indicate the open failed.


      ! Local declarations.

   INTEGER                      :: IOS                                          ! I/O status of OPEN.

      ! NOTE: Do not explicitly declare the precision of this variable [as in
      !       LOGICAL(1)] so that the statements using this variable work with
      !       any compiler:


      ! Open input file.  Make sure it worked.

!20110512 jm Change ACCESS from Sequential to F03std 'stream' to avoid reading/writing record block control words
   OPEN( Un, FILE=TRIM( InFile ), STATUS='OLD', FORM='UNFORMATTED', ACCESS='STREAM', IOSTAT=IOS, ACTION='READ' )

   IF ( IOS /= 0 )  THEN
      Error = .TRUE.
   ELSE
      Error = .FALSE.
   END IF


   RETURN
   END SUBROUTINE OpenBinInpFile
!=======================================================================
 SUBROUTINE OpenCon


      ! This routine opens the console for standard output.



   OPEN ( CU , FILE='/dev/stdout' , STATUS='OLD' )

   CALL FlushOut ( CU )


   RETURN
   END SUBROUTINE OpenCon
!=======================================================================
   SUBROUTINE OpenUnfInpBEFile ( Un, InFile, RecLen, Error )


      ! This routine opens a binary input file with data stored in Big Endian format (created on a UNIX machine.)
      ! Data are stored in RecLen-byte records.

   IMPLICIT                        NONE



      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the input file.

   CHARACTER(*), INTENT(IN)     :: InFile                                       ! Name of the input file.

   INTEGER, INTENT(IN)          :: RecLen                                       ! Size of records in the input file, in bytes.

   LOGICAL, INTENT(OUT)         :: Error                                        ! Flag to indicate the open failed.


      ! Local declarations.

   INTEGER                      :: IOS                                          ! I/O status of OPEN.



      ! Open input file.  Make sure it worked.

   ! The non-standard CONVERT keyword allows us to read UNIX binary files, whose bytes are in reverse order (i.e., stored in BIG ENDIAN format).

   ! NOTE: using RecLen in bytes requires using the /assume:byterecl compiler option!

   OPEN ( Un, FILE=TRIM( InFile ), STATUS='OLD', FORM='UNFORMATTED', ACCESS='DIRECT', RECL=RecLen, IOSTAT=IOS, &
                   ACTION='READ'  )                                              ! Use this for UNIX systems.
!                  ACTION='READ', CONVERT='BIG_ENDIAN' )                         ! Use this for PC systems.


   IF ( IOS /= 0 )  THEN
      Error = .TRUE.
   ELSE
      Error = .FALSE.
   END IF


   RETURN
   END SUBROUTINE OpenUnfInpBEFile
!=======================================================================
   SUBROUTINE ProgExit ( StatCode )


      ! This routine stops the program.  If the compiler supports the EXIT routine,
      ! pass the program status to it.  Otherwise, do a STOP.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: StatCode                                      ! The status code to pass to the OS.



   CALL EXIT ( StatCode )

!   IF ( StatCode == 0 ) THEN
!      STOP 0
!   ELSE
!      IF ( StatCode < 0 ) THEN
!         CALL WrScr( 'Invalid STOP code.' )
!      END IF
!
!      STOP 1
!   END IF


   RETURN
   END SUBROUTINE ProgExit ! ( StatCode )
!=======================================================================
   SUBROUTINE UsrAlarm


      ! This routine generates an alarm to warn the user that something went wrong.



   CALL WrOver ( CHAR( 7 ) )


   RETURN
   END SUBROUTINE UsrAlarm
!=======================================================================
!   FUNCTION UserTime()
!
!
!      ! This function returns the user CPU time.
!
!      ! The functionality of this routine was replaced by the F95 intrinsic, CPU_TIME().
!
!
!      ! Passed variables.
!
!   REAL(4)                      :: UserTime                                        ! User CPU time.
!
!
!      ! Local variables.
!
!   REAL(4)                      :: TimeAry (2)                                     ! TimeAry(1): User CPU time, TimeAry(2): System CPU time.
!   REAL(4)                      :: TotTime                                         ! User CPU time plus system CPU time.
!
!
!
!
!   TotTime  = DTIME( TimeAry )
!   UserTime = TimeAry(1)
!
!
!   RETURN
!   END FUNCTION UserTime
!=======================================================================
   SUBROUTINE WrNR ( Str )


      ! This routine writes out a string to the screen without following it with a new line.


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: Str                                          ! The string to write to the screen.



   WRITE (CU,'(1X,A)',ADVANCE='NO')  Str


   RETURN
   END SUBROUTINE WrNR ! ( Str )
!=======================================================================
   SUBROUTINE WrOver ( Str )


      ! This routine writes out a string that overwrites the previous line


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: Str                                          ! The string to write to the screen.



   WRITE (CU,'(''+'',A)')  Str


   RETURN
   END SUBROUTINE WrOver ! ( Str )
!=======================================================================
   SUBROUTINE WrScr ( Str )


      ! This routine writes out a string to the screen.


   IMPLICIT                        NONE


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: Str                                          ! The string to write to the screen.


      ! Local declarations.

   INTEGER                      :: Beg                                          ! The beginning of the next line of text.
   INTEGER                      :: Indent                                       ! The amunt to be indented.
   INTEGER                      :: LStr                                         ! The length of the remaining portion of the string.
   INTEGER                      :: MaxLen                                       ! Maximum number of columns to be written to the screen.

   CHARACTER(10)                :: Frm                                          ! Format specifier for the output.



      ! Find the amount of indent.  Create format.

   MaxLen = 98
   Indent = LEN_TRIM( Str ) - LEN_TRIM( ADJUSTL( Str ) )
   Indent = MIN( Indent, MaxLen-2 )                                              ! at least 2 characters per line
   MaxLen = MaxLen - Indent

   IF ( Indent > 0 )  THEN
      Frm    = '(1X,  X,A)'
      WRITE (Frm(5:6),'(I2)')  Indent
   ELSE
      Frm    = '(1X,A)'
   END IF



   !  Break long messages into multiple lines.

   Beg  = Indent + 1
   LStr = LEN_TRIM( Str(Beg:) )

   DO WHILE ( Lstr > MaxLen )

      CALL FindLine ( Str(Beg:) , MaxLen , LStr )

      WRITE (CU,Frm)  TRIM( ADJUSTL( Str(Beg:Beg+LStr-1) ) )

      Beg = Beg + LStr


         ! If we have a space at the beginning of the string, let's get rid of it

      DO WHILE ( Beg < LEN_TRIM( Str ) .AND. Str(Beg:Beg) == ' ' )
         Beg = Beg + 1
      ENDDO

      LStr = LEN_TRIM( Str(Beg:) )

   ENDDO

   IF ( LStr > 0 ) THEN
      WRITE (CU,Frm)  TRIM( ADJUSTL( Str(Beg:Beg+LStr-1) ) )
   ELSE
      WRITE (CU,'()')
   END IF


   RETURN
   END SUBROUTINE WrScr ! ( Str )
!=======================================================================

END MODULE SysSubs
MODULE NWTC_IO


   ! This module contains I/O-related variables and routines with non-system-specific logic.


   ! It contains the following routines:

   !     SUBROUTINE CheckArgs     ( InputFile [, ErrStat] )
   !     SUBROUTINE CheckIOS      ( IOS, Fil, Variable, VarType [, TrapErrors] )
   !     SUBROUTINE CloseEcho     ( )
   !     SUBROUTINE Conv2UC       ( Str )
   !     FUNCTION   CountWords    ( Line )
   !     FUNCTION   CurDate       ( )
   !     FUNCTION   CurTime       ( )
   !     SUBROUTINE DispNVD       ( )
   !     FUNCTION   Flt2LStr      ( FltNum )
   !     SUBROUTINE GetNewUnit    ( UnIn )
   !     SUBROUTINE GetPath       ( GivenFil, PathName )
   !     SUBROUTINE GetRoot       ( GivenFil, RootName )
   !     SUBROUTINE GetTokens     ( Line, NumTok, Tokens, Error )
   !     SUBROUTINE GetWords      ( Line, Words, NumWords )
   !     FUNCTION   GetNVD        ( ProgDesc )
   !     FUNCTION   Int2LStr      ( Intgr )
   !     SUBROUTINE NameOFile     ( InArg, OutExten, OutFile )
   !     SUBROUTINE NormStop      ( )
   !     FUNCTION   Num2LStr      ( Num )                                                             ! Generic interface for Int2LStr, R2LStr4, R2LStr8, R2LStr16
   !     SUBROUTINE OpenBin       ( Un, OutFile, RecLen [, ErrStat] )
   !     SUBROUTINE OpenBInpFile  ( Un, InFile [, ErrStat] )
   !     SUBROUTINE OpenEcho      ( Un, InFile [, ErrStat] )
   !     SUBROUTINE OpenFInpFile  ( Un, InFile [, ErrStat] )
   !     SUBROUTINE OpenFOutFile  ( Un, OutFile [, ErrStat] )
   !     SUBROUTINE OpenFUnkFile  ( Un, OutFile, FailAbt, Failed, Exists [, ErrStat] )
   !     SUBROUTINE OpenUInfile   ( Un, InFile [, ErrStat] )
   !     SUBROUTINE OpenUInBEFile ( Un, InFile, RecLen [, ErrStat] )
   !     SUBROUTINE OpenUOutfile  ( Un, OutFile [, ErrStat] )
   !     FUNCTION   PathIsRelative( GivenFil )
   !     SUBROUTINE PremEOF       ( Fil , Variable [, TrapErrors] )
   !     SUBROUTINE ProgAbort     ( Message [, TrapErrors] )
   !     SUBROUTINE ProgWarn      ( Message )
   !     SUBROUTINE ReadAry       ( UnIn, Fil, Ary, AryLen, AryName, AryDescr [, ErrStat] )           ! Generic interface for ReadCAry, ReadIAry, ReadLAry, and ReadRAry.
   !     SUBROUTINE ReadAryLines  ( UnIn, Fil, Ary, AryLen, AryName, AryDescr [, ErrStat] )           ! Generic interface for ReadCAryLines, ReadRAryLines4, ReadRAryLines8, and ReadRAryLines16.
   !     SUBROUTINE ReadCAry      ( UnIn, Fil, CharAry, AryLen, AryName, AryDescr [, ErrStat] )
   !     SUBROUTINE ReadCAryLines ( UnIn, Fil, CharAry, AryLen, AryName, AryDescr [, ErrStat] )
   !     SUBROUTINE ReadCom       ( UnIn, Fil, ComName [, ErrStat] )
   !     SUBROUTINE ReadCVar      ( UnIn, Fil, CharVar, VarName, VarDescr [, ErrStat] )
   !     SUBROUTINE ReadFASTbin   ( UnIn, FASTdata [, ErrLev, ErrMsg] )                               ! Read a FAST binary output file.
   !     SUBROUTINE ReadIAry      ( UnIn, Fil, IntAry, AryLen, AryName, AryDescr [, ErrStat] )
   !     SUBROUTINE ReadIVar      ( UnIn, Fil, IntVar, VarName, VarDescr [, ErrStat] )
   !     SUBROUTINE ReadLAry      ( UnIn, Fil, LogAry, AryLen, AryName, AryDescr [, ErrStat] )
   !     SUBROUTINE ReadLVar      ( UnIn, Fil, LogVar, VarName, VarDescr [, ErrStat] )
   !     SUBROUTINE ReadNum       ( UnIn, Fil, Word, VarName, ErrStat )
   !     SUBROUTINE ReadOutputList( UnIn, Fil, CharAry, AryLenRead, AryName, AryDescr, ErrStat )
   !     SUBROUTINE ReadRAry      ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
   !     SUBROUTINE ReadRAryLines ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
   !     SUBROUTINE ReadRVar      ( UnIn, Fil, RealVar, VarName, VarDescr [, ErrStat] )
   !     SUBROUTINE ReadStr       ( UnIn, Fil, CharVar, VarName, VarDescr [, ErrStat] )
   !     SUBROUTINE ReadVar       ( UnIn, Fil, Var, VarName, VarDescr [, ErrStat] )                   ! Generic interface for ReadCVar, ReadIVar, ReadLVar, and ReadRVar.
   !     SUBROUTINE WaitTime      ( WaitSecs )
   !     SUBROUTINE WrPr          ( Str )
   !     SUBROUTINE WrFileNR      ( Unit, Str )
   !     SUBROUTINE WrML          ( Str )
   !     SUBROUTINE WrScr1        ( Str )


   USE                             SysSubs

   IMPLICIT  NONE

!=======================================================================

   TYPE, PUBLIC :: ProgDesc
      CHARACTER(24)              :: Name
      CHARACTER(99)              :: Ver
      CHARACTER(24)              :: Date
   END TYPE ProgDesc

   TYPE, PUBLIC :: FASTdataType                                                  ! The derived type for holding FAST binary output data.
      CHARACTER(1024)            :: File                                         ! The name of the binary input file containing FAST output.
      CHARACTER(1024)            :: Descr                                        ! The file descriptor stored in the FAST binary output file.
      INTEGER(B4Ki)              :: NumChans                                     ! The number of channels of FAST output data (including time).
      INTEGER(B4Ki)              :: NumRecs                                      ! The number of records of FAST output data.
      REAL(R8Ki)                 :: TimeStep                                     ! The time step.
      CHARACTER(20), ALLOCATABLE :: ChanNames(:)                                 ! The channel names.
      CHARACTER(20), ALLOCATABLE :: ChanUnits(:)                                 ! The channel units.
      REAL(ReKi)   , ALLOCATABLE :: Data(:,:)                                    ! The channel data.  Time is stored in the first column.
   END TYPE FASTdataType

   INTEGER(IntKi), PARAMETER     :: ErrID_None   = 0
   INTEGER(IntKi), PARAMETER     :: ErrID_Info   = 1
   INTEGER(IntKi), PARAMETER     :: ErrID_Warn   = 2
   INTEGER(IntKi), PARAMETER     :: ErrID_Severe = 3
   INTEGER(IntKi), PARAMETER     :: ErrID_Fatal  = 4

   INTEGER(IntKi)                :: AbortErrLev  = ErrID_Fatal

      ! Global I/O-related variables.

   INTEGER(IntKi), PARAMETER     :: FlgType  = 1                                 ! Switch for telling if a variable is a flag.
   INTEGER(IntKi), PARAMETER     :: NumType  = 2                                 ! Switch for telling if a variable is a number.
   INTEGER(IntKi), PARAMETER     :: StrType  = 3                                 ! Switch for telling if a variable is a string.
   INTEGER                       :: UnEc     = 19                                ! I/O unit number for the echo file.

   LOGICAL                       :: Beep     = .TRUE.                            ! Flag that specifies whether or not to beep for error messages and program terminations.
   LOGICAL                       :: Echo     = .FALSE.                           ! Flag that specifies whether or not to produce an echo file.

   TYPE(ProgDesc), PARAMETER     :: NWTC_Ver = ProgDesc( 'NWTC Subroutine Library', 'v1.06.00b-bjj', '07-Dec-2012')       ! The name, version, and date of the NWTC Subroutine Library.
   CHARACTER(20)                 :: ProgName = ' '                               ! The name of the calling program.
   CHARACTER(99)                 :: ProgVer                                      ! The version (including date) of the calling program.
   CHARACTER(1), PARAMETER       :: Tab      = CHAR( 9 )                         ! The tab character.


!=======================================================================

      ! Create interface for a generic AllocAry that actually uses specific routines.

   INTERFACE AllocAry
      MODULE PROCEDURE AllCAry1
      MODULE PROCEDURE AllCAry2
      MODULE PROCEDURE AllCAry3
   !   MODULE PROCEDURE AllCAry4                               Not yet coded.
      MODULE PROCEDURE AllIAry1
      MODULE PROCEDURE AllIAry2
      MODULE PROCEDURE AllIAry3
   !   MODULE PROCEDURE AllIAry4                               Not yet coded.
      MODULE PROCEDURE AllLAry1
      MODULE PROCEDURE AllLAry2
      MODULE PROCEDURE AllLAry3
   !   MODULE PROCEDURE AllLAry4                               Not yet coded.
      MODULE PROCEDURE AllRAry1
      MODULE PROCEDURE AllRAry2
      MODULE PROCEDURE AllRAry3
      MODULE PROCEDURE AllRAry4
   END INTERFACE


      ! Create interface for a generic ReadVar that actually uses specific routines.

   INTERFACE ReadVar
      MODULE PROCEDURE ReadCVar
      MODULE PROCEDURE ReadIVar
      MODULE PROCEDURE ReadLVar
      MODULE PROCEDURE ReadR4Var     ! 4-byte real
      MODULE PROCEDURE ReadR8Var     ! 8-byte real
      MODULE PROCEDURE ReadR16Var    ! 16-byte real
   END INTERFACE


      ! Create interface for a generic ReadAry that actually uses specific routines.

   INTERFACE ReadAry
      MODULE PROCEDURE ReadCAry
      MODULE PROCEDURE ReadIAry
      MODULE PROCEDURE ReadLAry
      MODULE PROCEDURE ReadRAry ! replace with routines for 4-, 8-, and 16-byte reals
   END INTERFACE


   INTERFACE ReadAryLines
      MODULE PROCEDURE ReadCAryLines
      MODULE PROCEDURE ReadRAryLines4
      MODULE PROCEDURE ReadRAryLines8
      MODULE PROCEDURE ReadRAryLines16
!     MODULE PROCEDURE ReadIAryLines         ! Not coded yet
!     MODULE PROCEDURE ReadLAryLines         ! Not coded yet
   END INTERFACE


      ! Create interface for a generic Num2LStr that actually uses specific routines.

   INTERFACE Num2LStr
      MODULE PROCEDURE Int2LStr        ! default integers
      MODULE PROCEDURE R2LStr4         ! 4-byte  reals
      MODULE PROCEDURE R2LStr8         ! 8-byte  reals
      MODULE PROCEDURE R2LStr16        ! 16-byte reals
   END INTERFACE


      ! Create interface for DispNVD so that we can pass in the name of the program

   INTERFACE DispNVD
      MODULE PROCEDURE DispNVD0        ! No arguments.
      MODULE PROCEDURE DispNVD1        ! Single argument of TYPE ProgDesc
      MODULE PROCEDURE DispNVD2        ! Two arguments of TYPE character
   END INTERFACE


CONTAINS

!=======================================================================
   SUBROUTINE AdjRealStr( NumStr )

      ! This routine adjusts strings created from real numbers (4, 8, or 16-byte)
      ! It removes leading spaces and trailing zeros. It is intended to be called
      ! from routines R2LStr4, R2LStr8, and R2LStr16.

   CHARACTER(*), INTENT(INOUT) :: NumStr       ! String representing a real number (e.g., from R2LStr4)

         ! Local declarations.

   INTEGER                      :: IC          ! Character index.


   NumStr = ADJUSTL( NumStr )


      ! Replace trailing zeros and possibly the decimal point with blanks.
      ! Stop trimming once we find the decimal point or a nonzero.


      ! Don't remove (important!) trailing zeros if they are in the exponent:

   IF (INDEX( NumStr, "E" ) > 0 ) RETURN
   IF (INDEX( NumStr, "e" ) > 0 ) RETURN

      ! These are not in the exponent

   DO IC=LEN_TRIM( NumStr ),1,-1

      IF ( NumStr(IC:IC) == '.' )  THEN
         NumStr(IC:IC) = ' '
         RETURN
      ELSE IF ( NumStr(IC:IC) /= '0' )  THEN
         RETURN
      END IF

      NumStr(IC:IC) = ' '

   END DO ! IC


   END SUBROUTINE AdjRealStr
!=======================================================================
   SUBROUTINE AllCAry1 ( Ary, AryDim, Descr, ErrStat )

      ! This routine allocates a 1-D CHARACTER array.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryDim                                      ! The size of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error


   CHARACTER(*), ALLOCATABLE    :: Ary    (:)                                 ! Array to be allocated
   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim) , STAT=Sttus )


   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus

   RETURN
   END SUBROUTINE AllCAry1 ! ( Ary, AryDim, Descr )
!=======================================================================
   SUBROUTINE AllCAry2 (  Ary, AryDim1, AryDim2, Descr, ErrStat )

      ! This routine allocates a 2-D CHARACTER array.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), ALLOCATABLE    :: Ary    (:,:)                                ! Array to be allocated
   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllCAry2 ! (  Ary, AryDim1, AryDim2, Descr )
!=======================================================================
   SUBROUTINE AllCAry3 (  Ary, AryDim1, AryDim2, AryDim3, Descr, ErrStat )


      ! This routine allocates a 3-D CHARACTER array.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim3                                     ! The size of the third dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error


   CHARACTER(*), ALLOCATABLE    :: Ary    (:,:,:)                              ! Array to be allocated
   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2,AryDim3) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllCAry3 ! (  Ary, AryDim1, AryDim2, AryDim3, Descr )
!=======================================================================
   SUBROUTINE AllIAry1 ( Ary, AryDim, Descr, ErrStat )


      ! This routine allocates a 1-D INTEGER array.


      ! Argument declarations.

   INTEGER, ALLOCATABLE         :: Ary    (:)                                  ! Array to be allocated
   INTEGER, INTENT(IN)          :: AryDim                                      ! The size of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus

   RETURN
   END SUBROUTINE AllIAry1 ! ( Ary, AryDim, Descr )
!=======================================================================
   SUBROUTINE AllIAry2 (  Ary, AryDim1, AryDim2, Descr, ErrStat )


      ! This routine allocates a 2-D INTEGER array.


      ! Argument declarations.

   INTEGER, ALLOCATABLE         :: Ary    (:,:)                                ! Array to be allocated
   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus

   RETURN
   END SUBROUTINE AllIAry2 ! (  Ary, AryDim1, AryDim2, Descr )
!=======================================================================
   SUBROUTINE AllIAry3 (  Ary, AryDim1, AryDim2, AryDim3, Descr, ErrStat )


      ! This routine allocates a 3-D INTEGER array.


      ! Argument declarations.

   INTEGER, ALLOCATABLE         :: Ary    (:,:,:)                              ! Array to be allocated
   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim3                                     ! The size of the third dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2,AryDim3) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllIAry3 ! (  Ary, AryDim1, AryDim2, AryDim3, Descr )
!=======================================================================
   SUBROUTINE AllLAry1 ( Ary, AryDim, Descr, ErrStat )


      ! This routine allocates a 1-D LOGICAL array.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryDim                                      ! The size of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   LOGICAL, ALLOCATABLE         :: Ary    (:)                                  ! Array to be allocated

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllLAry1 ! ( Ary, AryDim, Descr )
!=======================================================================
   SUBROUTINE AllLAry2 (  Ary, AryDim1, AryDim2, Descr, ErrStat )


      ! This routine allocates a 2-D LOGICAL array.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   LOGICAL, ALLOCATABLE         :: Ary    (:,:)                                ! Array to be allocated

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllLAry2 ! (  Ary, AryDim1, AryDim2, Descr )
!=======================================================================
   SUBROUTINE AllLAry3 (  Ary, AryDim1, AryDim2, AryDim3, Descr, ErrStat )


      ! This routine allocates a 3-D LOGICAL array.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim3                                     ! The size of the third dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   LOGICAL, ALLOCATABLE         :: Ary    (:,:,:)                              ! Array to be allocated

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2,AryDim3) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllLAry3 ! (  Ary, AryDim1, AryDim2, AryDim3, Descr )
!=======================================================================
   SUBROUTINE AllRAry1 ( Ary, AryDim, Descr, ErrStat )


      ! This routine allocates a 1-D REAL array.


      ! Argument declarations.

   REAL(ReKi), ALLOCATABLE      :: Ary    (:)                                  ! Array to be allocated

   INTEGER, INTENT(IN)          :: AryDim                                      ! The size of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllRAry1 ! ( Ary, AryDim, Descr )
!=======================================================================
   SUBROUTINE AllRAry2 (  Ary, AryDim1, AryDim2, Descr, ErrStat )


      ! This routine allocates a 2-D REAL array.


      ! Argument declarations.

   REAL(ReKi), ALLOCATABLE      :: Ary    (:,:)                                ! Array to be allocated

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
   END SUBROUTINE AllRAry2 ! (  Ary, AryDim1, AryDim2, Descr )
!=======================================================================
   SUBROUTINE AllRAry3 (  Ary, AryDim1, AryDim2, AryDim3, Descr, ErrStat )


      ! This routine allocates a 3-D REAL array.


      ! Argument declarations.

   REAL(ReKi), ALLOCATABLE      :: Ary    (:,:,:)                              ! Array to be allocated

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim3                                     ! The size of the third dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2,AryDim3) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
  END SUBROUTINE AllRAry3 ! (  Ary, AryDim1, AryDim2, AryDim3, Descr )
!=======================================================================
   SUBROUTINE AllRAry4 (  Ary, AryDim1, AryDim2, AryDim3, AryDim4, Descr, ErrStat )


      ! This routine allocates a 4-D REAL array.


      ! Argument declarations.

   REAL(ReKi), ALLOCATABLE      :: Ary    (:,:,:,:)                            ! Array to be allocated

   INTEGER, INTENT(IN)          :: AryDim1                                     ! The size of the first dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim2                                     ! The size of the second dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim3                                     ! The size of the third dimension of the array.
   INTEGER, INTENT(IN)          :: AryDim4                                     ! The size of the fourth dimension of the array.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Descr                                       ! Brief array description.


      ! Local declarations.

   INTEGER                      :: Sttus                                       ! Status of allocation attempt.



   ALLOCATE ( Ary(AryDim1,AryDim2,AryDim3,AryDim4) , STAT=Sttus )

   IF ( Sttus /= 0 )  THEN
      CALL ProgAbort ( ' Error allocating memory for the '//TRIM( Descr )//' array.', PRESENT(ErrStat) )
   END IF

   IF ( PRESENT(ErrStat) ) ErrStat = Sttus


   RETURN
  END SUBROUTINE AllRAry4 ! (  Ary, AryDim1, AryDim2, AryDim3, AryDim4, Descr )
!=======================================================================
!bjj: shouldn't this come after the next subroutine, alphabetically?
   SUBROUTINE CheckIOS ( IOS, Fil, Variable, VarType, TrapErrors )


      ! This routine checks the I/O status and prints either an end-of-file or
      ! an invalid-input message, and then aborts the program.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: IOS                                          ! I/O status.
   INTEGER, INTENT(IN)          :: VarType                                      ! Type of variable.

   LOGICAL, INTENT(IN), OPTIONAL:: TrapErrors                                   ! Determines if the program should abort or return to calling function
   LOGICAL                      :: TrapThisError                                ! The local version of TrapErrors

   CHARACTER(*), INTENT(IN)     :: Fil                                          ! Name of input file.
   CHARACTER(*), INTENT(IN)     :: Variable                                     ! Variable name.


   IF ( PRESENT( TrapErrors ) ) THEN
      TrapThisError = TrapErrors
   ELSE
      TrapThisError = .FALSE.
   END IF


   IF ( IOS < 0 )  THEN

      CALL PremEOF ( TRIM( Fil ), Variable, TrapThisError )

   ELSE IF ( IOS > 0 )  THEN

      SELECTCASE ( VarType )

      CASE ( NumType )
         CALL WrScr1 ( ' Invalid numerical input for file "'//TRIM( Fil )//'".' )
      CASE ( FlgType )
         CALL WrScr1 ( ' Invalid logical input for file "'//TRIM( Fil )//'".' )
      CASE ( StrType )
         CALL WrScr1 ( ' Invalid character input for file "'//TRIM( Fil )//'".' )
      ENDSELECT

      CALL ProgAbort  ( ' The error occurred while trying to read '//TRIM( Variable )//'.', TrapThisError )

   END IF


   RETURN
   END SUBROUTINE CheckIOS ! ( IOS, Fil, Variable, VarType )
!=======================================================================
   SUBROUTINE CheckArgs ( InputFile, ErrStat )


      ! This subroutine is used to check for command-line arguments.


      ! Argument declarations:
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                      ! Error status; if present, program does not abort on error
!bjj: I made this INOUT instead of OUT so that a default input name can be used
!bjj: MLB requests no default InputFile names be allowed; generate error when there is InputFile listed
!Thus, change to
! CALL WrScr1   ( '    '//TRIM( ProgName )//' ['//SwChar//'h] <InputFile>' )
! and add error when NumArg == 0

   CHARACTER(*), INTENT(INOUT)  :: InputFile                                    ! The name of the input file specified on the command line.


      ! Local declarations:

   INTEGER                      :: IArg                                         ! The argument number.
   INTEGER                      :: NumArg                                       ! The number of arguments on the command line.

   LOGICAL                      :: Error                                        ! Flag indicating if there was an error getting an argument.

   CHARACTER(LEN(InputFile))    :: Arg                                          ! A command-line argument.




      ! Find out how many arguments were entered on the command line.

   CALL Get_Arg_Num ( NumArg )


      ! Parse them.

   IF ( NumArg .GT. 0 )  THEN

      DO IArg=1,NumArg

         CALL Get_Arg ( IArg , Arg , Error )

         IF ( Error )  THEN
            CALL ProgAbort ( ' Error getting command-line argument #'//TRIM( Int2LStr( IArg ) )//'.', PRESENT(ErrStat) )
            IF ( PRESENT(ErrStat) ) THEN
               ErrStat = 1
               RETURN
            END IF
         END IF

         IF ( Arg(1:1) == SwChar )  THEN

            CALL WrScr1   ( ' Syntax is:' )
            CALL WrScr1   ( '    '//TRIM( ProgName )//' ['//SwChar//'h] [<InputFile>]' )
            CALL WrScr1   ( ' where:' )
            CALL WrScr1   ( '    '//SwChar//'h generates this help message.' )
            CALL WrScr    ( '    <InputFile> is the name of the primary input file ['//TRIM( InputFile )//'].' )
            CALL WrScr    ( ' ')

            IF ( INDEX( 'Hh?', Arg(2:2)  ) > 0 )  THEN
               IF ( PRESENT(ErrStat) ) THEN
                  ErrStat = -1
                  RETURN
               ELSE
                  CALL ProgExit ( 1 )
               END IF
            ELSE
               CALL ProgAbort ( ' Invalid command-line switch "'//SwChar//TRIM( Arg(2:) )//'".', PRESENT(ErrStat) )
               IF ( PRESENT(ErrStat) ) THEN
                  ErrStat = 1
                  RETURN
               END IF
            END IF

         ELSE
            InputFile = Arg
         END IF

      END DO

   END IF

   IF ( PRESENT( ErrStat ) ) ErrStat = 0

   RETURN
   END SUBROUTINE CheckArgs
!=======================================================================
   SUBROUTINE CloseEcho( )

      ! This subroutine closes the echo file and sets Echo to false

      CLOSE ( UnEc )

      Echo  = .FALSE.

   END SUBROUTINE CloseEcho
!=======================================================================
   SUBROUTINE Conv2UC ( Str )


      ! This routine converts all the text in a string to upper case.


      ! Argument declarations.

   CHARACTER(*), INTENT(INOUT)  :: Str                                          ! The string to be converted to UC.


      ! Local declarations.

   INTEGER                      :: IC                                           ! Character index



   DO IC=1,LEN_TRIM( Str )

      IF ( ( Str(IC:IC) >= 'a' ).AND.( Str(IC:IC) <= 'z' ) )  THEN
         Str(IC:IC) = CHAR( ICHAR( Str(IC:IC) ) - 32 )
      ELSE
         Str(IC:IC) = Str(IC:IC)
      END IF

   END DO ! IC


   RETURN
   END SUBROUTINE Conv2UC !  ( Str )
!=======================================================================
   FUNCTION CountWords ( Line )


      ! This subroutine is used to count the number of "words" in a line of text.
      ! It uses spaces, tabs, commas, semicolons, single quotes, and double quotes ("whitespace")
      !  as word separators.


      ! Function declaration.

   INTEGER                      :: CountWords                                   ! This function.


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: Line                                         ! Count the words in this text string.


      ! Local declarations.

   INTEGER                      :: Ch                                           ! Character position.
   INTEGER                      :: NextWhite                                    ! Position of the next white space.



      ! Let's initialize the number of columns and the character pointer.

   CountWords = 0


      ! Let's make sure we have text on this line.

   IF ( LEN_TRIM( Line ) == 0 )  RETURN


      ! Count words separated by any combination of spaces, tabs, commas,
      ! semicolons, single quotes, and double quotes ("whitespace").

   Ch = 0

   DO

      NextWhite = SCAN( Line(Ch+1:) , ' ,;''"'//Tab )
      Ch        = Ch + NextWhite

      IF ( NextWhite > 1 )  THEN
         CountWords = CountWords + 1
      ELSE IF ( NextWhite == 1 )  THEN
         CYCLE
      ELSE
         EXIT
      END IF

   END DO


   RETURN
   END FUNCTION CountWords ! ( Line )
!=======================================================================
   FUNCTION CurDate( )


      ! This function returns a character string encoded with the date in the form dd-mmm-ccyy.


      ! Function declaration.

   CHARACTER(11)                :: CurDate                                      ! This function


      ! Local declarations.

   CHARACTER(8)                 :: CDate                                        ! String to hold the returned value from the DATE_AND_TIME subroutine call.



   !  Call the system date function.

   CALL DATE_AND_TIME ( CDate )


   !  Parse out the day.

   CurDate(1:3) = CDate(7:8)//'-'


   !  Parse out the month.

   SELECT CASE ( CDate(5:6) )
      CASE ( '01' )
         CurDate(4:6) = 'Jan'
      CASE ( '02' )
         CurDate(4:6) = 'Feb'
      CASE ( '03' )
         CurDate(4:6) = 'Mar'
      CASE ( '04' )
         CurDate(4:6) = 'Apr'
      CASE ( '05' )
         CurDate(4:6) = 'May'
      CASE ( '06' )
         CurDate(4:6) = 'Jun'
      CASE ( '07' )
         CurDate(4:6) = 'Jul'
      CASE ( '08' )
         CurDate(4:6) = 'Aug'
      CASE ( '09' )
         CurDate(4:6) = 'Sep'
      CASE ( '10' )
         CurDate(4:6) = 'Oct'
      CASE ( '11' )
         CurDate(4:6) = 'Nov'
      CASE ( '12' )
         CurDate(4:6) = 'Dec'
   END SELECT


   !  Parse out the year.

   CurDate(7:11) = '-'//CDate(1:4)


   RETURN
   END FUNCTION CurDate ! ()
!=======================================================================
   FUNCTION CurTime( )


      ! This function returns a character string encoded with the time in the form "hh:mm:ss".


      ! Function declaration.

   CHARACTER(8)                 :: CurTime                                      ! This function.


      ! Local declarations.

   CHARACTER(10)                :: CTime                                        ! String to hold the returned value from the DATE_AND_TIME subroutine call.



   CALL DATE_AND_TIME ( TIME=CTime )

   CurTime = CTime(1:2)//':'//CTime(3:4)//':'//CTime(5:6)


   RETURN
   END FUNCTION CurTime ! ()
!=======================================================================
   SUBROUTINE DispNVD0


      ! This routine displays the name of the program, its version, and its release date.


      ! Print out program name, version, and date.

   CALL WrScr1 ( ' Running '//TRIM( ProgName )//' '//Trim( ProgVer )//'.' )


   RETURN
   END SUBROUTINE DispNVD0
!=======================================================================
   SUBROUTINE DispNVD1( ProgInfo )


      ! This routine displays the name of the program, its version, and its release date.


   IMPLICIT NONE
   TYPE( ProgDesc ), INTENT(IN)        :: ProgInfo    ! Contains the name and version info


      ! Print out program name, version, and date.

   CALL WrScr1 ( ' Running '//TRIM( GetNVD( ProgInfo ) )//'.' )


   RETURN
   END SUBROUTINE DispNVD1
!=======================================================================
   SUBROUTINE DispNVD2( Name, Ver )


      ! This routine displays the name of the program, its version, and its release date passed in as strings
      ! This routine is depricated and for legacy purposes only. Please don't use for any new code (Dec-2012)

   IMPLICIT NONE
   CHARACTER(*),  INTENT(IN)           :: Name     ! String containing the name of the program using the library
   CHARACTER(*),  INTENT(IN)           :: Ver      ! String containing the version and date info


      ! Print out program name, version, and date.

   CALL WrScr1 ( ' Running '//TRIM( Name )//' ('//Trim( Ver )//').' )


   RETURN
   END SUBROUTINE DispNVD2
!=======================================================================
   FUNCTION Flt2LStr ( FltNum )


      ! This function converts a floating point number to a left-aligned
      ! string.  It eliminates trailing zeroes and even the decimal
      ! point if it is not a fraction.
      ! This function remains here only for backward compatibility. New
      ! code should use Num2LStr instead.


      ! Function declaration.

   CHARACTER(15)                :: Flt2LStr                                        ! This function.


      ! Argument declarations.

   REAL(ReKi), INTENT(IN)       :: FltNum                                          ! The floating-point number to convert.



      ! Return a 0 if that's what we have.

   IF ( FltNum == 0.0 )  THEN
      Flt2LStr = '0'
      RETURN
   END IF


      ! Write the number into the string using G format and left justify it.

   WRITE (Flt2LStr,'(1PG15.5)')  FltNum

   CALL AdjRealStr( Flt2LStr )

   RETURN
   END FUNCTION Flt2LStr !  ( FltNum )
!=======================================================================
   SUBROUTINE GetNewUnit ( UnIn )

      ! This routine returns a unit number not currently in use.


      ! Argument declarations.

   INTEGER, INTENT(OUT)         :: UnIn                                         ! Logical unit for the file.


      ! Local declarations.

   INTEGER, SAVE                :: Un   = 10                                    ! Unit number; saved between calls (and a GLOBAL) variable
   LOGICAL                      :: Opened                                       ! Flag indicating whether or not a file is opened.



      ! See if unit is connected to an open file. Check the next largest number until it is not opened.

   DO

      INQUIRE ( UNIT=Un , OPENED=Opened )

      IF ( .NOT. Opened )  EXIT
      Un = Un + 1

!      IF ( Un > 99 ) Un = 10                                                     !some systems don't like unit numbers > 99, but we also don't want an infinite loop

   END DO

   UnIn = Un

   RETURN
   END SUBROUTINE GetNewUnit !  ( UnIn )
!=======================================================================
   FUNCTION GetNVD ( ProgInfo )
   
      ! This function converts the three strings contained in the ProgDesc
      ! data type into a single string listing the program name,
      ! version, and release date.
   
   
      ! Argument declarations.
      
   TYPE( ProgDesc ), INTENT(IN)        :: ProgInfo    ! Contains the name and version info
   
   
      ! Function delcaration
      
   CHARACTER(200)                      :: GetNVD      ! A single string containing the name, date, and version info
   
      
      ! Print all the version info into a nice string:
   
      GetNVD = TRIM( ProgInfo%Name )//' ('//Trim( ProgInfo%Ver )//', '//Trim( ProgInfo%Date )//')'

   END FUNCTION GetNVD 
!=======================================================================

   SUBROUTINE GetPath ( GivenFil, PathName )


      ! Let's parse the path name from the name of the given file.
      ! We'll count everything before (and including) the last "\" or "/".


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: GivenFil                                     ! The name of the given file.
   CHARACTER(*), INTENT(OUT)    :: PathName                                     ! The path name of the given file.


      ! Local declarations.

   INTEGER                      :: I                                            ! DO index for character position.


      ! Look for path separators

   I = INDEX( GivenFil, '\', BACK=.TRUE. )
   I = MAX( I, INDEX( GivenFil, '/', BACK=.TRUE. ) )

   IF ( I == 0 ) THEN
      ! we don't have a path specified, return '.'
      PathName = '.'//PathSep
   ELSE
      PathName = GivenFil(:I)
   END IF


   RETURN
   END SUBROUTINE GetPath ! ( GivenFil, PathName )
!=======================================================================
   SUBROUTINE GetRoot ( GivenFil, RootName )


      ! Let's parse the root file name from the name of the given file.
      ! We'll count everything after the last period as the extension.


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: GivenFil                                     ! The name of the given file.
   CHARACTER(*), INTENT(OUT)    :: RootName                                     ! The parsed root name of the given file.


      ! Local declarations.

   INTEGER                      :: I                                            ! DO index for character position.



      ! Deal with a couple of special cases.

   IF ( ( TRIM( GivenFil ) == "." ) .OR. (  TRIM( GivenFil ) == ".." ) )  THEN
      RootName = TRIM( GivenFil )
      RETURN
   END IF


      ! More-normal cases.

   DO I=LEN_TRIM( GivenFil ),1,-1


      IF ( GivenFil(I:I) == '.' )  THEN


         IF ( I < LEN_TRIM( GivenFil ) ) THEN                   ! Make sure the index I is okay
            IF ( INDEX( '\/', GivenFil(I+1:I+1)) == 0 ) THEN    ! Make sure we don't have the RootName in a different directory
               RootName = GivenFil(:I-1)
            ELSE
               RootName = GivenFil                              ! This does not have a file extension
            END IF
         ELSE
            IF ( I == 1 ) THEN
               RootName = ''
            ELSE
               RootName = GivenFil(:I-1)
            END IF
         END IF

         RETURN

      END IF
   END DO ! I

   RootName =  GivenFil


   RETURN
   END SUBROUTINE GetRoot ! ( GivenFil, RootName )
!=======================================================================
   SUBROUTINE GetTokens ( Line, NumTok, Tokens, Error )


      ! This routine will parse Line for NumTok "tokens" and return them in the Tokens array.
      ! THis routine differs from GetWords() in that it uses only spaces as token separators.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: NumTok                                       ! The number of "words" to look for.

   LOGICAL, INTENT(OUT)         :: Error                                        ! Error flag to indicate an insuffient number of tokens were found.

   CHARACTER(*), INTENT(INOUT)  :: Line                                         ! The string to search.
   CHARACTER(*), INTENT(OUT)    :: Tokens  (NumTok)                             ! The tokens that were found.


      ! Local declarations.

   INTEGER                      :: IT                                           ! Token index.
   INTEGER                      :: NextBlank                                    ! The location of the next blank character.



   NextBlank = 0

   DO IT=1,NumTok

      Line      = ADJUSTL( Line(NextBlank+1:) )
      NextBlank = INDEX  ( Line , ' ' )

      IF ( NextBlank == 0 )  THEN
        Error = .TRUE.
        RETURN
      END IF

      Tokens(IT) = Line(1:NextBlank-1)

   END DO ! IT

   Error = .FALSE.


   RETURN
   END SUBROUTINE GetTokens ! ( Line, NumTok, Tokens, Error )
!=======================================================================
   SUBROUTINE GetWords ( Line, Words, NumWords )


      ! This subroutine is used to get NumWords "words" from a line of text.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: NumWords                                     ! The number of words to look for.

   CHARACTER(*), INTENT(IN)     :: Line                                         ! The string to search.
   CHARACTER(*), INTENT(OUT)    :: Words(NumWords)                              ! The array of found words.


      ! Local declarations.

   INTEGER                      :: Ch                                           ! Character position within the string.
   INTEGER                      :: IW                                           ! Word index.
   INTEGER                      :: NextWhite                                    ! The location of the next whitespace in the string.



      ! Let's prefill the array with blanks.

   DO IW=1,NumWords
      Words(IW) = ' '
   END DO ! IW


      ! Let's make sure we have text on this line.

   IF ( LEN_TRIM( Line ) == 0 )  RETURN


      ! Parse words separated by any combination of spaces, tabs, commas,
      ! semicolons, single quotes, and double quotes ("whitespace").

   Ch = 0
   IW = 0

   DO

      NextWhite = SCAN( Line(Ch+1:) , ' ,;''"'//Tab )

      IF ( NextWhite > 1 )  THEN

         IW        = IW + 1
         Words(IW) = Line(Ch+1:Ch+NextWhite-1)

         IF ( IW == NumWords )  EXIT

         Ch = Ch + NextWhite

      ELSE IF ( NextWhite == 1 )  THEN

         Ch = Ch + 1

         CYCLE

      ELSE

         EXIT

      END IF

   END DO


   RETURN
   END SUBROUTINE GetWords ! ( Line, Words, NumWords )
!======================================================================= 
   FUNCTION Int2LStr ( Intgr )


      ! This function returns a left-adjusted string representing the passed integer.



   CHARACTER(11)                :: Int2LStr                                     ! This function.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Intgr                                        ! The integer to convert to a left-justified string.



   WRITE (Int2LStr,'(I11)')  Intgr

   Int2Lstr = ADJUSTL( Int2LStr )


   RETURN
   END FUNCTION Int2LStr ! ( Intgr )
!=======================================================================
   SUBROUTINE NameOFile ( InArg, OutExten, OutFile, ErrStat )


      ! Get the name of the input file from the InArgth command-line argument.
      ! Remove the extension if there is one, and append OutExten to the end.


      ! Argument declarations.

   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                     ! Error status; if present, program does not abort on error
   INTEGER, INTENT(IN)          :: InArg                                        ! The number of the command-line argument that should hold the input file name.

   CHARACTER(*), INTENT(IN)     :: OutExten                                     ! The requested extension for the output file.
   CHARACTER(*), INTENT(OUT)    :: OutFile                                      ! The name of the output file.


      ! Local declarations.

   CHARACTER(100)               :: InFile                                       ! The name of the input file.
   CHARACTER(100)               :: RootName                                     ! The root name of the input file.



      ! See if the command line has enough arguments.

   IF ( InArg > COMMAND_ARGUMENT_COUNT() )  THEN
      CALL ProgAbort ( 'Insufficient arguments on the command line (at least '//&
                         TRIM( Int2LStr( InArg ) )//' were expected).', PRESENT(ErrStat) )
      IF ( PRESENT( ErrStat ) ) ErrStat = 1
      RETURN
   END IF


      ! Get the root of the input file name (strip off the extension).

   CALL GET_COMMAND_ARGUMENT( InArg, InFile )
   CALL GetRoot ( TRIM( InFile ), RootName )

   OutFile = TRIM( RootName )//'.'//OutExten

   IF ( PRESENT( ErrStat ) ) ErrStat = 0

   RETURN
   END SUBROUTINE NameOFile ! ( InArg, OutExten, OutFile [, ErrStat])
!=======================================================================
   SUBROUTINE NormStop


      ! This routine performs a normal termination of the program.


   CALL WrScr1   ( ' '//TRIM( ProgName )//' terminated normally.' )
   CALL WrScr    ( '' )
   CALL ProgExit ( 0 )


   END SUBROUTINE NormStop
!=======================================================================
   SUBROUTINE OpenBin ( Un, OutFile, RecLen, ErrStat )

      ! This routine opens a binary output file.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the output file.
   INTEGER, INTENT(IN)          :: RecLen                                       ! Length of binary record.
   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                     ! Error status; if present, program does not abort on error


   CHARACTER(*), INTENT(IN)     :: OutFile                                      ! Name of the output file.


      ! Local declarations.

   LOGICAL                      :: Error                                        ! Flag to indicate the open failed.


      ! Open output file.  Make sure it worked.

   CALL OpenBinFile ( Un, OutFile, RecLen, Error )

   IF ( Error )  THEN
      CALL ProgAbort ( ' Cannot open file "'//TRIM( OutFile )// &
                       '".  Another program may have locked it for writing.', PRESENT(ErrStat) )
      IF ( PRESENT(ErrStat) ) ErrStat = 1
      RETURN
   ELSE
      IF ( PRESENT(ErrStat) ) ErrStat = 0
   ENDIF


   RETURN
   END SUBROUTINE OpenBin ! ( Un, OutFile, RecLen [, ErrStat] )
!=======================================================================
   SUBROUTINE OpenBInpFile ( Un, InFile, ErrStat )


      ! This routine opens a binary input file.

   IMPLICIT                        NONE



      ! Argument declarations.

   INTEGER, INTENT(IN)            :: Un                                          ! Logical unit for the input file.
   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                     ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)       :: InFile                                      ! Name of the input file.


      ! Local declarations.

      ! NOTE: Do not explicitly declare the precision of this variable [as in
      !       LOGICAL(1)] so that the statements using this variable work with
      !       any compiler:
   LOGICAL                      :: Exists                                       ! Flag indicating whether or not a file Exists.
   LOGICAL                      :: Error                                        ! Flag to indicate the open failed.



      ! See if input file Exists.

   INQUIRE ( FILE=TRIM( InFile ) , EXIST=Exists )

   IF ( .NOT. Exists )  THEN
      CALL ProgAbort ( ' The input file, "'//TRIM( InFile )//'", was not found.', PRESENT( ErrStat) )
      IF ( PRESENT( ErrStat) ) ErrStat = -1
      RETURN
   END IF


      ! Open input file.  Make sure it worked.

   CALL OpenBinInpFile ( Un, InFile, Error )

   IF ( Error )  THEN

      CALL ProgAbort ( ' Cannot open file "'//TRIM( InFile )//'".  Another program may have locked it.', PRESENT( ErrStat ) )
      IF ( PRESENT( ErrStat) ) ErrStat = 1
      RETURN

   ELSE

      IF ( PRESENT( ErrStat) ) ErrStat = 0

   END IF


   RETURN
   END SUBROUTINE OpenBInpFile
!=======================================================================
   SUBROUTINE OpenEcho ( Un, OutFile, ErrStat )


      ! This routine opens a formatted output file for the echo file.


      ! Argument declarations.

   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                   ! Error status; if present, program does not abort on error
   INTEGER, INTENT(IN)            :: Un                                        ! Logical unit for the input file.

   CHARACTER(*), INTENT(IN)       :: OutFile                                   ! Name of the input file.




   UnEc = Un

   IF ( PRESENT(ErrStat) ) THEN

      CALL OpenFOutFile( UnEc, OutFile, ErrStat )

   ELSE

      CALL OpenFOutFile( UnEc, OutFile )

   ENDIF

   Echo = .TRUE.

   RETURN
   END SUBROUTINE OpenEcho ! ( Un, OutFile [, ErrStat]  )
!=======================================================================
   SUBROUTINE OpenFInpFile ( Un, InFile, ErrStat )


      ! This routine opens a formatted input file.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                      ! Error status; if present, program does not abort on error
   CHARACTER(*), INTENT(IN)     :: InFile                                       ! Name of the input file.


      ! Local declarations.

   INTEGER                      :: IOS                                          ! I/O status of OPEN.

   LOGICAL                      :: Exists                                       ! Flag indicating whether or not a file Exists.



      ! See if input file Exists.

   INQUIRE ( FILE=TRIM( InFile ) , EXIST=Exists )

   IF ( .NOT. Exists )  THEN
      CALL ProgAbort ( ' The input file, "'//TRIM( InFile )//'", was not found.', PRESENT(ErrStat) )
      IF (PRESENT(ErrStat)) ErrStat = -1
      RETURN
   END IF


      ! Open input file.  Make sure it worked.

   OPEN( Un, FILE=TRIM( InFile ), STATUS='OLD', FORM='FORMATTED', IOSTAT=IOS, ACTION='READ' )

   IF ( IOS /= 0 )  THEN
      CALL ProgAbort ( ' Cannot open file "'//TRIM( InFile ) &
                      //'".  Another program like MS Excel may have locked it for writing.',PRESENT(ErrStat)  )
      IF (PRESENT(ErrStat)) ErrStat = 1
      RETURN
   ELSE
      IF (PRESENT(ErrStat)) ErrStat = 0
   END IF


   RETURN
   END SUBROUTINE OpenFInpFile ! ( Un, InFile [, ErrStat] )
!=======================================================================
   SUBROUTINE OpenFOutFile ( Un, OutFile, ErrStat )


      ! This routine opens a formatted output file.


      ! Argument declarations.

   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                    ! Error status; if present, program does not abort on error
   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the output file.

   CHARACTER(*), INTENT(IN)     :: OutFile                                      ! Name of the output file.


      ! Local declarations.

   INTEGER                      :: IOS                                          ! I/O status of OPEN.



      ! Open output file.  Make sure it worked.

   OPEN( Un, FILE=TRIM( OutFile ), STATUS='UNKNOWN', FORM='FORMATTED', IOSTAT=IOS, ACTION="WRITE" )



   IF ( PRESENT(ErrStat) ) ErrStat = IOS

   IF ( IOS /= 0 )  CALL ProgAbort( ' Cannot open file "'//TRIM( OutFile )// &
                                    '".  Another program like MS Excel may have locked it for writing.', PRESENT(ErrStat) )


   RETURN
   END SUBROUTINE OpenFOutFile ! ( Un, OutFile [, ErrStat] )
!=======================================================================
   SUBROUTINE OpenFUnkFile ( Un, OutFile, FailAbt, Failed, Exists, ErrStat )


      ! This routine opens a formatted output file and returns a flag telling if it already existed.


      ! Argument declarations.

   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                    ! Error status; if present, program does not abort on error
   INTEGER, INTENT(IN)          :: Un                                           ! Logical unit for the output file.

   LOGICAL, INTENT(OUT)         :: Exists                                       ! Flag that indicates if the file already existedo.
   LOGICAL, INTENT(IN)          :: FailAbt                                      ! Flag that tells this routine to abort if the open fails.
   LOGICAL, INTENT(OUT)         :: Failed                                       ! Flag that indicates if the open failed.

   CHARACTER(*), INTENT(IN)     :: OutFile                                      ! Name of the output file.


      ! Local declarations.

   INTEGER                      :: IOS                                          ! I/O status of OPEN.



      ! Check to see if the file already exists.

   INQUIRE ( FILE=TRIM( OutFile ) , EXIST=Exists )

!bjj: should we be checking something here?


      ! Open output file.  Make sure it worked.

   OPEN( Un, FILE=TRIM( OutFile ), STATUS='UNKNOWN', FORM='FORMATTED', IOSTAT=IOS )

   IF ( PRESENT(ErrStat) ) ErrStat = IOS

   IF ( IOS /= 0 )  THEN
      Failed = .TRUE.
      IF ( FailAbt )  CALL ProgAbort ( ' Cannot open file "'//TRIM( OutFile ) &
                                 //'".  Another program like MS Excel may have locked it for writing.', PRESENT(ErrStat) )
   ELSE
      Failed = .FALSE.
   END IF


   RETURN
   END SUBROUTINE OpenFUnkFile ! ( Un, OutFile, FailAbt, Failed, Exists [,ErrStat] )
!=======================================================================
   SUBROUTINE OpenUInfile ( Un, InFile, ErrStat )


      !  This routine opens an unformatted input file.


      ! Argument declarations.

   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                    ! Error status; if present, program does not abort on error
   INTEGER, INTENT(IN)         ::  Un                                           ! Logical unit for the input file

   CHARACTER(*), INTENT(IN)    ::  InFile                                       ! Name of the input file


      ! Local declarations.

   INTEGER                     ::  IOS                                          ! Returned input/output status.

   LOGICAL                      :: Exists                                       ! Flag indicating whether or not a file Exists.



      ! See if input file Exists.

   INQUIRE ( FILE=TRIM( InFile ) , EXIST=Exists )

   IF ( .NOT. Exists )  THEN
      CALL ProgAbort ( ' The input file, "'//TRIM( InFile )//'", was not found.', PRESENT(ErrStat) )
      IF ( PRESENT(ErrStat) ) ErrStat = -1
      RETURN
   END IF


      ! Open the file.

   OPEN ( Un, FILE=TRIM( InFile ), STATUS='UNKNOWN', FORM=UnfForm, ACCESS='SEQUENTIAL', IOSTAT=IOS, ACTION='READ' )

   IF ( PRESENT(ErrStat) ) ErrStat = IOS

   IF ( IOS /= 0 )  CALL ProgAbort( ' Cannot open file "'//TRIM( InFile )// &
                                    '".  Another program may have locked it for writing.', PRESENT(ErrStat) )



   RETURN
   END SUBROUTINE OpenUInfile ! ( Un, InFile [,ErrStat] )
!=======================================================================
SUBROUTINE OpenUInBEFile( Un, InFile, RecLen, ErrStat )

      !  This routine opens an unformatted input file of RecLen-byte data records
      !  stored in Big Endian format.


      ! Argument declarations.

   INTEGER, INTENT(IN)           ::  Un                                         ! Logical unit for the input file
   CHARACTER(*), INTENT(IN)      ::  InFile                                     ! Name of the input file
   INTEGER, INTENT(IN)           ::  RecLen                                     ! The input file's record length in bytes
   INTEGER, INTENT(OUT),OPTIONAL ::  ErrStat                                    ! Error status; if present, program does not abort on error



      ! Local declarations.

   LOGICAL                       :: Exists                                       ! Flag to indicate if a file exists
   LOGICAL                       :: Error                                        ! Flag to indicate the open failed



      ! See if input file Exists.

   INQUIRE ( FILE=TRIM( InFile ) , EXIST=Exists )

   IF ( .NOT. Exists )  THEN
      CALL ProgAbort ( ' The input file, "'//TRIM( InFile )//'", was not found.', PRESENT(ErrStat) )
      IF ( PRESENT(ErrStat) ) ErrStat = -1
      RETURN
   END IF


      ! Open the file.

   CALL OpenUnfInpBEFile ( Un, InFile, RecLen, Error )

   IF ( Error )  THEN

      CALL ProgAbort ( ' Cannot open file "'//TRIM( InFile )//'".  Another program may have locked it.', PRESENT( ErrStat ) )
      IF ( PRESENT( ErrStat) ) ErrStat = 1
      RETURN

   ELSE

      IF ( PRESENT( ErrStat) ) ErrStat = 0

   END IF


   RETURN

END SUBROUTINE OpenUInBEFile !( Un, InFile, RecLen [, ErrStat] )
!=======================================================================
   SUBROUTINE OpenUOutfile ( Un, OutFile, ErrStat )


      !  This routine opens an unformatted output file.


      ! Argument declarations.

   INTEGER, INTENT(IN)            ::  Un                                        ! Logical unit for the output file
   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                    ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)       ::  OutFile                                   ! Name of the output file


      ! Local declarations.

   INTEGER                        ::  IOS                                       ! Returned input/output status.



      ! Open the file.

   OPEN ( Un, FILE=TRIM( OutFile ), STATUS='UNKNOWN', FORM=UnfForm, ACCESS='SEQUENTIAL', IOSTAT=IOS, ACTION='WRITE' )


   IF ( PRESENT( ErrStat ) )   ErrStat = IOS

   IF ( IOS /= 0 )  CALL ProgAbort( ' Cannot open file "'//TRIM( OutFile )// &
                                    '".  Another program may have locked it for writing.', PRESENT( ErrStat ) )


   RETURN
   END SUBROUTINE OpenUOutfile ! ( Un, InFile [,ErrStat] )
!=======================================================================
   FUNCTION PathIsRelative ( GivenFil )


      ! Let's determine in the given file name is absolute or relative.
      !
      ! We'll consider an absolute path one that satisfies one of the
      ! following four criteria:
      !     1) It contains ":/"
      !     2) It contains ":\"
      !     3) It starts with "/"
      !     4) It starts with "\"
      ! All others are considered relative.



      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: GivenFil                                            ! The name of the given file.
   LOGICAL                      :: PathIsRelative                                      ! The function return value


      ! Determine if file name begins with an absolute path name or if it is relative

   PathIsRelative = .FALSE.

   IF ( ( INDEX( GivenFil, ':/') == 0 ) .AND. ( INDEX( GivenFil, ':\') == 0 ) ) THEN   ! No drive is specified (by ':\' or ':/')

      IF ( INDEX( '/\', GivenFil(1:1) ) == 0 ) THEN                                    ! The file name doesn't start with '\' or '/'

         PathIsRelative = .TRUE.

      END IF

   END IF

   RETURN
   END FUNCTION PathIsRelative ! ( GivenFil )
!=======================================================================
   SUBROUTINE PremEOF ( Fil , Variable, TrapErrors )


      ! This routine prints out an EOF message and aborts the program.


      ! Argument declarations.

   LOGICAL, INTENT(IN), OPTIONAL:: TrapErrors                                   ! Determines if the program should abort or return to calling function
   LOGICAL                      :: TrapThisError                                ! The local version of TrapErrors

   CHARACTER(*), INTENT(IN)     :: Fil                                          ! The name of the file that ran out of data.
   CHARACTER(*), INTENT(IN)     :: Variable                                     ! The name of the variable we were trying to read at the time.


   IF ( PRESENT( TrapErrors ) ) THEN
      TrapThisError = TrapErrors
   ELSE
      TrapThisError = .FALSE.
   END IF

   CALL WrScr1 ( ' Premature EOF for file "'//TRIM( Fil )//'".' )

   CALL ProgAbort  ( ' The error occurred while trying to read '//TRIM( Variable )//'.', TrapThisError )


   RETURN
   END SUBROUTINE PremEOF ! ( Fil , Variable [, TrapErrors] )
!=======================================================================
   SUBROUTINE ProgAbort ( Message, TrapErrors )


      ! This routine outputs fatal error messages and stops the program.


      ! Argument declarations.

   LOGICAL, INTENT(IN), OPTIONAL:: TrapErrors                                   ! Determines if the program should abort or return to calling function
   CHARACTER(*), INTENT(IN)     :: Message                                      ! Error message.



   IF ( Beep )  CALL UsrAlarm

   CALL WrScr    ( Message )
   IF ( PRESENT(TrapErrors) )  THEN
      IF ( TrapErrors ) RETURN
   END IF

   IF ( LEN_TRIM(ProgName) > 0 ) THEN
      CALL WrScr1   ( ' Aborting '//TRIM( ProgName )//'.' )
   ELSE
      CALL WrScr1   ( ' Aborting program.' )
   END IF

   CALL WrScr1   ( ' Hit the <Enter> key to continue.' )
   READ (*,'()')
   CALL ProgExit ( 1 )


   END SUBROUTINE ProgAbort ! ( Message [, TrapErrors] )
!=======================================================================
   SUBROUTINE ProgWarn ( Message )


      ! This routine outputs non-fatal warning messages and returns to the calling routine.


      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: Message                                      ! Warning message.



   IF ( Beep )  CALL UsrAlarm
   CALL WrScr ( ' WARNING:  '//Message )


   RETURN
   END SUBROUTINE ProgWarn ! ( Message )
!=======================================================================
   FUNCTION R2LStr4 ( FltNum )

      ! This function converts a 4-byte floating point number to
      ! a left-aligned string.  It eliminates trailing zeroes
      ! and even the decimal point if it is not a fraction.


      ! Function declaration.

   CHARACTER(15)                :: R2LStr4                                         ! This function.


      ! Argument declarations.

   REAL(SiKi), INTENT(IN)       :: FltNum                                          ! The floating-point number to convert.


      ! Return a 0 if that's what we have.

   IF ( FltNum == 0.0_SiKi )  THEN
      R2LStr4 = '0'
      RETURN
   END IF


      ! Write the number into the string using G format and left justify it.

   WRITE (R2LStr4,'(1PG15.5)')  FltNum

   CALL AdjRealStr( R2LStr4 )


   RETURN
   END FUNCTION R2LStr4 !  ( FltNum )
!=======================================================================
   FUNCTION R2LStr8 ( FltNum )

      ! This function converts a 8-byte floating point number to
      ! a left-aligned string.  It eliminates trailing zeroes
      ! and even the decimal point if it is not a fraction.


      ! Function declaration.

   CHARACTER(15)                :: R2LStr8                                         ! This function.


      ! Argument declarations.

   REAL(R8Ki), INTENT(IN)       :: FltNum                                          ! The floating-point number to convert.


      ! Return a 0 if that's what we have.

   IF ( FltNum == 0.0_R8Ki )  THEN
      R2LStr8 = '0'
      RETURN
   END IF


      ! Write the number into the string using G format and left justify it.

   WRITE (R2LStr8,'(1PG15.5)')  FltNum

   CALL AdjRealStr( R2LStr8 )


   RETURN
   END FUNCTION R2LStr8 !  ( FltNum )
!=======================================================================
   FUNCTION R2LStr16 ( FltNum )

      ! This function converts a 16-byte floating point number to
      ! a left-aligned string.  It eliminates trailing zeroes
      ! and even the decimal point if it is not a fraction.


      ! Function declaration.

   CHARACTER(15)                :: R2LStr16                                        ! This function.


      ! Argument declarations.

   REAL(QuKi), INTENT(IN)       :: FltNum                                          ! The floating-point number to convert.


      ! Return a 0 if that's what we have.

   IF ( FltNum == 0.0_QuKi )  THEN
      R2LStr16 = '0'
      RETURN
   END IF


      ! Write the number into the string using G format and left justify it.

   WRITE (R2LStr16,'(1PG15.5)')  FltNum

   CALL AdjRealStr( R2LStr16 )


   RETURN
   END FUNCTION R2LStr16 !  ( FltNum )

!======================================================================
   SUBROUTINE ReadCAry ( UnIn, Fil, CharAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a character array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(OUT)    :: CharAry(AryLen)                                 ! Real variable being read.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.
   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the string array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(44)                :: Frmt = "(15X,A,T30,' - ',A,/,2X,100('""',A,'""',:,1X))"    ! Output format for string parameters.



   READ (UnIn,*,IOSTAT=IOS)  ( CharAry(Ind), Ind=1,AryLen )

   CALL CheckIOS ( IOS, Fil, TRIM( AryName ), StrType, PRESENT(ErrStat) )

   IF (PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  TRIM( AryName ), AryDescr, ( TRIM( CharAry(Ind) ), Ind=1,AryLen )
   END IF


   RETURN
   END SUBROUTINE ReadCAry ! ( UnIn, Fil, CharAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadCAryLines ( UnIn, Fil, CharAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a real array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(OUT)    :: CharAry(AryLen)                                 ! Char variable being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the real array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(35)                :: Frmt = "( 15X, A, T30, ' - ', A, /, 2X, A )"    ! Output format for string parameters.


   IF ( PRESENT(ErrStat) ) ErrStat = 0

   DO Ind=1,AryLen
      READ (UnIn,*,IOSTAT=IOS)  CharAry(Ind)

      CALL CheckIOS ( IOS, Fil, TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', StrType, PRESENT(ErrStat) )

      IF (IOS /= 0) THEN
         IF ( PRESENT(ErrStat) ) ErrStat = IOS
         RETURN
      ENDIF

      IF ( Echo )  THEN
         WRITE (UnEc,Frmt)  TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', AryDescr, TRIM(CharAry(Ind))
      END IF
   END DO

   RETURN
   END SUBROUTINE ReadCAryLines ! ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadCom ( UnIn, Fil, ComName, ErrStat )

      ! This routine reads a comment from the next line of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)   :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)   :: ComName                                         ! Text string containing the comment name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(200)               :: Comment                                         ! Text string containing the comment.



   READ (UnIn,'(A)',IOSTAT=IOS)  Comment

   CALL CheckIOS ( IOS, Fil, ComName, StrType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      WRITE (UnEc,'(A)')  Comment
   END IF


   RETURN
   END SUBROUTINE ReadCom ! ( UnIn, Fil, ComName [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadCVar ( UnIn, Fil, CharVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single character variable from the next line of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(OUT)    :: CharVar                                         ! Integer variable being read.
   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: VarDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(35)                :: Frmt = "( 15X, A, T30, ' - ', A, /, 2X, A )"    ! Output format for string parameters.




   READ (UnIn,*,IOSTAT=IOS)  CharVar

   CALL CheckIOS ( IOS, Fil, VarName, StrType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  VarName, VarDescr, '"'//TRIM( CharVar )//'"'
   END IF


   RETURN
   END SUBROUTINE ReadCVar ! ( UnIn, Fil, CharVar, VarName, VarDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadFASTbin ( UnIn, FASTdata , ErrLev, ErrMsg )

      ! This routine reads the contents of a FAST binary output file (FASTbinFile) and stores it in FASTdata.
      ! It is assumed that the name of the binary file is preloaded into FASTdata%File by the calling procedure.


      ! Argument declarations.

   INTEGER(IntKi), OPTIONAL, INTENT(OUT)  :: ErrLev                  ! An optional error level to be returned to the calling routine.
   INTEGER(IntKi), INTENT(INOUT)          :: UnIn                    ! The IO unit for the FAST binary file.

   CHARACTER(*), OPTIONAL, INTENT(OUT)    :: ErrMsg                  ! An optional error message to be returned to the calling routine.

   TYPE (FASTdataType), INTENT(INOUT)     :: FASTdata                ! The derived type for holding FAST output data.


      ! Local declarations.

   REAL(R8Ki)                             :: TimeIncr                ! The increment for the time data when a time channel is not included.
   REAL(R8Ki)                             :: TimeOff                 ! The offset for the time data when a time channel is included.
   REAL(R8Ki)                             :: TimeOut1                ! The first output data when a time channel is not included.
   REAL(R8Ki)                             :: TimeScl                 ! The slope for the time data when a time channel is included.

   REAL(ReKi), ALLOCATABLE                :: ColMax(:)               ! The maximum value of the column data.
   REAL(ReKi), ALLOCATABLE                :: ColMin(:)               ! The minimum value of the column data.

   REAL(SiKi), ALLOCATABLE                :: ColOff(:)               ! The offset for the column data.
   REAL(SiKi), ALLOCATABLE                :: ColScl(:)               ! The slope for the column data.

   INTEGER(IntKi)                         :: IChan                   ! The channel index used for DO loops.
   INTEGER(IntKi)                         :: IChr                    ! The character index used for DO loops.
   INTEGER(IntKi)                         :: IRow                    ! The row index used for DO loops.
   INTEGER(IntKi)                         :: LenDesc                 ! The length of the description string, DescStr.
   INTEGER(IntKi), PARAMETER              :: MaxLenDesc = 1024       ! The maximum allowed length of the description string, DescStr.
   INTEGER(IntKi), PARAMETER              :: MaxChrLen  = 10         ! The maximum length for channel names and units.

   INTEGER(B4Ki), ALLOCATABLE             :: TmpTimeArray(:)         ! This array holds the normalized time channel that was read from the binary file.

   INTEGER(B2Ki)                          :: FileType                ! The type of FAST data file (1: Time channel included in file; 2: Time stored as start time and step).
   INTEGER(B2Ki), ALLOCATABLE             :: TmpInArray(:,:)         ! This array holds the normalized channels that were read from the binary file.

   INTEGER(B1Ki), ALLOCATABLE             :: DescStrASCII(:)         ! The ASCII equivalent of DescStr.
   INTEGER(B1Ki)                          :: TmpStrASCII(MaxChrLen)  ! The temporary ASCII equivalent of a channel name or units.


      !  Open data file.

   CALL OpenBInpFile ( UnIn, FASTdata%File, ErrLev )
   IF ( ErrLev /= 0 )  THEN
      RETURN
   ENDIF


      ! Process the requested data records of this file.

   CALL WrScr1 ( ' =======================================================' )
   CALL WrScr  ( ' Reading in data from file "'//TRIM( FASTdata%File )//'".' )
   CALL WrScr  ( ' ' )


      ! Read some of the header information.

   READ (UnIn, IOSTAT=ErrLev)  FileType
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading FileType in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF

   READ (UnIn, IOSTAT=ErrLev)  FASTdata%NumChans
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the number of channels in ReadFASTbin for file "' &
                                      //TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF

   READ (UnIn, IOSTAT=ErrLev)  FASTdata%NumRecs
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the number of records in ReadFASTbin for file "' &
                                          //TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF

   IF ( FileType == 1 )  THEN

      READ (UnIn, IOSTAT=ErrLev)  TimeScl
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading TimeScl in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF

      READ (UnIn, IOSTAT=ErrLev)  TimeOff
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading TimeOff in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF

   ELSE

      READ (UnIn, IOSTAT=ErrLev)  TimeOut1
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading TimeOut1 in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF

      READ (UnIn, IOSTAT=ErrLev)  TimeIncr
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading TimeIncr in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF

   END IF ! IF ( FileType == 1 )


      ! Allocate the necessary arrays.

   ALLOCATE ( ColMax( FASTdata%NumChans ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for ColMax array in ReadFASTbin.' )
      RETURN
   ENDIF

   ALLOCATE ( ColMin( FASTdata%NumChans ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for ColMin array in ReadFASTbin.' )
      RETURN
   ENDIF

   ALLOCATE ( ColOff( FASTdata%NumChans ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for ColOff array in ReadFASTbin.' )
      RETURN
   ENDIF

   ALLOCATE ( FASTdata%ChanNames( FASTdata%NumChans+1 ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for FASTdata%ChanNames array in ReadFASTbin.' )
      RETURN
   ENDIF

   ALLOCATE ( FASTdata%ChanUnits( FASTdata%NumChans+1 ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine( ErrID_Fatal, '>>Error allocating memory for FASTdata%ChanUnits array in ReadFASTbin.' )
      RETURN
   ENDIF

   ALLOCATE ( ColScl( FASTdata%NumChans ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for ColScl array in ReadFASTbin.' )
      RETURN
   ENDIF

   ALLOCATE ( TmpInArray( FASTdata%NumRecs, FASTdata%NumChans ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for the TmpInArray array in ReadFASTbin.' )
      RETURN
   ENDIF

   IF ( FileType == 1 ) THEN
      ALLOCATE ( TmpTimeArray( FASTdata%NumRecs ) , STAT=ErrLev )
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for the TmpTimeArray array in ReadFASTbin.' )
         RETURN
      ENDIF
   END IF

   ALLOCATE ( FASTdata%Data( FASTdata%NumRecs, FASTdata%NumChans+1 ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for the FASTdata%Data array in ReadFASTbin.' )
      RETURN
   ENDIF


      ! Read more of the header information.

   READ (UnIn, IOSTAT=ErrLev)  ColScl
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the ColScl array in ReadFASTbin for file "' &
                                          //TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF

   READ (UnIn, IOSTAT=ErrLev)  ColOff
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the ColOff array in ReadFASTbin for file "' &
                                          //TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF

   READ (UnIn, IOSTAT=ErrLev)  LenDesc
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading LenDesc in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF
   LenDesc = MIN( LenDesc, MaxLenDesc )

   ALLOCATE ( DescStrASCII( LenDesc ) , STAT=ErrLev )
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error allocating memory for the DescStrASCII array in ReadFASTbin.' )
      RETURN
   ENDIF

   READ (UnIn, IOSTAT=ErrLev)  DescStrASCII
   IF ( ErrLev /= 0 )  THEN
      CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the DescStrASCII array in ReadFASTbin for file "' &
                                      //TRIM( FASTdata%File )//'".' )
      RETURN
   ENDIF

   FASTdata%Descr = ''

   DO IChr=1,LenDesc
      FASTdata%Descr(IChr:IChr) = CHAR( DescStrASCII(IChr) )
   END DO

   TmpStrASCII(:) = ICHAR( ' ' )
   DO IChan=1,FASTdata%NumChans+1
      READ (UnIn, IOSTAT=ErrLev)  TmpStrASCII
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the title of Channel #'//Int2LStr(  IChan )// &
                                          ' in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF
      FASTdata%ChanNames(IChan) = ''
      DO IChr=1,MaxChrLen
         FASTdata%ChanNames(IChan)(IChr:IChr) = CHAR( TmpStrASCII(IChr) )
      END DO
   END DO

   TmpStrASCII(:) = ICHAR( ' ' )
   DO IChan=1,FASTdata%NumChans+1
      READ (UnIn, IOSTAT=ErrLev)  TmpStrASCII
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading the units of Channel #'//Int2LStr(  IChan )// &
                                          ' in ReadFASTbin for file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF
      FASTdata%ChanUnits(IChan) = ''
      DO IChr=1,MaxChrLen
         FASTdata%ChanUnits(IChan)(IChr:IChr) = CHAR( TmpStrASCII(IChr) )
      END DO
   END DO


      ! If the file contains a time channel (as opposed to just initial time and time step), read it.
      ! There are four bytes per time value.

   IF ( FileType == 1 ) THEN

      READ (UnIn, IOSTAT=ErrLev)  TmpTimeArray                                 ! Time data stored in normalized 32-bit integers
      IF ( ErrLev /= 0 )  THEN
         CALL ExitThisRoutine ( ErrID_Fatal, '>>Error reading time data from the FAST binary file "'//TRIM( FASTdata%File )//'".' )
         RETURN
      ENDIF

   END IF ! FileType


      ! Put time data in the data array.

   IF ( FileType == 1 )  THEN
      FASTdata%Data(:,1) = ( TmpTimeArray(:) - TimeOff )/TimeScl;
      FASTdata%TimeStep  = FASTdata%Data(2,1) - FASTdata%Data(1,1)
   ELSE
      FASTdata%Data(:,1) = REAL( TimeOut1, DbKi ) + REAL( TimeIncr, DbKi )*[ (IRow, IRow=0,FASTdata%NumRecs-1 ) ];
      FASTdata%TimeStep  = TimeIncr
   END IF


      ! Read the FAST channel data.

   DO IRow=1,FASTdata%NumRecs
      READ (UnIn, IOSTAT=ErrLev)  TmpInArray(IRow,:)
   END DO ! IRow=1,FASTdata%NumRecs


      ! Denormalize the data one row at a time and store it in the FASTdata%Data array.

   DO IRow=1,FASTdata%NumRecs
      FASTdata%Data(IRow,2:) = ( TmpInArray(IRow,:) - ColOff(:) )/ColScl(:)
   END DO ! IRow=1,FASTdata%NumRecs


   CALL ExitThisRoutine( ErrID_None, '' )
   RETURN

   !=======================================================================
   CONTAINS
   !=======================================================================
      SUBROUTINE ExitThisRoutine ( ErrID, Msg )

         ! This subroutine cleans up all the allocatable arrays, sets the error status/message and closes the binary file

            ! Passed arguments

         INTEGER(IntKi), INTENT(IN) :: ErrID       ! The error identifier (ErrLev)
         CHARACTER(*),   INTENT(IN) :: Msg         ! The error message (ErrMsg)


            ! Set error status/message

         ErrLev = ErrID
         ErrMsg  = Msg


            ! Deallocate arrays created in this routine.

         IF ( ALLOCATED( ColMax             ) ) DEALLOCATE( ColMax             )
         IF ( ALLOCATED( ColMin             ) ) DEALLOCATE( ColMin             )
         IF ( ALLOCATED( ColOff             ) ) DEALLOCATE( ColOff             )
         IF ( ALLOCATED( ColScl             ) ) DEALLOCATE( ColScl             )
         IF ( ALLOCATED( DescStrASCII       ) ) DEALLOCATE( DescStrASCII       )
         IF ( ALLOCATED( TmpInArray         ) ) DEALLOCATE( TmpInArray         )
         IF ( ALLOCATED( TmpTimeArray       ) ) DEALLOCATE( TmpTimeArray       )


            ! If there was an error, deallocate the arrays in the FASTdata structure.

         IF ( ErrLev /= 0 )  THEN
            IF ( ALLOCATED( FASTdata%ChanNames ) ) DEALLOCATE( FASTdata%ChanNames )
            IF ( ALLOCATED( FASTdata%ChanUnits ) ) DEALLOCATE( FASTdata%ChanUnits )
            IF ( ALLOCATED( FASTdata%Data      ) ) DEALLOCATE( FASTdata%Data      )
         END IF ! ( ErrLev /= 0 )


            ! Close file

         CLOSE ( UnIn )

      END SUBROUTINE ExitThisRoutine

   END SUBROUTINE ReadFASTbin ! ( FASTbinData [, ErrLev] )
!=======================================================================
   SUBROUTINE ReadIAry ( UnIn, Fil, IntAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into an integer array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(OUT)         :: IntAry(AryLen)                                  ! Integer array being read.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the integer array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, I11, 2X, A, T30, ' - ', A )"      ! Output format for integer array parameters



   READ (UnIn,*,IOSTAT=IOS)  ( IntAry(Ind), Ind=1,AryLen )

   CALL CheckIOS ( IOS, Fil, TRIM( AryName ), NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      DO Ind=1,AryLen
         WRITE (UnEc,Frmt)  IntAry(Ind), TRIM( AryName ), AryDescr
      END DO ! Ind
   END IF


   RETURN
   END SUBROUTINE ReadIAry ! ( UnIn, Fil, IntAry, AryLen, AryName, AryDescr [, ErrStat])
!=======================================================================
   SUBROUTINE ReadIVar ( UnIn, Fil, IntVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single integer variable from the next line of the input file.


      ! Argument declarations:

   INTEGER, INTENT(OUT)         :: IntVar                                          ! Integer variable being read.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: VarDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(33)                :: Frmt = "( 2X, I11, 2X, A, T30, ' - ', A )"      ! Output format for integer parameters.
   CHARACTER(30)                :: Word                                            ! String to hold the first word on the line.



   IF ( PRESENT(ErrStat) ) THEN
      CALL ReadNum ( UnIn, Fil, Word, VarName, ErrStat )
      IF (ErrStat /= 0) RETURN
   ELSE
      CALL ReadNum ( UnIn, Fil, Word, VarName )
   END IF

   READ (Word,*,IOSTAT=IOS)  IntVar

   CALL CheckIOS ( IOS, Fil, VarName, NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  IntVar, VarName, VarDescr
   END IF


   RETURN
   END SUBROUTINE ReadIVar ! ( UnIn, Fil, IntVar, VarName, VarDescr [, ErrStat])
!=======================================================================
   SUBROUTINE ReadLAry ( UnIn, Fil, LogAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into an logical array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   LOGICAL, INTENT(OUT)         :: LogAry(AryLen)                                  ! Logical array being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the integer array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, I11, 2X, A, T30, ' - ', A )"      ! Output format for integer array parameters



   READ (UnIn,*,IOSTAT=IOS)  ( LogAry(Ind), Ind=1,AryLen )

   CALL CheckIOS ( IOS, Fil, TRIM( AryName ), NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      DO Ind=1,AryLen
         WRITE (UnEc,Frmt)  LogAry(Ind), TRIM( AryName ), AryDescr
      END DO ! Ind
   END IF


   RETURN
   END SUBROUTINE ReadLAry ! ( UnIn, Fil, LogAry, AryLen, AryName, AryDescr [, ErrStat])
!=======================================================================
   SUBROUTINE ReadLVar ( UnIn, Fil, LogVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single logical variable from the next line of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   LOGICAL, INTENT(OUT)         :: LogVar                                          ! Logical variable being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: VarDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(33)                :: Frmt  = "( 2X, L11, 2X, A, T30, ' - ', A )"     ! Output format for logical parameters.
   CHARACTER( 4)                :: VName                                           ! Temporary holder for the variable name.




   READ (UnIn,*,IOSTAT=IOS)  LogVar

   CALL CheckIOS ( IOS, Fil, VarName, FlgType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   VName = VarName

   CALL Conv2UC ( VName )

   IF ( Echo .AND. ( VName /= 'ECHO' ) )  THEN
      WRITE (UnEc,Frmt)  LogVar, VarName, VarDescr
   END IF


   RETURN
   END SUBROUTINE ReadLVar ! ( UnIn, Fil, LogVar, VarName, VarDescr [, ErrStat])
!=======================================================================
   SUBROUTINE ReadNum ( UnIn, Fil, Word, VarName, ErrStat )


      ! This routine reads a single word from a file and tests to see if it's a pure number (no true or false).


      ! Argument declarations:

   INTEGER, INTENT(IN)            :: UnIn                                          ! I/O unit for input file.
   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                       ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(IN)       :: Fil                                           ! Name of the input file.
   CHARACTER(*), INTENT(IN)       :: VarName                                       ! Text string containing the variable name.
   CHARACTER(*), INTENT(Out)      :: Word                                          ! Text string containing the first word from the input line.


      ! Local declarations:

   INTEGER                        :: IOS                                           ! I/O status returned from the read statement.


   IF ( PRESENT(ErrStat) ) ErrStat = 0


      ! Read in the first word of the input line.  Check I/O status.

   READ (UnIn,*,IOSTAT=IOS)  Word

   CALL CheckIOS ( IOS, Fil, VarName, NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF


      ! See if the word starts with a T or F.  If so, flag it as an invalid number.

   IF ( INDEX( 'FTft', Word(:1) ) > 0 )  THEN
      CALL WrScr ( '' )
      CALL ProgAbort( ' Invalid numeric input.  "'//TRIM( Word )//'" found when trying to read the number, '// &
                      TRIM( VarName )//'.', PRESENT(ErrStat) )

      IF ( PRESENT(ErrStat) ) ErrStat = 1
   END IF



   RETURN
   END SUBROUTINE ReadNum ! ( UnIn, Fil, Word, VarName [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadOutputList ( UnIn, Fil, CharAry, AryLenRead, AryName, AryDescr, ErrStat )


      ! This routine reads up to MaxAryLen values from an input file and store them in CharAry(:).
      ! These values represent the names of output channels, and they are specified in the format
      ! required for OutList(:) in FAST input files.
      ! The end of this list is specified with the line beginning with the 3 characters "END".


      ! Argument declarations:

   INTEGER, INTENT(OUT)         :: AryLenRead                                      ! Length of the array that was actually read.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(OUT)    :: CharAry(:)                                      ! Character array being read (calling routine dimensions it to max allowable size).

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: MaxAryLen                                       ! Maximum length of the array being read
   INTEGER                      :: NumWords                                        ! Number of words contained on a line


   CHARACTER(1000)              :: OutLine
   CHARACTER(3)                 :: EndOfFile


      ! Initialize some values

   IF ( PRESENT(ErrStat) ) ErrStat = 0
   MaxAryLen  = SIZE(CharAry)
   AryLenRead = 0

   CharAry = ''



      ! Read in all of the lines containing output parameters and store them in CharAry(:).
      ! The end of this list is specified with the line beginning with END.

   DO

      IF ( PRESENT(ErrStat) ) THEN
         CALL ReadVar ( UnIn, Fil, OutLine, AryName, AryDescr, ErrStat )
         IF ( ErrStat /= 0 ) RETURN
      ELSE
         CALL ReadVar ( UnIn, Fil, OutLine, AryName, AryDescr  )
      END IF

      EndOfFile = OutLine(1:3)            ! EndOfFile is the 1st 3 characters of OutLine
      CALL Conv2UC( EndOfFile )           ! Convert EndOfFile to upper case
      IF ( EndOfFile == 'END' )  EXIT     ! End of OutList has been reached; therefore, exit this DO

      NumWords = CountWords( OutLine )    ! The number of words in OutLine.

      AryLenRead = AryLenRead + NumWords  ! The total number of output channels read in so far.

         ! Check to see if the maximum # allowable in the array has been reached.

      IF ( AryLenRead > MaxAryLen )  THEN

         CALL ProgAbort ( ' The maximum number of output channels allowed is ' &
                     //TRIM( Int2LStr(MaxAryLen) )//'.', PRESENT(ErrStat)      )
         ErrStat = 1
         RETURN

      ELSE

         CALL GetWords ( OutLine, CharAry((AryLenRead - NumWords + 1):AryLenRead), NumWords )

      END IF

   END DO


   RETURN
   END SUBROUTINE ReadOutputList ! ( UnIn, Fil, CharAry, AryLenRead, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadRAry ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a real array separated by white space (possibly on the same line of the input file).


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   REAL(ReKi), INTENT(INOUT)    :: RealAry(AryLen)                                 ! Real array being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the real array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real array parameters



   READ (UnIn,*,IOSTAT=IOS)  ( RealAry(Ind), Ind=1,AryLen )

   CALL CheckIOS ( IOS, Fil, TRIM( AryName ), NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   ENDIF

   IF ( Echo )  THEN
      DO Ind=1,AryLen
         WRITE (UnEc,Frmt)  RealAry(Ind), TRIM( AryName ), AryDescr
      END DO ! Ind
   END IF


   RETURN
   END SUBROUTINE ReadRAry ! ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadRAryLines ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a real array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   REAL(ReKi), INTENT(OUT)      :: RealAry(AryLen)                                 ! Real array being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the real array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real array parameters


   IF ( PRESENT(ErrStat) ) ErrStat = 0

   DO Ind=1,AryLen
      READ (UnIn,*,IOSTAT=IOS)  RealAry(Ind)

      CALL CheckIOS ( IOS, Fil, TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', NumType, PRESENT(ErrStat) )

      IF (IOS /= 0) THEN
         IF ( PRESENT(ErrStat) ) ErrStat = IOS
         RETURN
      ENDIF

      IF ( Echo )  THEN
         WRITE (UnEc,Frmt)  RealAry(Ind), TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', AryDescr
      END IF
   END DO

   RETURN
   END SUBROUTINE ReadRAryLines ! ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadRAryLines4 ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a real array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   REAL(SiKi), INTENT(OUT)      :: RealAry(AryLen)                                 ! Real (4-byte) array being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the real array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real array parameters


   IF ( PRESENT(ErrStat) ) ErrStat = 0

   DO Ind=1,AryLen
      READ (UnIn,*,IOSTAT=IOS)  RealAry(Ind)

      CALL CheckIOS ( IOS, Fil, TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', NumType, PRESENT(ErrStat) )

      IF (IOS /= 0) THEN
         IF ( PRESENT(ErrStat) ) ErrStat = IOS
         RETURN
      ENDIF

      IF ( Echo )  THEN
         WRITE (UnEc,Frmt)  RealAry(Ind), TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', AryDescr
      END IF
   END DO

   RETURN
   END SUBROUTINE ReadRAryLines4 ! ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadRAryLines8 ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a real array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   REAL(R8Ki), INTENT(OUT)      :: RealAry(AryLen)                                 ! Real (8-byte) array being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the real array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real array parameters


   IF ( PRESENT(ErrStat) ) ErrStat = 0

   DO Ind=1,AryLen
      READ (UnIn,*,IOSTAT=IOS)  RealAry(Ind)

      CALL CheckIOS ( IOS, Fil, TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', NumType, PRESENT(ErrStat) )

      IF (IOS /= 0) THEN
         IF ( PRESENT(ErrStat) ) ErrStat = IOS
         RETURN
      ENDIF

      IF ( Echo )  THEN
         WRITE (UnEc,Frmt)  RealAry(Ind), TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', AryDescr
      END IF
   END DO

   RETURN
   END SUBROUTINE ReadRAryLines8 ! ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadRAryLines16 ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr, ErrStat )


      ! This routine reads a AryLen values into a real array from the next AryLen lines of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   REAL(QuKi), INTENT(OUT)      :: RealAry(AryLen)                                 ! Real (16-byte) array being read.

   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: AryDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: AryName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: Ind                                             ! Index into the real array.  Assumed to be one digit.
   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real array parameters


   IF ( PRESENT(ErrStat) ) ErrStat = 0

   DO Ind=1,AryLen
      READ (UnIn,*,IOSTAT=IOS)  RealAry(Ind)

      CALL CheckIOS ( IOS, Fil, TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', NumType, PRESENT(ErrStat) )

      IF (IOS /= 0) THEN
         IF ( PRESENT(ErrStat) ) ErrStat = IOS
         RETURN
      ENDIF

      IF ( Echo )  THEN
         WRITE (UnEc,Frmt)  RealAry(Ind), TRIM( AryName )//'('//TRIM( Int2LStr( Ind ) )//')', AryDescr
      END IF
   END DO

   RETURN
   END SUBROUTINE ReadRAryLines16 ! ( UnIn, Fil, RealAry, AryLen, AryName, AryDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadRVar ( UnIn, Fil, RealVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single real variable from the next line of the input file.
      ! New code should use ReadVar instead of this routine.


      ! Argument declarations:

   REAL(ReKi), INTENT(OUT)      :: RealVar                                         ! Real variable being read.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.

   CHARACTER( *), INTENT(IN)    :: Fil                                             ! Name of the input file.
   CHARACTER( *), INTENT(IN)    :: VarDescr                                        ! Text string describing the variable.
   CHARACTER( *), INTENT(IN)    :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real parameters
   CHARACTER(30)                :: Word                                            ! String to hold the first word on the line.



   IF ( PRESENT(ErrStat) ) THEN
      CALL ReadNum ( UnIn, Fil, Word, VarName, ErrStat )
      IF (ErrStat /= 0) RETURN
   ELSE
      CALL ReadNum ( UnIn, Fil, Word, VarName )
   END IF

   READ (Word,*,IOSTAT=IOS)  RealVar

   CALL CheckIOS ( IOS, Fil, VarName, NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   END IF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  RealVar, VarName, VarDescr
   END IF


   RETURN
   END SUBROUTINE ReadRVar ! ( UnIn, Fil, RealVar, VarName, VarDescr [, ErrStat] )
!=======================================================================
  SUBROUTINE ReadR4Var ( UnIn, Fil, RealVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single double (real) variable from the next line of the input file.


      ! Argument declarations:

   REAL(SiKi), INTENT(OUT)      :: RealVar                                         ! Real (4-byte) variable being read.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.

   CHARACTER( *), INTENT(IN)    :: Fil                                             ! Name of the input file.
   CHARACTER( *), INTENT(IN)    :: VarDescr                                        ! Text string describing the variable.
   CHARACTER( *), INTENT(IN)    :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real parameters
   CHARACTER(30)                :: Word                                            ! String to hold the first word on the line.



   IF ( PRESENT(ErrStat) ) THEN
      CALL ReadNum ( UnIn, Fil, Word, VarName, ErrStat )
      IF (ErrStat /= 0) RETURN
   ELSE
      CALL ReadNum ( UnIn, Fil, Word, VarName )
   END IF

   READ (Word,*,IOSTAT=IOS)  RealVar

   CALL CheckIOS ( IOS, Fil, VarName, NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   END IF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  RealVar, VarName, VarDescr
   END IF


   RETURN
  END SUBROUTINE ReadR4Var ! ( UnIn, Fil, RealVar, VarName, VarDescr [, ErrStat] )
!=======================================================================
  SUBROUTINE ReadR8Var ( UnIn, Fil, RealVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single double (real) variable from the next line of the input file.


      ! Argument declarations:

   REAL(R8Ki), INTENT(OUT)      :: RealVar                                         ! Real (8-byte) variable being read.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.

   CHARACTER( *), INTENT(IN)    :: Fil                                             ! Name of the input file.
   CHARACTER( *), INTENT(IN)    :: VarDescr                                        ! Text string describing the variable.
   CHARACTER( *), INTENT(IN)    :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real parameters
   CHARACTER(30)                :: Word                                            ! String to hold the first word on the line.



   IF ( PRESENT(ErrStat) ) THEN
      CALL ReadNum ( UnIn, Fil, Word, VarName, ErrStat )
      IF (ErrStat /= 0) RETURN
   ELSE
      CALL ReadNum ( UnIn, Fil, Word, VarName )
   END IF

   READ (Word,*,IOSTAT=IOS)  RealVar

   CALL CheckIOS ( IOS, Fil, VarName, NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   END IF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  RealVar, VarName, VarDescr
   END IF


   RETURN
  END SUBROUTINE ReadR8Var ! ( UnIn, Fil, RealVar, VarName, VarDescr [, ErrStat] )
!=======================================================================
  SUBROUTINE ReadR16Var ( UnIn, Fil, RealVar, VarName, VarDescr, ErrStat )


      ! This routine reads a single double (real) variable from the next line of the input file.


      ! Argument declarations:

   REAL(QuKi), INTENT(OUT)      :: RealVar                                         ! Real (16-byte) variable being read.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.

   CHARACTER( *), INTENT(IN)    :: Fil                                             ! Name of the input file.
   CHARACTER( *), INTENT(IN)    :: VarDescr                                        ! Text string describing the variable.
   CHARACTER( *), INTENT(IN)    :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(38)                :: Frmt = "( 2X, ES11.4e2, 2X, A, T30, ' - ', A )" ! Output format for real parameters
   CHARACTER(30)                :: Word                                            ! String to hold the first word on the line.



   IF ( PRESENT(ErrStat) ) THEN
      CALL ReadNum ( UnIn, Fil, Word, VarName, ErrStat )
      IF (ErrStat /= 0) RETURN
   ELSE
      CALL ReadNum ( UnIn, Fil, Word, VarName )
   END IF

   READ (Word,*,IOSTAT=IOS)  RealVar

   CALL CheckIOS ( IOS, Fil, VarName, NumType, PRESENT(ErrStat) )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   END IF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  RealVar, VarName, VarDescr
   END IF


   RETURN
   END SUBROUTINE ReadR16Var ! ( UnIn, Fil, RealVar, VarName, VarDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE ReadStr ( UnIn, Fil, CharVar, VarName, VarDescr, ErrStat )


      ! This routine reads a string from the next line of the input file.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: UnIn                                            ! I/O unit for input file.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                         ! Error status; if present, program does not abort on error

   CHARACTER(*), INTENT(OUT)    :: CharVar                                         ! Integer variable being read.
   CHARACTER(*), INTENT(IN)     :: Fil                                             ! Name of the input file.
   CHARACTER(*), INTENT(IN)     :: VarDescr                                        ! Text string describing the variable.
   CHARACTER(*), INTENT(IN)     :: VarName                                         ! Text string containing the variable name.


      ! Local declarations:

   INTEGER                      :: IOS                                             ! I/O status returned from the read statement.

   CHARACTER(35)                :: Frmt = "( 15X, A, T30, ' - ', A, /, 2X, A )"    ! Output format for string parameters.




   READ (UnIn,'(A)',IOSTAT=IOS)  CharVar

   CALL CheckIOS ( IOS, Fil, VarName, StrType )

   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = IOS
      IF (IOS /= 0) RETURN
   END IF

   IF ( Echo )  THEN
      WRITE (UnEc,Frmt)  VarName, VarDescr, '"'//TRIM( CharVar )//'"'
   END IF


   RETURN
   END SUBROUTINE ReadStr ! ( UnIn, Fil, CharVar, VarName, VarDescr [, ErrStat] )
!=======================================================================
   SUBROUTINE WaitTime ( WaitSecs )


      ! This routine writes out a prompt to the screen without
      ! following it with a new line, though a new line precedes it.


   IMPLICIT NONE


      ! Argument declarations:

   REAL(ReKi), INTENT(IN)       :: WaitSecs                                        ! The number of seconds to wait.


      ! Local declarations:

   REAL(ReKi)                   :: EndCounts                                       ! The number of counts when wait time is over.

   INTEGER                      :: Counts                                          ! Current number of counts on the system clock.
   INTEGER                      :: CountMax                                        ! Maximum number of counts possible on the system clock.
   INTEGER                      :: CountRate                                       ! Number of counts per second on the system clock.



   CALL SYSTEM_CLOCK ( Counts, CountRate, CountMax )
   EndCounts = Counts + INT( WaitSecs*CountRate )

   DO
      CALL SYSTEM_CLOCK ( Counts, CountRate, CountMax )
      IF ( Counts > EndCounts )  EXIT
   END DO


   RETURN
   END SUBROUTINE WaitTime ! ( Seconds )
!=======================================================================
   SUBROUTINE WrPr ( Str )


      ! This routine writes out a prompt to the screen without
      ! following it with a new line, though a new line precedes it.


      ! Argument declarations:

   CHARACTER(*), INTENT(IN)     :: Str                                          ! The prompt string to print.



   CALL WrScr ( ' ' )
   CALL WrNR  ( TRIM( Str )//' > ' )


   RETURN
   END SUBROUTINE WrPr ! ( Str )
!=======================================================================
   SUBROUTINE WrFileNR ( Unit, Str )


      ! This routine writes out a string to the file connected to Unit without following it with a new line.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: Unit                                         ! I/O unit for input file.

   CHARACTER(*), INTENT(IN)     :: Str                                          ! String to be written without a newline at the end.



   WRITE (Unit,'(A)',ADVANCE='NO')  Str


   RETURN
   END SUBROUTINE WrFileNR ! ( Unit, Str )
!=======================================================================
   SUBROUTINE WrML ( Str )


      ! This routine writes out a string in the middle of a line.


      ! Argument declarations.

   CHARACTER(*)                 :: Str



   CALL WrNR ( Str )


   RETURN
   END SUBROUTINE WrML ! ( Str )
!=======================================================================
   SUBROUTINE WrScr1 ( Str )


      ! This routine writes out a string to the screen after a blank line.


      ! Argument declarations.

   CHARACTER(*)                 :: Str                                         ! The string to print.



   CALL WrScr ( ' ' )
   CALL WrScr ( TRIM( Str ) )


   RETURN
   END SUBROUTINE WrScr1 ! ( Str )
!=======================================================================

END MODULE NWTC_IO
MODULE NWTC_Num


   ! This module contains numeric-type routines with non-system-specific logic and references.


   ! It contains the following routines:

   !     SUBROUTINE AddOrSub2Pi   ( OldAngle, NewAngle )
   !     SUBROUTINE BSortReal     ( RealAry, NumPts )
   !     FUNCTION   CROSS_PRODUCT ( Vector1, Vector2 )
   !     FUNCTION   EqualRealNos  ( ReNum1, ReNum2 )
   !     SUBROUTINE GL_Pts        ( IPt, NPts, Loc, Wt [, ErrStat] )
   !     FUNCTION   IndexCharAry  ( CVal, CAry )
   !     FUNCTION   InterpBin     ( XVal, XAry, YAry, ILo, AryLen )             ! Generic interface for InterpBinComp and InterpBinReal.
   !     FUNCTION   InterpBinComp ( XVal, XAry, YAry, ILo, AryLen )
   !     FUNCTION   InterpBinReal ( XVal, XAry, YAry, ILo, AryLen )
   !     FUNCTION   InterpStp     ( XVal, XAry, YAry, ILo, AryLen )             ! Generic interface for InterpStpComp and InterpStpReal.
   !     FUNCTION   InterpStpComp ( XVal, XAry, YAry, Ind, AryLen )
   !     FUNCTION   InterpStpReal ( XVal, XAry, YAry, Ind, AryLen )
   !     SUBROUTINE LocateStp     ( XVal, XAry, Ind, AryLen )
   !     FUNCTION   Mean          ( Ary, AryLen )                               ! Function to calculate the mean value of a vector array.
   !     SUBROUTINE MPi2Pi        ( Angle )
   !     SUBROUTINE RombergInt    ( f, a, b, R, err, eps, ErrStat )
   !     SUBROUTINE SetConstants
   !     SUBROUTINE SmllRotTrans  ( RotationType, Theta1, Theta2, Theta3, TransMat, ErrTxt )
   !     SUBROUTINE SortUnion     ( Ary1, N1, Ary2, N2, Ary, N )
   !     FUNCTION   StdDevFn      ( Ary, AryLen, Mean )                         ! Function to calculate the standard deviation of a vector array.


   USE                             NWTC_IO

   IMPLICIT NONE

!=======================================================================


      ! Global numeric-related variables.

   REAL(DbKi)                   :: D2R_D                                        ! Factor to convert degrees to radians in double precision.
   REAL(DbKi)                   :: Inf_D                                        ! IEEE value for NaN (not-a-number) in double precision 
   REAL(DbKi)                   :: NaN_D                                        ! IEEE value for Inf (infinity) in double precision
   REAL(DbKi)                   :: Pi_D                                         ! Ratio of a circle's circumference to its diameter in double precision.
   REAL(DbKi)                   :: PiBy2_D                                      ! Pi/2 in double precision.
   REAL(DbKi)                   :: R2D_D                                        ! Factor to convert radians to degrees in double precision.
   REAL(DbKi)                   :: RPM2RPS_D                                    ! Factor to convert revolutions per minute to radians per second in double precision.
   REAL(DbKi)                   :: RPS2RPM_D                                    ! Factor to convert radians per second to revolutions per minute in double precision.
   REAL(DbKi)                   :: TwoByPi_D                                    ! 2/Pi in double precision.
   REAL(DbKi)                   :: TwoPi_D                                      ! 2*Pi in double precision.
   
   
   REAL(ReKi)                   :: D2R                                          ! Factor to convert degrees to radians.
   REAL(ReKi)                   :: Inf                                          ! IEEE value for NaN (not-a-number)
   REAL(ReKi)                   :: NaN                                          ! IEEE value for Inf (infinity)
   REAL(ReKi)                   :: Pi                                           ! Ratio of a circle's circumference to its diameter.
   REAL(ReKi)                   :: PiBy2                                        ! Pi/2.
   REAL(ReKi)                   :: R2D                                          ! Factor to convert radians to degrees.
   REAL(ReKi)                   :: RPM2RPS                                      ! Factor to convert revolutions per minute to radians per second.
   REAL(ReKi)                   :: RPS2RPM                                      ! Factor to convert radians per second to revolutions per minute.
   REAL(ReKi)                   :: TwoByPi                                      ! 2/Pi.
   REAL(ReKi)                   :: TwoPi                                        ! 2*Pi.

   INTEGER, ALLOCATABLE         :: IntIndx  (:,:)                               ! The array of indices holding that last index used for interpolation in IntBlade().


!=======================================================================

      ! Create interface for a generic EqualRealNos that uses specific routines.

   INTERFACE EqualRealNos
      MODULE PROCEDURE EqualRealNos4
      MODULE PROCEDURE EqualRealNos8
      MODULE PROCEDURE EqualRealNos16
   END INTERFACE
   

      ! Create interface for a generic InterpBin that actually uses specific routines.

   INTERFACE InterpBin
      MODULE PROCEDURE InterpBinComp
      MODULE PROCEDURE InterpBinReal
   END INTERFACE


      ! Create interface for a generic InterpStp that actually uses specific routines.

   INTERFACE InterpStp
      MODULE PROCEDURE InterpStpComp
      MODULE PROCEDURE InterpStpReal
   END INTERFACE


CONTAINS

!=======================================================================
   SUBROUTINE AddOrSub2Pi ( OldAngle, NewAngle )


      ! This routine is used to convert NewAngle to an angle within 2*Pi of
      !   OldAngle by adding or subtracting 2*Pi accordingly; it then sets
      !   OldAngle equal to NewAngle.  This routine is useful for converting
      !   angles returned from a call to the ATAN2() FUNCTION into angles that may
      !   exceed the -Pi to Pi limit of ATAN2().  For example, if the nacelle yaw
      !   angle was 179deg in the previous time step and the yaw angle increased
      !   by 2deg in the new time step, we want the new yaw angle returned from a
      !   call to the ATAN2() FUNCTION to be 181deg instead of -179deg.  This
      !   routine assumes that the angle change between calls is not more than
      !   2*Pi in absolute value.  OldAngle should be SAVEd in the calling
      !   routine.


      ! Argument declarations:

   REAL(ReKi), INTENT(INOUT)    :: OldAngle                                     ! Angle from which NewAngle will be converted to within 2*Pi of, rad.
   REAL(ReKi), INTENT(INOUT)    :: NewAngle                                     ! Angle to be converted to within 2*Pi of OldAngle, rad.


      ! Local declarations:

   REAL(ReKi)                   :: DelAngle                                     ! The difference between OldAngle and NewAngle, rad.



      ! Add or subtract 2*Pi in order to convert NewAngle two within 2*Pi of
      !   OldAngle:

   DelAngle = OldAngle - NewAngle

   DO WHILE ( ABS( DelAngle ) >= TwoPi )

      NewAngle = NewAngle + SIGN( TwoPi, DelAngle )
      DelAngle = OldAngle - NewAngle

   END DO


      ! Set OldAngle to equal NewAngle:

   OldAngle = NewAngle



   RETURN
   END SUBROUTINE AddOrSub2Pi
!=======================================================================
   SUBROUTINE BSortReal ( RealAry, NumPts )


      ! This routine sorts a list of real numbers.  It uses the buble sort algorithm,
      ! which is only suitable for short lists.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: NumPts                                       ! The length of the list to be sorted.

   REAL(ReKi), INTENT(INOUT)    :: RealAry(NumPts)                              ! The list of real numbers to be sorted.


      ! Local declarations:

   REAL(ReKi)                   :: Temp                                         ! Temporary variable to hold the current element.

   INTEGER                      :: I                                            ! Index into the array.

   LOGICAL                      :: Change                                       ! Flag to indicate if a change of order was made.


      ! Sort the list

   Change = .TRUE.

   DO WHILE ( Change )

      Change = .FALSE.

      DO I=2,NumPts
         IF ( RealAry(I) < RealAry(I-1) )  THEN
            Temp           = RealAry(I)
            RealAry(I)   = RealAry(I-1)
            RealAry(I-1) = Temp
            Change         = .TRUE.
         END IF
      END DO ! I

   END DO ! WHILE


   RETURN
   END SUBROUTINE BSortReal ! ( RealAry, NumPts )
!=======================================================================
   FUNCTION Cross_Product(Vector1, Vector2)

      ! This function computes the cross product of two 3-element arrays:
      ! Cross_Product = Vector1 X Vector2 (resulting in a vector)


      ! Argument declarations.

   REAL(ReKi), INTENT(IN )         :: Vector1       (3)
   REAL(ReKi), INTENT(IN )         :: Vector2       (3)

      ! Function definition
   REAL(ReKi)                      :: Cross_Product (3)        ! = Vector1 X Vector2 (resulting in a vector)


   Cross_Product(1) = Vector1(2)*Vector2(3) - Vector1(3)*Vector2(2)
   Cross_Product(2) = Vector1(3)*Vector2(1) - Vector1(1)*Vector2(3)
   Cross_Product(3) = Vector1(1)*Vector2(2) - Vector1(2)*Vector2(1)


   RETURN
   END FUNCTION Cross_Product
!=======================================================================
!   SUBROUTINE GetPermMat ( InpMat, PMat, ErrStat )
!
!      ! This subroutine computes a permutation matrix, PMat, for a given
!      ! input matrix, InpMat. It assumes that InpMat is of full rank
!      ! and for now, the matrices are 3 x 3.
!
!      ! passed variables
!
!   REAL(ReKi), INTENT(IN )         :: InpMat       (3,3)
!   REAL(ReKi), INTENT(OUT )        :: PMat         (3,3) !this could be integer, but we'll leave it real now
!   INTEGER,    INTENT(OUT )        :: ErrStat            ! a non-zero value indicates an error in the permutation matrix algorithm
!
!      ! local variables
!   INTEGER                         :: iCol               ! loop counter
!   INTEGER                         :: iRow               ! loop counter
!   INTEGER                         :: MaxCol             ! holds index of maximum value in a column
!
!   LOGICAL                         :: ChkCols     (3)    ! a check to make sure we have only one non-zero element per column
!
!      ! initialize some variables
!   PMat    = 0.0
!   ChkCols = .FALSE.
!   ErrStat = 0
!
!      ! find the pivots
!   DO iRow = 1,3
!
!      MaxCol = 1        ! initialize max index
!      DO iCol = 2,3
!         IF ( ABS(InpMat(iRow,iCol)) > ABS(InpMat(iRow,MaxCol)) ) &
!            MaxCol = iCol
!      END DO ! iCol
!
!      IF ( ChkCols(MaxCol) ) THEN   ! we can have only 1 non-zero entry per row and column, but we've just violated that!
!         CALL ProgAbort( ' Error in GetPermMat(): InpMat is not full rank.', TrapErrors = .TRUE. )
!         ErrStat = 1
!      END IF
!
!      PMat(MaxCol, iRow) = SIGN( 1.0_ReKi, InpMat(iRow,MaxCol) )  ! technically a permutation matrix would only have +1.0 (not -1.0)
!      ChkCols(MaxCol)    = .TRUE.
!
!   END DO ! iRow
!
!   RETURN
!   END SUBROUTINE GetPermMat ! ( InpMat, PMat, ErrStat )

!=======================================================================
   FUNCTION EqualRealNos4 ( ReNum1, ReNum2 )

      ! This function compares 2 real numbers and determines if they
      ! are "almost" equal, i.e. within some relative tolerance
      ! ("Safe Comparisons" suggestion from http://www.lahey.com/float.htm)

      ! passed variables

   REAL(SiKi), INTENT(IN )         :: ReNum1                            ! the first  real number to compare
   REAL(SiKi), INTENT(IN )         :: ReNum2                            ! the second real number to compare

   LOGICAL                         :: EqualRealNos4                     ! the function definition -- returns .true. if the numbers are almost equal

      ! local variables
   REAL(SiKi), PARAMETER           :: Eps = EPSILON(ReNum1)             ! machine precision
   REAL(SiKi), PARAMETER           :: Tol = 100.0_SiKi*Eps / 2.0_SiKi   ! absolute tolerance (ignore the last 2 significant digits)

   REAL(SiKi)                      :: Fraction


      ! make sure we're never trying to get more precision than Tol

   Fraction = MAX( ABS(ReNum1+ReNum2), 1.0_SiKi )



      ! determine if ReNum1 and ReNum2 are approximately equal

   IF ( ABS(ReNum1 - ReNum2) <= Fraction*Tol ) THEN  ! the relative error 
      EqualRealNos4 = .TRUE.
   ELSE
      EqualRealNos4 = .FALSE.
   ENDIF


   END FUNCTION EqualRealNos4
!=======================================================================
  FUNCTION EqualRealNos8 ( ReNum1, ReNum2 )

      ! This function compares 2 real numbers and determines if they
      ! are "almost" equal, i.e. within some relative tolerance
      ! ("Safe Comparisons" suggestion from http://www.lahey.com/float.htm)

      ! passed variables

   REAL(R8Ki), INTENT(IN )         :: ReNum1                            ! the first  real number to compare
   REAL(R8Ki), INTENT(IN )         :: ReNum2                            ! the second real number to compare

   LOGICAL                         :: EqualRealNos8                     ! the function definition -- returns .true. if the numbers are almost equal

      ! local variables
   REAL(R8Ki), PARAMETER           :: Eps = EPSILON(ReNum1)             ! machine precision
   REAL(R8Ki), PARAMETER           :: Tol = 100.0_R8Ki*Eps / 2.0_R8Ki   ! absolute tolerance (ignore the last 2 significant digits)

   REAL(R8Ki)                      :: Fraction


      ! make sure we're never trying to get more precision than Tol

   Fraction = MAX( ABS(ReNum1+ReNum2), 1.0_R8Ki )



      ! determine if ReNum1 and ReNum2 are approximately equal

   IF ( ABS(ReNum1 - ReNum2) <= Fraction*Tol ) THEN  ! the relative error
      EqualRealNos8 = .TRUE.
   ELSE
      EqualRealNos8 = .FALSE.
   ENDIF


  END FUNCTION EqualRealNos8
!=======================================================================
  FUNCTION EqualRealNos16 ( ReNum1, ReNum2 )

      ! This function compares 2 real numbers and determines if they
      ! are "almost" equal, i.e. within some relative tolerance
      ! ("Safe Comparisons" suggestion from http://www.lahey.com/float.htm)

      ! passed variables

   REAL(QuKi), INTENT(IN )         :: ReNum1                            ! the first  real number to compare
   REAL(QuKi), INTENT(IN )         :: ReNum2                            ! the second real number to compare

   LOGICAL                         :: EqualRealNos16                    ! the function definition -- returns .true. if the numbers are almost equal

      ! local variables
   REAL(QuKi), PARAMETER           :: Eps = EPSILON(ReNum1)             ! machine precision
   REAL(QuKi), PARAMETER           :: Tol = 100.0_QuKi*Eps / 2.0_QuKi   ! absolute tolerance (ignore the last 2 significant digits)

   REAL(QuKi)                      :: Fraction


      ! make sure we're never trying to get more precision than Tol

   Fraction = MAX( ABS(ReNum1+ReNum2), 1.0_QuKi )



      ! determine if ReNum1 and ReNum2 are approximately equal

   IF ( ABS(ReNum1 - ReNum2) <= Fraction*Tol ) THEN  ! the relative error
      EqualRealNos16 = .TRUE.
   ELSE
      EqualRealNos16 = .FALSE.
   ENDIF


  END FUNCTION EqualRealNos16
!=======================================================================
   FUNCTION GetSmllRotAngs ( DCMat, ErrStat )

      ! This subroutine computes the angles that make up the input
      ! direction cosine matrix, DCMat

      ! passed variables

   REAL(ReKi), INTENT(IN )         :: DCMat          (3,3)
   INTEGER,    INTENT(OUT )        :: ErrStat               ! a non-zero value indicates an error in the permutation matrix algorithm

   REAL(ReKi)                      :: GetSmllRotAngs ( 3 )

      ! local variables
   REAL(ReKi)                      :: denom                 ! the denominator of the resulting matrix
   REAL(ReKi), PARAMETER           :: LrgAngle  = 0.4       ! Threshold for when a small angle becomes large (about 23deg).  This comes from: COS(SmllAngle) ~ 1/SQRT( 1 + SmllAngle^2 ) and SIN(SmllAngle) ~ SmllAngle/SQRT( 1 + SmllAngle^2 ) results in ~5% error when SmllAngle = 0.4rad.
   REAL(ReKi), PARAMETER           :: TOL = EPSILON(TOL)    ! tolerance for division by zero



      ! initialize output angles (just in case there is an error that prevents them from getting set)

   GetSmllRotAngs = 0.0
   ErrStat        = 0


      ! calculate the small angles
   GetSmllRotAngs(1) = DCMat(2,3) - DCMat(3,2)
   GetSmllRotAngs(2) = DCMat(3,1) - DCMat(1,3)
   GetSmllRotAngs(3) = DCMat(1,2) - DCMat(2,1)

   denom             = DCMat(1,1) + DCMat(2,2) + DCMat(3,3) - 1

   IF ( ABS(denom) > TOL ) THEN
      GetSmllRotAngs = GetSmllRotAngs / denom

               ! check that the angles are, in fact, small
      IF ( ANY( ABS(GetSmllRotAngs) > LrgAngle ) ) THEN
         CALL ProgWarn( ' Angles in GetSmllRotAngs() are larger than '//TRIM(Num2LStr(LrgAngle))//' radians.' )
         ErrStat = 1
      END IF

   ELSE
            ! check that the angles are, in fact, small (denom should be close to 2 if angles are small)
      CALL ProgAbort( ' Denominator is zero in GetSmllRotAngs().', TrapErrors = .TRUE. )
      ErrStat = -1

   END IF


   END FUNCTION GetSmllRotAngs ! ( DCMat, PMat, ErrStat )
!=======================================================================
   SUBROUTINE GL_Pts ( IPt, NPts, Loc, Wt, ErrStat )

      ! This funtion returns the non-dimensional (-1:+1) location of the given Gauss-Legendre Quadrature point and its weight.
      ! The values came from Carnahan, Brice; Luther, H.A.; Wilkes, James O.  (1969)  "Applied Numerical Methods."


      ! Argument declarations.

   REAL(ReKi)                     :: Loc                                         ! The location of the specified point.
   REAL(ReKi)                     :: Wt                                          ! The weight for the specified point.

   INTEGER, INTENT(OUT), OPTIONAL :: ErrStat                                     ! Error status; if present, program does not abort on error
   INTEGER, INTENT(INOUT)         :: IPt                                         ! The quadrature point in question.
   INTEGER, INTENT(INOUT)         :: NPts                                        ! The number of points used in the quadrature.


   IF ( PRESENT(ErrStat) ) ErrStat = 0


      ! Check to see if the number of points and the specific point are valid values.

   IF ( ( NPts < 1 ) .OR. ( NPts > 6 ) )  THEN
      CALL ProgAbort ( ' In function GL_Loc, the number of points used for Gauss-Legendre Quadrature must be between 1 and 6' &
                    //' (inclusive).  Instead, it is "'//TRIM( Int2LStr( NPts ) )//'".', PRESENT(ErrStat) )
      IF ( PRESENT(ErrStat) ) THEN ! this should always be true here
         ErrStat = 1
         RETURN
      END IF
   END IF

   IF ( ( Ipt < 1 ) .OR. ( Ipt > NPts ) )  THEN
      CALL ProgAbort ( ' In function GL_Loc, the point being used for Gauss-Legendre Quadrature must be between 1 and ' &
                   //TRIM( Int2LStr( NPts ) )//' (inclusive).  Instead, it is "'//TRIM( Int2LStr( Ipt ) )//'".', PRESENT(ErrStat) )
      IF ( PRESENT(ErrStat) ) THEN
         ErrStat = 1
         RETURN
      END IF
   END IF


      ! Set the location and weight of the point.

   SELECT CASE ( NPts )
      CASE ( 1 )                         ! Case 1 is really just rectangular integration.
         Loc = 0.0
         Wt  = 2.0
      CASE ( 2 )
         SELECT CASE ( Ipt )
            CASE ( 1 )
               Loc = -0.5773503
               Wt  =  1.0
            CASE ( 2 )
               Loc = 0.5773503
               Wt  = 1.0
          END SELECT ! Ipt
      CASE ( 3 )
         SELECT CASE ( Ipt )
            CASE ( 1 )
               Loc = -0.7745967
               Wt  =  0.5555556
            CASE ( 2 )
               Loc =  0.0
               Wt  =  0.8888889
            CASE ( 3 )
               Loc =  0.7745967
               Wt  =  0.5555556
         END SELECT ! Ipt
      CASE ( 4 )
         SELECT CASE ( Ipt )
            CASE ( 1 )
               Loc = -0.8611363
               Wt  =  0.3478548
            CASE ( 2 )
               Loc = -0.3399810
               Wt  =  0.6521452
            CASE ( 3 )
               Loc =  0.3399810
               Wt  =  0.6521452
            CASE ( 4 )
               Loc =  0.8611363
               Wt  =  0.3478548
         END SELECT ! Ipt
      CASE ( 5 )
         SELECT CASE ( Ipt )
            CASE ( 1 )
               Loc = -0.9061798
               Wt  =  0.2369269
            CASE ( 2 )
               Loc = -0.5384693
               Wt  =  0.4786287
            CASE ( 3 )
               Loc =  0.0
               Wt  =  0.5688889
            CASE ( 4 )
               Loc =  0.5384693
               Wt  =  0.4786287
            CASE ( 5 )
               Loc =  0.9061798
               Wt  =  0.2369269
         END SELECT ! Ipt
      CASE ( 6 )
         SELECT CASE ( Ipt )
            CASE ( 1 )
               Loc = -0.9324695
               Wt  =  0.1713245
            CASE ( 2 )
               Loc = -0.6612094
               Wt  =  0.3607616
            CASE ( 3 )
               Loc = -0.2386192
               Wt  =  0.4679139
            CASE ( 4 )
               Loc =  0.2386192
               Wt  =  0.4679139
            CASE ( 5 )
               Loc =  0.6612094
               Wt  =  0.3607616
            CASE ( 6 )
               Loc =  0.9324695
               Wt  =  0.1713245
         END SELECT ! Ipt
   END SELECT ! Npts

   RETURN
   END SUBROUTINE GL_Pts ! ( IPt, NPts, Loc, Wt [, ErrStat] )
!=======================================================================
   FUNCTION IndexCharAry( CVal, CAry )


      ! This funtion returns an integer index such that CAry(IndexCharAry) = CVal. If
      ! no element in the array matches CVal, the value -1 is returned.  The routine
      ! performs a binary search on the input array to determine if CVal is an
      ! element of the array; thus, CAry must be sorted and stored in increasing
      ! alphebetical (ASCII) order. The routine does not check that the array is
      ! sorted.  The routine assumes that CVal is type CHARACTER and CAry
      ! is an array of CHARACTERS.


      ! Function declaration.


   INTEGER                      :: IndexCharAry                                   ! This function

      ! Argument declarations.

   CHARACTER(*), INTENT(IN)     :: CVal                                           ! String to find.
   CHARACTER(*), INTENT(IN)     :: CAry(:)                                        ! Array of strings to search.



      ! Local declarations.

   INTEGER                      :: IHi                                             ! The high index into the arrays.
   INTEGER                      :: IMid                                            ! The mid-point index between IHi and ILo.
   INTEGER                      :: ILo


      ! Initialize some variables

   ILo = 1
   IHi = SIZE(CAry)

   IF (     CVal == CAry(ILo) ) THEN
      IndexCharAry = ILo
   ELSEIF ( CVal == CAry(IHi) ) THEN
      IndexCharAry = IHi
   ELSE
      IndexCharAry = -1


         ! Let's search!

      DO WHILE ( IHi-ILo > 1 )

         IMid = ( IHi + ILo )/2

         IF( CVal > CAry(IMid) ) THEN
            ILo = IMid
         ELSEIF (CVal < CAry(IMid) ) THEN
            IHi = IMid
         ELSE !Found it
            IndexCharAry = IMid
            EXIT
         END IF

      END DO

   END IF


   RETURN

   END FUNCTION IndexCharAry
!=======================================================================
   FUNCTION InterpBinComp( XVal, XAry, YAry, ILo, AryLen )


      ! This funtion returns a y-value that corresponds to an input x-value by interpolating into the arrays.
      ! It uses a binary interpolation scheme that takes about log(AryLen)/log(2) steps to converge.
      ! It returns the first or last YAry() value if XVal is outside the limits of XAry().
      ! This routine assumes YAry is COMPLEX.


      ! Function declaration.


   COMPLEX(ReKi)                :: InterpBinComp                                   ! This function.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the arrays.
   INTEGER, INTENT(INOUT)       :: ILo                                             ! The low index into the arrays.

   REAL(ReKi), INTENT(IN)       :: XAry    (AryLen)                                ! Array of X values to be interpolated.
   REAL(ReKi), INTENT(IN)       :: XVal                                            ! X value to be interpolated.

   COMPLEX(ReKi), INTENT(IN)    :: YAry    (AryLen)                                ! Array of Y values to be interpolated.


      ! Local declarations.

   INTEGER                      :: IHi                                             ! The high index into the arrays.
   INTEGER                      :: IMid                                            ! The mid-point index between IHi and ILo.



      ! Let's check the limits first.

   IF ( XVal <= XAry(1) )  THEN
      InterpBinComp = YAry(1)
      ILo           = 1
      RETURN
   ELSE IF ( XVal >= XAry(AryLen) )  THEN
      InterpBinComp = YAry(AryLen)
      ILo           = AryLen - 1
      RETURN
   END IF


      ! Let's interpolate!

   ILo  = 1
   IHi  = AryLen

   DO WHILE ( IHi-ILo > 1 )

      IMid = ( IHi + ILo )/2

      IF ( XVal >= XAry(IMid) ) THEN
         ILo = IMid
      ELSE
         IHi = IMid
      END IF

   END DO

   InterpBinComp = YAry(ILo) + ( YAry(IHi) - YAry(ILo) )*( XVal - XAry(ILo) )/( XAry(IHi) - XAry(ILo) )


   RETURN
   END FUNCTION InterpBinComp ! ( XVal, XAry, YAry, ILo, AryLen )
!=======================================================================
   FUNCTION InterpBinReal( XVal, XAry, YAry, ILo, AryLen )


      ! This funtion returns a y-value that corresponds to an input x-value by interpolating into the arrays.
      ! It uses a binary interpolation scheme that takes about log(AryLen)/log(2) steps to converge.
      ! It returns the first or last YAry() value if XVal is outside the limits of XAry().
      ! This routine assumes YAry is REAL.


      ! Function declaration.


   REAL(ReKi)                   :: InterpBinReal                                   ! This function.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the arrays.
   INTEGER, INTENT(INOUT)       :: ILo                                             ! The low index into the arrays.

   REAL(ReKi), INTENT(IN)       :: XAry    (AryLen)                                ! Array of X values to be interpolated.
   REAL(ReKi), INTENT(IN)       :: XVal                                            ! X value to be interpolated.
   REAL(ReKi), INTENT(IN)       :: YAry    (AryLen)                                ! Array of Y values to be interpolated.


      ! Local declarations.

   INTEGER                      :: IHi                                             ! The high index into the arrays.
   INTEGER                      :: IMid                                            ! The mid-point index between IHi and ILo.



      ! Let's check the limits first.

   IF ( XVal <= XAry(1) )  THEN
      InterpBinReal = YAry(1)
      ILo           = 1
      RETURN
   ELSE IF ( XVal >= XAry(AryLen) )  THEN
      InterpBinReal = YAry(AryLen)
      ILo           = AryLen - 1
      RETURN
   END IF


      ! Let's interpolate!

   ILo  = 1
   IHi  = AryLen

   DO WHILE ( IHi-ILo > 1 )

      IMid = ( IHi + ILo )/2

      IF ( XVal >= XAry(IMid) ) THEN
         ILo = IMid
      ELSE
         IHi = IMid
      END IF

   END DO

   InterpBinReal = YAry(ILo) + ( YAry(IHi) - YAry(ILo) )*( XVal - XAry(ILo) )/( XAry(IHi) - XAry(ILo) )


   RETURN
   END FUNCTION InterpBinReal ! ( XVal, XAry, YAry, ILo, AryLen )
!=======================================================================
   FUNCTION InterpStpComp( XVal, XAry, YAry, Ind, AryLen )


      ! This funtion returns a y-value that corresponds to an input x-value by interpolating into the arrays.
      ! It uses the passed index as the starting point and does a stepwise interpolation from there.  This is
      ! especially useful when the calling routines save the value from the last time this routine was called
      ! for a given case where XVal does not change much from call to call.  When there is no correlation
      ! from one interpolation to another, InterpBin() may be a better choice.
      ! It returns the first or last YAry() value if XVal is outside the limits of XAry().
      ! This routine assumes YAry is COMPLEX.


      ! Function declaration.


   COMPLEX(ReKi)                :: InterpStpComp                                   ! This function.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the arrays.
   INTEGER, INTENT(INOUT)       :: Ind                                             ! Initial and final index into the arrays.

   REAL(ReKi), INTENT(IN)       :: XAry    (AryLen)                                ! Array of X values to be interpolated.
   REAL(ReKi), INTENT(IN)       :: XVal                                            ! X value to be interpolated.

   COMPLEX(ReKi), INTENT(IN)    :: YAry    (AryLen)                                ! Array of Y values to be interpolated.



      ! Let's check the limits first.

   IF ( XVal <= XAry(1) )  THEN
      InterpStpComp = YAry(1)
      Ind           = 1
      RETURN
   ELSE IF ( XVal >= XAry(AryLen) )  THEN
      InterpStpComp = YAry(AryLen)
      Ind           = AryLen - 1
      RETURN
   END IF


     ! Let's interpolate!

   Ind = MAX( MIN( Ind, AryLen-1 ), 1 )

   DO

      IF ( XVal < XAry(Ind) )  THEN

         Ind = Ind - 1

      ELSE IF ( XVal >= XAry(Ind+1) )  THEN

         Ind = Ind + 1

      ELSE

         InterpStpComp = ( YAry(Ind+1) - YAry(Ind) )*( XVal - XAry(Ind) )/( XAry(Ind+1) - XAry(Ind) ) + YAry(Ind)
         RETURN

      END IF

   END DO


   RETURN
   END FUNCTION InterpStpComp ! ( XVal, XAry, YAry, Ind, AryLen )
!=======================================================================
   FUNCTION InterpStpReal( XVal, XAry, YAry, Ind, AryLen )


      ! This funtion returns a y-value that corresponds to an input x-value by interpolating into the arrays.
      ! It uses the passed index as the starting point and does a stepwise interpolation from there.  This is
      ! especially useful when the calling routines save the value from the last time this routine was called
      ! for a given case where XVal does not change much from call to call.  When there is no correlation
      ! from one interpolation to another, InterpBin() may be a better choice.
      ! It returns the first or last YAry() value if XVal is outside the limits of XAry().
      ! This routine assumes YAry is REAL.


      ! Function declaration.

   REAL(ReKi)                   :: InterpStpReal                                   ! This function.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the arrays.
   INTEGER, INTENT(INOUT)       :: Ind                                             ! Initial and final index into the arrays.

   REAL(ReKi), INTENT(IN)       :: XAry    (AryLen)                                ! Array of X values to be interpolated.
   REAL(ReKi), INTENT(IN)       :: XVal                                            ! X value to be interpolated.
   REAL(ReKi), INTENT(IN)       :: YAry    (AryLen)                                ! Array of Y values to be interpolated.



      ! Let's check the limits first.

   IF ( XVal <= XAry(1) )  THEN
      InterpStpReal = YAry(1)
      Ind           = 1
      RETURN
   ELSE IF ( XVal >= XAry(AryLen) )  THEN
      InterpStpReal = YAry(AryLen)
      Ind           = AryLen - 1
      RETURN
   END IF


     ! Let's interpolate!

   Ind = MAX( MIN( Ind, AryLen-1 ), 1 )

   DO

      IF ( XVal < XAry(Ind) )  THEN

         Ind = Ind - 1

      ELSE IF ( XVal >= XAry(Ind+1) )  THEN

         Ind = Ind + 1

      ELSE

         InterpStpReal = ( YAry(Ind+1) - YAry(Ind) )*( XVal - XAry(Ind) )/( XAry(Ind+1) - XAry(Ind) ) + YAry(Ind)
         RETURN

      END IF

   END DO


   RETURN
   END FUNCTION InterpStpReal ! ( XVal, XAry, YAry, Ind, AryLen )
!=======================================================================
   SUBROUTINE LocateBin( XVal, XAry, Ind, AryLen )

      ! This subroutine finds the lower-bound index of an input x-value located in an array.
      ! On return, Ind has a value such that
      !           XAry(Ind) <= XVal < XAry(Ind+1), with the exceptions that
      !             Ind = 0 when XVal < XAry(1), and
      !          Ind = AryLen when XAry(AryLen) <= XVal.
      !
      ! It uses a binary interpolation scheme that takes about log(AryLen)/log(2) steps to converge.
      ! If the index doesn't change much between calls, LocateStp() may be a better option.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(OUT)         :: Ind                                             ! Final (low) index into the array.

   REAL(ReKi), INTENT(IN)       :: XAry    (AryLen)                                ! Array of X values to be interpolated.
   REAL(ReKi), INTENT(IN)       :: XVal                                            ! X value to be interpolated.


      ! Local declarations.

   INTEGER                      :: IHi                                             ! The high index into the arrays.
   INTEGER                      :: IMid                                            ! The mid-point index between IHi and Ind.



      ! Let's check the limits first.

   IF ( XVal < XAry(1) )  THEN
      Ind = 0
   ELSE IF ( XVal >= XAry(AryLen) )  THEN
      Ind = AryLen
   ELSE
         ! Let's interpolate!

      Ind  = 1
      IHi  = AryLen

      DO WHILE ( IHi-Ind > 1 )

         IMid = ( IHi + Ind )/2

         IF ( XVal >= XAry(IMid) ) THEN
            Ind = IMid
         ELSE
            IHi = IMid
         END IF

      END DO

   END IF

   RETURN
   END SUBROUTINE LocateBin
!=======================================================================
   SUBROUTINE LocateStp( XVal, XAry, Ind, AryLen )

      ! This subroutine finds the lower-bound index of an input x-value located in an array.
      ! On return, Ind has a value such that
      !           XAry(Ind) <= XVal < XAry(Ind+1), with the exceptions that
      !             Ind = 0 when XVal < XAry(1), and
      !          Ind = AryLen when XAry(AryLen) <= XVal.
      !
      ! It uses the passed index as the starting point and does a stepwise search from there.  This is
      ! especially useful when the calling routines save the value from the last time this routine was called
      ! for a given case where XVal does not change much from call to call.  When there is no correlation
      ! from one interpolation to another, a binary search may be a better choice.



      ! Argument declarations.

   INTEGER, INTENT(IN)          :: AryLen                                          ! Length of the array.
   INTEGER, INTENT(INOUT)       :: Ind                                             ! Initial and final index into the array.

   REAL(ReKi), INTENT(IN)       :: XAry    (AryLen)                                ! Array of X values to be interpolated.
   REAL(ReKi), INTENT(IN)       :: XVal                                            ! X value to be interpolated.



      ! Let's check the limits first.

   IF ( XVal < XAry(1) )  THEN
      Ind = 0
   ELSE IF ( XVal >= XAry(AryLen) )  THEN
      Ind = AryLen
   ELSE

      Ind = MAX( MIN( Ind, AryLen-1 ), 1 )

      DO

         IF ( XVal < XAry(Ind) )  THEN

            Ind = Ind - 1

         ELSE IF ( XVal >= XAry(Ind+1) )  THEN

            Ind = Ind + 1

         ELSE

            RETURN

         END IF

      END DO


   END IF

   RETURN

   END SUBROUTINE LocateStp
!=======================================================================
   FUNCTION Mean ( Ary, AryLen )


      ! This routine calculates the mean value of an array.


      ! Function declaration.

   REAL(ReKi)                   :: Mean                                         ! This function.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                       ! Length of the array.

   REAL(ReKi), INTENT(IN)       :: Ary  (AryLen)                                ! Input array.


      ! Local declarations.

   INTEGER                      :: I                                            ! The index into the array.



   Mean = 0.0

   DO I=1,AryLen
      Mean = Mean + Ary(I)
   END DO ! I

   Mean = Mean/AryLen


   RETURN
   END FUNCTION Mean ! ( Ary, AryLen )
!=======================================================================
   SUBROUTINE MPi2Pi ( Angle )


      ! This routine ensures that Angle lies between -pi and pi.


      ! Argument declarations:

   REAL(ReKi), INTENT(INOUT)    :: Angle



      ! Get the angle between 0 and 2Pi.

   Angle = MODULO( Angle, TwoPi )


      ! Get the angle between -Pi and Pi.

   IF ( Angle > Pi )  THEN
      Angle = Angle - TwoPi
   END IF


   RETURN
   END SUBROUTINE MPi2Pi
!=======================================================================
   SUBROUTINE RombergInt(f, a, b, R, err, eps, ErrStat)

      ! This routine is used to integrate funciton f over the interval [a, b]. This routine
      ! is useful for sufficiently smooth (e.g., analytic) integrands, integrated over
      ! intervals which contain no singularities, and where the endpoints are also nonsingular.
      !
      ! f is an external function. For example f(x) = 1 + x.
      !
      !   FUNCTION f(x)
      !      USE PRECISION
      !      IMPLICIT NONE
      !
      !      REAL(ReKi) f
      !      REAL(ReKi) x
      !
      !      f = 1 + x
      !
      !      RETURN
      !   END FUNCTION f

   IMPLICIT NONE

      ! Argument declarations:

   REAL(ReKi), EXTERNAL              :: f               ! Integrand function name
   REAL(ReKi), INTENT(IN)            :: a               ! Lower integration limit
   REAL(ReKi), INTENT(IN)            :: b               ! Upper integration limit
   REAL(ReKi), INTENT(IN)            :: eps             ! Absolute error bound
   REAL(ReKi), INTENT(OUT)           :: R               ! The result of integration
   REAL(ReKi), INTENT(OUT)           :: err             ! Actual absolute error
   INTEGER, INTENT(OUT), OPTIONAL    :: ErrStat         ! Error status; if present, program does not abort on error

      ! Local declarations:

   INTEGER                           :: m, i, j, k
   INTEGER, PARAMETER                :: mmax = 50       ! Maximum iteration number for m
   INTEGER, PARAMETER                :: imax = 50       ! Maximum iteration number for i

   REAL(ReKi), ALLOCATABLE           :: T(:,:)
   REAL(ReKi)                        :: h               ! Step length
   REAL(ReKi)                        :: sumf

      ! Initialize T
   ALLOCATE( T( mmax, imax ) )
   T = 0

   T(1, 1) = 0.5*(b - a)*( f(a) + f(b) )

   k = 2
   DO m = 1, mmax-2
      h = (b-a)*(0.5)**m

      sumf = 0
      DO i = 1, 2**(m-1)
         sumf = sumf + f(a + (2*i-1)*h)
         k = k + 1
      END DO


      T( m+1, 1) = 0.5*T( m, 1 )+ h * sumf

      DO j = 1, m
         T(m-j+1, j+1) = ( 4.0**j * T(m-j+2, j) - T(m-j+1, j) )/(4.0**j - 1.0)

            ! absolute error
         err = ABS( T(m-j+1, j+1) - T( m-j+2, j ) )

            ! set k >=9 to prevent early terminations
         IF( (err .LT. eps) .and. (k >= 9) ) THEN

               ! return the intergration result if the conditions are met
            R = T(m-j+1, j+1)

            IF( ALLOCATED(T) ) DEALLOCATE(T)

            RETURN
         END IF

      END DO

   END DO

   err = ABS( T(m-j+1, j+1) - T( m-j+2, j ) )
   R = T(m-j+1, j+1)

   IF( ALLOCATED(T) ) DEALLOCATE(T)

      ! Return error message if the maximum iteration number is reached.
   CALL ProgAbort ( ' In subroutine RombergInt, the iteration reaches the maximum number. The integration did NOT converge! ', &
                    PRESENT(ErrStat) )
   IF ( PRESENT(ErrStat) ) THEN
      ErrStat = 1
      RETURN
   END IF

   RETURN
END SUBROUTINE RombergInt
!=======================================================================
   SUBROUTINE SetConstants( )

      ! This routine computes numeric constants stored in the NWTC Library

!   USE, INTRINSIC :: ieee_arithmetic  !use this for compilers that have implemented 

      ! local variables for getting values of NaN and Inf (not necessary when using ieee_arithmetic)
   REAL(DbKi)                          :: Neg_D          ! a negative real(DbKi) number
   REAL(ReKi)                          :: Neg            ! a negative real(ReKi) number                                        

      
      ! Constants based upon Pi:

   Pi_D      = ACOS( -1.0_DbKi )
   D2R_D     = Pi_D/180.0_DbKi
   R2D_D     = 180.0_DbKi/Pi_D
   PiBy2_D   = Pi_D/2.0_DbKi
   RPM2RPS_D = Pi_D/30.0_DbKi
   RPS2RPM_D = 30.0_DbKi/Pi_D
   TwoByPi_D = 2.0_DbKi/Pi_D
   TwoPi_D   = 2.0_DbKi*Pi_D

   Pi      = ACOS( -1.0_ReKi )
   D2R     = Pi/180.0_ReKi
   R2D     = 180.0_ReKi/Pi
   PiBy2   = Pi/2.0_ReKi
   RPM2RPS = Pi/30.0_ReKi
   RPS2RPM = 30.0_ReKi/Pi
   TwoByPi =  2.0_ReKi/Pi
   TwoPi   =  2.0_ReKi*Pi
   
   
      ! IEEE constants:
      
!   NaN_D = ieee_value(0.0_DbKi, ieee_quiet_nan)
!   Inf_D = ieee_value(0.0_DbKi, ieee_positive_inf)
!
!   NaN   = ieee_value(0.0_ReKi, ieee_quiet_nan)
!   Inf   = ieee_value(0.0_DbKi, ieee_positive_inf)
   
      ! set variables to negative numbers to calculate NaNs (compilers may complain when taking sqrt of negative constants)
   Neg   = -1.0_ReKi
   Neg_D = -1.0_DbKi
   
   NaN_D = SQRT ( Neg_D )
   Inf_D = Pi_D / 0.0_DbKi

   NaN   = SQRT ( Neg )
   Inf   = Pi / 0.0_ReKi
   
   
   RETURN
   END SUBROUTINE SetConstants
!=======================================================================
   SUBROUTINE SmllRotTrans( RotationType, Theta1, Theta2, Theta3, TransMat, ErrTxt )


      ! This routine computes the 3x3 transformation matrix, TransMat,
      !   to a coordinate system x (with orthogonal axes x1, x2, x3)
      !   resulting from three rotations (Theta1, Theta2, Theta3) about the
      !   orthogonal axes (X1, X2, X3) of coordinate system X.  All angles
      !   are assummed to be small, as such, the order of rotations does
      !   not matter and Euler angles do not need to be used.  This routine
      !   is used to compute the transformation matrix (TransMat) between
      !   undeflected (X) and deflected (x) coordinate systems.  In matrix
      !   form:
      !      {x1}   [TransMat(Theta1, ] {X1}
      !      {x2} = [         Theta2, ]*{X2}
      !      {x3}   [         Theta3 )] {X3}

      ! The transformation matrix, TransMat, is the closest orthonormal
      !   matrix to the nonorthonormal, but skew-symmetric, Bernoulli-Euler
      !   matrix:
      !          [   1.0    Theta3 -Theta2 ]
      !      A = [ -Theta3   1.0    Theta1 ]
      !          [  Theta2 -Theta1   1.0   ]
      !
      !   In the Frobenius Norm sense, the closest orthornormal matrix is:
      !      TransMat = U*V^T,
      !
      !   where the columns of U contain the eigenvectors of A*A^T and the
      !   columns of V contain the eigenvectors of A^T*A (^T = transpose).
      !   This result comes directly from the Singular Value Decomposition
      !   (SVD) of A = U*S*V^T where S is a diagonal matrix containing the
      !   singular values of A, which are SQRT( eigenvalues of A*A^T ) =
      !   SQRT( eigenvalues of A^T*A ).

      ! The algebraic form of the transformation matrix, as implemented
      !   below, was derived symbolically by J. Jonkman by computing U*V^T
      !   by hand with verification in Mathematica.



      ! Passed Variables:

   REAL(ReKi), INTENT(IN )             :: Theta1                                          ! The small rotation about X1, (rad).
   REAL(ReKi), INTENT(IN )             :: Theta2                                          ! The small rotation about X2, (rad).
   REAL(ReKi), INTENT(IN )             :: Theta3                                          ! The small rotation about X3, (rad).
   REAL(ReKi), INTENT(OUT)             :: TransMat (3,3)                                  ! The resulting transformation matrix from X to x, (-).

   CHARACTER(*), INTENT(IN)            :: RotationType                                    ! The type of rotation; used to inform the user where a large rotation is occuring upon such an event.
   CHARACTER(*), INTENT(IN ), OPTIONAL :: ErrTxt                                          ! an additional message to be displayed as a warning (typically the simulation time)


      ! Local Variables:

   REAL(ReKi)                          :: ComDenom                                        ! = ( Theta1^2 + Theta2^2 + Theta3^2 )*SQRT( 1.0 + Theta1^2 + Theta2^2 + Theta3^2 )
   REAL(ReKi), PARAMETER               :: LrgAngle  = 0.4                                 ! Threshold for when a small angle becomes large (about 23deg).  This comes from: COS(SmllAngle) ~ 1/SQRT( 1 + SmllAngle^2 ) and SIN(SmllAngle) ~ SmllAngle/SQRT( 1 + SmllAngle^2 ) results in ~5% error when SmllAngle = 0.4rad.
   REAL(ReKi)                          :: Theta11                                         ! = Theta1^2
   REAL(ReKi)                          :: Theta12S                                        ! = Theta1*Theta2*[ SQRT( 1.0 + Theta1^2 + Theta2^2 + Theta3^2 ) - 1.0 ]
   REAL(ReKi)                          :: Theta13S                                        ! = Theta1*Theta3*[ SQRT( 1.0 + Theta1^2 + Theta2^2 + Theta3^2 ) - 1.0 ]
   REAL(ReKi)                          :: Theta22                                         ! = Theta2^2
   REAL(ReKi)                          :: Theta23S                                        ! = Theta2*Theta3*[ SQRT( 1.0 + Theta1^2 + Theta2^2 + Theta3^2 ) - 1.0 ]
   REAL(ReKi)                          :: Theta33                                         ! = Theta3^2
   REAL(ReKi)                          :: SqrdSum                                         ! = Theta1^2 + Theta2^2 + Theta3^2
   REAL(ReKi)                          :: SQRT1SqrdSum                                    ! = SQRT( 1.0 + Theta1^2 + Theta2^2 + Theta3^2 )

   LOGICAL,    SAVE                    :: FrstWarn  = .TRUE.                              ! When .TRUE., indicates that we're on the first warning.



      ! Display a warning message if at least one angle gets too large in
      !   magnitude:

   IF ( ( ( ABS(Theta1) > LrgAngle ) .OR. ( ABS(Theta2) > LrgAngle ) .OR. ( ABS(Theta3) > LrgAngle ) ) .AND. FrstWarn )  THEN

               
      CALL ProgWarn(' Small angle assumption violated in SUBROUTINE SmllRotTrans() due to'// &
                     ' a large '//TRIM(RotationType)//'. The solution may be inaccurate.'// &
                     ' Simulation continuing, but future warnings will be suppressed.')
      IF ( PRESENT(ErrTxt) ) THEN
         CALL WrScr(' Additional debugging message from SUBROUTINE SmllRotTrans(): '//TRIM(ErrTxt) )
      END IF

      FrstWarn = .FALSE.   ! Don't enter here again!

   ENDIF



      ! Compute some intermediate results:

   Theta11      = Theta1*Theta1
   Theta22      = Theta2*Theta2
   Theta33      = Theta3*Theta3

   SqrdSum      = Theta11 + Theta22 + Theta33
   SQRT1SqrdSum = SQRT( 1.0 + SqrdSum )
   ComDenom     = SqrdSum*SQRT1SqrdSum

   Theta12S     = Theta1*Theta2*( SQRT1SqrdSum - 1.0 )
   Theta13S     = Theta1*Theta3*( SQRT1SqrdSum - 1.0 )
   Theta23S     = Theta2*Theta3*( SQRT1SqrdSum - 1.0 )


      ! Define the transformation matrix:

   IF ( ComDenom == 0.0 )  THEN  ! All angles are zero and matrix is ill-conditioned (the matrix is derived assuming that the angles are not zero); return identity

      TransMat(1,:) = (/ 1.0, 0.0, 0.0 /)
      TransMat(2,:) = (/ 0.0, 1.0, 0.0 /)
      TransMat(3,:) = (/ 0.0, 0.0, 1.0 /)

   ELSE                          ! At least one angle is nonzero

      TransMat(1,1) = ( Theta11*SQRT1SqrdSum + Theta22              + Theta33              )/ComDenom
      TransMat(2,2) = ( Theta11              + Theta22*SQRT1SqrdSum + Theta33              )/ComDenom
      TransMat(3,3) = ( Theta11              + Theta22              + Theta33*SQRT1SqrdSum )/ComDenom
      TransMat(1,2) = (  Theta3*SqrdSum + Theta12S )/ComDenom
      TransMat(2,1) = ( -Theta3*SqrdSum + Theta12S )/ComDenom
      TransMat(1,3) = ( -Theta2*SqrdSum + Theta13S )/ComDenom
      TransMat(3,1) = (  Theta2*SqrdSum + Theta13S )/ComDenom
      TransMat(2,3) = (  Theta1*SqrdSum + Theta23S )/ComDenom
      TransMat(3,2) = ( -Theta1*SqrdSum + Theta23S )/ComDenom

   ENDIF



   RETURN
   END SUBROUTINE SmllRotTrans
!=======================================================================
   SUBROUTINE SortUnion ( Ary1, N1, Ary2, N2, Ary, N )


      ! This routine takes two sorted arrays and finds the sorted union of the two.

      ! Note: If the same value is found in both arrays, only one is kept.  However, if either
      !       array as multiple occurances of the same value, the largest multiple will be
      !       kept.  Duplicates should be eliminated externally if this is not desirable.


      ! Argument declarations:

   INTEGER, INTENT(OUT)         :: N                                            ! The length of the output array.
   INTEGER, INTENT(IN)          :: N1                                           ! The length of the first input array.
   INTEGER, INTENT(IN)          :: N2                                           ! The length of the second input array.

   REAL(ReKi), INTENT(OUT)      :: Ary(N1+N2)                                   ! The sorted union.
   REAL(ReKi), INTENT(IN)       :: Ary1(N1)                                     ! The first list of sorted real numbers.
   REAL(ReKi), INTENT(IN)       :: Ary2(N2)                                     ! The second list of sorted real numbers.


      ! Local declarations:

   INTEGER                      :: I1                                           ! Index into the first array.
   INTEGER                      :: I2                                           ! Index into the second array.



   I1 = 1
   I2 = 1
   N  = 1

   DO WHILE ( ( I1 <= N1 ) .AND. ( I2 <= N2 ) )

      IF ( Ary1(I1) < Ary2(I2) )  THEN
         Ary(N) = Ary1(I1)
         I1 = I1 + 1
      ELSE IF ( Ary1(I1) > Ary2(I2) )  THEN
         Ary(N) = Ary2(I2)
         I2 = I2 + 1
      ELSE
         Ary(N) = Ary1(I1)
         I1 = I1 + 1
         I2 = I2 + 1
      END IF

      N  = N  + 1

   END DO ! WHILE


     ! We've reached the end of one array, but we need to add the end
     ! of the other array if we haven't reached the end of it yet.

   IF ( I1 <= N1 ) THEN
      Ary(N:N+N1-I1) = Ary1(I1:)
      N = N+N1-I1
   ELSEIF ( I2 <= N2 ) THEN
      Ary(N:N+N2-I2) = Ary2(I2:)
      N = N+N2-I2
   ELSE
      N = N - 1
   ENDIF


   RETURN
   END SUBROUTINE SortUnion ! ( Ary1, N1, Ary2, N2, Ary, N )
!=======================================================================
   FUNCTION StdDevFn ( Ary, AryLen, Mean )


      ! This routine calculates the standard deviation of a population contained in Ary.


      ! Function declaration.

   REAL(ReKi)                   :: StdDevFn                                     ! This function.


      ! Argument declarations:

   INTEGER, INTENT(IN)          :: AryLen                                       ! Length of the array.

   REAL(ReKi), INTENT(IN)       :: Ary  (AryLen)                                ! Input array.
   REAL(ReKi), INTENT(IN)       :: Mean                                         ! The previously calculated mean of the array.


      ! Local declarations.

   REAL(DbKi)                   :: Sum                                          ! A temporary sum.

   INTEGER                      :: I                                            ! The index into the array.



   Sum = 0.0_DbKi

   DO I=1,AryLen
      Sum = Sum + ( Ary(I) - Mean )**2
   END DO ! I

   StdDevFn = SQRT( Sum/( AryLen - 1 ) )


   RETURN
   END FUNCTION StdDevFn ! ( Ary, AryLen, Mean )
!=======================================================================

END MODULE NWTC_Num
MODULE ModMesh
! (c) 2012 National Renewable Energy Laboratory
!
!BJJ: This is a place holder for a module John Michalaches and Ilene Carpenter are writing.
! This will be part of the NWTC Subroutine Library.


 USE PRECISION

   INTEGER(IntKi), PARAMETER :: MESH_NEWCOPY    = 1
   INTEGER(IntKi), PARAMETER :: MESH_SIBLING    = 2
   INTEGER(IntKi), PARAMETER :: MESH_UPDATECOPY = 3


TYPE, PUBLIC :: MeshType
   LOGICAL                 :: committed             ! Indicate whether this mesh is committed
   INTEGER(IntKi)          :: ios                   ! COMPONENT_INPUT/OUTPUT/STATE/PARAMETER
   INTEGER(IntKi)          :: RemapFlag             ! Remap flag: zero=noaction/ignore
                                                    !             nonzero=module_defined
   INTEGER(IntKi)          :: Nnodes                ! Number of nodes (vertices) in mesh
   INTEGER(IntKi)          :: Nelements             ! Number of elements in mesh
   INTEGER(IntKi)          :: Npoint                ! Number of point elements
   INTEGER(IntKi)          :: Nline2                ! Number of 2-node line elements
   INTEGER(IntKi)          :: Nline3                ! Number of 3-node line elements
   INTEGER(IntKi)          :: Ntri3                 ! Number of 3-node triangle elements
   INTEGER(IntKi)          :: Ntri6                 ! Number of 6-node triangle elements
   INTEGER(IntKi)          :: Nquad4                ! Number of 4-node quadrilateral elements
   INTEGER(IntKi)          :: Nquad8                ! Number of 8-node quadrilateral elements
   INTEGER(IntKi)          :: Ntet4                 ! Number of 4-node tet elements
   INTEGER(IntKi)          :: Ntet10                ! Number of 10-node tet elements
   INTEGER(IntKi)          :: Nhex8                 ! Number of 8-node hex elements
   INTEGER(IntKi)          :: Nhex20                ! Number of 20-node hex elements
   INTEGER(IntKi)          :: Nwedge6               ! Number of 6-node wedge elements
   INTEGER(IntKi)          :: Nwedge15              ! Number of 15-node wedgeelements
   INTEGER(IntKi), POINTER :: element_point(:)      ! Point connectivity
   INTEGER(IntKi), POINTER :: element_line2(:,:)    ! 2-node line connectivity
   INTEGER(IntKi), POINTER :: element_line3(:,:)    ! 3-node line connectivity
   INTEGER(IntKi), POINTER :: element_tri3(:,:)     ! 3-node triangle connectivity
   INTEGER(IntKi), POINTER :: element_tri6(:,:)     ! 6-node triangle connectivity
   INTEGER(IntKi), POINTER :: element_quad4(:,:)    ! 4-node quad connectivity
   INTEGER(IntKi), POINTER :: element_quad8(:,:)    ! 8-node quad connectivity
   INTEGER(IntKi), POINTER :: element_tet4(:,:)     ! 4-node tet connectivity
   INTEGER(IntKi), POINTER :: element_tet10(:,:)   ! 10-node tet connectivity
   INTEGER(IntKi), POINTER :: element_hex8(:,:)     ! 8-node hex connectivity
   INTEGER(IntKi), POINTER :: element_hex20(:,:)   ! 20-node hex connectivity
   INTEGER(IntKi), POINTER :: element_wedge6(:,:)   ! 6-node wedge connectivity
   INTEGER(IntKi), POINTER :: element_wedge15(:,:) ! 15-node wedge connectivity
   REAL(ReKi),     POINTER :: Position(:,:)         ! XYZ coordinate of node
   REAL(ReKi),     POINTER :: Force(:,:)            ! Force vectors
   REAL(ReKi),     POINTER :: Moment(:,:)           ! Moment vectors
   REAL(ReKi),     POINTER :: Orientation(:,:,:)    ! Direction Cosine Matrix (DCM)
   REAL(ReKi),     POINTER :: Rotation(:,:)         ! Rotational Velocities
   REAL(ReKi),     POINTER :: Translation(:,:)      ! Translational Velocities
   REAL(ReKi),     POINTER :: AddedMass(:,:,:)      ! Added mass matrix
   REAL(ReKi),     POINTER :: Scalars(:,:)          ! Scalars (2nd Dim is over Scalars)
   TYPE(MeshType), POINTER :: YoungerSibling        ! Pointer to next sibling in list
   TYPE(MeshType), POINTER :: ElderSibling          ! Pointer to prev sibling in list
END TYPE MeshType


END MODULE
MODULE NWTC_Aero


   ! This module contains aerodynamics routines with non-system-specific logic and references.


   ! It contains the following routines:

   !     SUBROUTINE AeroInt  ( ISeg, Alpha, Re, AF_Table, IntData, DoCl, DoCd, DoCm, DoCpmin [, ErrStat] )
   !     SUBROUTINE CompDR   ( NumSeg, RLoc, HubRad, RotorRad, DimenInp, DelRLoc [, ErrStat] )
   !     SUBROUTINE GetAF    ( AF_File, AF_Table, ISeg )
   !     FUNCTION   GetCoef  ( ISeg, Alpha, AlfaTab, CoefTab, NumRows, Ind [, ErrStat] )
   !     SUBROUTINE GetCoefs ( ISeg, Alpha, Re, AF_Table, ClInt, CdInt, CmInt, CpminInt, DoCl, DoCd, DoCm, DoCpmin [, ErrStat] )


   USE                             NWTC_IO
   USE                             NWTC_Num
   
   IMPLICIT  NONE


!=======================================================================


      ! Global aerodynamics-related variables.

   TYPE                            :: AeroData                                  ! Declare new type that holds the interpolated aero data from the big tables.
      REAL(ReKi)                   :: AlfaStal                                  ! The stall AoA for this table.
      REAL(ReKi)                   :: AOD                                       ! The AoA for minimum CD.
      REAL(ReKi)                   :: AOL                                       ! The zero-lift AoA.
      REAL(ReKi)                   :: Cd0                                       ! The minimum Cd value.
      REAL(ReKi)                   :: CnA                                       ! The Cn slope for zero-lift.
      REAL(ReKi)                   :: CnS                                       ! The Cn at stall value for positive AoA.
      REAL(ReKi)                   :: CnSL                                      ! Cn at stall value for negative AoA.
      REAL(ReKi)                   :: Cl                                        ! The lift coefficient.
      REAL(ReKi)                   :: Cd                                        ! The drag coefficient.
      REAL(ReKi)                   :: Cm                                        ! The pitching-moment coefficient.
      REAL(ReKi)                   :: Cpmin                                     ! The minimum pressure coefficient.
      REAL(ReKi)                   :: FTB                                       ! The normal-coefficient divided by the Cn slope at zero lift.
      REAL(ReKi)                   :: FTBC                                      ! The chordwise-coefficient divided by the Cn slope at zero lift.
   ENDTYPE AeroData

   TYPE                            :: AeroTable                                 ! Declare new type that is an allocatable table of data.
      REAL(ReKi)                   :: AlfaStal                                  ! The stall AoA for this table.
      REAL(ReKi)                   :: AOD                                       ! The AoA for minimum CD.
      REAL(ReKi)                   :: AOL                                       ! The zero-lift AoA.
      REAL(ReKi)                   :: Cd0                                       ! The minimum Cd value.
      REAL(ReKi)                   :: CnA                                       ! The Cn slope for zero-lift.
      REAL(ReKi)                   :: CnS                                       ! The Cn at stall value for positive AoA.
      REAL(ReKi)                   :: CnSL                                      ! Cn at stall value for negative AoA.
      REAL(ReKi)                   :: Re                                        ! The Re for this table.
      REAL(ReKi)                   :: Ctrl                                      ! The control setting for this table.
      INTEGER                      :: Ind      = 0                              ! Last-used index into table.  Zero at beginning.
      INTEGER                      :: NumAlf                                    ! Number of angles of attack in the table.
      REAL(ReKi), ALLOCATABLE      :: Alpha    (:)                              ! The angle of attack vector.
      REAL(ReKi), ALLOCATABLE      :: Cl       (:)                              ! The lift-coefficient vector.
      REAL(ReKi), ALLOCATABLE      :: Cd       (:)                              ! The drag-coefficient vector.
      REAL(ReKi), ALLOCATABLE      :: Cm       (:)                              ! The pitching-moment-coefficient vector.
      REAL(ReKi), ALLOCATABLE      :: Cpmin    (:)                              ! The minimum-pressure-coefficient vector.
      REAL(ReKi), ALLOCATABLE      :: FTB      (:)                              ! The normal-coefficient divided by the Cn slope at zero lift.
      REAL(ReKi), ALLOCATABLE      :: FTBC     (:)                              ! The chordwise-coefficient divided by the Cn slope at zero lift.
   ENDTYPE AeroTable

   TYPE                            :: AlfIndx                                   ! Declare new type that is an allocatable table of alpha indices.
      INTEGER                      :: NumBld                                    ! Number of blades in the table.
      INTEGER                      :: NumElm                                    ! Number of segments in the table.
      INTEGER, ALLOCATABLE         :: Ind      (:,:)                            ! The tables in this supertable.
   ENDTYPE AlfIndx

   TYPE                            :: ElmTable                                  ! Declare new type that is an allocatable table of data.
      INTEGER                      :: NumTabs                                   ! Number of tables in the supertable for an element.
      TYPE(AeroTable), ALLOCATABLE :: Tab      (:)                              ! The tables in this supertable.
   ENDTYPE ElmTable

   LOGICAL                         :: UseCm    = .FALSE.                        ! Flag to tell if there are Cm data in the airfoil files.
   LOGICAL                         :: UseCpmin = .FALSE.                        ! Flag to tell if there are Cp,min data in the airfoil files.


CONTAINS

!=======================================================================
   SUBROUTINE AeroInt ( ISeg, Alpha, Re, AF_Table, IntData, DoCl, DoCd, DoCm, DoCpmin, ErrStat )

      ! This routine finds the Re-bounding tables and then calls GetCoef() to get the
      ! desired coefficients for the two tables and then interpolates between them.

!NOTE: This routine needs to be modified to account for various control settings.  mlb  1-May-2010

      ! Argument declarations.

   REAL(ReKi), INTENT(IN)            :: Alpha                                   ! Angle of attack to get the coefficient for.
   REAL(ReKi), INTENT(IN)            :: Re                                      ! Reynolds number.

   INTEGER, INTENT(OUT), OPTIONAL    :: ErrStat                                 ! Error status; if present, program does not abort on error
   INTEGER, INTENT(IN)               :: ISeg                                    ! The current segment.

   LOGICAL, INTENT(IN)               :: DoCd                                    ! Get Cd.
   LOGICAL, INTENT(IN)               :: DoCl                                    ! Get Cl.
   LOGICAL, INTENT(IN)               :: DoCm                                    ! Get Cm.
   LOGICAL, INTENT(IN)               :: DoCpmin                                 ! Get Cp,min.

   TYPE (ElmTable), INTENT(INOUT)    :: AF_Table                                ! The table of airfoil data for the current segment.
   TYPE (AeroData), INTENT(OUT)      :: IntData                                 ! The interpolated airfoil data for the current segment.


      ! Local declarations.

   REAL(ReKi)                        :: CdHi                                    ! The drag coefficient for the higher Re.
   REAL(ReKi)                        :: ClHi                                    ! The lift coefficient for the higher Re.
   REAL(ReKi)                        :: CmHi                                    ! The pitching-moment coefficient for the higher Re.
   REAL(ReKi)                        :: CpminHi                                 ! The minimum pressure coefficient for the higher Re.
   REAL(ReKi)                        :: Fract                                   ! The fractional distance between tables.

   INTEGER                           :: ITab                                    ! An index for table number.
   INTEGER                           :: ITabLo                                  ! The table number that is the lower bound for Re.
   INTEGER                           :: ITabHi                                  ! The table number that is the lower bound for Re.

   LOGICAL                           :: OneTable                                ! Flag that tells if we need to read only one table (no interpolation).



      ! Find the bounding tables (if multiple) for this Re.  If there is only one table
      ! or if we are outside the range of tables, we won't need to interpolate.

   IF ( Re <= AF_Table%Tab(1)%Re )  THEN
      ITabLo   = 1
      OneTable = .TRUE.
   ELSE IF ( Re >= AF_Table%Tab(AF_Table%NumTabs)%Re )  THEN
      ITabLo   = AF_Table%NumTabs
      OneTable = .TRUE.
   ELSE IF ( AF_Table%NumTabs > 1 )  THEN
      DO ITab=1,AF_Table%NumTabs-1
         IF ( Re <= AF_Table%Tab(ITab+1)%Re )  THEN
            ITabLo = ITab
            ITabHi = ITab + 1
            EXIT
         END IF
      END DO
      OneTable = .FALSE.
   ELSE
      ITabLo   = 1
      OneTable = .TRUE.
   END IF


      ! Get the coefficients for ITabLo.

   IF ( DoCl )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         IntData%Cl = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cl, AF_Table%Tab(ITabLo)%NumAlf &
                           , AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         IntData%Cl = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cl, AF_Table%Tab(ITabLo)%NumAlf &
                           , AF_Table%Tab(ITabLo)%Ind )
      END IF
   END IF

   IF ( DoCd )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         IntData%Cd  = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cd, AF_Table%Tab(ITabLo)%NumAlf &
                              , AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         IntData%Cd  = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cd, AF_Table%Tab(ITabLo)%NumAlf &
                              , AF_Table%Tab(ITabLo)%Ind )
      END IF
   END IF

   IF ( DoCm )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         IntData%Cm = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cm, AF_Table%Tab(ITabLo)%NumAlf &
                             , AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         IntData%Cm = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cm, AF_Table%Tab(ITabLo)%NumAlf &
                             , AF_Table%Tab(ITabLo)%Ind )
      END IF
   END IF

   IF ( DoCpmin )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         IntData%Cpmin = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cpmin, AF_Table%Tab(ITabLo)%NumAlf &
                                , AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         IntData%Cpmin = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cpmin, AF_Table%Tab(ITabLo)%NumAlf &
                                , AF_Table%Tab(ITabLo)%Ind )
      END IF
   END IF

   IntData%AlfaStal = AF_Table%Tab(ITabLo)%AlfaStal
   IntData%AOD      = AF_Table%Tab(ITabLo)%AOD
   IntData%AOL      = AF_Table%Tab(ITabLo)%AOL
   IntData%Cd0      = AF_Table%Tab(ITabLo)%Cd0
   IntData%CnA      = AF_Table%Tab(ITabLo)%CnA
   IntData%CnS      = AF_Table%Tab(ITabLo)%CnS
   IntData%CnSL     = AF_Table%Tab(ITabLo)%CnSL


      ! If we don't need to interpolate, we don't need to make a second call and we are done.

   IF ( OneTable )  RETURN


      ! Get the coefficients for ITabHi.  Use step-wise interpolation for all but the first coefficient called.

   Fract = ( Re - AF_Table%Tab(ITabLo)%Re )/( AF_Table%Tab(ITabHi)%Re - AF_Table%Tab(ITabLo)%Re )


   IF ( DoCl )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         ClHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cl, AF_Table%Tab(ITabHi)%NumAlf, &
                                      AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         ClHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cl, AF_Table%Tab(ITabHi)%NumAlf, &
                                      AF_Table%Tab(ITabHi)%Ind )
      END IF
      IntData%Cl  = IntData%Cl + Fract*( ClHi - IntData%Cl )
   END IF

   IF ( DoCd )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         CdHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cd, AF_Table%Tab(ITabHi)%NumAlf, &
                                      AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         CdHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cd, AF_Table%Tab(ITabHi)%NumAlf, &
                                      AF_Table%Tab(ITabHi)%Ind )
      END IF
      IntData%Cd = IntData%Cd + Fract*( CdHi - IntData%Cd )
   END IF

   IF ( DoCm )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         CmHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cm, AF_Table%Tab(ITabHi)%NumAlf, &
                                      AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         CmHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cm, AF_Table%Tab(ITabHi)%NumAlf, &
                                      AF_Table%Tab(ITabHi)%Ind )
      END IF
      IntData%Cm = IntData%Cm + Fract*( CmHi - IntData%Cm )
   END IF

   IF ( DoCpmin )  THEN
      IF ( PRESENT( ErrStat ) ) THEN
         CpminHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cpmin, AF_Table%Tab(ITabHi)%NumAlf, &
                                         AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat /= 0) RETURN
      ELSE
         CpminHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cpmin, AF_Table%Tab(ITabHi)%NumAlf, &
                                         AF_Table%Tab(ITabHi)%Ind )
      END IF
      IntData%Cpmin = IntData%Cpmin + Fract*( CpminHi - IntData%Cpmin )
   END IF

   IntData%AlfaStal = IntData%AlfaStal + Fract*( AF_Table%Tab(ITabHi)%AlfaStal - IntData%AlfaStal )
   IntData%AOD      = IntData%AOD      + Fract*( AF_Table%Tab(ITabHi)%AOD      - IntData%AOD      )
   IntData%AOL      = IntData%AOL      + Fract*( AF_Table%Tab(ITabHi)%AOL      - IntData%AOL      )
   IntData%Cd0      = IntData%Cd0      + Fract*( AF_Table%Tab(ITabHi)%Cd0      - IntData%Cd0      )
   IntData%CnA      = IntData%CnA      + Fract*( AF_Table%Tab(ITabHi)%CnA      - IntData%CnA      )
   IntData%CnS      = IntData%CnS      + Fract*( AF_Table%Tab(ITabHi)%CnS      - IntData%CnS      )
   IntData%CnSL     = IntData%CnSL     + Fract*( AF_Table%Tab(ITabHi)%CnSL     - IntData%CnSL     )


   RETURN
   END SUBROUTINE AeroInt ! ( ISeg, Alpha, Re, AF_Table, IntData, ClInt, CdInt, CmInt )
!=======================================================================
   SUBROUTINE CompDR ( NumSeg, RLoc, HubRad, RotorRad, DimenInp, DelRLoc, ErrStat )


      ! This routine computes the segment lengths from the local radii and the rotor radius.
      ! It prints and error if the list of radii is not realizable.


      ! Argument declarations.

   INTEGER, INTENT(IN)          :: NumSeg                                       ! Number of blade segments.
   INTEGER, INTENT(OUT),OPTIONAL:: ErrStat                                      ! Error status; if present, program does not abort on error

   REAL(ReKi), INTENT(OUT)      :: DelRLoc (NumSeg)                             ! The array of segment lengths.
   REAL(ReKi), INTENT(IN)       :: HubRad                                       ! The hub radius.
   REAL(ReKi), INTENT(IN)       :: RLoc    (NumSeg)                             ! The array of radii (segment centers).
   REAL(ReKi), INTENT(IN)       :: RotorRad                                     ! The rotor radius.

   LOGICAL, INTENT(IN)          :: DimenInp                                     ! Flag that tells if input is dimensional or not.


      ! Local declarations.

   REAL(ReKi)                   :: CompRad                                      ! The computed radius of the rotor.
   REAL(ReKi)                   :: ErrFact                                      ! The conversion to non-dimensional form if needed.
   REAL(ReKi)                   :: SegBeg                                       ! The beginning of the current segment.

   INTEGER                      :: ISeg                                         ! Segment index



   IF ( PRESENT(ErrStat) ) ErrStat = 0


      ! Determine the correct units for error messages.

   IF ( DimenInp )  THEN
      ErrFact = 1.0
   ELSE
      ErrFact = RotorRad
   END IF


      ! We will work our way from the root to the tip.

   SegBeg = HubRad

   DO ISeg=1,NumSeg

      IF ( RLoc(ISeg) <= SegBeg )  THEN
         ! START v1.03.00b-dcm  21-Jun-2010  D. Maniaci
         CALL WrScr1('Your analysis nodes are incorrectly defined.  Please review the following forum topic for an explaination' &
                    //' of this error:')
         CALL WrScr1('  https://wind.nrel.gov/forum/wind/viewtopic.php?f=4&t=241')
         ! END v1.03.00b-dcm  21-Jun-2010  D. Maniaci
         CALL ProgAbort ( ' The radius for blade segment #'//Trim( Int2LStr( ISeg ) )//' is too far inboard for a physically' &
                    //' realizable blade.  It must be greater than '//Trim( Num2LStr( SegBeg/ErrFact ) )//'.', PRESENT(ErrStat) )
         IF ( PRESENT(ErrStat) ) ErrStat = 1
         RETURN
      END IF

      DelRLoc(ISeg) = 2.0*( RLoc(ISeg) - SegBeg )
      SegBeg        = SegBeg + DelRLoc(ISeg)

   END DO ! ISeg


      ! Ensure that the segments (almost) exactly fill the blade.

   CompRad = RLoc(NumSeg) + 0.5*DelRLoc(NumSeg)

   IF ( ABS( CompRad - RotorRad )/RotorRad > 0.005 )  THEN
         ! START v1.03.00b-dcm  21-Jun-2010  D. Maniaci
         CALL WrScr1('Your analysis nodes are incorrectly defined.  Please review the following forum topic for an explaination' &
                    //' of this error:')
         CALL WrScr1('  https://wind.nrel.gov/forum/wind/viewtopic.php?f=4&t=241')
         ! END v1.03.00b-dcm  21-Jun-2010  D. Maniaci
         CALL ProgAbort ( ' The sum of the lengths of the blade segments does not match the rotor radius.  The segments add up' &
                    //' to a rotor radius of '//Trim( Num2LStr( CompRad ) )//' instead of the specified radius of ' &
                    //Trim( Num2LStr( RotorRad ) )//'.  They must agree within 0.5%', PRESENT(ErrStat) )
         IF ( PRESENT(ErrStat) ) ErrStat = 1
         RETURN
   ELSE IF ( ABS( CompRad - RotorRad )/RotorRad > 0.001 )  THEN
! Nice message, Marshall! ;-)  Thank you!  :-)  I don't even remember writing this.
         ! START v1.03.00b-dcm  21-Jun-2010  D. Maniaci
         CALL WrScr1('Your analysis nodes are incorrectly defined.  Please review the following forum topic for an explaination' &
                    //' of this error:')
         CALL WrScr1('  https://wind.nrel.gov/forum/wind/viewtopic.php?f=4&t=241')
         ! END v1.03.00b-dcm  21-Jun-2010  D. Maniaci
         CALL WrScr1 ( ' The sum of the lengths of the blade segments does not match the rotor radius.  The segments add up to a' &
                    //' rotor radius of '//Trim( Num2LStr( CompRad ) )//' instead of the specified radius of ' &
                    //Trim( Num2LStr( RotorRad ) )//'.  They really should agree within 0.1%, but I''ll let you slide.' )
!      IF ( Beep ) &
         CALL UsrAlarm
   END IF


   RETURN
   END SUBROUTINE CompDR ! ( NumSeg, RLoc, RotorRad, DimenInp, DelRLoc [, ErrStat] )
!=======================================================================
   SUBROUTINE GetAF ( AF_File, AF_Table, ISeg )
!bjj: note that this routine aborts instead of allowing an optional returned error code.

      ! Routine to get airfoil data from either a new NWTC-style or an old AeroDyn-style airfoil file.


      ! Argument declarations.

   TYPE (ElmTable), INTENT(OUT) :: AF_Table                                  ! The table of airfoil data for the current segment.

   INTEGER, INTENT(IN)          :: ISeg                                      ! The segment number.

   CHARACTER(*), INTENT(IN)     :: AF_File                                   ! Name of file containing AeroDyn-style airfoil data.


      ! Local declarations.

      ! Because of what seems to be a compiler bug, we cannot dynamically allocate the data arrays for the new-style
      ! airfoil files.  We really need to do it for the old-style files because there is no limit on the number of points.

!   TYPE                            :: DataRowO                                  ! Declare new type that is an allocatable table of data using a linked list.
!      REAL(ReKi), ALLOCATABLE      :: Data      (:)
!      TYPE(DataRowO), POINTER      :: Next            => NULL()
!   ENDTYPE DataRowO

   REAL(ReKi)                      :: AF_Data   (5)                             ! The values from one line of airfol data.
   REAL(ReKi), ALLOCATABLE         :: AF_DataO  (:)                             ! The values from one line of airfol data.
   REAL(ReKi), ALLOCATABLE         :: RnAry     (:)                             ! The temporary array for Re.
   REAL(ReKi), ALLOCATABLE         :: ASAry     (:)                             ! The temporary array for Stall AoA.
   REAL(ReKi), ALLOCATABLE         :: AOLAry    (:)                             ! The temporary array for zero-lift AoA.
   REAL(ReKi)                      :: Cc                                        ! The chordwise force coefficient.
   REAL(ReKi)                      :: Cn                                        ! The normal force coefficient.
   REAL(ReKi), ALLOCATABLE         :: CnAAry    (:)                             ! The temporary array for Cn slope for zero lift.
   REAL(ReKi), ALLOCATABLE         :: CnSAry    (:)                             ! The temporary array for Cn at stall value for positive AoA.
   REAL(ReKi), ALLOCATABLE         :: CnSLAry   (:)                             ! The temporary array for Cn at stall value for negative AoA.
   REAL(ReKi), ALLOCATABLE         :: AODAry    (:)                             ! The temporary array for AoA for minimum Cd.
   REAL(ReKi), ALLOCATABLE         :: CDOAry    (:)                             ! The temporary array for minimum Cd value.

   INTEGER                         :: IAlf                                      ! A generic array index for angle of attack.
   INTEGER                         :: Ind                                       ! A generic array index.
   INTEGER                         :: IOS                                       ! The status of an I/O operation.
   INTEGER                         :: ITab                                      ! The table index.
   INTEGER                         :: NumAlf                                    ! The number of lines in an old-style airfoil table.
   INTEGER                         :: NumAlpha                                  ! The number of non--blank lines in an old-style airfoil table.
   INTEGER                         :: NumCoef                                   ! The number of coefficiants in an airfoil table.
   INTEGER                         :: NumVals                                   ! The total number of values on one line of airfoil data.
   INTEGER                         :: Sttus                                     ! The status returned from the allocation.
   INTEGER                         :: UnAF     = 20                             ! I/O unit number for the airfoil file.

   CHARACTER( 15)                  :: Frmt = "(1000(F11.4,:))"                  ! Output format for a line of airfoil data.
   CHARACTER(999)                  :: Line                                      ! A line of text.
   CHARACTER(  3)                  :: Line3                                     ! The first three characters of a line of text.



      ! Open the airfoil data file.

   CALL OpenFInpFile ( UnAF, AF_File )


      ! Read the header block of the airfoil file.  Look to see if this is a new-format file.

   READ (UnAF,'(A)',IOSTAT=IOS)  Line

   CALL CheckIOS ( IOS, AF_File, 'FirstHead', StrType )

   IF ( Echo )  THEN
      WRITE (UnEc,"(15X,A,T30,' - ',A,/,2X,A)")  'FirstHead', 'First line in the airfoil file.', TRIM( Line )
   END IF

   CALL Conv2UC  ( Line )

   IF ( Line(:21) == 'AERODYN AIRFOIL FILE.' )  THEN


         ! This is new style of AeroDyn file.

      CALL ReadCom  ( UnAF, AF_File, 'the first title' )
      CALL ReadCom  ( UnAF, AF_File, 'the second title' )
      CALL ReadIVar ( UnAF, AF_File, AF_Table%NumTabs, 'NumTabs', 'Number of airfoil tables for segment #' &
                                                                 //TRIM( Int2LStr( ISeg ) )//'.' )

      IF ( AF_Table%NumTabs < 1 )  CALL ProgAbort ( ' Number of tables in airfoil file, "'//TRIM( AF_File ) &
                                              //'", must be > 0 for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )


         ! Are we expecting Cm data in the file?  Allocate the temporary data array.

      IF ( UseCm )  THEN
         NumVals = 4
      ELSE
         NumVals = 3
      END IF


         ! Are we expecting Cp,min data in the file?  Allocate the temporary data array.

      IF ( UseCpmin )  THEN
         NumVals = NumVals + 1
      END IF


         ! Allocate the AF_Table of pointers for this element.

      ALLOCATE ( AF_Table%Tab(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the Tab subtable of the AF_Table of pointers for segment #' &
                    //TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF


         ! Read the NumTabs airfoil tables.

      DO ITab=1,AF_Table%NumTabs


            ! Read in the Table ID (Re), control setting, and stall parameters for this table.

         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%Re      , 'Re('      //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'Reynolds number for this airfoil table.'    )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%Ctrl    , 'Ctrl('    //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'Control setting for this airfoil table.'    )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%AlfaStal, 'AlfaStal('//TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'stall AoA for this airfoil table.'          )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%AOL     , 'AOL('     //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'zero-lift AoA.'                             )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%CnA     , 'CnA('     //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'Cn slope for zero-lift.'                    )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%CnS     , 'CnS('     //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'Cn at stall value for positive AoA.'        )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%CnSL    , 'CnSL('    //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'Cn at stall value for negative AoA.'        )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%AOD     , 'AOD('     //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'AoA for minimum CD.'                        )
         CALL ReadRVar ( UnAF, AF_File, AF_Table%Tab(ITab)%Cd0     , 'Cd0('     //TRIM( Int2LStr( ITab ) )//')'   &
                                                                   , 'minimum Cd value.'                          )


            ! Convert to proper units.

         AF_Table%Tab(ITab)%AlfaStal = AF_Table%Tab(ITab)%AlfaStal*D2R
         AF_Table%Tab(ITab)%AOD      = AF_Table%Tab(ITab)%AOD     *D2R
         AF_Table%Tab(ITab)%AOL      = AF_Table%Tab(ITab)%AOL     *D2R
         AF_Table%Tab(ITab)%Re       = AF_Table%Tab(ITab)%Re      *1.0e6


            ! Find the length of this table.

         AF_Table%Tab(ITab)%NumAlf = 0

         DO

            READ (UnAF,'(A)',IOSTAT=IOS)  Line3

            IF ( IOS < 0 )  THEN
               CALL PremEOF ( AF_File , 'the "EOT" end-of-table mark for airfoil table #'//TRIM( Int2LStr( ITab ) ) &
                                      //' and segment #'//TRIM( Int2LStr( ISeg ) ) )
            ELSE IF ( IOS > 0 )  THEN
               CALL WrScr1 ( ' Invalid character input for file "'//TRIM( AF_File )//'.' )
               CALL ProgAbort  ( ' The error occurred while trying to read line #'//TRIM( Int2LStr( AF_Table%Tab(ITab)%NumAlf+1 ) )&
                           //' of airfoil table #'//TRIM( Int2LStr( ITab ) )//' for segment #'//TRIM( Int2LStr( ISeg ) )//'.' )
            END IF

            CALL Conv2UC ( Line3 )
            IF ( Line3 == 'EOT' )  EXIT
            AF_Table%Tab(ITab)%NumAlf = AF_Table%Tab(ITab)%NumAlf + 1

         END DO


            ! Rewind the file to the beginning of this table.

         DO IAlf=1,AF_Table%Tab(ITab)%NumAlf+1
            BACKSPACE UnAF
         END DO ! IAlf


            ! Let's allocate the permanent table.

         ALLOCATE ( AF_Table%Tab(ITab)%Alpha(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the Alpha subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%Cl(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the Cl subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%Cd(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the Cd subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
         END IF

         IF ( UseCm )  THEN
            ALLOCATE ( AF_Table%Tab(ITab)%Cm(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
            IF ( Sttus /= 0 )  THEN
               CALL ProgAbort ( ' Error allocating memory for the Cm subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
            END IF
         END IF

         IF ( UseCpmin )  THEN
            ALLOCATE ( AF_Table%Tab(ITab)%Cpmin(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
            IF ( Sttus /= 0 )  THEN
               CALL ProgAbort ( ' Error allocating memory for the Cpmin subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
            END IF
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%FTB(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the FTB subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%FTBC(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the FTBC subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
         END IF


            ! Read in the airfoil data for this table.

         DO IAlf=1,AF_Table%Tab(ITab)%NumAlf

            READ (UnAF,*,IOSTAT=IOS)  ( AF_Data(Ind), Ind=1,NumVals )

            CALL CheckIOS ( IOS, AF_File, 'AF_Data', NumType )

            IF ( Echo )  WRITE (UnEc,Frmt)  ( AF_Data(Ind), Ind=1,NumVals )

            AF_Table%Tab(ITab)%Alpha(IAlf) = AF_Data(1)

            AF_Table%Tab(ITab)%Cl(IAlf) = AF_Data(2)
            AF_Table%Tab(ITab)%Cd(IAlf) = AF_Data(3)

            IF ( ABS( AF_Table%Tab(ITab)%CnA ) .GT. 1.0e-6 )  THEN

               Cn = AF_Data(2)*COS( AF_Data(1) ) + ( AF_Data(3) - AF_Table%Tab(ITab)%Cd0 )*SIN( AF_Data(1) )
               Cc = AF_Data(2)*SIN( AF_Data(1) ) - ( AF_Data(3) - AF_Table%Tab(ITab)%Cd0 )*COS( AF_Data(1) )

               AF_Table%Tab(ITab)%FTB (IAlf) = Cn/AF_Table%Tab(ITab)%CnA
               AF_Table%Tab(ITab)%FTBC(IAlf) = Cc/AF_Table%Tab(ITab)%CnA

            ELSE

               AF_Table%Tab(ITab)%FTB (IAlf) = 1.0
               AF_Table%Tab(ITab)%FTBC(IAlf) = 1.0

            END IF

            IF ( UseCm )  THEN
               AF_Table%Tab(ITab)%Cm(IAlf) = AF_Data(4)
            END IF

            IF ( UseCpmin )  THEN
               AF_Table%Tab(ITab)%Cpmin(IAlf) = AF_Data(NumVals)
            END IF

         END DO ! IAlf


            ! Check AoA range.

         IF ( ( AF_Table%Tab(ITab)%Alpha(1)                         > -180.0 ) .OR. &
              ( AF_Table%Tab(ITab)%Alpha(AF_Table%Tab(ITab)%NumAlf) <  180.0 ) )  THEN
            CALL ProgAbort ( 'Angle of attack range for airfoil table #'//TRIM( Int2LStr( ITab ) )//' of segment #' &
                       //TRIM( Int2LStr( ISeg ) )//' must be from -180 to 180.' )
         END IF


            ! Skip this EOT mark.

         READ (UnAF,'()')

      END DO ! ITab

   ELSE


         ! This is old style of AeroDyn file.

      CALL ReadCom  ( UnAF, AF_File, 'the second title' )
      CALL ReadIVar ( UnAF, AF_File, AF_Table%NumTabs, 'NumTabs', 'Number of airfoil tables for segment #' &
                                                                //TRIM( Int2LStr( ISeg ) )//'.' )

      ALLOCATE ( RnAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the RnAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( ASAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the ASAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( AOLAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the AOLAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( CnAAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the CnAAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( CnSAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the CnSAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( CnSLAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the CnSLAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( AODAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the AODAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      ALLOCATE ( CDOAry(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the CDOAry array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF

      CALL ReadRAry ( UnAF, AF_File, RnAry  , AF_Table%NumTabs, 'RnAry'  , 'Reynolds number values for the airfoil tables.' )
      CALL ReadRAry ( UnAF, AF_File, ASAry  , AF_Table%NumTabs, 'ASAry'  , 'Stall AoA for this airfoil table.'              )
      CALL ReadCom  ( UnAF, AF_File,                                       'the unused first obsolete stall parameter'      )
      CALL ReadCom  ( UnAF, AF_File,                                       'the unused second obsolete stall parameter'     )
      CALL ReadCom  ( UnAF, AF_File,                                       'the unused third obsolete stall parameter'      )
      CALL ReadRAry ( UnAF, AF_File, AOLAry , AF_Table%NumTabs, 'AOLAry' , 'zero-lift AoA'                                  )
      CALL ReadRAry ( UnAF, AF_File, CnAAry , AF_Table%NumTabs, 'CnAAry' , 'Cn slope for zero lift'                         )
      CALL ReadRAry ( UnAF, AF_File, CnSAry , AF_Table%NumTabs, 'CnSAry' , 'Cn at stall value for positive AoA'             )
      CALL ReadRAry ( UnAF, AF_File, CnSLAry, AF_Table%NumTabs, 'CnSLAry', 'Cn at stall value for negative AoA'             )
      CALL ReadRAry ( UnAF, AF_File, AODAry , AF_Table%NumTabs, 'AODAry' , 'AoA for minimum Cd'                             )
      CALL ReadRAry ( UnAF, AF_File, CDOAry , AF_Table%NumTabs, 'CDOAry' , 'minimum Cd value'                               )


         ! Are we expecting Cm data in the file?  Allocate the temporary data array.

      IF ( UseCm )  THEN
         NumCoef = 3
      ELSE
         NumCoef = 2
      END IF

      NumVals = 1 + NumCoef*AF_Table%NumTabs

      ALLOCATE ( AF_DataO(NumVals) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the AF_DataO array for segment #'//TRIM( Int2LStr( ISeg ) )//' in GetAF.' )
      END IF


         ! Allocate the AF_Table of pointers for this element.

      ALLOCATE ( AF_Table%Tab(AF_Table%NumTabs) , STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error allocating memory for the AF_Table of pointers in GetAF.' )
      END IF


            ! Find the length of this table.

      NumAlf = 0

      DO
         READ (UnAF,'()',IOSTAT=IOS)
         IF ( IOS < 0 )  EXIT
         NumAlf = NumAlf + 1
      END DO


         ! Rewind the file to the beginning of this table.

      DO IAlf=1,NumAlf+1
         BACKSPACE UnAF
      END DO ! IAlf


         ! Let's allocate the tables.

      DO ITab=1,AF_Table%NumTabs

         ALLOCATE ( AF_Table%Tab(ITab)%Alpha(NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the Alpha vector of airfoil table #'//TRIM( Int2LStr( ITab) ) &
                       //' for element #'//TRIM( Int2LStr( ISeg) )//'.' )
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%Cl(NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the Cl vector of airfoil table #'//TRIM( Int2LStr( ITab) ) &
                       //' for element #'//TRIM( Int2LStr( ISeg) )//'.' )
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%Cd(NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the Cd vector of airfoil table #'//TRIM( Int2LStr( ITab) ) &
                       //' for element #'//TRIM( Int2LStr( ISeg) )//'.' )
         END IF

         IF ( UseCm )  THEN
            ALLOCATE ( AF_Table%Tab(ITab)%Cm(NumAlf) , STAT=Sttus )
            IF ( Sttus /= 0 )  THEN
               CALL ProgAbort ( ' Error allocating memory for the Cm vector of airfoil table #'//TRIM( Int2LStr( ITab) ) &
                          //' for element #'//TRIM( Int2LStr( ISeg) )//'.' )
            END IF
         END IF

!         ALLOCATE ( AF_Table%Tab(ITab)%FTB(AF_Table%Tab(ITab)%NumAlf) , STAT=Sttus )
         ALLOCATE ( AF_Table%Tab(ITab)%FTB(NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the FTB subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                       //' and table #'//TRIM( Int2LStr( ITab) )//').' )
         END IF

         ALLOCATE ( AF_Table%Tab(ITab)%FTBC(NumAlf) , STAT=Sttus )
         IF ( Sttus /= 0 )  THEN
            CALL ProgAbort ( ' Error allocating memory for the FTBC subtable for segment #'//TRIM( Int2LStr( ISeg) ) &
                      //' and table #' //TRIM( Int2LStr( ITab) )//').' )
         END IF

      END DO ! ITab


         ! Let's read the data this time through.

      NumAlpha = NumAlf

      DO IAlf=1,NumAlf


            ! Let's skip blank lines.  Decrement the number of alphas when we find them.

         READ (UnAF,'(A)')  Line

         IF ( LEN_TRIM( Line ) == 0 )  THEN
            NumAlpha = NumAlpha - 1
            CYCLE
         END IF


            ! Let's get the data from the non-blank line.

         READ (Line,*,IOSTAT=IOS)  ( AF_DataO(Ind), Ind=1,NumVals )

         CALL CheckIOS ( IOS, AF_File, 'AF_DataO', NumType )

         IF ( Echo )  THEN
            WRITE (UnEc,Frmt)  ( AF_DataO(Ind), Ind=1,NumVals )
         END IF


            ! Let's move this good data into permanent storage.

         DO ITab=1,AF_Table%NumTabs

            AF_Table%Tab(ITab)%Alpha(IAlf) = AF_DataO(1)
            AF_Table%Tab(ITab)%Cl   (IAlf) = AF_DataO(NumCoef*(ITab-1)+2)
            AF_Table%Tab(ITab)%Cd   (IAlf) = AF_DataO(NumCoef*(ITab-1)+3)

            IF ( UseCm )  THEN
               AF_Table%Tab(ITab)%Cm(IAlf) = AF_DataO(NumCoef*(ITab-1)+4)
            END IF

            IF ( ABS( AF_Table%Tab(ITab)%CnA ) .GT. 1.0e-6 )  THEN

               Cn = AF_Data(2)*COS( AF_Data(1) ) + ( AF_Data(3) - AF_Table%Tab(ITab)%Cd0 )*SIN( AF_Data(1) )
               Cc = AF_Data(2)*SIN( AF_Data(1) ) - ( AF_Data(3) - AF_Table%Tab(ITab)%Cd0 )*COS( AF_Data(1) )

               AF_Table%Tab(ITab)%FTB (IAlf) = Cn/AF_Table%Tab(ITab)%CnA
               AF_Table%Tab(ITab)%FTBC(IAlf) = Cc/AF_Table%Tab(ITab)%CnA

            ELSE

               AF_Table%Tab(ITab)%FTB (IAlf) = 1.0
               AF_Table%Tab(ITab)%FTBC(IAlf) = 1.0

            END IF

         END DO ! ITab

      END DO ! IAlf


         ! Check AoA range.  AoAs are the same for all tables in a given segment.

      IF ( ( AF_Table%Tab(1)%Alpha(1)      > -180.0 ) .OR. &
           ( AF_Table%Tab(1)%Alpha(NumAlf) <  180.0 ) )  THEN
!           ( AF_Table%Tab(1)%Alpha(AF_Table%Tab(ITab)%NumAlf) <  180.0 ) )  THEN
         CALL ProgAbort ( 'Angle of attack range of airfoil tables for segment #'//TRIM( Int2LStr( ISeg ) ) &
                    //' must be from -180 to 180.' )
      END IF


           ! Store the header data in the permanent structure.

      DO ITab=1,AF_Table%NumTabs
         AF_Table%Tab(ITab)%AlfaStal = ASAry  (ITab)*D2R
         AF_Table%Tab(ITab)%Re       = RnAry  (ITab)*1.0e6
         AF_Table%Tab(ITab)%AOD      = AODAry (ITab)*D2R
         AF_Table%Tab(ITab)%AOL      = AOLAry (ITab)*D2R
         AF_Table%Tab(ITab)%Cd0      = CDOAry (ITab)
         AF_Table%Tab(ITab)%CnA      = CnAAry (ITab)
         AF_Table%Tab(ITab)%CnS      = CnSAry (ITab)
         AF_Table%Tab(ITab)%CnSL     = CnSLAry(ITab)
         AF_Table%Tab(ITab)%NumAlf   = NumAlpha
      END DO ! ITab


         ! Deallocate the temporary Re array.

      DEALLOCATE ( RnAry, STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error deallocating memory for the RnAry array in GetAF.' )
      END IF


         ! Deallocate the temporary data array.

      DEALLOCATE ( AF_DataO, STAT=Sttus )
      IF ( Sttus /= 0 )  THEN
         CALL ProgAbort ( ' Error deallocating memory for the AF_DataO array in GetAF.' )
      END IF

   END IF

   CLOSE ( UnAF )


   RETURN
   END SUBROUTINE GetAF !  ( AF_File, AF_Table, ISeg )
!=======================================================================
   FUNCTION GetCoef( ISeg, Alpha, AlfaTab, CoefTab, NumRows, Ind, ErrStat )


      ! Interpolation routine for airfoil section coefficients.


      ! Function declaration.

   REAL(ReKi)                        :: GetCoef                                 ! The value returned by this function.


      ! Argument declarations.

   INTEGER, INTENT(INOUT)            :: Ind                                     ! The starting/resulting index into the tables.
   INTEGER, INTENT(IN)               :: ISeg                                    ! The current segment.
   INTEGER, INTENT(IN)               :: NumRows                                 ! The length of the arrays.
   INTEGER, INTENT(OUT), OPTIONAL    :: ErrStat                                 ! Error status; if present, program does not abort on error

   REAL(ReKi), INTENT(IN)            :: AlfaTab   (NumRows)                     ! Table of AoAs.
   REAL(ReKi), INTENT(IN)            :: Alpha                                   ! Angle of attack to get the coefficient for.
   REAL(ReKi), INTENT(IN)            :: CoefTab   (NumRows)                     ! Table of coefficients.


   IF ( PRESENT(ErrStat) ) ErrStat = 1


      ! If Alpha is to the outside the table, the user needs to make up some data.  Warn the user and stop the program.

   IF ( ( Alpha < AlfaTab(1) ) .OR. ( AlfaTab(NumRows) < Alpha ) )  THEN

      CALL ProgAbort ( ' For segment '//TRIM( Int2LStr( ISeg ) )//', the current angle of attack ('//TRIM( Num2LStr( Alpha ) ) &
                 //' degrees) is outside the domain of your data table (' //TRIM( Num2LStr( AlfaTab(1) ) )//' to ' &
                 //TRIM( Num2LStr( AlfaTab(NumRows) ) )//' degrees).  Please extend your data table.', PRESENT(ErrStat) )
      IF ( PRESENT(ErrStat) ) ErrStat = 1
      RETURN

   END IF


      ! Alpha is in range.  Interpolate.  Use binary interpolation if this is the first time to access this table.

   IF ( Ind == 0 )  THEN
      GetCoef = InterpBin( Alpha, AlfaTab, CoefTab, Ind, NumRows )
   ELSE
      GetCoef = InterpStp( Alpha, AlfaTab, CoefTab, Ind, NumRows )
   END IF


   RETURN
   END FUNCTION GetCoef ! ( ISeg, Alpha, AlfaTab, CoefTab, NumRows, Ind )
!=======================================================================
   SUBROUTINE GetCoefs ( ISeg, Alpha, Re, AF_Table, ClInt, CdInt, CmInt, CpminInt, DoCl, DoCd, DoCm, DoCpmin, ErrStat )


      ! This routine finds the Re-bounding tables and then calls GetCoef() to get the
      ! desired coefficients for the two tables and then interpolates between them.


      ! Argument declarations.

   TYPE (ElmTable), INTENT(INOUT)    :: AF_Table                                ! The table of airfoil data for the current segment.

   INTEGER, INTENT(IN)               :: ISeg                                    ! The current segment.
   INTEGER, INTENT(OUT), OPTIONAL    :: ErrStat                                 ! Error status; if present, program does not abort on error

   LOGICAL, INTENT(IN)               :: DoCd                                    ! Get Cd.
   LOGICAL, INTENT(IN)               :: DoCl                                    ! Get Cl.
   LOGICAL, INTENT(IN)               :: DoCm                                    ! Get Cm.
   LOGICAL, INTENT(IN)               :: DoCpmin                                 ! Get Cp,min.

   REAL(ReKi), INTENT(IN)            :: Alpha                                   ! Angle of attack to get the coefficient for.
   REAL(ReKi), INTENT(OUT)           :: CdInt                                   ! Interpolated drag coefficient.
   REAL(ReKi), INTENT(OUT)           :: ClInt                                   ! Interpolated lift coefficient.
   REAL(ReKi), INTENT(OUT)           :: CmInt                                   ! Interpolated pitching-moment coefficient.
   REAL(ReKi), INTENT(OUT)           :: CpminInt                                ! Interpolated minimum-pressure coefficient.
   REAL(ReKi), INTENT(IN)            :: Re                                      ! Reynolds number.


      ! Local declarations.

   REAL(ReKi)                        :: CdHi                                    ! The drag coefficient for the higher Re.
   REAL(ReKi)                        :: ClHi                                    ! The lift coefficient for the higher Re.
   REAL(ReKi)                        :: CmHi                                    ! The pitching-moment coefficient for the higher Re.
   REAL(ReKi)                        :: CpminHi                                 ! The minimum-pressure coefficient for the higher Re.
   REAL(ReKi)                        :: Fract                                   ! The fractional distance between tables.

   INTEGER                           :: ITab                                    ! An index for table number.
   INTEGER                           :: ITabLo                                  ! The table number that is the lower bound for Re.
   INTEGER                           :: ITabHi                                  ! The table number that is the lower bound for Re.

   LOGICAL                           :: OneTable                                ! Flag that tells if we need to read only one table (no interpolation).


   IF ( PRESENT(ErrStat) ) ErrStat = 0

      ! Find the bounding tables (if multiple) for this Re.  If there is only one table
      ! or if we are outside the range of tables, we won't need to interpolate.

   IF ( Re <= AF_Table%Tab(1)%Re )  THEN
      ITabLo   = 1
      OneTable = .TRUE.
   ELSE IF ( Re >= AF_Table%Tab(AF_Table%NumTabs)%Re )  THEN
      ITabLo   = AF_Table%NumTabs
      OneTable = .TRUE.
   ELSE IF ( AF_Table%NumTabs > 1 )  THEN
      DO ITab=1,AF_Table%NumTabs-1
         IF ( Re <= AF_Table%Tab(ITab+1)%Re )  THEN
            ITabLo = ITab
            ITabHi = ITab + 1
            EXIT
         END IF
      END DO
      OneTable = .FALSE.
   ELSE
      ITabLo   = 1
      OneTable = .TRUE.
   END IF


      ! Get the coefficients for ITabLo.


   IF ( PRESENT(ErrStat) ) THEN
      IF ( DoCl )  THEN
         ClInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cl, AF_Table%Tab(ITabLo)%NumAlf, &
                                       AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      END IF

      IF ( DoCd )  THEN
         CdInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cd, AF_Table%Tab(ITabLo)%NumAlf, &
                                       AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      END IF

      IF ( DoCm )  THEN
         CmInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cm, AF_Table%Tab(ITabLo)%NumAlf, &
                                       AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      END IF

      IF ( DoCpmin )  THEN
         CpminInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cpmin, AF_Table%Tab(ITabLo)%NumAlf, &
                                          AF_Table%Tab(ITabLo)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      END IF

   ELSE  ! Abort the program when errors are found

      IF ( DoCl )  THEN
         ClInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cl, AF_Table%Tab(ITabLo)%NumAlf, &
                                       AF_Table%Tab(ITabLo)%Ind )
      END IF

      IF ( DoCd )  THEN
         CdInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cd, AF_Table%Tab(ITabLo)%NumAlf, &
                                       AF_Table%Tab(ITabLo)%Ind )
      END IF

      IF ( DoCm )  THEN
         CmInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cm, AF_Table%Tab(ITabLo)%NumAlf, &
                                       AF_Table%Tab(ITabLo)%Ind )
      END IF

      IF ( DoCpmin )  THEN
         CpminInt = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabLo)%Alpha, AF_Table%Tab(ITabLo)%Cpmin, AF_Table%Tab(ITabLo)%NumAlf, &
                                          AF_Table%Tab(ITabLo)%Ind )
      END IF

   END IF


      ! If we don't need to interpolate, we don't need to make a second call and we are done.

   IF ( OneTable )  RETURN                 ! We probably shouldn't do this.  We should probably do a block IF.  mlb


      ! Get the coefficients for ITabHi.  Use step-wise interpolation for all but the first coefficient called.

   Fract = ( Re - AF_Table%Tab(ITabLo)%Re )/( AF_Table%Tab(ITabHi)%Re - AF_Table%Tab(ITabLo)%Re )

   IF ( DoCl )  THEN
      IF ( PRESENT(ErrStat) ) THEN
         ClHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cl, AF_Table%Tab(ITabHi)%NumAlf, &
                                       AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      ELSE
         ClHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cl, AF_Table%Tab(ITabHi)%NumAlf, &
                                       AF_Table%Tab(ITabHi)%Ind )
      END IF
      ClInt = ClInt + Fract*( ClHi - ClInt )
   END IF

   IF ( DoCd )  THEN
      IF ( PRESENT(ErrStat) ) THEN
         CdHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cd, AF_Table%Tab(ITabHi)%NumAlf, &
                                       AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      ELSE
         CdHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cd, AF_Table%Tab(ITabHi)%NumAlf, &
                                       AF_Table%Tab(ITabHi)%Ind )
      END IF
      CdInt = CdInt + Fract*( CdHi - CdInt )
   END IF

   IF ( DoCm )  THEN
      IF ( PRESENT(ErrStat) ) THEN
         CmHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cm, AF_Table%Tab(ITabHi)%NumAlf, &
                                       AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      ELSE
         CmHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cm, AF_Table%Tab(ITabHi)%NumAlf, &
                                       AF_Table%Tab(ITabHi)%Ind )
      END IF
      CmInt = CmInt + Fract*( CmHi - CmInt )
   END IF

   IF ( DoCpmin )  THEN
      IF ( PRESENT(ErrStat) ) THEN
         CpminHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cpmin, AF_Table%Tab(ITabHi)%NumAlf, &
                                          AF_Table%Tab(ITabHi)%Ind, ErrStat )
         IF (ErrStat > 0) RETURN
      ELSE
         CpminHi = GetCoef( ISeg, Alpha, AF_Table%Tab(ITabHi)%Alpha, AF_Table%Tab(ITabHi)%Cpmin, AF_Table%Tab(ITabHi)%NumAlf, &
                                          AF_Table%Tab(ITabHi)%Ind )
      END IF
      CpminInt = CpminInt + Fract*( CpminHi - CpminInt )
   END IF


   RETURN
   END SUBROUTINE GetCoefs ! ( ISeg, Alpha, Re, AF_Table, ClInt, CdInt, CmInt, CpminInt, DoCl, DoCd, DoCm, DoCpmin, ErrStat )
!=======================================================================

END MODULE NWTC_Aero
MODULE NWTC_Library


      ! Notes:

         ! Your project must include the following files:
         !     NWTC_Aero.f90
         !     NWTC_IO.f90
         !     NWTC_Library.f90
         !     NWTC_Num.f90
         !     ModMesh.f90

         ! Your project must include one, but not both, of the following files:
         !     DoubPrec.f90 - for double-precision arithmetic for floating-points variables.  You may have to set a compiler option to have constants use double precision.
         !     SingPrec.f90 - for single-precision arithmetic for floating-points variables.

         ! Your project must include one, and only one, of the following files:
         !     SysIVF.f90    - for Intel Visual Fortran for Windows compiler
         !     SysGnu.f90    - for Gnu Fortran for Linux compiler
         !     SysIFL.f90    - for Intel Fortran for Linux compiler
         !     SysMatlab.f90 - for Intel Visual Fortran for Windows compiler with Matlab's mex functions


         ! Compilation order for command-line compilation:
         !     SingPrec.f90 or DoubPrec.f90
         !     SysIVF.f90 (or other Sys*.f90 file)
         !     NWTC_IO.f90
         !     NWTC_Num.f90
         !     NWTC_Aero.f90
         !     ModMesh.f90
         !     NWTC_Library.f90

         ! Invoking programs should call NWTC_Init() to initialize data important to the use of the library.  Currently,
         !  this is used for the NaN, Inf, and Pi-based constants.


   USE NWTC_Aero   ! The other modules (NWTC_IO, NWTC_Num, Precision, SysSubs, and F2kCLI) are already included in NWTC_Aero.

   USE ModMesh  !BJJ update with JM/IC's Mesh module

   IMPLICIT  NONE


CONTAINS

!=======================================================================
   SUBROUTINE NWTC_Init( ProgNameIn, ProgVerIn )

      ! passed parameters

   CHARACTER(*), INTENT(IN), OPTIONAL :: ProgNameIn
   CHARACTER(*), INTENT(IN), OPTIONAL :: ProgVerIn



      ! Initialize ProgName and ProgVer if parameters have been passed

   IF ( PRESENT( ProgNameIN ) ) THEN
      ProgName = ProgNameIN
   END IF

   IF ( PRESENT( ProgVerIn ) ) THEN
      ProgVer = ProgVerIn
   END IF


      ! This routine calls all required initialization routines.

   CALL SetConstants()

!mlb Let's get rid of this once FLUSH works.
   CALL OpenCon( )


      ! Write the version of the NWTC subroutine library that we are running
   CALL DispNVD( NWTC_Ver )


   RETURN
   END SUBROUTINE NWTC_Init
!=======================================================================

END MODULE NWTC_Library
!----------------------------------------------------------------------------------------------------
MODULE SharedInflowDefns
! This module is used to define shared types and parameters that are used in the module InflowWind.
! 7 Oct 2009    B. Jonkman, NREL/NWTC
!----------------------------------------------------------------------------------------------------

   USE NWTC_Library                                               ! Precision module 

   !-------------------------------------------------------------------------------------------------
   ! Shared types
   !-------------------------------------------------------------------------------------------------

!   TYPE, PUBLIC :: InflLoc   
!      REAL(ReKi)                    :: Position(3)                ! X, Y, Z
!   END TYPE InflLoc
   
   
   TYPE, PUBLIC :: InflIntrpOut
      REAL(ReKi)                    :: Velocity(3)                ! U, V, W
   END TYPE InflIntrpOut

   !-------------------------------------------------------------------------------------------------
   ! Shared parameters, defining the wind types
   ! THEY MUST BE UNIQUE!
   !-------------------------------------------------------------------------------------------------

   INTEGER, PARAMETER, PUBLIC  :: DEFAULT_Wind = -1        ! Undetermined wind type; calls internal routine to guess what type of file it is.
   INTEGER, PARAMETER, PUBLIC  :: Undef_Wind   =  0        ! This is the code for an undefined WindType
   INTEGER, PARAMETER, PUBLIC  :: HH_Wind      =  1        ! Hub-Height wind file
   INTEGER, PARAMETER, PUBLIC  :: FF_Wind      =  2        ! Binary full-field wind file
   INTEGER, PARAMETER, PUBLIC  :: UD_Wind      =  3        ! User-defined wind
   INTEGER, PARAMETER, PUBLIC  :: FD_Wind      =  4        ! 4-dimensional wind (LES)
   INTEGER, PARAMETER, PUBLIC  :: CTP_Wind     =  5        ! Coherent turbulence wind field (superimpose KH billow on background wind)
   INTEGER, PARAMETER, PUBLIC  :: HAWC_Wind    =  6        ! Binary full-field wind file in HAWC format

END MODULE SharedInflowDefns
MODULE CTWind
! This module uses reads coherent turbulence parameter (CTP) files and processes the data in them
! to get coherent turbulence which is later superimposed on a background wind field (the super-
! positioning occurs elsewhere).  The turbulence in this module is part of the KH billow, which
! can be read using FDWind.  As a result, the scaling here should be similiar to FDWind.
!
! This module assumes that the origin, (0,0,0), is located at the tower centerline at ground level,
! and that all units are specified in the metric system (using meters and seconds).
! Data is shifted by half the grid width when used with FFWind.
!
!  Created 25-Sept-2009 by B. Jonkman, National Renewable Energy Laboratory
!     using subroutines and modules from AeroDyn v12.58
!
!----------------------------------------------------------------------------------------------------

   USE                     NWTC_Library
   USE                     SharedInflowDefns

   IMPLICIT                NONE
   PRIVATE
   
      
   INTEGER, PARAMETER           :: NumComps  = 3                              ! number of components
   
            ! CT_Wind
   REAL(ReKi)                   :: DelYCTgrid                                 ! The nondimensional distance between grid points in the y direction.
   REAL(ReKi)                   :: DelZCTgrid                                 ! The nondimensional distance between grid points in the z direction.
   REAL(ReKi)                   :: CTDistSc                                   ! Disturbance scale (ratio of wave height to rotor diameter).
   REAL(ReKi)                   :: CTOffset (NumComps)                        ! Offsets to convert integer data to actual wind speeds.
   REAL(ReKi)                   :: CTScale  (NumComps)                        ! Scaling factors to convert integer data to actual wind speeds.

   
   REAL(ReKi), ALLOCATABLE      :: CTvelU   (:,:,:)                         ! The y-z grid velocity data (U components) for the lower- and upper-bound time slices
   REAL(ReKi), ALLOCATABLE      :: CTvelV   (:,:,:)                         ! The y-z grid velocity data (V components) for the lower- and upper-bound time slices
   REAL(ReKi), ALLOCATABLE      :: CTvelW   (:,:,:)                         ! The y-z grid velocity data (W components) for the lower- and upper-bound time slices
   REAL(ReKi)                   :: CTLy                                       ! Fractional location of tower centerline from right (looking downwind) to left side of the dataset.
   REAL(ReKi)                   :: CTLz                                       ! Fractional location of hub height from bottom to top of dataset.
   REAL(ReKi)                   :: CTScaleVel                                 ! Scaling velocity, U0.  2*U0 is the difference in wind speed between the top and bottom of the wave.
   REAL(ReKi), ALLOCATABLE      :: Tdata    (:)                               ! The list of times for the CT-wind input files.  
   
   REAL(ReKi)                   :: CT_Zref                                    ! The reference height for the CT file (the bottom of the billow)
   REAL(ReKi)                   :: CTYHWid                                    ! The half the width of the background dataset, used to compute the CTwind time offset
   REAL(ReKi)                   :: CTYmax                                     ! The dimensional lateral width of the dataset.
   REAL(ReKi)                   :: CTYt                                       ! Distance of the tower from the right side of the dataset (looking downwind).
   REAL(ReKi)                   :: CTZmax                                     ! The dimensional vertical height of the dataset.
   REAL(ReKi)                   :: InvMCTWS                                   ! The multiplicative inverse of the mean hub height wind speed for the CT wind data

   INTEGER                      :: CT_DF_Y                                    ! The decimation factor for the CT wind data in the y direction.
   INTEGER                      :: CT_DF_Z                                    ! The decimation factor for the CT wind data in the z direction.
   INTEGER                      :: CTvel_files(2)                             ! Times for the CT wind files stored in CTvel arrays.

   INTEGER                      :: IndCT_hi                                   ! An index into the 3rd dimension of the CTvel arrays, indicating the upper time slice (allows us to avoid copying array)
   INTEGER                      :: IndCT_lo                                   ! An index into the 3rd dimension of the CTvel arrays, indicating the lower time slice (allows us to avoid copying array)
   
   INTEGER                      :: NumCTt                                     ! The number of CT wind grids, no more than one grid per time step.
   INTEGER                      :: NumCTy                                     ! The number of CT wind grid points in the y direction.
   INTEGER                      :: NumCTyD                                    ! The decimated number of CT wind grid points in the y direction.
   INTEGER                      :: NumCTyD1                                   ! The decimated number of CT wind grid points in the y direction minus 1.
   INTEGER                      :: NumCTz                                     ! The number of CT wind grid points in the z direction.
   INTEGER                      :: NumCTzD                                    ! The decimated number of CT wind grid points in the z direction.
   INTEGER                      :: NumCTzD1                                   ! The decimated number of CT wind grid points in the z direction minus 1.
   INTEGER, SAVE                :: TimeIndx  = 0                              ! Index into the time array
   INTEGER, ALLOCATABLE         :: TimeStpCT (:)                              ! The list of time steps from the original LE simulation, associated with the CT-wind times.

   INTEGER                      :: CTWindUnit                                 ! unit number used to read the wind files at each call to CT_GetWindSpeed()
   
   LOGICAL                      :: CTVertShft                                 ! Flag to indicate whether or not to shift the z values for the w component.

   CHARACTER(3)                 :: CText                                      ! The extension used for coherent turbulence data files. (usually "les" or "dns")
   CHARACTER(1024)              :: CTSpath                                    ! The path to the CT wind files.

   TYPE :: CTWindFiles
      CHARACTER(1024)           :: CTTSfile                                   ! The name of the file containing the time-step history of the wind files.
      CHARACTER(1024)           :: CTbackgr                                   ! The name of the background wind data
   END TYPE CTWindFiles


   TYPE, PUBLIC :: CT_Backgr
      CHARACTER(1024)           :: WindFile                                   ! The name of the background wind file
      INTEGER                   :: WindFileType                               ! The type of background wind file (currently only FF)
      LOGICAL                   :: CoherentStr                                ! If the coherent time step file is blank or doesn't exist, this is FALSE (use the background only)
   END TYPE CT_Backgr
            
   
   PUBLIC                       :: CT_Init
   PUBLIC                       :: CT_GetWindSpeed
   PUBLIC                       :: CT_SetRefVal
   PUBLIC                       :: CT_Terminate

CONTAINS
!====================================================================================================
SUBROUTINE CT_Init(UnWind, WindFile, BackGrndValues, ErrStat)
!  This subroutine is called at the beginning of a simulation.  It reads the CTP file to obtain
!  the name of the CTS file, the path locating the binary KH files, and decimation factors.
!  It returns the background wind file and type; it also returns a flag that determines if CT wind
!  files are ACTUALLY to be used (e.g., if the CTS file is blank or there is one line of zero in the
!  CTS time array).  
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: WindFile                     ! Name of the CTP (.ctp) wind file
   TYPE(CT_Backgr), INTENT(OUT)   :: BackGrndValues               ! output background values
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise


      ! Local Variables:
      
   TYPE(CTWindFiles)              :: CTP_files
   CHARACTER(3)                   :: CT_SC_ext                    ! extension of the scaling file
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( TimeIndx /= 0 ) THEN  
      CALL WrScr( ' CTWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Read the CTP file and set the background data info to be returned later
   !-------------------------------------------------------------------------------------------------
   
   CALL ReadCTP( UnWind, WindFile, CTP_files, ErrStat )
   IF (ErrStat /= 0) RETURN           
   
  
   BackGrndValues%WindFile     = CTP_files%CTbackgr
   BackGrndValues%WindFileType = FF_Wind             !bjj: perhaps we should check the wind type here
   
   !-------------------------------------------------------------------------------------------------
   ! Read the CTTS file to get the time step and file number arrays
   !-------------------------------------------------------------------------------------------------   
   CALL ReadCTTS( UnWind, CTP_files%CTTSfile, CT_SC_ext, ErrStat )

   IF (ErrStat == 0 .AND. NumCTt > 1) THEN    
      BackGrndValues%CoherentStr  = .TRUE.
      
      !-------------------------------------------------------------------------------------------------
      ! Read file containing scaling for the binary large-eddy files
      !-------------------------------------------------------------------------------------------------
      CALL ReadCTScales( UnWind, TRIM( CTSpath )//'\Scales.'//TRIM( CT_SC_ext ), ErrStat )
      IF (ErrStat /= 0) RETURN


      CTScale(:)  = CTScaleVel*CTScale(:)
      CTOffset(:) = CTScaleVel*CTOffset(:)

   ELSE              
      
      IF (ErrStat <= 0) THEN
         
            ! The file is missing, blank (or possibly incomplete), or has only 1 time step line (which  
            ! is zero); Go on without the CT file, using just the background

         CALL ProgWarn( ' Coherent turbulence wind file will be turned off.' )
         
         BackGrndValues%CoherentStr  = .FALSE.
         CALL CT_Terminate( ErrStat )          
         
      END IF

      RETURN
      
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Set some values that don't change during the run
   !-------------------------------------------------------------------------------------------------
      
   CTYHWid        = 0.0                                                    ! This value is used to perform a time shift (the equivalent distance of FFYHWid [approx. rotor radius])
   CT_Zref        = -1.0                                                   ! This value needs to be set after the corresponding background turbulence has been read (or the CTS file should be changed)

   NumCTyD        = ( NumCTy + CT_DF_Y - 1 )/CT_DF_Y                       ! The decimated number of CT wind grid points in the y direction.
   NumCTzD        = ( NumCTz + CT_DF_Z - 1 )/CT_DF_Z                       ! The decimated number of CT wind grid points in the z direction.
   NumCTyD1       = NumCTyD - 1                                            ! The decimated number of CT wind grid points in the y direction minus 1.
   NumCTzD1       = NumCTzD - 1                                            ! The decimated number of CT wind grid points in the z direction minus 1.

   CTYt           = CTYmax*CTLy                                            ! Distance of the tower from the right side of the dataset (looking downwind).
!   CTZt           = CTZmax*CTLz                                            ! Distance of the hub from the bottom of the dataset.
   DelYCTgrid     = 1.0/NumCTyD1                                           ! The nondimensional distance between grid points in the y direction.
   DelZCTgrid     = 1.0/NumCTzD1                                           ! The nondimensional distance between grid points in the z direction.
    

     
   !-------------------------------------------------------------------------------------------------
   ! Allocate the wind array and initialize it
   !-------------------------------------------------------------------------------------------------
   
   IF (.NOT. ALLOCATED(CTvelU) ) THEN
      ALLOCATE ( CTvelU(NumCTyD,NumCTzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the CTvelU array.' )
         RETURN
      END IF
   END IF   
   
   IF (.NOT. ALLOCATED(CTvelV) ) THEN
!      CALL AllocAry( CTvelV, NumCTyD, NumCTzD, 2, 'CTvelV', ErrStat ) !AllRAry3 AllocAry
      ALLOCATE ( CTvelV(NumCTyD,NumCTzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the CTvelV array.' )
         RETURN
      END IF
   END IF   
   
   IF (.NOT. ALLOCATED(CTvelW) ) THEN
!      CALL AllocAry( CTvelW, NumCTyD, NumCTzD, 2, 'CTvelW', ErrStat ) !AllRAry3 AllocAry
      ALLOCATE ( CTvelW(NumCTyD,NumCTzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the CTvelW array.' )
         RETURN
      END IF
   END IF   

   CTvelU(:,:,:) = 0.0                                                    ! the original velocity data      
   CTvelV(:,:,:) = 0.0                                                    ! the original velocity data      
   CTvelW(:,:,:) = 0.0                                                    ! the original velocity data      
      
   !-------------------------------------------------------------------------------------------------
   ! Initialize the arrays and set the initialization flag
   !-------------------------------------------------------------------------------------------------   
   CTvel_files(:) = 0                                                      ! the name of the files currently in the CTvel array
   CTWindUnit     = UnWind                                                 ! This unit is needed to open the binary files at each step
   TimeIndx       = 1
    
   RETURN

END SUBROUTINE CT_Init
!====================================================================================================
SUBROUTINE CT_SetRefVal(Height, HWidth, ErrStat)

   REAL(ReKi), INTENT(IN)           :: Height                                 ! a reference height (should be hub height)
   REAL(ReKi), INTENT(IN), OPTIONAL :: HWidth                                 ! a reference offset (should be half grid width [~rotor radius])
   INTEGER,    INTENT(OUT)          :: ErrStat                                ! returns 0 if no error; non-zero otherwise


   !-------------------------------------------------------------------------------------------------     
   ! Check that we've initialized everything first
   !-------------------------------------------------------------------------------------------------     
     
   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Initialialize the CTWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE IF ( CT_Zref >= 0 ) THEN
      CALL WrScr( ' Cannot reset the CTWind reference height in the middle of a simulation.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0         
   END IF      


   !-------------------------------------------------------------------------------------------------     
   ! Set the grid shift using the half-width
   !-------------------------------------------------------------------------------------------------     
   IF ( PRESENT( HWidth ) ) THEN
      CTYHWid = HWidth
        
      IF ( CTYHWid < 0 ) THEN
         CALL WrScr( ' Reference width in CTWind cannot be negative.')
         CTYHWid = 0
         ErrStat = 1
      END IF
   END IF
 
 
   !-------------------------------------------------------------------------------------------------     
   ! Set the reference height (bottom of the KH billow) using the input hub-height
   !-------------------------------------------------------------------------------------------------     
      ! CTZt = CTZmax*CTLz             ! the distance between the hub and the bottom of the dataset

   CT_Zref = Height - CTZmax*CTLz      ! the height of the bottom of the KH billow

   IF ( CT_Zref < 0 ) THEN
      CALL WrScr( ' Reference height in CTWind cannot be negative.')
      CT_Zref = 0
      ErrStat = 1
   END IF      

   
END SUBROUTINE CT_SetRefVal
!====================================================================================================
FUNCTION CT_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are are 
! requested.  It returns the velocities at the specified time and space that are superimposed on
! a background wind flow.  This function interpolates into the full-field CT wind arrays, performing
! a time shift based on the average windspeed. The modified time is used to decide which pair of time 
! slices to interpolate within and between. After finding the two time slices, it decides which four 
! grid points bound the (Y,Z) pair. It does a bilinear interpolation for (Y,Z) on each bounding time 
! slice, then linearly interpolates between the 2 time slices. This routine assumes that X is downwind, 
! Y is to the left when looking downwind and Z is up.  In the time (X) and Z directions, steady winds 
! are used when extrapolation is required.  The dataset is assumed to be periodic in the Y direction.
!----------------------------------------------------------------------------------------------------
 
      ! Passed variables:
      
   REAL(ReKi),        INTENT(IN) :: Time                                   ! the time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)                       ! the position (X,Y,Z)
   INTEGER,           INTENT(OUT):: ErrStat                                ! returns 0 if no error; non-zero otherwise
   TYPE(InflIntrpOut)            :: CT_GetWindSpeed                        ! the resultant wind speed
   
   
      ! Local Variables:

   REAL(ReKi)                    :: Iyz_th                                 ! Temporary interpolated value. (time hi, all y, all z)
   REAL(ReKi)                    :: Iyz_tl                                 ! Temporary interpolated value. (time lo, all y, all z)
   REAL(ReKi)                    :: Iyhz                                   ! Temporary interpolated value. (y hi, all z)
   REAL(ReKi)                    :: Iylz                                   ! Temporary interpolated value. (y lo, all z)
   REAL(ReKi)                    :: TimeShifted                            ! Shifted time (necessary because we're keeping x constant)
   REAL(ReKi)                    :: Tgrid                                  ! Fractional distance between time grids.
   REAL(ReKi)                    :: Ygrid                                  ! Fractional distance between grids in the y direction.
   REAL(ReKi)                    :: Ynorm                                  ! Nondimensional lateral distance of the analysis point from right side of dataset (looking downwind).
   REAL(ReKi)                    :: Zgrid(3)                               ! Fractional distance between grids in the z direction.
   REAL(ReKi)                    :: Znorm                                  ! Nondimensional vertical distance of the analysis point from bottom of dataset.

   INTEGER                       :: I
   INTEGER                       :: IYHi
   INTEGER                       :: IYLo
   INTEGER                       :: IZHi(3)
   INTEGER                       :: IZLo(3)


   !-------------------------------------------------------------------------------------------------     
   ! Check that we've initialized everything first
   !-------------------------------------------------------------------------------------------------     
     
   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Initialialize the CTWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE IF ( CT_Zref < 0 ) THEN
      CALL WrScr( ' Set the reference height in the CTWind module before calling CT_GetWindSpeed.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------     
   ! Perform the time shift. At time=0, a point half the grid width downstream will index into the zero 
   ! time slice.  CTYHWid is used to shift the CT wind the same as FF wind is shifted.
   ! This assumes that the coherent turbulence events are moving at MCTWS
   !-------------------------------------------------------------------------------------------------     

   TimeShifted = TIME + ( CTYHWid - InputPosition(1) )*InvMCTWS


   !-------------------------------------------------------------------------------------------------
   ! Find the bounding time slices:
   ! Linearly interpolate in time (or set to 0 before and/or after) 
   ! (compare with NWTC_Num.f90\InterpStpReal) 
   !-------------------------------------------------------------------------------------------------

      ! Let's check the limits first.

   IF ( TimeShifted <= Tdata(1) )  THEN
   
      TimeIndx = 1
      Tgrid    = 0.0
                     
!      CT_GetWindSpeed%Velocity(:) = 0.0
!      RETURN
                           
   ELSE IF ( TimeShifted >= Tdata(NumCTt) )  THEN
   
      TimeIndx = NumCTt - 1
      Tgrid    = 1.0

!      CT_GetWindSpeed%Velocity(:) = 0.0
!      RETURN
      
   ELSE
   
         ! Let's interpolate!

      TimeIndx = MAX( MIN( TimeIndx, NumCTt-1 ), 1 )


      DO 

         IF ( TimeShifted < Tdata(TimeIndx) )  THEN

            TimeIndx = TimeIndx - 1

         ELSE IF ( TimeShifted >= Tdata(TimeIndx+1) )  THEN

            TimeIndx = TimeIndx + 1

         ELSE
         
            Tgrid = MIN( MAX( ( TimeShifted - Tdata(TimeIndx) )/( Tdata(TimeIndx+1) - Tdata(TimeIndx) ), 0.0 ), 1.0 )
            EXIT

         END IF

      END DO
      
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Read the data at the two time steps, if necessary
   !-------------------------------------------------------------------------------------------------
     
   IF ( TimeStpCT(TimeIndx) == CTvel_files(2) ) THEN
      IndCT_lo = 2      
      IndCT_hi = 1
            
   ELSE
      IndCT_lo = 1
      IndCT_hi = 2 
        
      IF ( TimeStpCT(TimeIndx) /= CTvel_files(IndCT_lo) ) THEN         
         CTvel_files(IndCT_lo) = TimeStpCT(TimeIndx)
         CALL ReadCTData ( CTWindUnit, CTvel_files(IndCT_lo), IndCT_lo, ErrStat  )
      END IF
      
   END IF
   

   IF ( CTvel_files(IndCT_hi) /= TimeStpCT(TimeIndx+1) ) THEN
      
      CTvel_files(IndCT_hi) = TimeStpCT(TimeIndx+1)
      CALL ReadCTData ( CTWindUnit, CTvel_files(IndCT_hi), IndCT_hi, ErrStat  )

   END IF
         

   !-------------------------------------------------------------------------------------------------
   ! Calculate the y values;                   The lower-right corner is (1,1) when looking downwind.
   ! note that the KH data is periodic in this direction
   !-------------------------------------------------------------------------------------------------
   
   Ynorm = ( CTYt + InputPosition(2) )/CTYmax

      ! Ensure Ynorm is not negative.  The wave is periodic in y.

   IF ( Ynorm < 0.0 ) THEN
      Ynorm = 1.0 + MOD(Ynorm, 1.0)
   ENDIF

   Ygrid = MIN( MAX( MOD( Ynorm, DelYCTgrid ), 0.0 ), 1.0 )
   IYLo  = MAX( MOD( INT( Ynorm*NumCTyD1 ) + 1, NumCTyD1 ), 1 )
   IYHi =  MOD( IYLo, NumCTyD ) + 1


   !-------------------------------------------------------------------------------------------------
   ! Calculate the z values                   The lower-right corner is (1,1) when looking downwind.
   ! Note: the equivalent Znorm for the w-component may be shifted vertically by half the original
   ! grid spacing. (the K-H data staggers w differently than u & v).  We store IZLo, IZHi, and 
   ! Zgrid in an array to account for this difference.
   !-------------------------------------------------------------------------------------------------

   Znorm = MIN( MAX( ( InputPosition(3) - CT_Zref )/CTZmax, 0.0 ), 1.0 ) ! non-dimensional height (CT_Zref is the bottom of the billow)

      ! Find out fractionally how far we are between grids in time and between grid points in each direction.
      ! Limit values to avoid extrapolation.  We need this for interpolation later on.

   Zgrid(1:2)   = MIN( MAX( MOD( Znorm, DelZCTgrid ), 0.0 ), 1.0 )
   IZLo(1:2)    = MAX( INT( Znorm*NumCTzD1 ) + 1, 1 )            ! Make sure the lowest possible value is 1.

      ! If we are located at the upper end of the z dimension, decrement the index by one and set the grid coordinate to 1.

   IF ( IZLo(1) == NumCTzD )  THEN
      IZLo(1:2)  = NumCTzD1
      Zgrid(1:2) = 1.0
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Find the equivalent Znorm for the w-component, which may be shifted vertically by half 
   ! the original grid spacing. (This is necessary due to the fact that the K-H data staggers w 
   ! differently than u & v).  LES and DNS scale differently.
   !-------------------------------------------------------------------------------------------------

   IF ( CTVertShft )  THEN
      Znorm = MAX( Znorm - 0.5*DelZCTgrid/CT_DF_Z, 0.0 )
      
      Zgrid(3) = MIN( MAX( MOD( Znorm, DelZCTgrid ), 0.0 ), 1.0 )
      IZLo(3)  = MAX( INT( Znorm*NumCTzD1 ) + 1, 1 )       ! Make sure the lowest possible value is 1.


         ! If we are located at the upper end of the z dimension, decrement the index by one and set the grid coordinate to 1.

      IF ( IZLo(3) == NumCTzD )  THEN
         IZLo(3)  = NumCTzD1
         Zgrid(3) = 1.0
      ENDIF
                 
   ELSE
      IZLo(3) = IZLo(1)
      Zgrid(3)= Zgrid(1)          
   ENDIF

   IZHi(:) = IZLo(:) + 1
   
!bjj: old versions used Zgrid(3) = Zgrid(1) without regard to CTVertShft. It seemed wrong to me so I changed it.

   !-------------------------------------------------------------------------------------------------
   !  Interpolate for U component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

      I = 1
         ! linearaly interpolate in the lower time slice
      Iylz   = ( CTvelU(IYLo,IZHi(I),IndCT_lo) - CTvelU(IYLo,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelU(IYLo,IZLo(I),IndCT_lo)
      Iyhz   = ( CTvelU(IYHi,IZHi(I),IndCT_lo) - CTvelU(IYHi,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelU(IYHi,IZLo(I),IndCT_lo)     
      Iyz_tl = ( Iyhz - Iylz )*Ygrid + Iylz

         ! linearaly interpolate in the upper time slice
      Iylz   = ( CTvelU(IYLo,IZHi(I),IndCT_hi) - CTvelU(IYLo,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelU(IYLo,IZLo(I),IndCT_hi)
      Iyhz   = ( CTvelU(IYHi,IZHi(I),IndCT_hi) - CTvelU(IYHi,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelU(IYHi,IZLo(I),IndCT_hi)     
      Iyz_th = ( Iyhz - Iylz )*Ygrid + Iylz

      CT_GetWindSpeed%Velocity(I) = ( Iyz_th - Iyz_tl )*Tgrid + Iyz_tl


   !-------------------------------------------------------------------------------------------------
   !  Interpolate for V component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

      I = 2

         ! linearaly interpolate in the lower time slice
      Iylz   = ( CTvelV(IYLo,IZHi(I),IndCT_lo) - CTvelV(IYLo,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelV(IYLo,IZLo(I),IndCT_lo)
      Iyhz   = ( CTvelV(IYHi,IZHi(I),IndCT_lo) - CTvelV(IYHi,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelV(IYHi,IZLo(I),IndCT_lo)     
      Iyz_tl = ( Iyhz - Iylz )*Ygrid + Iylz

         ! linearaly interpolate in the upper time slice
      Iylz   = ( CTvelV(IYLo,IZHi(I),IndCT_hi) - CTvelV(IYLo,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelV(IYLo,IZLo(I),IndCT_hi)
      Iyhz   = ( CTvelV(IYHi,IZHi(I),IndCT_hi) - CTvelV(IYHi,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelV(IYHi,IZLo(I),IndCT_hi)     
      Iyz_th = ( Iyhz - Iylz )*Ygrid + Iylz

      CT_GetWindSpeed%Velocity(I) = ( Iyz_th - Iyz_tl )*Tgrid + Iyz_tl


   !-------------------------------------------------------------------------------------------------
   !  Interpolate for W component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

      I = 3

         ! linearaly interpolate in the lower time slice
      Iylz   = ( CTvelW(IYLo,IZHi(I),IndCT_lo) - CTvelW(IYLo,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelW(IYLo,IZLo(I),IndCT_lo)
      Iyhz   = ( CTvelW(IYHi,IZHi(I),IndCT_lo) - CTvelW(IYHi,IZLo(I),IndCT_lo) )*Zgrid(I) + CTvelW(IYHi,IZLo(I),IndCT_lo)     
      Iyz_tl = ( Iyhz - Iylz )*Ygrid + Iylz

         ! linearaly interpolate in the upper time slice
      Iylz   = ( CTvelW(IYLo,IZHi(I),IndCT_hi) - CTvelW(IYLo,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelW(IYLo,IZLo(I),IndCT_hi)
      Iyhz   = ( CTvelW(IYHi,IZHi(I),IndCT_hi) - CTvelW(IYHi,IZLo(I),IndCT_hi) )*Zgrid(I) + CTvelW(IYHi,IZLo(I),IndCT_hi)     
      Iyz_th = ( Iyhz - Iylz )*Ygrid + Iylz

      CT_GetWindSpeed%Velocity(I) = ( Iyz_th - Iyz_tl )*Tgrid + Iyz_tl


   RETURN

END FUNCTION CT_GetWindSpeed
!====================================================================================================
SUBROUTINE ReadCTData ( UnWind, CTFileNo, Itime, ErrStat )
!    This subroutine is used to read one time-step's worth of large-eddy
!    zero-mean wind data for each wind component from a file.
!----------------------------------------------------------------------------------------------------


      ! Passed variables.

   INTEGER,       INTENT(IN)     :: UnWind                                    ! The I/O unit of the input file
   INTEGER,       INTENT(IN)     :: CTFileNo                                  ! The number of the file to read
   INTEGER,       INTENT(IN)     :: Itime                                     ! The index of the time slice
   INTEGER,       INTENT(OUT)    :: ErrStat                                   ! returns 0 if no error; non-zero otherwise

      ! Local variables.

!   CHARACTER(1),PARAMETER        :: Comp(NumComps) = (/'u', 'v', 'w' /)       ! the wind components
   CHARACTER(5)                  :: CTnum                                     ! string equivalent of input variable CTFileNo
   CHARACTER(1024)               :: FileName                                  ! The name of the input data file
   
   
   IF ( CTFileNo == 0 ) THEN
   
      CTvelU(:,:,Itime) = 0.0
      CTvelV(:,:,Itime) = 0.0
      CTvelW(:,:,Itime) = 0.0
      
   ELSE
         ! Loop through the components

      WRITE( CTnum, '(I5.5)' ) CTFileNo


      FileName = TRIM( CTSpath )//'\u\u_16i_'//CTnum//'.'//TRIM( CText )
      CALL LoadCTData( UnWind, TRIM(FileName), Itime, 1, CTvelU, ErrStat )
      IF ( ErrStat /= 0 ) RETURN
      

      FileName = TRIM( CTSpath )//'\v\v_16i_'//CTnum//'.'//TRIM( CText )
      CALL LoadCTData( UnWind, TRIM(FileName), Itime, 2, CTvelV, ErrStat )
      IF ( ErrStat /= 0 ) RETURN
      
      
      FileName = TRIM( CTSpath )//'\w\w_16i_'//CTnum//'.'//TRIM( CText )
      CALL LoadCTData( UnWind, TRIM(FileName), Itime, 3, CTvelW, ErrStat )
      IF ( ErrStat /= 0 ) RETURN
      
   
   END IF

   RETURN
   
END SUBROUTINE ReadCTData
!====================================================================================================
SUBROUTINE LoadCTData( UnWind, FileName, ITime, IComp, Vel, ErrStat )
!  This function is used to read the input parameters for the coherent turbulence events, 
!  based on the large-eddy simulation.
!----------------------------------------------------------------------------------------------------

      ! Passed variables.

   INTEGER,       INTENT(IN)     :: UnWind                                    ! The I/O unit of the input file
   CHARACTER(*),  INTENT(IN)     :: FileName                                  ! The name of the file to open
   INTEGER,       INTENT(IN)     :: Itime                                     ! The index of the time slice
   INTEGER,       INTENT(IN)     :: IComp                                     ! The index of the component
   REAL(ReKi),    INTENT(INOUT)  :: Vel    (NumCTyD,NumCTzD,2)                ! returns the velocity array (don't use INTENT OUT!)  
   INTEGER,       INTENT(OUT)    :: ErrStat                                   ! returns 0 if no error; non-zero otherwise

   INTEGER(B2Ki)                 :: Com    (NumCTy)                           ! Temporary array to hold component's integer values for a given Z.
   INTEGER                       :: IY                                        ! A DO index for indexing the arrays in the y direction.
   INTEGER                       :: IYK                                       ! An index for the decimated arrays in the y direction.
   INTEGER                       :: IZ                                        ! A DO index for indexing the arrays in the z direction.
   INTEGER                       :: IZK                                       ! An index for the decimated arrays in the z direction.



   !-------------------------------------------------------------------------------------------------
   ! Open the input file
   !-------------------------------------------------------------------------------------------------

   CALL OpenUInBEFile( UnWind, TRIM(FileName), 2*NumCTy, ErrStat )
   IF (ErrStat /= 0) RETURN


   !-------------------------------------------------------------------------------------------------
   ! Read the data and fill the arrays
   !-------------------------------------------------------------------------------------------------
      
   IZK = 0                          ! the Z index into the array (necessary b/c of decimation factor)
   DO IZ=1,NumCTz,CT_DF_Z

      READ (UnWind,REC=IZ,IOSTAT=ErrStat)  Com

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Error reading record '//TRIM( Num2LStr( IZ ) )//' of the binary CT wind file, "' &
                           //TRIM( FileName )//'."')
         RETURN                           

      ENDIF

      IZK = IZK + 1
      IYK = 0                       ! the Y index into the array (necessary b/c of decimation factor)
      
      DO IY=1,NumCTy,CT_DF_Y
         IYK = IYK + 1
         Vel(IYK,IZK,ITime) = CTScale(IComp)*Com(IY) + CTOffset(IComp)
      ENDDO ! IY

   ENDDO ! IZ


   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
      CLOSE ( UnWind )

   RETURN


END SUBROUTINE LoadCTData
!====================================================================================================
SUBROUTINE ReadCTP( UnWind, FileName, CTPscaling, ErrStat )
!  This function is used to read the input parameters for the coherent turbulence events, 
!  based on the large-eddy simulation.
!----------------------------------------------------------------------------------------------------


      ! Passed variables.

   INTEGER,            INTENT(IN)  :: UnWind                                   ! The I/O unit of the input file
   CHARACTER(*),       INTENT(IN)  :: FileName                                 ! The name of the input data file
   TYPE(CTWindFiles),  INTENT(OUT) :: CTPscaling                               ! The file names contained in the CTP file
   INTEGER,            INTENT(OUT) :: ErrStat                                  ! returns 0 if no error; non-zero otherwise


      ! Local variables.
      
   CHARACTER(1024)                 :: HeaderLine                               ! The header text in the file
   CHARACTER(1024)                 :: TmpPath

   !-------------------------------------------------------------------------------------------------
   ! Open the CTP input file
   !-------------------------------------------------------------------------------------------------
   
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) RETURN


   !-------------------------------------------------------------------------------------------------
   ! Read the CTP input file
   !-------------------------------------------------------------------------------------------------
   CALL ReadStr( UnWind, TRIM( FileName ), HeaderLine, 'Header line', 'The header line in the CTP file', ErrStat )
   IF (ErrStat /= 0) RETURN   
   CALL WrScr ( ' Heading of the CT-wind-parameter file: "'//TRIM(HeaderLine)//'"' )


   CALL ReadCom( UnWind, TRIM( FileName ), 'parameter header line', ErrStat )
   IF (ErrStat /= 0) RETURN
   

   CALL ReadVar( UnWind, TRIM( FileName ), CTSpath,  'CTSpath',  & 
                  'Location (path) of the binary coherent turbulence dataset', ErrStat )
   IF (ErrStat /= 0) RETURN
                  

   CALL ReadVar( UnWind, TRIM( FileName ), CTPscaling%CTTSfile, 'CTTSfile', &
                  'File containing the time steps for the coherent turbulence events (.cts)', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   
   IF ( PathIsRelative( CTPscaling%CTTSfile ) ) THEN
      CALL GetPath( FileName, TmpPath ) 
      CTPscaling%CTTSfile = TRIM(TmpPath)//TRIM(CTPscaling%CTTSfile)
   END IF      

   CALL ReadVar( UnWind, TRIM( FileName ), CTPscaling%CTbackgr, 'CTbackgr', 'File containing the background wind', ErrStat )
   IF (ErrStat /= 0) RETURN

   IF ( PathIsRelative( CTPscaling%CTbackgr ) ) THEN
      CALL GetPath( FileName, TmpPath ) 
      CTPscaling%CTbackgr = TRIM(TmpPath)//TRIM(CTPscaling%CTbackgr)
   END IF      


   CALL ReadVar( UnWind, TRIM( FileName ), CT_DF_Y, 'CT_DF_Y', 'Decimation factor for wind data in the Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CT_DF_Z, 'CT_DF_Z', 'Decimation factor for wind data in the Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN

   
   !-------------------------------------------------------------------------------------------------
   ! Close the CTP input file
   !-------------------------------------------------------------------------------------------------
   
   CLOSE( UnWind )


END SUBROUTINE ReadCTP
!====================================================================================================
SUBROUTINE ReadCTTS ( UnWind, FileName, CT_SC_ext, ErrStat )
!  This subroutine is used to read the input parameters calculated in TurbSim for the scaling of 
!  coherent turbulence events.  It reads the .cts file and saves the time step and file number arrays.
!----------------------------------------------------------------------------------------------------


      ! Passed variables.

   INTEGER,            INTENT(IN)  :: UnWind                                   ! The I/O unit of the input file
   CHARACTER(*),       INTENT(IN)  :: FileName                                 ! The name of the input data file
   INTEGER,            INTENT(OUT) :: ErrStat                                  ! returns 0 if no error; -1 if the file is blank or can't be opened;                                                                               ! non-zero otherwise
   CHARACTER(3),       INTENT(OUT) :: CT_SC_ext                                ! The extension used for coherent turbulence scale files.(usually "les", "dns", or "dat")

      ! Local variables
   INTEGER                         :: IT                                       ! Loop counter

   !-------------------------------------------------------------------------------------------------
   ! Initialize variables
   !-------------------------------------------------------------------------------------------------

   NumCTt = 0

   !-------------------------------------------------------------------------------------------------
   ! Open the CTS input file
   !-------------------------------------------------------------------------------------------------
   
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) THEN
      ErrStat = -1
      RETURN
   END IF
   
   !-------------------------------------------------------------------------------------------------
   ! Read the header of the CTS input file
   !-------------------------------------------------------------------------------------------------
   
      ! Check to see if the first value is numeric (old) or the file type (new) and start again
      
   READ ( UnWind, *, IOSTAT=ErrStat ) CTScaleVel       
   REWIND( UnWind )  


   IF ( ErrStat /= 0 )  THEN   ! try again
            
      CALL ReadVar( UnWind, TRIM( FileName ), CText, 'CText', 'FileType ', ErrStat ) 
      IF ( ErrStat /= 0 ) THEN
         ErrStat = SIGN( 1, ErrStat)
         RETURN
      END IF
      CT_SC_ext = CText      
      
      CALL ReadVar( UnWind, TRIM( FileName ), CTScaleVel, 'CTScaleVel', ' ', ErrStat ) 
      IF ( ErrStat /= 0 ) RETURN
   ELSE  ! assume LES files
   
      CALL ReadVar( UnWind, TRIM( FileName ), CTScaleVel, 'CTScaleVel', ' ', ErrStat ) 

      CText     = 'les'
      CT_SC_ext = 'dat'
   END IF
   
   CALL ReadVar( UnWind, TRIM( FileName ), InvMCTWS, 'MeanCTWS', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   InvMCTWS = 1.0 / InvMCTWS
      

   CALL ReadVar( UnWind, TRIM( FileName ), CTYmax, 'CTYmax', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   

   CALL ReadVar( UnWind, TRIM( FileName ), CTZmax, 'CTZmax', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CTDistSc, 'CTDistSc', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CTLy, 'CTLy', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   
   
   CALL ReadVar( UnWind, TRIM( FileName ), CTLz, 'CTLz', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN
   
   
   CALL ReadVar( UnWind, TRIM( FileName ), NumCTt, 'NumCTt', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   !-------------------------------------------------------------------------------------------------
   ! Allocate space for the arrays
   !-------------------------------------------------------------------------------------------------

   IF (.NOT. ALLOCATED(Tdata) ) THEN
      ALLOCATE ( Tdata(NumCTt) , STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the Tdata array.' )
         RETURN
      END IF
   END IF

   IF (.NOT. ALLOCATED(TimeStpCT) ) THEN
      ALLOCATE ( TimeStpCT(NumCTt) , STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the TimeStpCT array.' )
         RETURN
      END IF
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Read the arrays from the CTS input file
   !-------------------------------------------------------------------------------------------------
   
   DO IT=1,NumCTt

      READ (UnWind,*,IOSTAT=ErrStat)  Tdata(IT), TimeStpCT(IT)

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error reading record '//TRIM( Num2LStr( IT ) )//' of the CT-wind time-steps file, "' &
                         //TRIM( FileName )//'."')

         NumCTt = IT - 1
         RETURN
      ENDIF

   ENDDO ! IT


   !-------------------------------------------------------------------------------------------------
   ! Close the CTS input file
   !-------------------------------------------------------------------------------------------------
   CLOSE( UnWind )


   RETURN
   
END SUBROUTINE ReadCTTS
!====================================================================================================
SUBROUTINE ReadCTScales ( UnWind, FileName, ErrStat )
!  This subroutine is used to read the input parameters for the coherent turbulence events, based
!  on the large-eddy simulation.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,            INTENT(IN)  :: UnWind                                   ! The I/O unit of the input file
   CHARACTER(*),       INTENT(IN)  :: FileName                                 ! The name of the input data file
   INTEGER,            INTENT(OUT) :: ErrStat                                  ! returns 0 if no error; non-zero otherwise


      ! Local variables
      
   INTEGER                         :: I                                        ! Array counter

   !-------------------------------------------------------------------------------------------------
   ! Open the file with the scales (les or dns)
   !-------------------------------------------------------------------------------------------------

   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) RETURN
   

   !-------------------------------------------------------------------------------------------------
   ! Read the file with the scales (les or dns)
   !-------------------------------------------------------------------------------------------------

   CALL ReadCom( UnWind, TRIM( FileName ), 'First line', ErrStat )
   IF (ErrStat /= 0) RETURN

   CALL ReadVar( UnWind, TRIM( FileName ), CTVertShft, 'CTVertShft', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN

   DO I = 1,3
      CALL ReadVar( UnWind, TRIM( FileName ), CTScale(I), 'CTScale('//TRIM(Num2LStr(I))//')', ' ', ErrStat ) 
      IF ( ErrStat /= 0 )  RETURN
   
      CALL ReadVar( UnWind, TRIM( FileName ), CTOffset(I), 'CTOffset('//TRIM(Num2LStr(I))//')', ' ', ErrStat ) 
      IF ( ErrStat /= 0 )  RETURN
   END DO !I

   CALL ReadVar( UnWind, TRIM( FileName ), NumCTy, 'NumCTy', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN

   CALL ReadVar( UnWind, TRIM( FileName ), NumCTz, 'NumCTz', ' ', ErrStat ) 
   IF ( ErrStat /= 0 )  RETURN


   !-------------------------------------------------------------------------------------------------
   ! Close the file with the scales (les or dns)
   !-------------------------------------------------------------------------------------------------
   
   CLOSE( UnWind )
   

   RETURN
   
END SUBROUTINE ReadCTScales
!====================================================================================================
SUBROUTINE CT_Terminate( ErrStat )
! This subroutine closes files, deallocates memory, and un-sets the initialization flag
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise


   CLOSE( CTWindUnit )
   
   ErrStat = 0

   IF ( ALLOCATED( CTvelU    ) )  DEALLOCATE( CTvelU,    STAT=ErrStat )
   IF ( ALLOCATED( CTvelV    ) )  DEALLOCATE( CTvelV,    STAT=ErrStat )
   IF ( ALLOCATED( CTvelW    ) )  DEALLOCATE( CTvelW,    STAT=ErrStat )
   IF ( ALLOCATED( Tdata     ) )  DEALLOCATE( Tdata,     STAT=ErrStat )
   IF ( ALLOCATED( TimeStpCT ) )  DEALLOCATE( TimeStpCT, STAT=ErrStat )

   TimeIndx = 0

END SUBROUTINE CT_Terminate
!====================================================================================================
END MODULE CTWind
MODULE FDWind
! This module reads and processes 4-dimensional wind fields.
! The subroutines were originally created by Marshall Buhl to read LES data provided by researchers
! at NCAR. It was later updated by Bonnie Jonkman to read DNS data provided by researchers at CoRA.
!
! Data are assumed to be in units of meters and seconds.
!
!  7 Oct 2009    B. Jonkman, NREL/NWTC using subroutines from AeroDyn 12.57
!----------------------------------------------------------------------------------------------------  

    USE                     NWTC_Library
    USE                     SharedInflowDefns

    IMPLICIT                NONE
   PRIVATE
  
      ! FD_Wind
      
   REAL(ReKi)                   :: DelXgrid                                   ! The nondimensional distance between grid points in the x direction.
   REAL(ReKi)                   :: DelYgrid                                   ! The nondimensional distance between grid points in the y direction.
   REAL(ReKi)                   :: DelZgrid                                   ! The nondimensional distance between grid points in the z direction.
   REAL(ReKi)                   :: FDper                                      ! Total time in dataset.
   REAL(ReKi)                   :: FDTime   (2)                               ! Times for the 4D wind files.
   REAL(ReKi), ALLOCATABLE      :: FDu      (:,:,:,:)                         ! The u-component array of 4D wind data.
   REAL(ReKi), ALLOCATABLE      :: FDv      (:,:,:,:)                         ! The v-component array of 4D wind data.
   REAL(ReKi), ALLOCATABLE      :: FDw      (:,:,:,:)                         ! The w-component array of 4D wind data.
   REAL(ReKi), ALLOCATABLE      :: FDuData  (:,:,:,:)                         ! The u-component array of all 4D wind data when used with advection.
   REAL(ReKi), ALLOCATABLE      :: FDvData  (:,:,:,:)                         ! The v-component array of all 4D wind data when used with advection.
   REAL(ReKi), ALLOCATABLE      :: FDwData  (:,:,:,:)                         ! The w-component array of all 4D wind data when used with advection.
   REAL(ReKi)                   :: Lx                                         ! Fractional location of tower centerline from upwind end to downwind end of the dataset.
   REAL(ReKi)                   :: Ly                                         ! Fractional location of tower centerline from right (looking downwind) to left side of the dataset.
   REAL(ReKi)                   :: Lz                                         ! Fractional location of hub height from bottom to top of dataset.
   REAL(ReKi)                   :: Offsets  (3)                               ! Offsets to convert integer data to actual wind speeds.
   REAL(ReKi), SAVE             :: PrevTime                                   ! The previous time this was called -- so we can go back in time if necessary
   REAL(ReKi)                   :: RotDiam                                    ! Rotor diameter.
   REAL(ReKi)                   :: ScalFact (3)                               ! Scaling factors to convert integer data to actual wind speeds.
   REAL(ReKi)                   :: ScaleVel                                   ! Scaling velocity, U0.  2*U0 is the difference in wind speed between the top and bottom of the wave.
   REAL(ReKi), ALLOCATABLE      :: Times4D  (:)                               ! The list of times for the 4D-wind input files.
   REAL(ReKi)                   :: Tm_max                                     ! The total nondimensional time of the dataset.
   REAL(ReKi)                   :: TSclFact                                   ! Scale factor for time (h/U0).
   REAL(ReKi)                   :: T_4D_En                                    ! Time at which the wave event ends.
   REAL(ReKi)                   :: T_4D_St                                    ! Time at which the wave event starts.
   REAL(ReKi)                   :: Xmax                                       ! The dimensional downwind length of the dataset.
   REAL(ReKi)                   :: Xt                                         ! Distance of the tower from the upwind end of the dataset.
   REAL(ReKi)                   :: Ymax                                       ! The dimensional lateral width of the dataset.
   REAL(ReKi)                   :: Yt                                         ! Distance of the tower from the right side of the dataset (looking downwind).
   REAL(ReKi)                   :: Zmax                                       ! The dimensional vertical height of the dataset.
   REAL(ReKi)                   :: Zt                                         ! Distance of the hub from the bottom of the dataset.
   REAL(ReKi)                   :: Zref                                       ! The reference height (hub height)

   INTEGER                      :: FD_DF_X                                    ! The decimation factor for the 4D wind data in the x direction.
   INTEGER                      :: FD_DF_Y                                    ! The decimation factor for the 4D wind data in the y direction.
   INTEGER                      :: FD_DF_Z                                    ! The decimation factor for the 4D wind data in the z direction.
   INTEGER                      :: FDFileNo                                   ! The 4D wind file number.
   INTEGER                      :: FDRecL                                     ! The length, in bytes, of the LE binary records.
   INTEGER                      :: Ind4DAdv                                   ! Index of the file to be used in advection
   INTEGER                      :: Ind4Dnew                                   ! Index of the newest 4D wind file.
   INTEGER                      :: Ind4Dold                                   ! Index of the older 4D wind file.
   INTEGER                      :: Num4Dt                                     ! The number of 4D wind grids, one grid per time step.
   INTEGER, PARAMETER           :: Num4DtD = 2                                ! The number of 4D wind grids stored in memory, normally 2
   INTEGER                      :: Num4Dx                                     ! The number of 4D wind grid points in the x direction.
   INTEGER                      :: Num4DxD                                    ! The decimated number of 4D wind grid points in the x direction.
   INTEGER                      :: Num4DxD1                                   ! The decimated number of 4D wind grid points in the x direction minus 1.
   INTEGER                      :: Num4Dy                                     ! The number of 4D wind grid points in the y direction.
   INTEGER                      :: Num4DyD                                    ! The decimated number of 4D wind grid points in the y direction.
   INTEGER                      :: Num4DyD1                                   ! The decimated number of 4D wind grid points in the y direction minus 1.
   INTEGER                      :: Num4Dz                                     ! The number of 4D wind grid points in the z direction.
   INTEGER                      :: Num4DzD                                    ! The decimated number of 4D wind grid points in the z direction.
   INTEGER                      :: Num4DzD1                                   ! The decimated number of 4D wind grid points in the z direction minus 1.
   INTEGER                      :: NumAdvect                                  ! Number of frozen timesteps to advect past the turbine
   INTEGER                      :: Shft4Dnew                                  ! Number of times the x-data needs to be shifted for advection
   INTEGER, ALLOCATABLE         :: Times4DIx (:)                              ! Index number of the 4D time files (used for advection)

   INTEGER                      :: FDUnit                                     ! Unit number for reading wind files

   LOGICAL                      :: Advect                                     ! Flag to indicate whether or not to advect a given data set or to just use the time step files 
   LOGICAL                      :: VertShft                                   ! Flag to indicate whether or not to shift the z values for the w component.

   LOGICAL, SAVE                :: Initialized = .FALSE.

   CHARACTER(5), ALLOCATABLE    :: AdvFiles (:)
   CHARACTER(1024)              :: FDSpath                                    ! The path to the 4D wind files.


   PUBLIC                       :: FD_Init
   PUBLIC                       :: FD_GetWindSpeed
   PUBLIC                       :: FD_Terminate
   PUBLIC                       :: FD_GetValue


CONTAINS
!====================================================================================================
SUBROUTINE FD_Init(UnWind, WindFile, RefHt, ErrStat)
!  This subroutine is called at the beginning of a simulation to initialize the module.  
!----------------------------------------------------------------------------------------------------

      ! Passed variables
      
   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: WindFile                     ! Name of the 4D wind parameter file (.fdp)
   REAL(ReKi),      INTENT(IN)    :: RefHt                        ! The reference height for the billow (should be hub height)
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors; non-zero otherwise

      ! Local variables

   CHARACTER(1024)                :: FDTSfile                     ! name of the 4D time step file
   REAL(ReKi)                     :: FDTimStp                     ! Average time step for 4D wind data.
   INTEGER                        :: IT
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' FDWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Set the reference height for the wind file (this takes the place of HH that was used earlier)
   !-------------------------------------------------------------------------------------------------

   ZRef = RefHt         
   
   !-------------------------------------------------------------------------------------------------
   ! Read the main 4D input file
   !-------------------------------------------------------------------------------------------------
   
   CALL ReadFDP( UnWind, WindFile, FDTSfile, ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   !-------------------------------------------------------------------------------------------------
   ! Get the times array, which must be scaled and shifted later using TSclFact and T_4D_St
   !-------------------------------------------------------------------------------------------------

   CALL Read4Dtimes ( UnWind, FDTSfile, ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   
   !-------------------------------------------------------------------------------------------------
   ! Calculate some values that don't change during the run.
   !-------------------------------------------------------------------------------------------------

   FDRecL      = 2*Num4Dx*Num4Dy                                           ! The length, in bytes, of the 4D binary records.
   Num4DxD     = ( Num4Dx + FD_DF_X - 1 )/FD_DF_X                          ! The decimated number of 4D wind grid points in the x direction.
   Num4DyD     = ( Num4Dy + FD_DF_Y - 1 )/FD_DF_Y                          ! The decimated number of 4D wind grid points in the y direction.
   Num4DzD     = ( Num4Dz + FD_DF_Z - 1 )/FD_DF_Z                          ! The decimated number of 4D wind grid points in the z direction.
   Num4DxD1    = Num4DxD - 1                                               ! The decimated number of 4D wind grid points in the x direction minus 1.
   Num4DyD1    = Num4DyD - 1                                               ! The decimated number of 4D wind grid points in the y direction minus 1.
   Num4DzD1    = Num4DzD - 1                                               ! The decimated number of 4D wind grid points in the z direction minus 1.

   Tm_max      = Times4D(Num4Dt)                                           ! Time of end of dataset.
   IF ( ADVECT ) THEN
      FDTimStp   = Xmax / ( ( Num4Dx - 1 )*( ScaleVel )*Num4Dt )           ! The timestep is calculated by the approximation dx/dt ~= U0 (divide by num4dt to get delta for a full timestep).
      FDper      = FDTimStp * Num4Dt                                       ! Total time in dataset. (We have periodic time, so multiply by number of time steps, without subtracting 1)
      TSclFact   = FDper / Tm_max                                          ! Equivalent scale factor for time.
   ELSE
      FDper       = TSclFact*Tm_max                                        ! Total time in dataset.
      FDTimStp    = FDper/( Num4Dt - 1 )                                   ! Average time step.
   ENDIF

   T_4D_En     = T_4D_St + FDper                                           ! Time for the end of the dataset.
   Xt          = Xmax*Lx                                                   ! Distance of the tower from the upwind end of the dataset.
   Yt          = Ymax*Ly                                                   ! Distance of the tower from the right side of the dataset (looking downwind).
   Zt          = Zmax*Lz                                                   ! Distance of the hub from the bottom of the dataset.
   DelXgrid    = 1.0/Num4DxD1                                              ! The nondimensional distance between grid points in the x direction.
   DelYgrid    = 1.0/Num4DyD1                                              ! The nondimensional distance between grid points in the y direction.
   DelZgrid    = 1.0/Num4DzD1                                              ! The nondimensional distance between grid points in the z direction.


   !-------------------------------------------------------------------------------------------------
   ! Scale and shift the times array using TSclFact and T_4D_St
   !-------------------------------------------------------------------------------------------------

   DO IT=1,Num4Dt
      
      Times4D(IT) = TSclFact*Times4D(IT) + T_4D_St

   ENDDO ! IT


   !-------------------------------------------------------------------------------------------------
   ! Allocate velocity arrays and fill Data arrays for advection (DNS files)
   !-------------------------------------------------------------------------------------------------

   IF (.NOT. ALLOCATED(FDu) ) THEN
!      CALL AllocAry ( FDu, Num4DxD, Num4DyD, Num4DzD, 2, 'U-component velocity array (FDu)', ErrStat)
      ALLOCATE ( FDu(Num4DxD,Num4DyD,Num4DzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the U-component velocity array (FDu) array.' )
         RETURN
      END IF
   END IF
   
   IF (.NOT. ALLOCATED(FDv) ) THEN
!      CALL AllocAry ( FDv, Num4DxD, Num4DyD, Num4DzD, 2, 'V-component velocity array (FDv)', ErrStat)
      ALLOCATE ( FDv(Num4DxD,Num4DyD,Num4DzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the V-component velocity array (FDv) array.' )
         RETURN
      END IF
   END IF

   IF (.NOT. ALLOCATED(FDw) ) THEN
!      CALL AllocAry ( FDw, Num4DxD, Num4DyD, Num4DzD, 2, 'W-component velocity array (FDw)', ErrStat)
      ALLOCATE ( FDw(Num4DxD,Num4DyD,Num4DzD,2), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the W-component velocity array (FDw) array.' )
         RETURN
      END IF
   END IF

   IF ( ADVECT ) THEN

      IF (.NOT. ALLOCATED(FDuData) ) THEN
!         CALL AllocAry ( FDuData, Num4DxD, Num4DyD, Num4DzD, Num4Dt, 'U-component velocity array (FDuData)', ErrStat)
         ALLOCATE ( FDuData(Num4DxD,Num4DyD,Num4DzD,Num4Dt), STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error allocating memory for the U-component velocity array (FDuData) array.' )
            RETURN
         END IF
      END IF

      IF (.NOT. ALLOCATED(FDvData) ) THEN
!         CALL AllocAry ( FDvData, Num4DxD, Num4DyD, Num4DzD, Num4Dt, 'V-component velocity array (FDvData)', ErrStat)
         ALLOCATE ( FDvData(Num4DxD,Num4DyD,Num4DzD,Num4Dt), STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error allocating memory for the V-component velocity array (FDvData) array.' )
            RETURN
         END IF
      END IF

      IF (.NOT. ALLOCATED(FDwData) ) THEN
!         CALL AllocAry ( FDwData, Num4DxD, Num4DyD, Num4DzD, Num4Dt, 'W-component velocity array (FDwData)', ErrStat)
         ALLOCATE ( FDwData(Num4DxD,Num4DyD,Num4DzD,Num4Dt), STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error allocating memory for the W-component velocity array (FDwData) array.' )
            RETURN
         END IF
      END IF

      CALL ReadAll4DData(UnWind, ErrStat) !This needs AdvFiles(:), which was is read in ReadFDP()
      IF ( ErrStat /= 0 ) RETURN

   ENDIF

     
   !-------------------------------------------------------------------------------------------------
   ! Determine the first file needed for this simulation.
   !-------------------------------------------------------------------------------------------------
   Ind4Dold  = 1                                                           ! Put the old stuff in the first part of the array.
   Ind4Dnew  = 2                                                           ! Put the new stuff in the second part of the array.

   Shft4Dnew = 0


   IF ( T_4D_St >= 0.0 )  THEN
      FDFileNo = 1
   ELSE
      FDFileNo = Num4Dt
      DO IT=1,Num4Dt
         IF ( Times4D(IT) > 0.0 )  THEN
            FDFileNo = IT - 1
            EXIT
         END IF
      END DO ! IT
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Open, read, and close the first set of files.
   !-------------------------------------------------------------------------------------------------
   FDTime(Ind4Dold) = Times4D(FDFileNo)                                 ! Set the time for this file.

   IF ( ADVECT ) THEN
      CALL Load4DData(Ind4Dold)     ! load data stored in FDuData, FDvData, and FDwData arrays
   ELSE
      CALL LoadLESData( UnWind, FDFileNo, Ind4Dold, ErrStat )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Open, read, and close the second set of files.
   !-------------------------------------------------------------------------------------------------
   FDFileNo  = FDFileNo + 1


   IF ( ADVECT ) THEN
      FDFileNo = MOD(FDFileNo-1,Num4Dt) + 1

      IF (FDFileNo == 1) THEN
         Shft4Dnew = Shft4Dnew + 1

         IF (Ind4DAdv <= NumAdvect) THEN                             ! Ind4DAdv was set in ReadFDP
            IF ( MOD( Shft4Dnew, Num4Dx ) == 0 ) THEN
               CALL ReadAll4DData(UnWind, ErrStat)
               IF ( ErrStat /= 0 ) RETURN
            END IF
         END IF

      ENDIF

      FDTime(Ind4Dnew) = Times4D(FDFileNo) + Shft4Dnew*FDPer         ! Set the time for this file.

      CALL Load4DData( Ind4Dnew )    ! shift the data

   ELSE   
      FDTime(Ind4Dnew) = Times4D(FDFileNo)                                           ! Set the time for this file.

      CALL LoadLESData( UnWind, FDFileNo, Ind4Dnew, ErrStat )
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Set the initialization flag
   !-------------------------------------------------------------------------------------------------
   FDUnit      = UnWind
   PrevTime    = 0.0
   
   Initialized = .TRUE.
   
   RETURN

END SUBROUTINE FD_Init
!====================================================================================================
SUBROUTINE ReadFDP ( UnWind, FileName, FDTSfile, ErrStat )
!  This subroutine is used to read the input parameters for the large-eddy simulation.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: FileName                     ! Then name of the LE data file.
   CHARACTER(*),    INTENT(OUT)   :: FDTSfile                     ! The name of the file containing the time-step history of the wind files.
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise


      ! Local variables

   CHARACTER(1024)                :: HeaderLine
   CHARACTER(1),PARAMETER         :: Comp(3) = (/'U', 'V', 'W' /) ! the wind components

   REAL(ReKi)                     :: CoefTE                       ! Coefficient of thermal expansion.
   REAL(ReKi)                     :: DistScal                     ! Disturbance scale (ratio of wave height to rotor diameter) from input file.
   REAL(ReKi)                     :: Grav                         ! Gravitational acceleration.
   REAL(ReKi)                     :: LenScale                     ! Length scale (h).
   REAL(ReKi)                     :: Ri                           ! Richardson number.
   REAL(ReKi)                     :: Ubot                         ! Steady u-component wind speed at the bottom of the wave.
   REAL(ReKi)                     :: Zm_maxo                      ! The nondimensional vertical height of the untrimmed dataset.

   REAL(ReKi)                     :: Xm_max                       ! The nondimensional downwind length of the dataset.
   REAL(ReKi)                     :: Ym_max                       ! The nondimensional lateral width of the dataset.
   REAL(ReKi)                     :: Zm_max                       ! The nondimensional vertical height of the dataset.

   INTEGER                        :: I

   !-------------------------------------------------------------------------------------------------
   ! Open the 4D parameter file for reading
   !-------------------------------------------------------------------------------------------------
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF (ErrStat /= 0) RETURN   


   !-------------------------------------------------------------------------------------------------
   ! Read the 4D parameter input file
   !-------------------------------------------------------------------------------------------------

      !..............................................................................................
      ! Read the 4D wind parameters specific to this turbine simulation.  
      !..............................................................................................

   CALL ReadStr( UnWind, TRIM( FileName ), HeaderLine, 'Header line', 'The header line in the FTP file', ErrStat )
   IF (ErrStat /= 0) RETURN   
   CALL WrScr ( ' Heading of the 4D-wind-parameter file: "'//TRIM(HeaderLine)//'"' )


   CALL ReadCom( UnWind, TRIM( FileName ), 'Header line', ErrStat )
   IF (ErrStat /= 0) RETURN
      

   CALL ReadVar( UnWind, TRIM( FileName ), FDSpath,  'FDSpath', 'Location (path) of the binary dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FDTSfile,  'FDTSfile', & 
                                  'Name of the file containing the time-step history of the wind files', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ubot,  'Ubot', 'Steady u-component wind speed at the bottom of the wave', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), DistScal,  'DistScal', 'Disturbance scale', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Lx,  'Lx', &
                            'Fractional location of tower centerline from upwind end to downwind end of the dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ly,  'Ly', &
                 'Fractional location of tower centerline from right (looking downwind) to left side of the dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Lz,  'Lz', &
                                          'Fractional location of hub height from bottom to top of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), T_4D_St,  'T_4D_St', 'Time at which the wave event starts', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), ScaleVel,  'ScaleVel', &
                 'Scaling velocity, U0: half the difference in wind speed between the top and bottom of the billow.', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), RotDiam,  'RotDiam', 'Rotor diameter', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FD_DF_X,  'FD_DF_X', 'Decimation factor in X direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FD_DF_Y,  'FD_DF_Y', 'Decimation factor in Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), FD_DF_Z,  'FD_DF_Z', 'Decimation factor in Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadCom( UnWind, TRIM( FileName ), 'blank line', ErrStat )
   IF (ErrStat /= 0) RETURN

      !..............................................................................................
      ! Read the 4D wind parameters specific to the K-H billow simulation being used.  
      !..............................................................................................

   CALL ReadCom( UnWind, TRIM( FileName ), 'LES parameters specific to the K-H billow simulation being used', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), VertShft,  'VertShft', & 
                           'Flag to indicate whether or not to shift the z values for the w component', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Xm_max,  'Xm_max', & 
                           'Maximum nondimensional downwind distance from center of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ym_max,  'Ym_max', & 
                           'Maximum nondimensional lateral distance from center of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Zm_max,  'Zm_max', & 
                           'Maximum nondimensional vertical distance from center of dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Zm_maxo,  'Zm_maxo', & 
                 'Maximum nondimensional vertical distance from center of untrimmed dataset', ErrStat )
   IF (ErrStat /= 0) RETURN


   DO I = 1,3

      CALL ReadVar( UnWind, TRIM( FileName ), ScalFact(I),  Comp(I)//'Scl', & 
                    Comp(I)//'-component scale factor for converting from integers to reals', ErrStat )
      IF (ErrStat /= 0) RETURN
      ScalFact(I) = ScalFact(I) * ScaleVel


      CALL ReadVar( UnWind, TRIM( FileName ), Offsets(I), Comp(I)//'Off', & 
                    Comp(I)//'-component offset for converting from integers to reals', ErrStat )
      IF (ErrStat /= 0) RETURN
      Offsets(I) = Offsets(I) * ScaleVel
      
   END DO   
   Offsets (1) = Offsets (1) + ScaleVel + Ubot                           ! u-component offset to convert integer data to actual wind speeds.


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dt, 'Num4Dt', 'The number of LE grids, one grid per time step', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dx, 'Num4Dx', 'The number of LE grid points in the x direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dy, 'Num4Dy', 'The number of LE grid points in the y direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Num4Dz, 'Num4Dz', 'The number of LE grid points in the z direction', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Ri, 'Ri', 'Richardson number', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), CoefTE, 'CoefTE', 'Coefficient of thermal expansion', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Grav, 'Grav', 'Gravitational acceleration', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, TRIM( FileName ), Advect, 'Advect', 'Advection flag', ErrStat )
   
   IF (ErrStat /= 0) THEN
   
      Advect   = .FALSE.
      Ind4DAdv = 0
      ErrStat  = 0
      CALL WrScr( ' Advection will not be used.')
      
   ELSE
   
      IF (Advect) THEN
         IF ( FD_DF_X /= 1 ) THEN
            CALL WrScr( ' FD_DF_X must be 1 when using advection. ' )
            FD_DF_X = 1            
         ENDIF

         CALL ReadVar( UnWind, TRIM( FileName ), NumAdvect, 'NumAdvect', 'Number of 4D files for advection', ErrStat )
         IF (ErrStat /= 0) RETURN
         

         IF ( NumAdvect < 1 ) THEN
            CALL WrScr( ' NumAdvect in 4D-wind-parameter file, "'//TRIM( FileName )//'," must be at least 1.' )
            ErrStat = 1
            RETURN
         ENDIF

         IF ( .NOT. ALLOCATED( AdvFiles ) ) THEN
!            CALL AllocAry( AdvFiles, NumAdvect, 'AdvFiles array', ErrStat )
            ALLOCATE ( AdvFiles(NumAdvect), STAT=ErrStat )

            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error allocating memory for the AdvFiles array.' )
               RETURN
            END IF
         ENDIF

         CALL ReadAryLines( UnWind, TRIM( FileName ), AdvFiles, NumAdvect, 'AdvFiles', 'Advection file names', ErrStat )
         IF (ErrStat /= 0) RETURN
         Ind4DAdv = 1
         
      ELSE
         Ind4DAdv = 0
      ENDIF !Advect == .TRUE.
   
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Close the 4D parameter input file
   !-------------------------------------------------------------------------------------------------
   CLOSE ( UnWind )
   
   !-------------------------------------------------------------------------------------------------
   ! Close the 4D parameter input file
   !-------------------------------------------------------------------------------------------------

   LenScale    = RotDiam*DistScal/Zm_max                             ! Length scale (h).
   Xmax        = Xm_max*LenScale                                     ! The dimensional length of the dataset.
   Ymax        = Ym_max*LenScale                                     ! The dimensional width of the dataset
   Zmax        = Zm_max*LenScale                                     ! The dimensional vertical height of the dataset.
   TSclFact    = LenScale/ScaleVel                                   ! Scale factor for time (h/U0).

   

   RETURN

END SUBROUTINE ReadFDP
!====================================================================================================
SUBROUTINE Read4Dtimes ( UnWind, FileName, ErrStat )
!  This subroutine is used to read the time array for the 4D data.  The times in the file are 
!  non-dimensional and non-uniformly spaced. They are scaled using TSclFact to obtain units of seconds
!  and T_4D_St is added to allow the billow to start at non-zero time.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   CHARACTER(*),    INTENT(IN)    :: FileName                     ! Then name of the LE data file.
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise


      ! Local variables

   INTEGER                        :: I                            ! Loop counter

   !-------------------------------------------------------------------------------------------------
   ! Allocate arrays to store the data in
   !-------------------------------------------------------------------------------------------------
   
   IF (.NOT. ALLOCATED( Times4D) ) THEN
!      CALL AllocAry( Times4D, Num4Dt, '4D time array', ErrStat)
      ALLOCATE ( Times4D(Num4Dt), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the Times4D array.' )
         RETURN
      END IF
   END IF
      
   IF (.NOT. ALLOCATED( Times4DIx) ) THEN
!      CALL AllocAry( Times4DIx, Num4Dt, '4D time array', ErrStat)
      ALLOCATE ( Times4DIx(Num4Dt), STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN
         CALL WrScr ( ' Error allocating memory for the Times4DIx array.' )
         RETURN
      END IF
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Open the 4D times file
   !-------------------------------------------------------------------------------------------------
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   !-------------------------------------------------------------------------------------------------
   ! Read the 4D times file
   !-------------------------------------------------------------------------------------------------
   CALL ReadCom( UnWind, TRIM( FileName ), 'first line', ErrStat)
   IF ( ErrStat /= 0 ) RETURN

   DO I=1,Num4Dt

      READ (UnWind,*,IOSTAT=ErrStat)  Times4DIx(I), Times4D(I)

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Error reading line '//TRIM( Num2LStr( I+1 ) )// &
                        ' of the 4D-wind time-steps file, "'//TRIM( FileName )//'."')
         RETURN                        

      ENDIF
      
   ENDDO ! I

   
   !-------------------------------------------------------------------------------------------------
   ! Close the 4D times file
   !-------------------------------------------------------------------------------------------------
   
   CLOSE ( UnWind )  
   
   RETURN     
   
END SUBROUTINE Read4Dtimes
!====================================================================================================
SUBROUTINE ReadAll4DData(UnWind, ErrStat)
! This subroutine reads the data into one array to be accessed later when ADVECT=.TRUE. Since there 
! are just a few time steps, we'll load them into memory to (hopefully) save I/O time.
!----------------------------------------------------------------------------------------------------

   INTEGER, INTENT(IN)        :: UnWind
   INTEGER, INTENT(OUT)       :: ErrStat                            ! 
   INTEGER                    :: IT

   CHARACTER(1)               :: FDNum
   CHARACTER(20)              :: DNSFileName                        ! String containing part of the current file name.


   DO IT = 1,Num4Dt

      WRITE(FDNum,'(I1.1)') Times4DIx(IT)
      DNSFileName = TRIM(AdvFiles(Ind4DAdv))//'_'//TRIM(FDNum)//'.dns'

      CALL Read4DData ( UnWind, TRIM( FDSpath )//'\u\u_16i_'//TRIM(DNSFileName), FDuData, IT, ScalFact(1), Offsets(1), ErrStat )
      IF ( ErrStat /= 0 ) RETURN

      CALL Read4DData ( UnWind, TRIM( FDSpath )//'\v\v_16i_'//TRIM(DNSFileName), FDvData, IT, ScalFact(2), Offsets(2), ErrStat )
      IF ( ErrStat /= 0 ) RETURN

      CALL Read4DData ( UnWind, TRIM( FDSpath )//'\w\w_16i_'//TRIM(DNSFileName), FDwData, IT, ScalFact(3), Offsets(3), ErrStat )
      IF ( ErrStat /= 0 ) RETURN

   ENDDO ! IT

   Ind4DAdv = Ind4DAdv + 1

   RETURN

END SUBROUTINE ReadAll4DData
!====================================================================================================
SUBROUTINE LoadLESData( UnWind, FileNo, Indx, ErrStat )
! This subroutine reads binary data from the U, V, and W files and stores them in the arrays FDu,
! FDv, and FDw (by calling Read4DData).
!----------------------------------------------------------------------------------------------------
      ! Passed variables

   INTEGER,         INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,         INTENT(IN)    :: FileNo                       ! current file number to read
   INTEGER,         INTENT(IN)    :: Indx                         ! index into the data arrays
   INTEGER,         INTENT(OUT)   :: ErrStat                      ! return 0 if no errors encountered; non-zero otherwise
   
      ! local variables
   CHARACTER(5)                   :: FDNum
   CHARACTER(20)                  :: LESFileName                  ! String containing part of the current file name.      
   
      
      ! get the file name for the file number
      
   WRITE(FDNum,'(I5.5)', IOStat=ErrStat) FileNo
   IF ( ErrStat /= 0 ) RETURN
   
   LESFileName = TRIM(FDNum)//'.les'


      ! set the paths and read the data for each component
      
   CALL Read4DData ( UnWind, TRIM( FDSpath )//'\u\u_16i_'//TRIM(LESFileName), FDu, Indx, ScalFact(1), Offsets(1), ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   CALL Read4DData ( UnWind, TRIM( FDSpath )//'\v\v_16i_'//TRIM(LESFileName), FDv, Indx, ScalFact(2), Offsets(2), ErrStat )
   IF ( ErrStat /= 0 ) RETURN
   
   CALL Read4DData ( UnWind, TRIM( FDSpath )//'\w\w_16i_'//TRIM(LESFileName), FDw, Indx, ScalFact(3), Offsets(3), ErrStat )


END SUBROUTINE LoadLESData
!====================================================================================================
SUBROUTINE Read4DData ( UnWind, FileName, Comp, Indx4, Scale, Offset,  ErrStat)
! This subroutine is used to read one time-step's worth of large-eddy wind data for one component 
! from a file.
!----------------------------------------------------------------------------------------------------

      ! Passed variables
      
   INTEGER,     INTENT(IN)    :: UnWind               ! The I/O unit of the LE file.
   CHARACTER(*),INTENT(IN)    :: FileName             ! Then name of the LE data file.

   REAL(ReKi),  INTENT(INOUT) :: Comp (:,:,:,:)       ! The velocity array [do NOT make this INTENT(OUT): other parts of the array may become undefined]
   INTEGER,     INTENT(IN)    :: Indx4                ! The index of the 4th dimension of Comp, which is to be read.
   REAL(ReKi),  INTENT(IN)    :: Scale                ! The scale factor for converting from intergers to non-normalized reals.
   REAL(ReKi),  INTENT(IN)    :: Offset               ! The offset for converting from intergers to non-normalized reals.

   INTEGER,     INTENT(OUT)   :: ErrStat              ! The returned status of a READ.
      
      ! Local variables

   INTEGER                    :: IX                   ! A DO index for indexing the arrays in the x direction.
   INTEGER                    :: IXK                  ! An index for the decimated arrays in the x direction.
   INTEGER                    :: IY                   ! A DO index for indexing the arrays in the y direction.
   INTEGER                    :: IYK                  ! An index for the decimated arrays in the y direction.
   INTEGER                    :: IZ                   ! A DO index for indexing the arrays in the z direction.
   INTEGER                    :: IZK                  ! An index for the decimated arrays in the z direction.

   INTEGER(B2Ki)              :: Com (Num4Dx,Num4Dy)  ! Temporary array to hold component's integer values for a given Z.


   !-------------------------------------------------------------------------------------------------
   ! Open the binary input file
   !-------------------------------------------------------------------------------------------------
   CALL OpenUInBEFile( UnWind, TRIM( FileName ), FDRecL, ErrStat )
   IF ( ErrStat /= 0 ) RETURN


   !-------------------------------------------------------------------------------------------------
   ! Read the input file
   !-------------------------------------------------------------------------------------------------

   IZK = 0
   DO IZ=1,Num4Dz,FD_DF_Z

      READ (UnWind,REC=IZ,IOSTAT=ErrStat)  Com

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Error reading record '//TRIM( Num2LStr( IZ ) )// & 
                                            ' of the binary 4D wind file, "'//TRIM( FileName )//'".')
         RETURN

      ENDIF

      IZK = IZK + 1                                ! IZK = ( IZ - 1 + FD_DF_Z )/FD_DF_Z
      IYK = 0
      
      DO IY=1,Num4Dy,FD_DF_Y
         
         IYK = IYK + 1                             ! IYK = ( IY - 1 + FD_DF_Y )/FD_DF_Y
         
         DO IX=1,Num4Dx,FD_DF_X
         
               ! shift the x-index, if necessary, to perform Advection
               
            !IXK = ( IX + FD_DF_X - 1 )/FD_DF_X
            IXK = ( MOD(IX+Shft4Dnew-1,Num4Dx) + FD_DF_X )/FD_DF_X
         
            Comp(IXK,IYK,IZK,Indx4) = Scale*Com(IX,IY) + Offset
         
         ENDDO ! IX
         
      ENDDO ! IY

   ENDDO ! IZ


   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
   CLOSE ( UnWind )

   RETURN

END SUBROUTINE Read4DData
!====================================================================================================
SUBROUTINE Load4DData( InpIndx )
! This subroutine takes the data from the storage array (used when ADVECT=.TRUE., shifts it if necessary, 
! and loads it into the array for the time slice indexed by InpIndx.
!----------------------------------------------------------------------------------------------------

   INTEGER, INTENT(IN) :: InpIndx

   INTEGER             :: IX
   INTEGER             :: IXK


   DO IX=1,Num4Dx,FD_DF_X

         ! shift the x-index, if necessary, to perform Advection
      IXK = ( MOD(IX+Shft4Dnew-1,Num4Dx) + FD_DF_X )/FD_DF_X

      FDu(IXK,:,:,InpIndx) = FDuData(IX,:,:,FDFileNo)
      FDv(IXK,:,:,InpIndx) = FDvData(IX,:,:,FDFileNo)
      FDw(IXK,:,:,InpIndx) = FDwData(IX,:,:,FDFileNo)

   ENDDO ! IX


   RETURN

END SUBROUTINE Load4DData
!====================================================================================================
FUNCTION FD_GetValue(RVarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the RVarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------

   CHARACTER(*),   INTENT(IN)    :: RVarName
   INTEGER,        INTENT(OUT)   :: ErrStat
   REAL(ReKi)                    :: FD_GetValue

   
   CHARACTER(20)                 :: VarNameUC
   

   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FDWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = RVarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
            
      CASE ('ROTDIAM' )
         FD_GetValue = RotDiam         
         
      CASE DEFAULT
         CALL WrScr( ' Invalid variable name in FD_GetRValue().' )
         ErrStat = 1
         
   END SELECT

END FUNCTION FD_GetValue
!====================================================================================================
FUNCTION FD_GetWindSpeed(Time, InputPosition, ErrStat)
! This function is used to interpolate into the 4D wind arrays.  It receives X, Y, Z and TIME from the 
! calling routine.  The time since the start of the 4D data is used to decide which pair of time slices 
! to interpolate within and between.  After finding the two time slices, it decides which eight grid 
! points bound the (X,Y,Z) pair. It does a trilinear interpolation for each time slice. Linear 
! interpolation is then used to interpolate between time slices.  This routine assumes that X is 
! downwind, Y is to the left when looking downwind and Z is up.  It also assumes that no 
! extrapolation will be needed except in time and the Z direction.  In those cases, the appropriate
! steady winds are used.
!----------------------------------------------------------------------------------------------------

      ! Passed variables:
      
   REAL(ReKi),        INTENT(IN) :: Time                                   ! the time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)                       ! structure that contains the position
   INTEGER,           INTENT(OUT):: ErrStat                                ! returns 0 if no error; non-zero otherwise
   TYPE(InflIntrpOut)            :: FD_GetWindSpeed                        ! the resultant wind speed


      ! Local Variables:

   REAL(ReKi)                 :: Ixhyz                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Ixlyz                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Ixyzo                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Iyhz                                      ! Temporary interpolated value.
   REAL(ReKi)                 :: Iylz                                      ! Temporary interpolated value.
   REAL(ReKi)                 :: Ixyzn                                     ! Temporary interpolated value.
   REAL(ReKi)                 :: Tgrid                                     ! Fractional distance between time grids.
   REAL(ReKi)                 :: Xgrid                                     ! Fractional distance between grids in the x direction.
   REAL(ReKi)                 :: Xnorm                                     ! Nondimensional downwind distance of the analysis point from upwind end of dataset.
   REAL(ReKi)                 :: Ygrid                                     ! Fractional distance between grids in the y direction.
   REAL(ReKi)                 :: Ynorm                                     ! Nondimensional lateral distance of the analysis point from right side of dataset (looking downwind).
   REAL(ReKi)                 :: Zgrid                                     ! Fractional distance between grids in the z direction.
   REAL(ReKi)                 :: Zgrid_w                                   ! Fractional distance between grids in the z direction for the w component.
   REAL(ReKi)                 :: Znorm                                     ! Nondimensional vertical distance of the analysis point from bottom of dataset.
   REAL(ReKi)                 :: Znorm_w                                   ! Nondimensional vertical distance of the analysis point from bottom of dataset for the w component.

   INTEGER                    :: IT                                        ! Index for do loop
   INTEGER                    :: IXHI                                      ! Index for the more-positive x value.
   INTEGER                    :: IXLO                                      ! Index for the more-negative x value.
   INTEGER                    :: IYHI                                      ! Index for the more-positive y value.
   INTEGER                    :: IYLO                                      ! Index for the more-negative y value.
   INTEGER                    :: IZHI                                      ! Index for the more-positive z value.
   INTEGER                    :: IZHI_w                                    ! Index for the more-positive z value for the w component.
   INTEGER                    :: IZLO                                      ! Index for the more-negative z value.
   INTEGER                    :: IZLO_w                                    ! Index for the more-negative z value for the w component.

   !-------------------------------------------------------------------------------------------------     
   ! Check that we've initialized everything first
   !-------------------------------------------------------------------------------------------------     
     
   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FDWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE 
      ErrStat = 0   
   END IF      

   !-------------------------------------------------------------------------------------------------     
   ! If the TIME is greater than the time for the last file read, read another set of files until we straddle the current time.
   ! Stick with the last file if we've exhausted the data.
   ! We're assuming here that the simulation time step is smaller than the wind-file time step.
   !-------------------------------------------------------------------------------------------------     

   IF ( Time < PrevTime .AND. Time < FDTime(Ind4Dold) ) THEN  ! bjj: GET THE CORRECT TIME if we're going backward!
     
      !----------------------------------------------------------------------------------------------
      ! Determine the first file needed for this simulation.
      !----------------------------------------------------------------------------------------------
      Ind4Dold  = 1                                                           ! Put the old stuff in the first part of the array.
      Ind4Dnew  = 2                                                           ! Put the new stuff in the second part of the array.
      
      FDFileNo  = Num4Dt
      DO IT=1,Num4Dt
         IF ( Times4D(IT) > Time )  THEN
            FDFileNo = IT - 1
            EXIT
         END IF
      END DO ! IT
         
      !----------------------------------------------------------------------------------------------
      ! Open, read, and close the first set of files.
      !----------------------------------------------------------------------------------------------
      FDTime(Ind4Dold) = Times4D(FDFileNo)                                 ! Set the time for this file.

      IF ( ADVECT ) THEN
         CALL Load4DData(Ind4Dold)     ! load data stored in FDuData, FDvData, and FDwData arrays
      ELSE
         CALL LoadLESData( FDUnit, FDFileNo, Ind4Dold, ErrStat )
      END IF
            
      !----------------------------------------------------------------------------------------------
      ! Open, read, and close the second set of files.
      !----------------------------------------------------------------------------------------------
      FDFileNo  = MIN(FDFileNo + 1, Num4Dt)
      Shft4Dnew = 0
      
      IF ( ADVECT ) THEN
         FDFileNo = MOD(FDFileNo-1,Num4Dt) + 1

         IF (FDFileNo == 1) THEN
            Shft4Dnew = Shft4Dnew + 1

            IF (Ind4DAdv <= NumAdvect) THEN                             ! Ind4DAdv was set in ReadFDP
               IF ( MOD( Shft4Dnew, Num4Dx ) == 0 ) THEN
                  CALL ReadAll4DData(FDUnit, ErrStat)
                  IF ( ErrStat /= 0 ) RETURN
               END IF
            END IF

         ENDIF

         FDTime(Ind4Dnew) = Times4D(FDFileNo) + Shft4Dnew*FDPer         ! Set the time for this file.

         CALL Load4DData( Ind4Dnew )    ! shift the data

      ELSE   
         FDTime(Ind4Dnew) = Times4D(FDFileNo)                                           ! Set the time for this file.
!
         CALL LoadLESData( FDUnit, FDFileNo, Ind4Dnew, ErrStat )
      ENDIF
                     
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Move forward in time
   !-------------------------------------------------------------------------------------------------

   DO WHILE ( Time > FDTime(Ind4Dnew) .AND. ( Time < T_4D_En .OR. ADVECT ) )

      Ind4Dnew         = Ind4Dold                                          ! Reverse array indices (1 or 2).
      Ind4Dold         = 3 - Ind4Dnew
      FDFileNo         = FDFileNo + 1                                      ! Increment file number.


      IF ( ADVECT ) THEN
         FDFileNo = MOD(FDFileNo-1,Num4Dt) + 1

         IF (FDFileNo == 1) THEN
               Shft4Dnew = Shft4Dnew + 1

               IF (Ind4DAdv <= NumAdvect) THEN
                  IF ( MOD( Shft4Dnew, Num4Dx ) == 0 ) THEN
                     CALL ReadAll4DData(FDUnit, ErrStat)
                     IF ( ErrStat /= 0 ) RETURN
                  END IF                  
               ENDIF

         ENDIF

         FDTime(Ind4Dnew) = Times4D(FDFileNo) + Shft4Dnew*FDPer

         CALL Load4DData( Ind4Dnew )  ! shift the data
      ELSE
         FDTime(Ind4Dnew) = Times4D(FDFileNo)

         CALL LoadLESData( FDUnit, FDFileNo, Ind4Dnew, ErrStat )
      ENDIF

   ENDDO


   !.................................................................................................
   ! Find the bounding rows, columns, and planes for the X,Y,Z position.  The near, lower-right  
   ! corner is (1,1,1) when looking downwind. Make sure the lowest possible value is 1.
   !.................................................................................................


   !-------------------------------------------------------------------------------------------------
   ! get values of Time for interpolation. Linear interpolation; Nearest-neighbor extrapolation.
   !-------------------------------------------------------------------------------------------------

      ! Find out fractionally how far we are between grids in time and between grid points in each direction.
      !  Limit values to avoid extrapolation.  We need this for interpolation later on.

   Tgrid = MIN( MAX( ( Time - FDTime(Ind4Dold) )/( FDTime(Ind4Dnew) - FDTime(Ind4Dold) ), 0.0 ), 1.0 )


   !-------------------------------------------------------------------------------------------------
   ! get values of X for interpolation. Grid is periodic in X.
   !-------------------------------------------------------------------------------------------------
   Xnorm = ( Xt + InputPosition(1) )/Xmax

   DO WHILE ( Xnorm < 0.0 )   ! Ensure Xnorm is not negative.  The wave is periodic in x.
      Xnorm = Xnorm + 1.0
   ENDDO

   Xgrid = MIN( MAX( MOD( Xnorm, DelXgrid ), 0.0 ), 1.0 )
   IXLo  = MAX( MOD( INT( Xnorm*Num4DxD1 ) + 1, Num4DxD1 ), 1 )
   IXHi  = MOD( IXLo, Num4DxD ) + 1

   !-------------------------------------------------------------------------------------------------
   ! get values of Y for interpolation. Grid is periodic in Y.
   !-------------------------------------------------------------------------------------------------
   Ynorm = ( Yt + InputPosition(2) )/Ymax

   DO WHILE ( Ynorm < 0.0 )  ! Ensure Ynorm is not negative.  The wave is periodic in y.
      Ynorm = Ynorm + 1.0
   ENDDO

   Ygrid = MIN( MAX( MOD( Ynorm, DelYgrid ), 0.0 ), 1.0 )
   IYLo  = MAX( MOD( INT( Ynorm*Num4DyD1 ) + 1, Num4DyD1 ), 1 )
   IYHi  = MOD( IYLo, Num4DyD ) + 1

   !-------------------------------------------------------------------------------------------------
   ! get values of Z for interpolation.  Linear interpolation; Nearest-neighbor extrapolation.  
   !-------------------------------------------------------------------------------------------------
   Znorm = MIN( MAX( ( Zt + InputPosition(3) - ZRef )/Zmax, 0.0 ), 1.0 ) !bjj: define ZRef

   Zgrid = MIN( MAX( MOD( Znorm, DelZgrid ), 0.0 ), 1.0 )
   IZLo  = MAX( INT( Znorm*Num4DzD1 ) + 1, 1 )

      ! If we are located at the upper end of the z dimension, decrement the index by one and set the grid coordinate to 1.

   IF ( IZLo == Num4DzD )  THEN
      IZLo  = Num4DzD1
      Zgrid = 1.0
   ENDIF
   IZHi = IZLo + 1

      !..............................................................................................
      ! Find the equivalent Znorm (Znorm_w) for the w-component, which may be shifted vertically
      ! by half the original grid spacing.
      !..............................................................................................

   IF ( VertShft ) THEN
      Znorm_w = MAX( Znorm - 0.5*DelZgrid/FD_DF_Z, 0.0 )
   ELSE
      Znorm_w = Znorm
   ENDIF

   Zgrid_w = MIN( MAX( MOD( Znorm_w, DelZgrid ), 0.0 ), 1.0 )
   IZLo_w  = MAX( INT( Znorm_w*Num4DzD1 ) + 1, 1 )

   IF ( IZLo_w == Num4DzD )  THEN
      IZLo_w  = Num4DzD1
      Zgrid_w = 1.0
   ENDIF

   IZHi_w = IZLo_w + 1


   !-------------------------------------------------------------------------------------------------
   ! Interpolate for u component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

   Iylz  = ( FDu(IXLo,IYLo,IZHi,Ind4Dold) - FDu(IXLo,IYLo,IZLo,Ind4Dold) )*Zgrid + FDu(IXLo,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDu(IXLo,IYHi,IZHi,Ind4Dold) - FDu(IXLo,IYHi,IZLo,Ind4Dold) )*Zgrid + FDu(IXLo,IYHi,IZLo,Ind4Dold)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDu(IXHi,IYLo,IZHi,Ind4Dold) - FDu(IXHi,IYLo,IZLo,Ind4Dold) )*Zgrid + FDu(IXHi,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDu(IXHi,IYHi,IZHi,Ind4Dold) - FDu(IXHi,IYHi,IZLo,Ind4Dold) )*Zgrid + FDu(IXHi,IYHi,IZLo,Ind4Dold)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzo = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   Iylz  = ( FDu(IXLo,IYLo,IZHi,Ind4Dnew) - FDu(IXLo,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDu(IXLo,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDu(IXLo,IYHi,IZHi,Ind4Dnew) - FDu(IXLo,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDu(IXLo,IYHi,IZLo,Ind4Dnew)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDu(IXHi,IYLo,IZHi,Ind4Dnew) - FDu(IXHi,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDu(IXHi,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDu(IXHi,IYHi,IZHi,Ind4Dnew) - FDu(IXHi,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDu(IXHi,IYHi,IZLo,Ind4Dnew)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzn = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   FD_GetWindSpeed%Velocity(1) = ( Ixyzn - Ixyzo )*Tgrid + Ixyzo

   !-------------------------------------------------------------------------------------------------
   ! Interpolate for v component of wind within the grid.
   !-------------------------------------------------------------------------------------------------

   Iylz  = ( FDv(IXLo,IYLo,IZHi,Ind4Dold) - FDv(IXLo,IYLo,IZLo,Ind4Dold) )*Zgrid + FDv(IXLo,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDv(IXLo,IYHi,IZHi,Ind4Dold) - FDv(IXLo,IYHi,IZLo,Ind4Dold) )*Zgrid + FDv(IXLo,IYHi,IZLo,Ind4Dold)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDv(IXHi,IYLo,IZHi,Ind4Dold) - FDv(IXHi,IYLo,IZLo,Ind4Dold) )*Zgrid + FDv(IXHi,IYLo,IZLo,Ind4Dold)
   Iyhz  = ( FDv(IXHi,IYHi,IZHi,Ind4Dold) - FDv(IXHi,IYHi,IZLo,Ind4Dold) )*Zgrid + FDv(IXHi,IYHi,IZLo,Ind4Dold)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzo = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   Iylz  = ( FDv(IXLo,IYLo,IZHi,Ind4Dnew) - FDv(IXLo,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDv(IXLo,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDv(IXLo,IYHi,IZHi,Ind4Dnew) - FDv(IXLo,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDv(IXLo,IYHi,IZLo,Ind4Dnew)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDv(IXHi,IYLo,IZHi,Ind4Dnew) - FDv(IXHi,IYLo,IZLo,Ind4Dnew) )*Zgrid + FDv(IXHi,IYLo,IZLo,Ind4Dnew)
   Iyhz  = ( FDv(IXHi,IYHi,IZHi,Ind4Dnew) - FDv(IXHi,IYHi,IZLo,Ind4Dnew) )*Zgrid + FDv(IXHi,IYHi,IZLo,Ind4Dnew)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzn = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   FD_GetWindSpeed%Velocity(2) = ( Ixyzn - Ixyzo )*Tgrid + Ixyzo

   !-------------------------------------------------------------------------------------------------
   ! Interpolate for w component of wind within the grid.
   !-------------------------------------------------------------------------------------------------
   !bjj: should Zgrid actually be Zgrid_w here?  I changed it so that it's consistent
   
   Iylz  = ( FDw(IXLo,IYLo,IZHi_w,Ind4Dold) - FDw(IXLo,IYLo,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXLo,IYLo,IZLo_w,Ind4Dold)
   Iyhz  = ( FDw(IXLo,IYHi,IZHi_w,Ind4Dold) - FDw(IXLo,IYHi,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXLo,IYHi,IZLo_w,Ind4Dold)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDw(IXHi,IYLo,IZHi_w,Ind4Dold) - FDw(IXHi,IYLo,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXHi,IYLo,IZLo_w,Ind4Dold)
   Iyhz  = ( FDw(IXHi,IYHi,IZHi_w,Ind4Dold) - FDw(IXHi,IYHi,IZLo_w,Ind4Dold) )*Zgrid_w + FDw(IXHi,IYHi,IZLo_w,Ind4Dold)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzo = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   Iylz  = ( FDw(IXLo,IYLo,IZHi_w,Ind4Dnew) - FDw(IXLo,IYLo,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXLo,IYLo,IZLo_w,Ind4Dnew)
   Iyhz  = ( FDw(IXLo,IYHi,IZHi_w,Ind4Dnew) - FDw(IXLo,IYHi,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXLo,IYHi,IZLo_w,Ind4Dnew)
   Ixlyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Iylz  = ( FDw(IXHi,IYLo,IZHi_w,Ind4Dnew) - FDw(IXHi,IYLo,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXHi,IYLo,IZLo_w,Ind4Dnew)
   Iyhz  = ( FDw(IXHi,IYHi,IZHi_w,Ind4Dnew) - FDw(IXHi,IYHi,IZLo_w,Ind4Dnew) )*Zgrid_w + FDw(IXHi,IYHi,IZLo_w,Ind4Dnew)
   Ixhyz = ( Iyhz - Iylz )*Ygrid + Iylz

   Ixyzn = ( Ixhyz - Ixlyz )*Xgrid + Ixlyz

   FD_GetWindSpeed%Velocity(3) = ( Ixyzn - Ixyzo )*Tgrid + Ixyzo


   !-------------------------------------------------------------------------------------------------
   ! Set the previous time here to compare with later...
   !-------------------------------------------------------------------------------------------------
   PrevTime = Time

   RETURN
   
END FUNCTION FD_GetWindSpeed
!====================================================================================================
SUBROUTINE FD_Terminate( ErrStat )
! This subroutine deallocates arrays, closes files, and un-sets the initialization flag.
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise


   CLOSE( FDunit )

   ErrStat = 0

   IF ( ALLOCATED( FDu       ) )   DEALLOCATE( FDu,       STAT=ErrStat )
   IF ( ALLOCATED( FDv       ) )   DEALLOCATE( FDv,       STAT=ErrStat )
   IF ( ALLOCATED( FDw       ) )   DEALLOCATE( FDw,       STAT=ErrStat )
   IF ( ALLOCATED( FDuData   ) )   DEALLOCATE( FDuData,   STAT=ErrStat )  
   IF ( ALLOCATED( FDvData   ) )   DEALLOCATE( FDvData,   STAT=ErrStat )
   IF ( ALLOCATED( FDwData   ) )   DEALLOCATE( FDwData,   STAT=ErrStat )
   IF ( ALLOCATED( Times4D   ) )   DEALLOCATE( Times4D,   STAT=ErrStat )
   IF ( ALLOCATED( Times4DIx ) )   DEALLOCATE( Times4DIx, STAT=ErrStat )
   IF ( ALLOCATED( AdvFiles  ) )   DEALLOCATE( AdvFiles,  STAT=ErrStat )

   Initialized = .FALSE.

END SUBROUTINE FD_Terminate
!====================================================================================================
END MODULE FDWind
MODULE FFWind
!
!  This module uses full-field binary wind files to determine the wind inflow.
!  This module assumes that the origin, (0,0,0), is located at the tower centerline at ground level,
!  and that all units are specified in the metric system (using meters and seconds).
!  Data is shifted by half the grid width to account for turbine yaw (so that data in the X 
!  direction actually starts at -1*FFYHWid meters).
!
!  Created 25-Sept-2009 by B. Jonkman, National Renewable Energy Laboratory
!     using subroutines and modules from AeroDyn v12.58
!
!----------------------------------------------------------------------------------------------------

   USE      NWTC_Library
   USE      SharedInflowDefns

   IMPLICIT NONE

   PRIVATE                                                        ! By default, everything in FFWind is private (methods, data, types, etc.)
   
      ! former FF_Wind module
      
   REAL(ReKi), ALLOCATABLE          :: FFData  (:,:,:,:)          ! Array of FF data
   REAL(ReKi), ALLOCATABLE          :: FFtower (:,:,:)            ! Array of data along the tower, below the FF array

   REAL(ReKi)                       :: FFDTime                    ! delta time
   REAL(ReKi)                       :: FFRate                     ! data rate in Hz (1/FFDTime)
   REAL(ReKi)                       :: FFYHWid                    ! half the grid width
   REAL(ReKi)                       :: FFZHWid                    ! half the grid height
   REAL(ReKi)                       :: RefHt                      ! the reference (hub) height of the grid in meters 
   REAL(ReKi)                       :: GridBase                   ! the height of the bottom of the grid in meters
   REAL(ReKi)                       :: InitXPosition              ! the initial x location of the wind file (distance the FF file will be offset)
   REAL(ReKi)                       :: InvFFYD                    ! reciprocal of delta y
   REAL(ReKi)                       :: InvFFZD                    ! reciprocal of delta z
   REAL(ReKi)                       :: InvMFFWS                   ! reciprocal of the mean wind speed (MeanFFWS)
   REAL(ReKi)                       :: MeanFFWS                   ! the mean wind speed (as defined in the FF file), not necessarially the mean of the portion of the wind used
   REAL(ReKi)                       :: TotalTime                  ! the total time in the simulation

   INTEGER                          :: NFFComp                    ! number of wind components
   INTEGER                          :: NFFSteps                   ! number of time steps in the FF array
   INTEGER                          :: NYGrids                    ! number of points in the lateral (y) direction of the grids
   INTEGER                          :: NZGrids                    ! number of points in the vertical (z) direction of the grids
   INTEGER                          :: NTGrids                    ! number of points in the vertical (z) direction on the tower (below the grids)
         
   LOGICAL, SAVE                    :: Initialized = .FALSE.      ! flag that determines if the module has been initialized
   LOGICAL                          :: Periodic    = .FALSE.      ! flag that determines if the wind is periodic


   INTERFACE FF_GetValue
      MODULE PROCEDURE FF_GetRValue                               ! routine to return scalar real values 
   END INTERFACE


   PUBLIC                           :: FF_Init                    ! initialization subroutine to read the FF grids
   PUBLIC                           :: FF_GetWindSpeed            ! interpolation function that returns velocities at specified time and space
   PUBLIC                           :: FF_GetValue                ! interface to return requested values
   PUBLIC                           :: FF_Terminate               ! subroutine that deallocates memory stored in the FFWind module

CONTAINS
!====================================================================================================
SUBROUTINE FF_Init ( UnWind, BinFile, ErrStat )
!  This routine is used read the full-field turbulence data.
!  09/25/97 - Created by M. Buhl from GETFILES in ViewWind.
!  09/23/09 - modified by B. Jonkman: this subroutine was split into several subroutines (was ReadFF)
!----------------------------------------------------------------------------------------------------

   IMPLICIT                       NONE


      ! Passed Variables:
      
   INTEGER,      INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered
   
   CHARACTER(*), INTENT(IN)    :: BinFile                      ! Name of the binary FF wind file

      ! Local Variables:

   REAL(ReKi)                  :: TI      (3)                  ! turbulence intensities of the wind components as defined in the FF file, not necessarially the actual TI
   REAL(ReKi)                  :: BinTI   (3)                  ! turbulence intensities of the wind components as defined in the FF binary file, not necessarially the actual TI
   REAL(ReKi)                  :: UBar
   REAL(ReKi)                  :: ZCenter
   
   INTEGER(B2Ki)               :: Dum_Int2
   INTEGER                     :: DumInt
   INTEGER                     :: I
   LOGICAL                     :: CWise
   LOGICAL                     :: Exists
   CHARACTER( 1028 )           :: SumFile                      ! length is LEN(BinFile) + the 4-character extension.
   CHARACTER( 1028 )           :: TwrFile                      ! length is LEN(BinFile) + the 4-character extension.


      !----------------------------------------------------------------------------------------------
      ! Check that the module hasn't already been initialized.
      !----------------------------------------------------------------------------------------------   
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' FFWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF   


      !----------------------------------------------------------------------------------------------
      ! Open the binary file, read its "header" (first 2-byte integer) to determine what format
      ! binary file it is, and close it.
      !----------------------------------------------------------------------------------------------

   CALL OpenBInpFile (UnWind, TRIM(BinFile), ErrStat)
   IF (ErrStat /= 0) RETURN
      
   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2
   CLOSE( UnWind )
   
   IF (ErrStat /= 0) THEN
      CALL WrScr( ' Error reading first binary integer from file "'//TRIM(BinFile)//'."' )
      RETURN
   END IF
   
      !----------------------------------------------------------------------------------------------
      ! Read the files to get the required FF data.
      !----------------------------------------------------------------------------------------------   
   DumInt = Dum_Int2  ! change to default INTEGER, instead of INT(2) to compare in SELECT below
    
   SELECT CASE (DumInt)  
   
      CASE ( 7, 8 )                                                    ! TurbSim binary format
         
         CALL Read_TurbSim_FF(UnWind, TRIM(BinFile), ErrStat)
         
      CASE ( -1, -2, -3, -99 )                                         ! Bladed-style binary format
      
         !...........................................................................................
         ! Create full-field summary file name from binary file root name.  Also get tower file
         ! name.
         !...........................................................................................

            CALL GetRoot(BinFile, SumFile)
            
            TwrFile = TRIM(SumFile)//'.twr'
            SumFile = TRIM(SumFile)//'.sum'
      
         !...........................................................................................
         ! Read the summary file to get necessary scaling information
         !...........................................................................................
   
            CALL Read_Summary_FF (UnWind, TRIM(SumFile), CWise, ZCenter, TI, ErrStat ) 
            IF (ErrStat /= 0) RETURN
            
            UBar = MeanFFWS      ! temporary storage .... this is our only check to see if the summary and binary files "match"

         !...........................................................................................
         ! Open the binary file and read its header
         !...........................................................................................
         
            CALL OpenBInpFile (UnWind, TRIM(BinFile), ErrStat)

            IF (ErrStat /= 0) RETURN

            IF ( Dum_Int2 == -99 ) THEN                                       ! Newer-style BLADED format
               CALL Read_Bladed_FF_Header1 (UnWind, BinTI, ErrStat)    
               
                  ! If the TIs are also in the binary file (BinTI > 0), 
                  ! use those numbers instead of ones from the summary file
                  
               DO I =1,NFFComp                  
                  IF ( BinTI(I) > 0 ) TI(I) = BinTI(I)
               END DO
               
            ELSE
               CALL Read_Bladed_FF_Header0 (UnWind, ErrStat)                  ! Older-style BLADED format
            END IF

            IF (ErrStat /= 0) RETURN

         !...........................................................................................
         ! Let's see if the summary and binary FF wind files go together before continuing.
         !...........................................................................................
               
            IF ( ABS( UBar - MeanFFWS ) > 0.1 )  THEN
               CALL WrScr( ' Error: Incompatible mean hub-height wind speeds in FF wind files. '//&
                           '(Check that the .sum and .wnd files were generated together.)' )
               ErrStat = 1
               RETURN
            ENDIF

         !...........................................................................................
         ! Calculate the height of the bottom of the grid
         !...........................................................................................

            GridBase = ZCenter - FFZHWid         ! the location, in meters, of the bottom of the grid

         !...........................................................................................
         ! Read the binary grids (converted to m/s) and close the file
         !...........................................................................................

            CALL Read_Bladed_Grids( UnWind, CWise, TI, ErrStat) 
            CLOSE ( UnWind )
                           
            IF ( ErrStat /= 0 ) RETURN
   
         !...........................................................................................
         ! Read the tower points file
         !...........................................................................................
   
            INQUIRE ( FILE=TRIM(TwrFile) , EXIST=Exists )

            IF (  Exists )  THEN  
               CALL Read_FF_Tower( UnWind, TRIM(TwrFile), ErrStat  )
            ELSE
               NTgrids = 0            
            END IF                        

                               
      CASE DEFAULT
         
         CALL WrScr( ' Error: Unrecognized binary wind file type.' )
         ErrStat = 1
         RETURN
                  
   END SELECT


   IF (Periodic) THEN
      InitXPosition = 0                ! start at the hub
      TotalTime     = NFFSteps*FFDTime
   ELSE
      InitXPosition = FFYHWid          ! start half the grid with ahead of the turbine
      TotalTime     = (NFFSteps-1)*FFDTime      
   END IF
      
   Initialized = .TRUE.
   
   RETURN
   
END SUBROUTINE FF_Init
!====================================================================================================
SUBROUTINE Read_Bladed_FF_Header0 (UnWind, ErrStat)
!   Reads the binary headers from the turbulence files of the old Bladed variety.  Note that
!   because of the normalization, neither NZGrids or NYGrids are larger than 32 points.
!   21-Sep-2009 - B. Jonkman, NREL/NWTC.
!----------------------------------------------------------------------------------------------------


   IMPLICIT                      NONE


      ! Passed Variables:
      
   INTEGER,   INTENT(IN)      :: UnWind
   INTEGER,   INTENT(OUT)     :: ErrStat

      ! Local Variables:

   REAL(ReKi)                 :: FFXDelt
   REAL(ReKi)                 :: FFYDelt
   REAL(ReKi)                 :: FFZDelt

   INTEGER(B2Ki)              :: Dum_Int2

   INTEGER                    :: I

   !-------------------------------------------------------------------------------------------------
   ! Read the header (file has just been opened)
   !-------------------------------------------------------------------------------------------------

   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! -NFFC (file ID)

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading number of wind components from binary FF file.' )
         RETURN
      END IF
      NFFComp = -1*Dum_Int2
         

   READ (UnWind, IOSTAT=ErrStat) Dum_Int2                                                    ! delta z (mm)
    
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dz from binary FF file.' )
         RETURN
      END IF
      FFZDelt = 0.001*Dum_Int2
      InvFFZD = 1.0/FFZDelt


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! delta y (mm)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dy from binary FF file.' )
         RETURN
      END IF
      FFYDelt = 0.001*Dum_Int2
      InvFFYD = 1.0/FFYDelt


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! delta x (mm)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dx from binary FF file.' )
         RETURN
      END IF
      FFXDelt = 0.001*Dum_Int2


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! half the number of time steps
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading number of time steps from binary FF file.' )
         RETURN
      END IF
      NFFSteps = 2*Dum_Int2


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! 10 times the mean full-field wind speed
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading mean full-field wind speed from binary FF file.' )
         RETURN
      END IF
      MeanFFWS = 0.1*Dum_Int2
      InvMFFWS = 1.0/MeanFFWS
      FFDTime  = FFXDelt/MeanFFWS
      FFRate   = 1.0/FFDTime

      
   DO I = 1,5   
   
      READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                ! unused variables: zLu, yLu, xLu, dummy, random seed

         IF (ErrStat /= 0) THEN
            CALL WrScr( ' Error reading 2-byte integers from binary FF file.' )
            RETURN
         END IF
         
   END DO


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! 1000*nz

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading nz from binary FF file.' )
         RETURN
      END IF
      NZGrids  = Dum_Int2/1000
      FFZHWid  = 0.5*FFZDelt*( NZGrids - 1 )    ! half the vertical size of the grid


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! 1000*ny
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading ny from binary FF file.' )
         RETURN
      END IF   
      NYGrids  = Dum_Int2/1000
      FFYHWid  = 0.5*FFYDelt*( NYGrids - 1 )


   IF (NFFComp == 3) THEN
   
      DO I=1,6
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                             ! unused variables: zLv, yLv, xLv, zLw, yLw, xLw
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 2-byte length scales from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I
      
   END IF !NFFComp


   RETURN
   
END SUBROUTINE Read_Bladed_FF_Header0
!====================================================================================================
SUBROUTINE Read_Bladed_FF_Header1 (UnWind, TI, ErrStat)
!   Reads the binary headers from the turbulence files of the new Bladed variety.
!   16-May-2002 - Windward Engineering.
!   21-Sep-2009 - B. Jonkman, NREL.  updated to trap errors and add extra parameters for MANN model
!----------------------------------------------------------------------------------------------------


   IMPLICIT                      NONE


      ! Passed Variables:
      
   INTEGER,   INTENT(IN)      :: UnWind
   REAL(ReKi), INTENT(OUT)    :: TI(3)
   INTEGER,   INTENT(OUT)     :: ErrStat

      ! Local Variables:

   REAL(ReKi)                 :: FFXDelt
   REAL(ReKi)                 :: FFYDelt
   REAL(ReKi)                 :: FFZDelt

   REAL(SiKi)                 :: Dum_Real4
   INTEGER(B2Ki)              :: Dum_Int2
   INTEGER(B4Ki)              :: Dum_Int4

   INTEGER                    :: I
   INTEGER                    :: TurbType


   TI(:) = -1                                                                                !Initialize to -1 (not all models contain TI)

   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! -99 (file ID)

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading integer from binary FF file.' )
         RETURN
      END IF

   
   READ (UnWind, IOSTAT=ErrStat)  Dum_Int2                                                   ! turbulence type

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading turbulence type from binary FF file.' )
         RETURN
      END IF
      TurbType = Dum_Int2


   SELECT CASE (TurbType)
      CASE(1, 2) 
         !----------------------------------------
         !1-component Von Karman (1) or Kaimal (2)
         !----------------------------------------
            NFFComp = 1
                  
      CASE(3, 5) 
         !----------------------------------------
         !3-component Von Karman (3) or IEC-2 
         ! Kaimal (5)
         !----------------------------------------
            NFFComp = 3
         
      CASE(4) 
         !----------------------------------------
         !improved Von Karman
         !----------------------------------------
      
            READ (UnWind, IOSTAT=ErrStat) Dum_Int4                                           ! number of components (should be 3)
            
               IF (ErrStat /= 0) THEN           
                  CALL WrScr( ' Error reading number of components from binary FF file.' )
                  RETURN
               END IF
               NFFComp = Dum_Int4
            
            READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                          ! Latitude (deg)
            
               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading latitude from binary FF file.' )  
                  RETURN
               END IF

            READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                          ! Roughness length (m)

               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading roughness length from binary FF file.' )
                  RETURN
               END IF
            
            READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                          ! Reference height (m) = Z(1) + GridHeight / 2.0

               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading reference height from binary FF file.' )
                  RETURN
               END IF
            
            
            DO I = 1,3
               READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                       ! TI(u, v, w) (%)
               
                  IF (ErrStat /= 0) THEN
                     CALL WrScr( ' Error reading TI('//'TRIM(Num2LStr(I))'//') from binary FF file.' )
                     RETURN
                  END IF
                  TI(I) = Dum_Real4                                                          ! This overwrites the TI read in the summary file
                  
            END DO !I            
                             
                  
      CASE (7, 8)
         !----------------------------------------
         ! General Kaimal (7) or  Mann model (8)
         !----------------------------------------
      
            READ (UnWind, IOSTAT=ErrStat) Dum_Int4                                           ! number of bytes in header
            
               IF (ErrStat /= 0) THEN           
                  CALL WrScr( ' Error reading number of header records from binary FF file.' )
                  RETURN
               END IF

            READ (UnWind, IOSTAT=ErrStat) Dum_Int4                                           ! number of components
            
               IF (ErrStat /= 0) THEN           
                  CALL WrScr( ' Error reading number of data from binary FF file.' )
                  RETURN
               END IF
               NFFComp = Dum_Int4

                                  
      CASE DEFAULT
      
         CALL ProgWarn( ' AeroDyn does not recognize the full-field turbulence file type ='//TRIM(Num2LStr(TurbType))//'.' )
                  
   END SELECT !TurbType


   READ (UnWind, IOSTAT=ErrStat) Dum_Real4                                                   ! delta z (m)
    
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dz from binary FF file.' )
         RETURN
      END IF
      FFZDelt = Dum_Real4
      InvFFZD = 1.0/FFZDelt


   READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                                  ! delta y (m)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dy from binary FF file.' )
         RETURN
      END IF
      FFYDelt = Dum_Real4
      InvFFYD = 1.0/FFYDelt

   READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                                  ! delta x (m)
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading dx from binary FF file.' )
         RETURN
      END IF
      FFXDelt = Dum_Real4


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                   ! half the number of time steps
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading number of time steps from binary FF file.' )
         RETURN
      END IF
      NFFSteps = 2*Dum_Int4


   READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                                  ! mean full-field wind speed
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading mean full-field wind speed from binary FF file.' )
         RETURN
      END IF
      MeanFFWS = Dum_Real4
      InvMFFWS = 1.0/MeanFFWS
      FFDTime  = FFXDelt/MeanFFWS
      FFRate   = 1.0/FFDTime

      
   DO I = 1,3   
   
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                               ! unused variables: zLu, yLu, xLu

         IF (ErrStat /= 0) THEN
            CALL WrScr( ' Error reading 4-byte length scales from binary FF file.' )
            RETURN
         END IF
         
   END DO
   
   
   DO I = 1,2
   
      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                ! unused variables: dummy, random seed
      
         IF (ErrStat /= 0) THEN
            CALL WrScr( ' Error reading 4-byte integers from binary FF file.' )
            RETURN
         END IF
         
   END DO


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                   ! nz

      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading nz from binary FF file.' )
         RETURN
      END IF
      NZGrids  = Dum_Int4
      FFZHWid  = 0.5*FFZDelt*( NZGrids - 1 )    ! half the vertical size of the grid


   READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                                   ! ny
   
      IF (ErrStat /= 0) THEN
         CALL WrScr( ' Error reading ny from binary FF file.' )
         RETURN
      END IF   
      NYGrids  = Dum_Int4
      FFYHWid  = 0.5*FFYDelt*( NYGrids - 1 )


   IF (NFFComp == 3) THEN
   
      DO I=1,6
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables: zLv, yLv, xLv, zLw, yLw, xLw
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte length scales from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I
      
   END IF !NFFComp



   IF ( TurbType == 7 ) THEN     ! General Kaimal model
   
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variable: coherence decay constant
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading coherence decay constant from binary FF file.' )
               RETURN
            END IF

         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables: coherence scale parameter in m
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading coherence scale parameter from binary FF file.' )
               RETURN
            END IF
         
   ELSE IF ( TurbType == 8 ) THEN     ! Mann model
      
      DO I=1,2
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables: shear parameter (gamma), scale length
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,4
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,3
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,2
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,3
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I

      DO I=1,2
      
         READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                                            ! unused variables
         
            IF (ErrStat /= 0) THEN
               CALL WrScr( ' Error reading 4-byte parameters from binary FF file.' )
               RETURN
            END IF
         
      ENDDO !I


   END IF !TurbType


   RETURN
   
END SUBROUTINE Read_Bladed_FF_Header1
!====================================================================================================
SUBROUTINE Read_Bladed_Grids ( UnWind, CWise, TI, ErrStat )
! This subroutine continues reading UnWind, starting after the headers have been read.
! It reads the grids and converts the data to un-normalized wind speeds in m/s.
!----------------------------------------------------------------------------------------------------

   INTEGER,     INTENT(IN)    :: UnWind
   LOGICAL,     INTENT(IN)    :: CWise
   REAL(ReKi),  INTENT(IN)    :: TI      (3)                  ! turbulence intensities of the wind components as defined in the FF file, not necessarially the actual TI
   INTEGER,     INTENT(OUT)   :: ErrStat

   REAL(ReKi), PARAMETER      :: FF_Offset(3) = (/ 1.0, 0.0, 0.0 /)  ! used for "un-normalizing" the data

   INTEGER                    :: CFirst
   INTEGER                    :: CLast
   INTEGER                    :: CStep
   INTEGER(B2Ki)              :: Dum_Int2
   INTEGER                    :: I
   INTEGER                    :: IC
   INTEGER                    :: IR
   INTEGER                    :: IT
   
   INTEGER                    :: TmpNumSteps


   !-------------------------------------------------------------------------------------------------
   ! Generate an informative message.
   !-------------------------------------------------------------------------------------------------
      
   CALL WrScr1( ' Reading a '//TRIM( Num2LStr(NYGrids) )//'x'//TRIM( Num2LStr(NZGrids) )//  &
            ' grid ('//TRIM( Num2LStr(FFYHWid*2) )//' m wide, '// &
            TRIM( Num2LStr(GridBase) )//' m to '//TRIM( Num2LStr(GridBase+FFZHWid*2) )//&
            ' m above ground) with a characterstic wind speed of '//TRIM( Num2LStr(MeanFFWS) )//' m/s. ' )

   !-------------------------------------------------------------------------------------------------
   ! Allocate space for the FF array 
   !-------------------------------------------------------------------------------------------------

   TmpNumSteps = NFFSteps + 1       ! add another step, just in case there is an odd number of steps.

!bjj: should we reorganize this FFData array so we access the data faster?
   
   IF ( .NOT. ALLOCATED( FFData ) ) THEN
      ALLOCATE ( FFData(NZGrids,NYGrids,NFFComp,TmpNumSteps),STAT=ErrStat )

      IF ( ErrStat /= 0 )  THEN

         CALL WrScr( ' Cannot allocate the full-field wind data array.' )
         RETURN

      ENDIF
      
   ELSE
      IF (SIZE(FFDATA,1) /= NZGrids .OR. SIZE(FFDATA,2) /= NYGrids .OR. &
          SIZE(FFDATA,3) /= NFFComp .OR. SIZE(FFDATA,3) /= TmpNumSteps ) THEN
          
            ! Let's make the array the correct size (we should never get here, but you never know)
            
         DEALLOCATE( FFData )
          
         ALLOCATE ( FFData(NZGrids,NYGrids,NFFComp,TmpNumSteps),STAT=ErrStat )

         IF ( ErrStat /= 0 )  THEN

            CALL WrScr( ' Cannot allocate the full-field wind data array.' )
            RETURN

         END IF ! Error
          
      END IF !Incorrect size
   END IF ! allocated

   !-------------------------------------------------------------------------------------------------
   ! Initialize the data and set column indexing to account for direction of turbine rotation (CWise)
   !-------------------------------------------------------------------------------------------------
   
   FFData(:,:,:,:) = 0.0                        ! we may have only one component
   
   IF ( CWise )  THEN
      CFirst    = NYGrids
      CLast     = 1
      CStep     = -1
   ELSE
      CFirst    = 1
      CLast     = NYGrids
      CStep     = 1
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Loop through all the time steps, reading the data and converting to m/s
   !-------------------------------------------------------------------------------------------------
!bjj: should we reorganize this FFData array so we access the data faster?
  
   NFFSteps = TmpNumSteps
  
TIME_LOOP:  DO IT=1,TmpNumSteps     ! time (add 1 to see if there is an odd number of grids)
   
      DO IR=1,NZGrids               ! the rows (vertical)
      
         DO IC=CFirst,CLast,CStep   ! the columns (lateral)
         
            DO I=1,NFFComp          ! wind components (U, V, W)
            
               READ (UnWind,IOStat=ErrStat)  Dum_Int2
               IF (ErrStat /= 0) THEN
                  IF ( IT == TmpNumSteps ) THEN ! There really were an even number of steps
                     NFFSteps = TmpNumSteps - 1
                     ErrStat  = 0
                     EXIT TIME_LOOP       
                  ELSE               
                     CALL WrScr( ' Error reading binary data file. ic = '//TRIM(Num2LStr(ic))// &
                                    ', ir = '//TRIM(Num2LStr(ir))//', it = '//TRIM(Num2LStr(it))// &
                                    ', nffsteps = '//TRIM(Num2LStr(nffsteps)) )
                     ErrStat = 1
                     RETURN
                  END IF
               ELSE               
                  FFData(IR,IC,I,IT) = MeanFFWS*(FF_Offset(I)+0.00001*TI(I)*Dum_Int2) 
               END IF
               
            END DO !I

         END DO !IC

      END DO !IR

   END DO TIME_LOOP !IT
   
   IF ( Periodic ) THEN
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data (period of '//TRIM( Num2LStr( FFDTime*NFFSteps ) )//' seconds).' )
   ELSE                     
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data ('//TRIM( Num2LStr( FFDTime*( NFFSteps - 1 ) ) )//' seconds).' )
   END IF

END SUBROUTINE Read_Bladed_Grids
!====================================================================================================
SUBROUTINE Read_Summary_FF ( UnWind, FileName, CWise, ZCenter, TI, ErrStat )
! This subroutine reads the text summary file to get normalizing parameters, the location of the
! grid, and the direction the grid was written to the binary file
!----------------------------------------------------------------------------------------------------

   INTEGER,     INTENT(IN)    :: UnWind         ! unit number for the file to open
   CHARACTER(*),INTENT(IN)    :: FileName       ! name of the summary file
   LOGICAL,     INTENT(OUT)   :: CWise          ! rotation (for reading the order of the binary data)
   REAL(ReKi),  INTENT(OUT)   :: ZCenter        ! the height at the center of the grid
   REAL(ReKi),  INTENT(OUT)   :: TI      (3)    ! turbulence intensities of the wind components as defined in the FF file, not necessarially the actual TI
   INTEGER,     INTENT(OUT)   :: ErrStat        ! returns 0 if no error encountered in the subroutine
   
   REAL(ReKi)                 :: ZGOffset       ! The vertical offset of the turbine on rectangular grid (allows turbulence not centered on turbine hub)

   
   INTEGER, PARAMETER         :: NumStrings = 6 ! number of strings to be looking for in the file

   INTEGER                    :: FirstIndx      ! The first character of a line where data is located
   INTEGER                    :: I              ! A loop counter
   INTEGER                    :: LastIndx       ! The last  character of a line where data is located
   INTEGER                    :: LineCount      ! Number of lines that have been read in the file
   INTEGER                    :: Status         ! Status from I/O calls
   
   LOGICAL                    :: StrNeeded(NumStrings)   ! if the string has been found
   
   CHARACTER(1024)            :: LINE           ! temporary storage for reading a line from the file
   
      !----------------------------------------------------------------------------------------------
      ! Initialize some variables
      !----------------------------------------------------------------------------------------------

   ErrStat      = 0
   LineCount    = 0
   StrNeeded(:) = .TRUE.
   ZGOffset     = 0.0
   RefHt        = 0.0
   Periodic     = .FALSE.
   
      !----------------------------------------------------------------------------------------------
      ! Open summary file.
      !----------------------------------------------------------------------------------------------
      
   CALL OpenFInpFile ( UnWind, TRIM( FileName ), ErrStat) 


      !----------------------------------------------------------------------------------------------
      ! Read the summary file.
      !----------------------------------------------------------------------------------------------

   DO WHILE ( ( ErrStat == 0 ) .AND. StrNeeded(NumStrings) )

      LineCount = LineCount + 1

      READ ( UnWind, '(A)', IOSTAT=ErrStat ) LINE
      IF ( ErrStat /= 0 ) THEN
      
         IF ( StrNeeded(NumStrings-1) ) THEN  ! the "HEIGHT OFFSET" StrNeeded(NumStrings) parameter is not necessary.  We'll assume it's zero if we didn't find it.
            CALL WrScr( ' Error reading line #'//TRIM(Num2LStr(LineCount))//' of the summary file, "'//TRIM(FileName)//'"' )
            CALL WrScr( 'Could not find all of the required parameters.' )
            ErrStat = NumStrings+1
            RETURN
         ELSE           
            EXIT
         ENDIF
         
      END IF
      
      CALL Conv2UC ( LINE )
            

      IF ( StrNeeded(1) ) THEN
      
         !-------------------------------------------------------------------------------------------
         ! #1: Get the rotation direction, using the string "CLOCKWISE" 
         !-------------------------------------------------------------------------------------------
            
         IF ( INDEX( LINE, 'CLOCKWISE' ) > 0 ) THEN
            
            READ (LINE, *, IOSTAT = Status)  CWise          ! Look for True/False values

            IF ( Status /= 0 ) THEN                         ! Look for Yes/No values instead

               LINE = ADJUSTL ( LINE )                      ! Remove leading spaces from input line

               SELECT CASE (LINE(1:1) )
                  CASE ('Y')
                     CWise = .TRUE.
                  CASE ('N')
                     CWise = .FALSE.
                  CASE DEFAULT                  
                     CALL WrScr( ' Error reading rotation direction (CLOCKWISE) from FF summary file.' )
                     ErrStat = 1
                     RETURN
               END SELECT
               
            END IF ! Status /= 0
            StrNeeded(1) = .FALSE.
            
         END IF   ! INDEX for "CLOCKWISE"
         
      ELSEIF ( StrNeeded(2) ) THEN
      
         !-------------------------------------------------------------------------------------------
         ! #2: Get the hub height, using the strings "HUB HEIGHT" or "ZHUB"
         !-------------------------------------------------------------------------------------------

         IF ( INDEX( LINE, 'HUB HEIGHT' ) > 0 .OR. INDEX( LINE, 'ZHUB' ) > 0 ) THEN
         
            READ (LINE, *, IOSTAT = Status) RefHt
         
            IF ( Status /= 0 ) THEN
               CALL WrScr( ' Error reading hub height from FF summary file.' )
               ErrStat = 2
               RETURN
            END IF ! Status /= 0
            StrNeeded(2) = .FALSE.
                  
         END IF !INDEX for "HUB HEIGHT" or "ZHUB"
         
         
!      ELSEIF ( StrNeeded(3) ) THEN
!
!         !-------------------------------------------------------------------------------------------
!         ! #3: Get the grid width (& height, if available), using the strings "GRID WIDTH" or "RDIAM"
!         !    If GRID HEIGHT is specified, use it, too. -- THIS IS UNNECESSARY AS IT'S STORED IN THE BINARY FILE
!         !-------------------------------------------------------------------------------------------         

      ELSEIF ( StrNeeded(4) ) THEN
      
         !-------------------------------------------------------------------------------------------
         ! #4: Get the mean wind speed "UBAR" and turbulence intensities from following lines for 
         !     scaling Bladed-style FF binary files
         !-------------------------------------------------------------------------------------------         

         IF ( INDEX( LINE, 'UBAR') > 0 ) THEN

            FirstIndx = INDEX( LINE, '=' ) + 1        ! Look for the equal siqn to find the number we're looking for

            READ ( LINE( FirstIndx:LEN(LINE) ), *, IOSTAT=Status ) MeanFFWS

            IF ( Status /= 0 ) THEN
               CALL WrScr( ' Error reading UBar binary data normalizing parameter from FF summary file.' )
               ErrStat = 4
               RETURN
            END IF ! Status /= 0      

            DO I = 1,3

               LineCount = LineCount + 1

               READ ( UnWind, '(A)', IOSTAT=Status ) LINE
               IF ( Status /= 0 ) THEN
                  CALL WrScr( ' Error reading line #'//TRIM(Num2LStr(LineCount))//' of the summary file, "'//TRIM(FileName)//'"' )
                  CALL WrScr( 'Could not find all of the required parameters.' )
                  ErrStat = Status
                  RETURN
               END IF

               FirstIndx = INDEX( LINE, '=' ) + 1     ! Read the number between the = and % signs
               LastIndx  = INDEX( LINE, '%' ) - 1

               IF ( LastIndx <= FirstIndx ) LastIndx = LEN( LINE )   ! If there's no % sign, read to the end of the line

               READ ( LINE( FirstIndx:LastIndx ), *, IOSTAT=Status ) TI(I)
               IF ( Status /= 0 ) THEN
                  CALL WrScr( ' Error reading TI('//TRIM(Num2LStr(I))//') binary data normalizing parameter from FF summary file.' )
                  ErrStat = 4
                  RETURN
               END IF ! Status /= 0      

            END DO !I

            StrNeeded(4) = .FALSE.            

          END IF
      
      ELSEIF ( StrNeeded(5) ) THEN
         
         !-------------------------------------------------------------------------------------------
         ! #5: Get the grid "HEIGHT OFFSET", if it exists (in TurbSim). Otherwise, assume it's zero 
         !           ZGOffset = HH - GridBase - FFZHWid
         !-------------------------------------------------------------------------------------------         
         IF ( INDEX( LINE, 'HEIGHT OFFSET' ) > 0  ) THEN
         
            FirstIndx = INDEX ( LINE, '=' ) + 1

            READ ( LINE( FirstIndx:LEN(LINE) ), *, IOSTAT=Status ) ZGOffset            
                  
            IF ( Status /= 0 ) THEN
               CALL WrScr( ' Error reading height offset from FF summary file.' )
               ErrStat = 5
               RETURN
            END IF ! Status /= 0
                  
            StrNeeded(5) = .FALSE.
            
         END IF !INDEX for "HEIGHT OFFSET"

      ELSEIF ( StrNeeded(6) ) THEN
         
         !-------------------------------------------------------------------------------------------
         ! #5: Get the grid "PERIODIC", if it exists (in TurbSim). Otherwise, assume it's  
         !        not a periodic file
         !-------------------------------------------------------------------------------------------         
         IF ( INDEX( LINE, 'PERIODIC' ) > 0  ) THEN
         
            Periodic     = .TRUE.                  
            StrNeeded(6) = .FALSE.
            
         END IF !INDEX for "PERIODIC"
         
      END IF ! StrNeeded
      
      
   END DO !WHILE

   ErrStat = 0    ! We made it to the end of the file
   
   !-------------------------------------------------------------------------------------------------
   ! Close the summary file
   !-------------------------------------------------------------------------------------------------         
   
   CLOSE ( UnWind )


   !-------------------------------------------------------------------------------------------------
   ! Calculate the height of the grid center
   !-------------------------------------------------------------------------------------------------         

    ZCenter  = RefHt - ZGOffset


END SUBROUTINE Read_Summary_FF
!====================================================================================================
SUBROUTINE Read_TurbSim_FF(UnWind,WindFile, ErrStat)
! This subroutine reads the binary TurbSim-format FF file (.bts).  It fills the FFData array with
! velocity data for the grids and fills the FFtower array with velocities at points on the tower 
! (if data exists).
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,      INTENT(IN)   :: UnWind            ! unit number for the wind file
   CHARACTER(*), INTENT(IN)   :: WindFile          ! name of the binary TurbSim file
   INTEGER,      INTENT(OUT)  :: ErrStat           ! error status return value (0=no error; non-zero is error)

      ! Local Variables:

   REAL(SiKi)                 :: Dum_Real4         ! dummy 4-byte real number
   INTEGER(B1Ki)              :: Dum_Int1          ! dummy 1-byte integer
   INTEGER(B2Ki)              :: Dum_Int2          ! dummy 2-byte integer
   INTEGER(B4Ki)              :: Dum_Int4          ! dummy 4-byte integer

   INTEGER                    :: IC                ! loop counter for wind components
   INTEGER                    :: IT                ! loop counter for time
   INTEGER                    :: IY                ! loop counter for y
   INTEGER                    :: IZ                ! loop counter for z
   INTEGER                    :: NChar             ! number of characters in the description string
   
   REAL(SiKi)                 :: Vslope(3)         ! slope  for "un-normalizing" data
   REAL(SiKi)                 :: Voffset(3)        ! offset for "un-normalizing" data
            
   CHARACTER(1024)            :: DescStr           ! description string contained in the file


   NFFComp = 3                                              ! this file contains 3 wind components
         
   !-------------------------------------------------------------------------------------------------
   ! Open the file
   !-------------------------------------------------------------------------------------------------

   CALL OpenBInpFile (UnWind, TRIM(WindFile), ErrStat)
   IF (ErrStat /= 0) RETURN
      
   !-------------------------------------------------------------------------------------------------
   ! Read the header information
   !-------------------------------------------------------------------------------------------------
      READ (UnWind, IOSTAT=ErrStat)  Dum_Int2               ! the file identifier, INT(2)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the file identifier in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF         
         Periodic = Dum_Int2 == INT( 8, B2Ki) ! the number 7 is used for non-periodic wind files; 8 is periodic wind


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4               ! the number of grid points vertically, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of z grid points in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NZgrids = Dum_Int4       

     
      READ (UnWind, IOSTAT=ErrStat) Dum_Int4                ! the number of grid points laterally, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of y grid points in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NYgrids = Dum_Int4


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4               ! the number of tower points, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of tower points in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NTgrids = Dum_Int4
         

      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4               ! the number of time steps, INT(4)
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading the number of time steps in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NFFSteps = Dum_Int4


      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! grid spacing in vertical direction (dz), REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dz in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         InvFFZD = 1.0/Dum_Real4                            ! 1/dz
         FFZHWid = 0.5*(NZgrids-1)*Dum_Real4                ! half the grid height


      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! grid spacing in lateral direction (dy), REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dy in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         InvFFYD = 1.0 / Dum_Real4                          ! 1/dy
         FFYHWid = 0.5*(NYgrids-1)*Dum_Real4                ! half grid grid width


      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! grid spacing in time (dt), REAL(4), in m/s
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dt in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         FFDTime = Dum_Real4
         FFRate  = 1.0/FFDTime
                  
                  
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! the mean wind speed at hub height, REAL(4), in m/s
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading mean wind speed in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         MeanFFWS = Dum_Real4
         InvMFFWS = 1.0 / MeanFFWS
         
         
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! height of the hub, REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading zHub in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         RefHt = Dum_Real4
         
         
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4              ! height of the bottom of the grid, REAL(4), in m
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading GridBase in the FF binary file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         GridBase = Dum_Real4

 !        ZGOffset = RefHt - GridBase  - FFZHWid
         
         
      !----------------------------------------------------------------------------------------------
      ! Read the binary scaling factors
      !----------------------------------------------------------------------------------------------         
         
         DO IC = 1,NFFComp         
            READ (UnWind, IOSTAT=ErrStat)  Vslope(IC)       ! the IC-component slope for scaling, REAL(4)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr ( ' Error reading Vslope('//Num2LStr(IC)//') in the FF binary file "'//TRIM( WindFile )//'."' )
                  RETURN
               ENDIF


            READ (UnWind, IOSTAT=ErrStat)  Voffset(IC)      ! the IC-component offset for scaling, REAL(4)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr ( ' Error reading Voffset('//Num2LStr(IC)//') in the FF binary file "'//TRIM( WindFile )//'."' )
                  RETURN
               ENDIF
               
         END DO !IC


      !----------------------------------------------------------------------------------------------
      ! Read the description string: "Generated by TurbSim (vx.xx, dd-mmm-yyyy) on dd-mmm-yyyy at hh:mm:ss."
      !----------------------------------------------------------------------------------------------

         READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                ! the number of characters in the description string, max 200, INT(4)
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error reading NCHAR in the FF binary file "'//TRIM( WindFile )//'."' )
               RETURN
            ENDIF
            nchar = Dum_Int4
            
         DescStr = ''                                       ! Initialize the description string
         
         DO IC=1,nchar

            READ (UnWind, IOSTAT=ErrStat) Dum_Int1          ! the ASCII integer representation of the character, INT(1)
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error reading description line in the FF binary file "'//TRIM( WindFile )//'."' )
               RETURN
            ENDIF
            
            IF ( LEN(DescStr) >= IC ) THEN
               DescStr(IC:IC) = ACHAR( Dum_Int1 )              ! converted ASCII characters
            ELSE
               CALL WrScr ( ' Description string too long.' )
               EXIT
            END IF

         ENDDO !IC


   !-------------------------------------------------------------------------------------------------
   ! Get the grid and tower velocities
   !-------------------------------------------------------------------------------------------------

   CALL WrScr1( ' Reading a '//TRIM( Num2LStr(NYGrids) )//'x'//TRIM( Num2LStr(NZGrids) )//  &
            ' grid ('//TRIM( Num2LStr(FFYHWid*2) )//' m wide, '// &
            TRIM( Num2LStr(GridBase) )//' m to '//TRIM( Num2LStr(GridBase+FFZHWid*2) )//&
            ' m above ground) with a characterstic wind speed of '//TRIM( Num2LStr(MeanFFWS) )//' m/s. '//TRIM(DescStr) )
               
               
   !----------------------------------------------------------------------------------------------
   ! Allocate arrays for the FF grid as well as the tower points, if they exist
   !----------------------------------------------------------------------------------------------
            
      IF ( .NOT. ALLOCATED( FFData ) ) THEN
         ALLOCATE ( FFData(NZGrids,NYGrids,NFFComp,NFFSteps), STAT=ErrStat )
               
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr( ' Cannot allocate the full-field wind data array.' )
            RETURN
         ENDIF         
      ENDIF
         
     
      IF ( NTgrids > 0 ) THEN
      
         IF ( .NOT. ALLOCATED( FFtower ) ) THEN
            ALLOCATE( FFtower( NFFComp, NTgrids, NFFSteps ), STAT=ErrStat )
            
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Cannot allocate the tower wind data array.' )
               RETURN
            ENDIF            
         ENDIF
         
      ENDIF         
      
   !-------------------------------------------------------------------------------------------------
   ! Read the 16-bit data and scale it to 32-bit reals
   !-------------------------------------------------------------------------------------------------
               
      ! Loop through time.

      DO IT=1,NFFSteps
      
         !...........................................................................................
         ! Read grid data at this time step.
         !...........................................................................................

         DO IZ=1,NZgrids
            ! Zgrid(IZ) = Z1 + (IZ-1)*dz                 ! Vertical location of grid data point, in m relative to ground

            DO IY=1,NYgrids
               ! Ygrid(IY) = -0.5*(ny-1)*dy + (IY-1)*dy  ! Horizontal location of grid data point, in m relative to tower centerline
            
               DO IC=1,NFFComp                           ! number of wind components (U, V, W)

                  READ (UnWind, IOSTAT=ErrStat)  Dum_Int2      ! normalized wind-component, INT(2)
                  IF ( ErrStat /= 0 )  THEN
                     CALL WrScr ( ' Error reading grid wind components in the FF binary file "'//TRIM( WindFile )//'."' )
                     RETURN
                  ENDIF
                  
                  FFData(IZ,IY,IC,IT) = ( Dum_Int2 - Voffset(IC) ) / VSlope(IC)

               ENDDO !IC

            ENDDO !IY
            
         ENDDO ! IZ


         !...........................................................................................
         ! Read the tower data at this time step.
         !...........................................................................................
            
         DO IZ=1,NTgrids         ! If NTgrids<1, there are no tower points & FFtower is not allocated

            ! Ytower     = 0               ! Lateral location of the tower data point, in m relative to tower centerline
            ! Ztower(IZ) = Z1 - (IZ-1)*dz  ! Vertical location of tower data point, in m relative to ground

            DO IC=1,NFFComp   ! number of wind components

               READ (UnWind, IOSTAT=ErrStat)  Dum_Int2      ! normalized wind-component, INT(2)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr ( ' Error reading tower wind components in the FF binary file "'//TRIM( WindFile )//'."' )
                  RETURN
               ENDIF
               
               FFtower(IC,IZ,IT) = ( Dum_Int2 - Voffset(IC) ) / VSlope(IC)  ! wind-component scaled to m/s

            ENDDO !IC

         ENDDO ! IZ


      ENDDO ! IT

   !-------------------------------------------------------------------------------------------------
   ! close the file and return
   !-------------------------------------------------------------------------------------------------
   
   CLOSE ( UnWind )


   IF ( Periodic ) THEN
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data (period of '//TRIM( Num2LStr( FFDTime*( NFFSteps ) ) )//' seconds).' )
   ELSE
      CALL WrScr ( ' Processed '//TRIM( Num2LStr( NFFSteps ) )//' time steps of '//TRIM( Num2LStr ( FFRate ) )// & 
                     '-Hz full-field data ('//TRIM( Num2LStr( FFDTime*( NFFSteps - 1 ) ) )//' seconds).' )
   END IF                  

   RETURN

END SUBROUTINE READ_TurbSim_FF
!====================================================================================================
SUBROUTINE Read_FF_Tower( UnWind, WindFile, ErrStat )
! This subroutine reads the binary tower file that corresponds with the Bladed-style FF binary file.
! The FF grid must be read before this subroutine is called! (many checks are made to ensure the
! files belong together)
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,      INTENT(IN)   :: UnWind            ! unit number for the wind file
   CHARACTER(*), INTENT(IN)   :: WindFile          ! name of the binary TurbSim file
   INTEGER,      INTENT(OUT)  :: ErrStat           ! error status return value (0=no error; non-zero is error)

      ! Local Variables:

   REAL(SiKi)                 :: Dum_Real4         ! dummy 4-byte real number
   INTEGER(B2Ki)              :: Dum_Int2          ! dummy 2-byte integer
   INTEGER(B4Ki)              :: Dum_Int4          ! dummy 4-byte integer

   INTEGER                    :: IC                ! loop counter for wind components
   INTEGER                    :: IT                ! loop counter for time
   INTEGER                    :: IZ                ! loop counter for z
   
   REAL(ReKi), PARAMETER      :: TOL = 1E-4        ! tolerence for wind file comparisons

   REAL(ReKi), PARAMETER      :: FF_Offset(3) = (/ 1.0, 0.0, 0.0 /)  ! used for "un-normalizing" the data
   REAL(SiKi)                 :: TI       (3)      ! scaling values for "un-normalizing the data" [approx. turbulence intensities of the wind components]

   !-------------------------------------------------------------------------------------------------
   ! 
   !-------------------------------------------------------------------------------------------------

   NTgrids = 0

   IF ( NFFComp /= 3 ) THEN
      CALL WrScr( ' Error: Tower binary files require 3 wind components.' )
      ErrStat = 1
      RETURN
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Open the file
   !-------------------------------------------------------------------------------------------------

   CALL OpenBInpFile (UnWind, TRIM(WindFile), ErrStat)
   IF (ErrStat /= 0) THEN
      ErrStat = -1
      RETURN
   END IF
      
   !-------------------------------------------------------------------------------------------------
   ! Read the header information and check that it's compatible with the FF Bladed-style binary
   ! parameters already read.
   !-------------------------------------------------------------------------------------------------
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! dz, in meters [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dz in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( ABS(Dum_Real4*InvFFZD-1) > TOL ) THEN
            CALL WrScr ( ' Resolution in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF
         
         
      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! dx, in meters [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading dx in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         
         IF ( ABS(Dum_Real4*InvMFFWS/FFDTime-1) > TOL ) THEN
            CALL WrScr ( ' Time resolution in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF
         

      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! Zmax, in meters [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading GridBase in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( ABS(Dum_Real4/GridBase-1) > TOL ) THEN
            CALL WrScr ( ' Height in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                  ! NumOutSteps [4-byte INTEGER]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading NumOutSteps in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( Dum_Int4 /= NFFSteps ) THEN
            CALL WrScr ( ' Number of time steps in the FF binary file does not match the tower file.' )
            ErrStat = 1
            RETURN
         END IF


      READ (UnWind, IOSTAT=ErrStat)  Dum_Int4                  ! NumZ      [4-byte INTEGER]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading NumZ in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF
         NTgrids = Dum_Int4
         

      READ (UnWind, IOSTAT=ErrStat)  Dum_Real4                 ! UHub      [4-byte REAL]
         IF ( ErrStat /= 0 )  THEN
            CALL WrScr ( ' Error reading UHub in the binary tower file "'//TRIM( WindFile )//'."' )
            RETURN
         ENDIF

         IF ( ABS(Dum_Real4*InvMFFWS - 1) > TOL ) THEN
            CALL WrScr ( ' Mean wind speed in the FF binary file does not match the tower file.' )
            ErrStat = 1
            NTgrids = 0
            RETURN
         END IF


      DO IC=1,3
         READ (UnWind, IOSTAT=ErrStat)  TI(IC)               ! TI(u), TI(v), TI(w)  [4-byte REAL]
            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error reading TI('//TRIM(Num2LStr(IC))//') in the binary tower file "' &
                               //TRIM( WindFile )//'."' )
               NTgrids = 0                               
               RETURN
            ENDIF
      END DO      

   !----------------------------------------------------------------------------------------------
   ! Allocate arrays for the tower points
   !----------------------------------------------------------------------------------------------        
     
      IF ( NTgrids > 0 ) THEN
      
         IF ( .NOT. ALLOCATED( FFtower ) ) THEN
!            CALL AllocAry( FFtower, NFFComp, NTgrids, NFFSteps, 'tower wind data', ErrStat )            
            ALLOCATE ( FFtower(NFFComp,NTgrids,NFFSteps), STAT=ErrStat )

            IF ( ErrStat /= 0 )  THEN
               CALL WrScr ( ' Error allocating memory for the tower wind data array.' )
               NTgrids = 0
               RETURN
            END IF

         ELSE
            ! Check sizes here!
         ENDIF
         
      ENDIF         
      
   !-------------------------------------------------------------------------------------------------
   ! Read the 16-bit time-series data and scale it to 32-bit reals
   !-------------------------------------------------------------------------------------------------
               
      ! Loop through time.

      DO IT=1,NFFSteps

         DO IZ=1,NTgrids         ! If NTgrids<1, there are no tower points & FFtower is not allocated

            ! Ytower     = 0               ! Lateral location of the tower data point, in m relative to tower centerline
            ! Ztower(IZ) = Z1 - (IZ-1)*dz  ! Vertical location of tower data point, in m relative to ground

            DO IC=1,NFFComp   ! number of wind components

               READ (UnWind, IOSTAT=ErrStat)  Dum_Int2      ! normalized wind-component, INT(2)
               IF ( ErrStat /= 0 )  THEN
                  CALL WrScr( ' Error reading binary tower data file. it = '//TRIM(Num2LStr(it))// &
                                 ', nffsteps = '//TRIM(Num2LStr(nffsteps)) )
                  ErrStat = 1  
                  NTgrids = 0            
                  RETURN
               ENDIF
               
               FFtower(IC,IZ,IT) = MeanFFWS*(FF_Offset(IC)+0.00001*TI(IC)*Dum_Int2)   ! wind-component scaled to m/s

            ENDDO !IC

         ENDDO ! IZ


      ENDDO ! IT   

   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
   CLOSE ( UnWind )


   CALL WrScr ( ' Processed '//TRIM( Num2LStr(NFFSteps) )//' time steps of '//TRIM( Num2LStr(NTgrids) )//'x1 tower data grids.')


   RETURN

END SUBROUTINE Read_FF_Tower
!====================================================================================================
FUNCTION FF_GetRValue(RVarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the RVarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------

   CHARACTER(*),   INTENT(IN)    :: RVarName
   INTEGER,        INTENT(OUT)   :: ErrStat
   REAL(ReKi)                    :: FF_GetRValue

   
   CHARACTER(20)                 :: VarNameUC
   

   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FFWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = RVarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
   
      CASE ('HUBHEIGHT', 'REFHEIGHT' )
         FF_GetRValue = RefHt
         
      CASE ('GRIDWIDTH', 'FFYWID' )
         FF_GetRValue = FFYHWid*2

      CASE ('GRIDHEIGHT', 'FFZWID' )
         FF_GetRValue = FFZHWid*2
         
      CASE ('MEANFFWS' )
         FF_GetRValue = MeanFFWS         
         
      CASE DEFAULT
         CALL WrScr( ' Invalid variable name in FF_GetRValue().' )
         ErrStat = 1
         
   END SELECT

END FUNCTION FF_GetRValue
!====================================================================================================
FUNCTION FF_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are are 
! requested.  It determines if the point is on the FF grid or tower points and calls the
! corresponding interpolation routine, which returns the velocities at the specified time and space.
!----------------------------------------------------------------------------------------------------
   
   REAL(ReKi),        INTENT(IN) :: Time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)
   INTEGER,           INTENT(OUT):: ErrStat
   TYPE(InflIntrpOut)            :: FF_GetWindSpeed
   
   REAL(ReKi), PARAMETER         :: TOL = 1E-3
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   
   
   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FFWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      

   
   !-------------------------------------------------------------------------------------------------
   ! Find out if the location is on the grid on on tower points; interpolate and return the value.
   !-------------------------------------------------------------------------------------------------   

    FF_GetWindSpeed%Velocity = FF_Interp(Time,InputPosition, ErrStat)


!   IF ( InputPosition(3) >= GridBase - TOL ) THEN  
!   
!         ! Get the velocities interpolated on the FF grid
!      
!      FF_GetWindSpeed%Velocity = FF_Interp(Time,InputPosition, ErrStat)
!      
!   ELSE
!   
!         ! Get the velocities interpolated below the FF grid, on the tower points
!
!      IF ( NTgrids < 1 ) THEN
!      
!         CALL WrScr( ' Error: FF interpolation height is below the grid and no tower points have been defined.' )
!         ErrStat = 1
!         RETURN
!         
!      ELSE
!      
!         FF_GetWindSpeed%Velocity = FF_TowerInterp(Time,InputInfo%Position, ErrStat)
!         
!      END IF   ! NTgrids < 1
!      
!   
!   END IF      ! InputInfo%Position(3)>= GridBase


END FUNCTION FF_GetWindSpeed
!====================================================================================================
FUNCTION FF_Interp(Time, Position, ErrStat)
!    This function is used to interpolate into the full-field wind array or tower array if it has   
!    been defined and is necessary for the given inputs.  It receives X, Y, Z and
!    TIME from the calling routine.  It then computes a time shift due to a nonzero X based upon 
!    the average windspeed.  The modified time is used to decide which pair of time slices to interpolate
!    within and between.  After finding the two time slices, it decides which four grid points bound the 
!    (Y,Z) pair.  It does a bilinear interpolation for each time slice. Linear interpolation is then used 
!    to interpolate between time slices.  This routine assumes that X is downwind, Y is to the left when  
!    looking downwind and Z is up.  It also assumes that no extrapolation will be needed.
!    
!    If tower points are used, it assumes the velocity at the ground is 0.  It interpolates between
!    heights and between time slices, but ignores the Y input.
!
!    11/07/94 - Created by M. Buhl from the original TURBINT.
!    09/25/97 - Modified by M. Buhl to use f90 constructs and new variable names.  Renamed to FF_Interp.
!    09/23/09 - Modified by B. Jonkman to use arguments instead of modules to determine time and position.  
!               Height is now relative to the ground
!
!----------------------------------------------------------------------------------------------------

   IMPLICIT                      NONE

   REAL(ReKi),      INTENT(IN) :: Position(3)       ! takes the place of XGrnd, YGrnd, ZGrnd
   REAL(ReKi),      INTENT(IN) :: Time
   REAL(ReKi)                  :: FF_Interp(3)      ! The U, V, W velocities

   INTEGER,         INTENT(OUT):: ErrStat

      ! Local Variables:

   REAL(ReKi)                  :: TimeShifted
   REAL(ReKi),PARAMETER        :: Tol = 1.0E-3      ! a tolerance for determining if two reals are the same (for extrapolation)
   REAL(ReKi)                  :: W_YH_Z
   REAL(ReKi)                  :: W_YH_ZH
   REAL(ReKi)                  :: W_YH_ZL
   REAL(ReKi)                  :: W_YL_Z
   REAL(ReKi)                  :: W_YL_ZH
   REAL(ReKi)                  :: W_YL_ZL
   REAL(ReKi)                  :: Wnd      (2)
   REAL(ReKi)                  :: T
   REAL(ReKi)                  :: TGRID
   REAL(ReKi)                  :: Y
   REAL(ReKi)                  :: YGRID
   REAL(ReKi)                  :: Z
   REAL(ReKi)                  :: ZGRID

   INTEGER                    :: IDIM
   INTEGER                    :: IG
   INTEGER                    :: IT
   INTEGER                    :: ITHI
   INTEGER                    :: ITLO
   INTEGER                    :: IYHI
   INTEGER                    :: IYLO
   INTEGER                    :: IZHI
   INTEGER                    :: IZLO
   
   LOGICAL                    :: OnGrid
   
   !-------------------------------------------------------------------------------------------------
   ! Initialize variables
   !-------------------------------------------------------------------------------------------------

   FF_Interp(:)          = 0.0                         ! the output velocities (in case NFFComp /= 3)
   Wnd(:)                = 0.0                         ! just in case we're on an end point

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding time slices.
   !-------------------------------------------------------------------------------------------------

   ! Perform the time shift.  At time=0, a point half the grid width downstream (FFYHWid) will index into the zero time slice.  
   ! If we did not do this, any point downstream of the tower at the beginning of the run would index outside of the array.   
   ! This all assumes the grid width is at least as large as the rotor.  If it isn't, then the interpolation will not work.


   TimeShifted = TIME + ( InitXPosition - Position(1) )*InvMFFWS    ! in distance, X: InputInfo%Position(1) - InitXPosition - TIME*MeanFFWS
      

   IF ( Periodic ) THEN ! translate TimeShifted to ( 0 <= TimeShifted < TotalTime )

      TimeShifted = MODULO( TimeShifted, TotalTime )
   
      TGRID = TimeShifted*FFRate
      ITLO  = INT( TGRID )             ! convert REAL to INTEGER (add 1 later because our grids start at 1, not 0) 
      T     = TGRID - ITLO             ! a value between 0 and 1 that indicates a relative location between ITLO and ITHI   
      
      ITLO = ITLO + 1
      IF ( ITLO == NFFSteps ) THEN
         ITHI = 1
      ELSE
         ITHI = ITLO + 1
      END IF
      
      
   ELSE
   
      TGRID = TimeShifted*FFRate
      ITLO  = INT( TGRID )             ! convert REAL to INTEGER (add 1 later because our grids start at 1, not 0) 
      T     = TGRID - ITLO             ! a value between 0 and 1 that indicates a relative location between ITLO and ITHI   
   
      ITLO = ITLO + 1                  ! add one since our grids start at 1, not 0 
      ITHI = ITLO + 1   

      IF ( ITLO >= NFFSteps .OR. ITLO < 1 ) THEN
         IF ( ITLO == NFFSteps  ) THEN
            ITHI = ITLO   
            IF ( T <= TOL ) THEN ! we're on the last point
               T = 0.0
            ELSE  ! We'll extrapolate one dt past the last value in the file
               ITLO = ITHI - 1
            END IF         
         ELSE                 
            CALL WrScr( ' Error: FF wind array was exhausted at '//TRIM( Num2LStr( REAL( TIME,   ReKi ) ) )// & 
                           ' seconds (trying to access data at '//TRIM( Num2LStr( REAL( TimeShifted, ReKi ) ) )//' seconds).'  )
            ErrStat = 1   
            RETURN
         END IF
      ENDIF

   END IF


   !-------------------------------------------------------------------------------------------------
   ! Find the bounding rows for the Z position. [The lower-left corner is (1,1) when looking upwind.]
   !-------------------------------------------------------------------------------------------------

   ZGRID = ( Position(3) - GridBase )*InvFFZD

   IF (ZGRID > -1*TOL) THEN
      OnGrid = .TRUE.
      
      IZLO = INT( ZGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
      IZHI = IZLO + 1

      Z = ZGRID - ( IZLO - 1 )            ! a value between 0 and 1 that indicates a relative location between IZLO and IZHI

      IF ( IZLO < 1 ) THEN
         IF ( IZLO == 0 .AND. Z >= 1.0-TOL ) THEN
            Z    = 0.0 
            IZLO = 1
         ELSE
            CALL WrScr( ' Error: FF wind array boundaries violated. Grid too small in Z direction (Z='//&
                        TRIM(Num2LStr(Position(3)))//' m is below the grid).' )
            ErrStat = 1   
            RETURN
         END IF
      ELSEIF ( IZLO >= NZGrids ) THEN
         IF ( IZLO == NZGrids .AND. Z <= TOL ) THEN
            Z    = 0.0
            IZHI = IZLO                   ! We're right on the last point, which is still okay
         ELSE      
            CALL WrScr( ' Error: FF wind array boundaries violated. Grid too small in Z direction (Z='//&
                        TRIM(Num2LStr(Position(3)))//' m is above the grid).' )
            ErrStat = 3   
            RETURN
         END IF         
      ENDIF

   ELSE
   
      OnGrid = .FALSE.  ! this is on the tower
      
      IF ( NTGrids < 1 ) THEN
         CALL WrScr ( ' Error: FF wind array boundaries violated. Grid too small in Z direction '// &
                       '(height (Z='//TRIM(Num2LStr(Position(3)))//' m) is below the grid and no tower points are defined).' )
         ErrStat = 1
         RETURN
      END IF

      IZLO = INT( -1.0*ZGRID ) + 1            ! convert REAL to INTEGER, then add one since our grids start at 1, not 0      
      

      IF ( IZLO >= NTGrids ) THEN  !our dz is the difference between the bottom tower point and the ground
         IZLO = NTGrids
         
         Z    = 1.0 - Position(3) / (GridBase - (IZLO-1)/InvFFZD) !check that this isn't 0         
      ELSE
         Z    = ABS(ZGRID) - (IZLO - 1)
      END IF
      IZHI = IZLO + 1
            
   END IF


   IF ( OnGrid ) THEN      ! The tower points don't use this

      !-------------------------------------------------------------------------------------------------
      ! Find the bounding columns for the Y position. [The lower-left corner is (1,1) when looking upwind.]
      !-------------------------------------------------------------------------------------------------

         YGRID = ( Position(2) + FFYHWid )*InvFFYD    ! really, it's (Position(2) - -1.0*FFYHWid)

         IYLO = INT( YGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
         IYHI = IYLO + 1

         Y    = YGRID - ( IYLO - 1 )         ! a value between 0 and 1 that indicates a relative location between IYLO and IYHI
         
         IF ( IYLO >= NYGrids .OR. IYLO < 1 ) THEN
            IF ( IYLO == 0 .AND. Y >= 1.0-TOL ) THEN
               Y    = 0.0 
               IYLO = 1
            ELSE IF ( IYLO == NYGrids .AND. Y <= TOL ) THEN
               Y    = 0.0
               IYHI = IYLO                   ! We're right on the last point, which is still okay      
            ELSE
               CALL WrScr( ' Error FF wind array boundaries violated: Grid too small in Y direction. Y=' &
                             //TRIM(Num2LStr(Position(2)))//'; Y boundaries = ['//TRIM(Num2LStr(-1.0*FFYHWid)) &
                             //', '//TRIM(Num2LStr(FFYHWid))//']' )
               ErrStat = 2   
               RETURN
            END IF
         ENDIF

      !-------------------------------------------------------------------------------------------------
      ! Interpolate on the grid 
      !-------------------------------------------------------------------------------------------------

      DO IDIM=1,NFFComp       ! all the components

         IT = ITLO            ! Start using the ITLO slice
   
         DO IG=1,2            ! repeat for 2 time slices (by changing the value of IT. note that we can't loop from IXLO to IXHI because they could be NFFSteps and 1 respectively)

            !-------------------------------------------------------------------------------------------
            ! Get the wind velocity values for the four corners of the grid for this time.
            !-------------------------------------------------------------------------------------------

            W_YL_ZL = FFData( IZLO, IYLO, IDIM, IT )
            W_YL_ZH = FFData( IZHI, IYLO, IDIM, IT )
            W_YH_ZL = FFData( IZLO, IYHI, IDIM, IT )
            W_YH_ZH = FFData( IZHI, IYHI, IDIM, IT )


            !-------------------------------------------------------------------------------------------
            ! Interpolate within the grid for this time.
            !-------------------------------------------------------------------------------------------

            W_YL_Z  = ( W_YL_ZH - W_YL_ZL )*Z + W_YL_ZL
            W_YH_Z  = ( W_YH_ZH - W_YH_ZL )*Z + W_YH_ZL
            Wnd(IG) = ( W_YH_Z  - W_YL_Z  )*Y + W_YL_Z

            IT = ITHI            ! repeat for the using the ITHI slice

         END DO !IG

         !----------------------------------------------------------------------------------------------
         ! Interpolate between the two times.
         !----------------------------------------------------------------------------------------------
         
         FF_Interp(IDIM) = ( Wnd(2) - Wnd(1) ) * T + Wnd(1)    ! interpolated velocity
         
      END DO !IDIM

   ELSE
   
   !-------------------------------------------------------------------------------------------------
   ! Interpolate on the tower array
   !-------------------------------------------------------------------------------------------------
      
      DO IDIM=1,NFFComp    ! all the components

         IT = ITLO            ! Start using the ITLO slice

         DO IG=1,2            ! repeat for 2 time slices (by changing the value of IT. note that we can't loop from IXLO to IXHI because they could be NFFSteps and 1 respectively)

            !-------------------------------------------------------------------------------------------
            ! Get the wind velocity values for the two corners of the grid for this time.
            !-------------------------------------------------------------------------------------------

            W_YH_ZL = FFTower( IDIM, IZLO, IT )
            
            IF ( IZHI > NTGrids ) THEN
               W_YH_ZH = 0.0
            ELSE
               W_YH_ZH = FFTower( IDIM, IZHI, IT )
            END IF


            !-------------------------------------------------------------------------------------------
            ! Interpolate within the grid for this time.
            !-------------------------------------------------------------------------------------------

            Wnd(IG) = ( W_YH_ZH - W_YH_ZL )*Z + W_YH_ZL

            IT = ITHI            ! repeat for the using the ITHI slice

         END DO !IG

         !----------------------------------------------------------------------------------------------
         ! Interpolate between the two times.
         !----------------------------------------------------------------------------------------------
         
         FF_Interp(IDIM) = ( Wnd(2) - Wnd(1) ) * T + Wnd(1)    ! interpolated velocity
         
      END DO !IDIM
   
   END IF ! OnGrid

   RETURN
   
END FUNCTION FF_Interp
!====================================================================================================
SUBROUTINE FF_Terminate( ErrStat )
!  This subroutine cleans up any data that is still allocated.  The (possibly) open files are 
!  closed in InflowWindMod.
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   ErrStat = 0

   IF ( ALLOCATED( FFData  ) )   DEALLOCATE( FFData,  STAT=ErrStat )   
   IF ( ALLOCATED( FFTower ) )   DEALLOCATE( FFTower, STAT=ErrStat )   
   
   Initialized = .FALSE.


END SUBROUTINE FF_Terminate
!====================================================================================================
END MODULE FFWind

MODULE HAWCWind
!
!  This module uses full-field binary wind files to determine the wind inflow.
!  This module assumes that the origin, (0,0,0), is located at the tower centerline at ground level,
!  and that all units are specified in the metric system (using meters and seconds).
!  Data is assumed periodic in the X direction (and thus not shifted like FFWind files are).
!
!  Created 25-June-2010 by B. Jonkman, National Renewable Energy Laboratory
!     using subroutines and modules from AeroDyn v12.58
!
!----------------------------------------------------------------------------------------------------

   USE      NWTC_Library
   USE      SharedInflowDefns

   IMPLICIT NONE

   PRIVATE                                                        ! By default, everything in HAWCWind is private (methods, data, types, etc.)
   
      
   REAL(ReKi), ALLOCATABLE          :: WindData  (:,:,:,:)        ! Array of FF data for all 3 wind components

   REAL(ReKi)                       :: deltaXInv                  ! multiplicative inverse of delta X
   REAL(ReKi)                       :: deltaYInv                  ! multiplicative inverse of delta Y
   REAL(ReKi)                       :: deltaZInv                  ! multiplicative inverse of delta Z

   INTEGER, PARAMETER               :: NC = 3                     ! number of wind components
   INTEGER                          :: NX                         ! number of points in the X direction
   INTEGER                          :: NY                         ! number of points in the Y direction
   INTEGER                          :: NZ                         ! number of points in the Z direction

   REAL(ReKi)                       :: GridBase                   ! the height of the bottom of the grid (Z direction) in meters
   REAL(ReKi)                       :: LengthX                    ! the grid length in the X direction (distance between point 1 and the next point 1 [because it is periodic])
   REAL(ReKi)                       :: LengthYHalf                ! half the grid width
   REAL(ReKi)                       :: RefHt                      ! the reference (hub) height of the grid in meters 
   REAL(ReKi)                       :: URef                       ! the mean wind speed in m/s at height RefHt meters (as defined in the input file)

         
   LOGICAL, SAVE                    :: Initialized = .FALSE.      ! flag that determines if the module has been initialized


   PUBLIC                           :: HW_Init                    ! initialization subroutine to read the FF grids
   PUBLIC                           :: HW_GetWindSpeed            ! interpolation function that returns velocities at specified time and space
   PUBLIC                           :: HW_GetValue                ! interface to return requested values
   PUBLIC                           :: HW_Terminate               ! subroutine that deallocates memory stored in the FFWind module

CONTAINS
!====================================================================================================
SUBROUTINE HW_Init ( UnWind, InpFileName, ErrStat )
!  This routine is used read the full-field turbulence data stored in HAWC format.
!----------------------------------------------------------------------------------------------------

   IMPLICIT                       NONE


      ! Passed Variables:
      
   INTEGER,      INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered
   
   CHARACTER(*), INTENT(IN)    :: InpFileName                  ! Name of the input text file

      ! Local Variables:

   REAL(SiKi)                  :: DumReal                      ! real variable to temporarially store values read from binary file

   REAL(ReKi)                  :: dx
   REAL(ReKi)                  :: dy
   REAL(ReKi)                  :: dz
   REAL(ReKi)                  :: PLExp                        ! Power law exponent, for the PL mean wind profile type
   REAL(ReKi)                  :: U                            ! The mean wind speed
   REAL(ReKi)                  :: Z                            ! The height above ground/sea level
   REAL(ReKi)                  :: Z0                           ! Surface layer roughness length in meters, used for LOG profile type
    
  
   INTEGER                     :: IC                           ! Loop counter for the number of wind components
   INTEGER                     :: IX                           ! Loop counter for the number of grid points in the X direction
   INTEGER                     :: IY                           ! Loop counter for the number of grid points in the Y direction
   INTEGER                     :: IZ                           ! Loop counter for the number of grid points in the Z direction

   CHARACTER( 1024 )           :: DataFiles ( 3 )              ! Names of the files containing the 3 wind components   
   CHARACTER(3)                :: WindProfileType              ! character code of mean wind profile type


   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' HAWCWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF   

! bjj: this (reading the file) should perhaps be in a subroutine...

   !-------------------------------------------------------------------------------------------------
   ! Open the text file 
   !-------------------------------------------------------------------------------------------------

   CALL OpenFInpFile ( UnWind, TRIM(InpFileName), ErrStat )
   IF (ErrStat /= 0) RETURN

   
   !-------------------------------------------------------------------------------------------------
   ! Read some header information in the text file 
   !-------------------------------------------------------------------------------------------------
   
   CALL ReadCom( UnWind, InpFileName, 'Header 1', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Header 2', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Header 3', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Header 4', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   CALL ReadCom( UnWind, InpFileName, 'Parameters for HAWC-format binary files', ErrStat )
   IF (ErrStat /= 0) RETURN
   
   
   !-------------------------------------------------------------------------------------------------
   ! Read file names and scaling info from the file
   !-------------------------------------------------------------------------------------------------

   CALL ReadVar( UnWind, InpFileName, DataFiles(1), 'FileName_u', 'Name of the u-component binary file', ErrStat )
   IF (ErrStat /= 0) RETURN

   CALL ReadVar( UnWind, InpFileName, DataFiles(2), 'FileName_v', 'Name of the v-component binary file', ErrStat )
   IF (ErrStat /= 0) RETURN

   CALL ReadVar( UnWind, InpFileName, DataFiles(3), 'FileName_w', 'Name of the w-component binary file', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, InpFileName, NX, 'nx', 'Number of grid points in the X direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( NX < 1 ) THEN
      CALL WrScr ( ' HAWCWind error reading "nx": number of grid points in the X direction must be at least 1.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, NY, 'ny', 'Number of grid points in the Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( NY < 1 ) THEN
      CALL WrScr ( ' HAWCWind error reading "ny": number of grid points in the Y direction must be at least 1.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, NZ, 'nz', 'Number of grid points in the Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( NZ < 1 ) THEN
      CALL WrScr ( ' HAWCWind error reading "nz": number of grid points in the Z direction must be at least 1.')
      ErrStat = 1
      RETURN
   END IF
   

   CALL ReadVar( UnWind, InpFileName, dx, 'dx', 'Distance between two points in the X direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( DX < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "dx": the grid spacing in the X direction must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, dy, 'dy', 'Distance between two points in the Y direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( DY < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "dy": the grid spacing in the Y direction must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, dz, 'dz', 'Distance between two points in the Z direction', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( DZ < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "dz": the grid spacing in the Z direction must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF


   CALL ReadVar( UnWind, InpFileName, RefHt, 'RefHt', 'Grid reference height', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( RefHt < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error reading "RefHt": the grid reference height must be larger than 0.')
      ErrStat = 1
      RETURN
   END IF

 
   !-------------------------------------------------------------------------------------------------
   ! Read the section to determine the mean wind profile
   !-------------------------------------------------------------------------------------------------
 
   CALL ReadCom( UnWind, InpFileName, 'mean wind profile parameters (added to HAWC-format files)', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, InpFileName, WindProfileType, 'WindProfileType', 'Wind profile type', ErrStat )
   IF (ErrStat /= 0) RETURN

    
   CALL ReadVar( UnWind, InpFileName, URef, 'URef', 'Reference wind speed', ErrStat )
   IF (ErrStat /= 0) RETURN
   IF ( URef < 0.0_ReKi ) THEN
      CALL WrScr ( ' HAWCWind error: the reference wind speed, URef, must not be negative.' )
      ErrStat = 1
      RETURN   
   END IF

    
   CALL ReadVar( UnWind, InpFileName, PLExp, 'PLExp', 'Power law exponent', ErrStat )
   IF (ErrStat /= 0) RETURN


   CALL ReadVar( UnWind, InpFileName, Z0, 'Z0', 'Surface roughness length', ErrStat )   
   IF (ErrStat /= 0) RETURN  
   
   IF ( Z0 <= EPSILON(Z0) ) THEN
      CALL WrScr ( ' HAWCWind error: the surface roughness length, Z0, must be greater than zero.' )
      ErrStat = 1
      RETURN   
   END IF
   
   !-------------------------------------------------------------------------------------------------
   ! Close the file.
   !-------------------------------------------------------------------------------------------------

   CLOSE ( UnWind )


   !-------------------------------------------------------------------------------------------------
   ! Set some internal module parameters based on input file values
   !-------------------------------------------------------------------------------------------------

   LengthX     = dx*nx !(nx-1)   !because the turbulence box is periodic in the X direction, we need to consider the length between point 1 and the next point 1 (instead of between points 1 and nx)
   LengthYHalf = 0.5*dy*(ny-1)
   GridBase    = RefHt - 0.5*(nz-1)*dz

   IF ( GridBase <= 0.0 ) THEN
      CALL WrScr( ' HAWCWind error: the bottom of the grid is located at a height of '//&
                      TRIM( Num2LStr(GridBase) )//' meters, which is below the ground.' )
      ErrStat = 1
      RETURN
   END IF 


   deltaXInv   = 1.0 / dx
   deltaYInv   = 1.0 / dy
   deltaZInv   = 1.0 / dz
   
   
   !-------------------------------------------------------------------------------------------------
   ! Allocate space for the wind arrays.
   !-------------------------------------------------------------------------------------------------

   IF (.NOT. ALLOCATED(WindData) ) THEN
      ALLOCATE( WindData( NZ, NY, NX, NC ), STAT=ErrStat )
      IF ( ErrStat /= 0 ) THEN
         CALL WrScr ( " Error allocating space for HAWCWind's WindData array." )
         RETURN
      END IF
   END IF
      

   !-------------------------------------------------------------------------------------------------
   ! Read the 3 files containg the turbulent wind speeds.
   !-------------------------------------------------------------------------------------------------
!bjj: check these indices... they do not seem to be very consistant between the WAsP IEC Turbulence
!     simulator and documentation of OC3 file formats... the current implementation is from the 
!     OC3/Kenneth Thompson documentation.

      ! The array must be filled so that x(i) < x(i+1), y(i) < y(i+1), and z(i) < z(i+1)
      ! Also, note that the time axis is the negative x axis.

   DO IC = 1,NC
   
      CALL OpenBInpFile ( UnWind, DataFiles(IC), ErrStat )
   
      DO IX = NX,1,-1                  ! Time is the opposite of X ....
         DO IY = NY,1,-1
            DO IZ = 1,NZ 
            
               READ( UnWind, IOSTAT=ErrStat ) DumReal
               
               WindData( IZ, IY, IX, IC ) = DumReal    ! possible type conversion here
               
               IF (ErrStat /= 0) THEN
                  CALL WrScr( ' Error reading binary data from "'//TRIM(DataFiles(IC))//'".' )
                  CALL WrScr( ' I/O error '//TRIM(Num2LStr(ErrStat))//' occurred at IZ='//TRIM(Num2LStr(IZ))//&
                                                   ', IY='//TRIM(Num2LStr(IY))//', IX='//TRIM(Num2LStr(IX))//'.' )
                  CLOSE ( UnWind )
                  RETURN
               END IF
                              
            END DO
         END DO
      END DO
      
      CLOSE ( UnWind )
      
   END DO

   
   !-------------------------------------------------------------------------------------------------
   ! Add the mean wind speed to the u component.
   !-------------------------------------------------------------------------------------------------

   CALL Conv2UC( WindProfileType )
                 
   
   IF ( RefHt > 0.0 ) THEN
   
      DO IZ = 1,NZ

         Z = GridBase  + ( IZ - 1 )*dz
         
         SELECT CASE ( TRIM(WindProfileType) )
   
            CASE ( 'PL' )         
               U = URef*( Z / RefHt )**PLExp      ! [IEC 61400-1 6.3.1.2 (10)]
      
            CASE ( 'LOG' )
            
               IF ( Z /= Z0 ) THEN
                  U = URef*( LOG( Z / Z0 ) )/( LOG( RefHt / Z0 ) )
               ELSE
                  U = 0.0
               ENDIF
            
            CASE DEFAULT
            
               CALL WrScr( ' Invalid wind profile type in HAWCWind.' )
               ErrStat = 1
               RETURN
      
         END SELECT
   
         WindData( IZ, :, :, 1 ) = WindData( IZ, :, :, 1 ) + U
            

      END DO ! IZ
   END IF ! RefHt
   
   
   !-------------------------------------------------------------------------------------------------
   ! Set initialized flag and return
   !-------------------------------------------------------------------------------------------------
   
   Initialized = .TRUE.

   RETURN
   
END SUBROUTINE HW_Init
!====================================================================================================
FUNCTION HW_GetValue(RVarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the RVarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------

   CHARACTER(*),   INTENT(IN)    :: RVarName
   INTEGER,        INTENT(OUT)   :: ErrStat
   REAL(ReKi)                    :: HW_GetValue

   
   CHARACTER(20)                 :: VarNameUC
   

   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the HAWCWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      


   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = RVarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
   
      CASE ( 'REFHEIGHT' )
         HW_GetValue = RefHt
         
      CASE ('GRIDWIDTH' )
         HW_GetValue = LengthYHalf*2

      CASE ('GRIDHEIGHT' )
         HW_GetValue = NZ/deltaZInv
         
      CASE ('UREF' )
         HW_GetValue = URef        
         
      CASE DEFAULT
         CALL WrScr( ' HAWCWind error: invalid variable name in HW_GetRValue().' )
         ErrStat = 1
         
   END SELECT

END FUNCTION HW_GetValue
!!====================================================================================================
FUNCTION HW_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are are 
! requested.  It determines if the point is on the FF grid or tower points and calls the
! corresponding interpolation routine, which returns the velocities at the specified time and space.
!----------------------------------------------------------------------------------------------------
   
   REAL(ReKi),        INTENT(IN) :: Time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)
   INTEGER,           INTENT(OUT):: ErrStat
   TYPE(InflIntrpOut)            :: HW_GetWindSpeed
     
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   
   
   IF ( .NOT. Initialized ) THEN
      CALL WrScr( ' Initialialize the FFWind module before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0   
   END IF      

   
   !-------------------------------------------------------------------------------------------------
   ! interpolate and return the value.
   !-------------------------------------------------------------------------------------------------   

    HW_GetWindSpeed%Velocity = HW_LinearInterp(Time,InputPosition, ErrStat)


END FUNCTION HW_GetWindSpeed
!====================================================================================================
FUNCTION HW_LinearInterp(Time, Position, ErrStat)
!    This function is used to interpolate into the full-field wind array for the given inputs. It receives 
!    X, Y, Z and TIME from the calling routine.  It then computes a time shift in the X axis based upon 
!    the average windspeed.  The modified position is used to decide which pair of X grids to interpolate
!    within and between.  After finding the two X slices, it decides which four grid points bound the 
!    (Y,Z) pair.  It does a bilinear interpolation for each X slice. Linear interpolation is then used 
!    to interpolate between the X slices.  This routine assumes that X is downwind, Y is to the left when  
!    looking downwind and Z is up.  It also assumes that no extrapolation will be needed.
!    
!    If tower points are used, it assumes the velocity at the ground is 0.  It interpolates between
!    heights and between time slices, but ignores the Y input.
!
!    09/23/09 - Modified by B. Jonkman to use arguments instead of modules to determine time and position.  
!               Height is now relative to the ground
!
!----------------------------------------------------------------------------------------------------

   IMPLICIT                      NONE

   REAL(ReKi),      INTENT(IN) :: Position(3)       ! takes the place of XGrnd, YGrnd, ZGrnd
   REAL(ReKi),      INTENT(IN) :: Time
   REAL(ReKi)                  :: HW_LinearInterp(3)      ! The U, V, W velocities

   INTEGER,         INTENT(OUT):: ErrStat

      ! Local Variables:

   REAL(ReKi)                  :: ShiftedXPosition
   REAL(ReKi),PARAMETER        :: Tol = 1.0E-3      ! a tolerance for determining if two reals are the same (for extrapolation)
   REAL(ReKi)                  :: W_YH_Z
   REAL(ReKi)                  :: W_YH_ZH
   REAL(ReKi)                  :: W_YH_ZL
   REAL(ReKi)                  :: W_YL_Z
   REAL(ReKi)                  :: W_YL_ZH
   REAL(ReKi)                  :: W_YL_ZL
   REAL(ReKi)                  :: Wnd      (2)
   REAL(ReKi)                  :: X                 ! a value between 0 and 1 that indicates a relative location between IXLO and IXHI
   REAL(ReKi)                  :: XGRID             ! the position in the X direction relative to the first grid point
   REAL(ReKi)                  :: Y                 ! a value between 0 and 1 that indicates a relative location between IYLO and IYHI
   REAL(ReKi)                  :: YGRID             ! the position in the Y direction relative to the first grid point
   REAL(ReKi)                  :: Z                 ! a value between 0 and 1 that indicates a relative location between IZLO and IZHI
   REAL(ReKi)                  :: ZGRID             ! the position in the Z direction relative to the first grid point             

   INTEGER                     :: IC                ! loop counter for number of grid points
   INTEGER                     :: IG                ! loop counter for X grids
   INTEGER                     :: IX                ! variable to store IXLO and IXHI while looping
   INTEGER                     :: IXHI              ! high index into the array in the X dimension
   INTEGER                     :: IXLO              ! low  index into the array in the X dimension
   INTEGER                     :: IYHI              ! high index into the array in the Y dimension
   INTEGER                     :: IYLO              ! low  index into the array in the Y dimension
   INTEGER                     :: IZHI              ! high index into the array in the Z dimension
   INTEGER                     :: IZLO              ! low  index into the array in the Z dimension
   
   
   !-------------------------------------------------------------------------------------------------
   ! Initialize variables
   !-------------------------------------------------------------------------------------------------

   HW_LinearInterp(:)    = 0.0                         ! the output velocities (in case NFFComp /= 3)
   Wnd(:)                = 0.0                         ! just in case we're on an end point

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding X slices.
   !-------------------------------------------------------------------------------------------------

! bjj: should we shift by MIN(YHalfWid,FFZHWid)?
         
         ! Assume Taylor's Frozen Turbulence Hypothesis applies: u(X,Y,Z,t) = u( X-U*t, Y, Z, 0)

   ShiftedXPosition = Position(1) - TIME*URef      !this puts the first X grid point at the undeflected tower centerline

   
      ! The wind file is periodic so we'll translate this position to ( 0 <= ShiftedXPosition < LengthX )
   
   ShiftedXPosition = MODULO( ShiftedXPosition, LengthX )
    
   XGrid            = ShiftedXPosition*deltaXInv
   
   IXLO = INT( XGrid ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
   
   IF ( IXLO == NX ) THEN
      IXHI = 1
   ELSE
      IXHI = IXLO + 1
      
! BJJ: assuming LengthX and NX have been correctly defined, this cannot happen:      
!      IF ( IXLO > NX .OR. IXLO < 1 ) THEN
!            CALL WrScr( ' HAWCWind error: wind array was exhausted at '//TRIM( Num2LStr( REAL( TIME,   ReKi ) ) )//' seconds '//& 
!                        '(trying to access X data at '//TRIM( Num2LStr( REAL( ShiftedXPosition, ReKi ) ) )//' m).'  )
!            ErrStat = 1   
!            RETURN
!      ENDIF
      
   END IF
   
   X = XGrid - ( IXLO - 1 )         ! a value between 0 and 1 that indicates a relative location between IXLO and IXHI

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding rows for the Z position. [The lower-left corner is (1,1) when looking upwind.]
   !-------------------------------------------------------------------------------------------------

   ZGRID = ( Position(3) - GridBase )*deltaZInv

     
   IZLO = INT( ZGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
   IZHI = IZLO + 1

   Z = ZGRID - ( IZLO - 1 )            ! a value between 0 and 1 that indicates a relative location between IZLO and IZHI

   IF ( IZLO < 1 ) THEN
      IF ( IZLO == 0 .AND. Z >= 1.0-TOL ) THEN
         Z    = 0.0 
         IZLO = 1
      ELSE
         CALL WrScr( ' HAWCWind error: wind array boundaries violated. Grid too small in Z direction (Z='//&
                     TRIM(Num2LStr(Position(3)))//' m is below the grid).' )
         ErrStat = 1   
         RETURN
      END IF
   ELSEIF ( IZLO >= NZ ) THEN
      IF ( IZLO == NZ .AND. Z <= TOL ) THEN
         Z    = 0.0
         IZHI = IZLO                   ! We're right on the last point, which is still okay
      ELSE      
         CALL WrScr( ' HAWCWind error: wind array boundaries violated. Grid too small in Z direction (Z='//&
                     TRIM(Num2LStr(Position(3)))//' m is above the grid).' )
         ErrStat = 3   
         RETURN
      END IF         
   ENDIF
   

   !-------------------------------------------------------------------------------------------------
   ! Find the bounding columns for the Y position. [The lower-left corner is (1,1) when looking upwind.]
   !-------------------------------------------------------------------------------------------------

   YGRID = ( Position(2) + LengthYHalf )*deltaYInv    ! really, it's (Position(2) - -1.0*YHalfWid)

   IYLO = INT( YGRID ) + 1             ! convert REAL to INTEGER, then add one since our grids start at 1, not 0
   IYHI = IYLO + 1

   Y    = YGRID - ( IYLO - 1 )         ! a value between 0 and 1 that indicates a relative location between IYLO and IYHI
   
   IF ( IYLO >= NY .OR. IYLO < 1 ) THEN
      IF ( IYLO == 0 .AND. Y >= 1.0-TOL ) THEN
         Y    = 0.0 
         IYLO = 1
      ELSE IF ( IYLO == NY .AND. Y <= TOL ) THEN
         Y    = 0.0
         IYHI = IYLO                   ! We're right on the last point, which is still okay      
      ELSE
         CALL WrScr( ' HAWCWind error: wind array boundaries violated: Grid too small in Y direction. Y=' &
                        //TRIM(Num2LStr(Position(2)))//'; Y boundaries = ['//TRIM(Num2LStr(-1.0*LengthYHalf)) &
                        //', '//TRIM(Num2LStr(LengthYHalf))//']' )
         ErrStat = 2   
         RETURN
      END IF
   ENDIF


   !-------------------------------------------------------------------------------------------------
   ! Interpolate on the Y-Z grid for each X (time) slice
   !-------------------------------------------------------------------------------------------------

   DO IC=1,NC            ! all the components

      IX = IXLO          ! start using the first time (X) slice

      DO IG = 1,2        ! repeat for 2 time slices (by changing the value of IX. note that we can't loop from IXLO to IXHI because they could be NX and 1 respectively)

         !-------------------------------------------------------------------------------------------
         ! Get the wind velocity values for the four corners of the grid for this time.
         !-------------------------------------------------------------------------------------------

         W_YL_ZL = WindData( IZLO, IYLO, IX, IC )
         W_YL_ZH = WindData( IZHI, IYLO, IX, IC )
         W_YH_ZL = WindData( IZLO, IYHI, IX, IC )
         W_YH_ZH = WindData( IZHI, IYHI, IX, IC )


         !-------------------------------------------------------------------------------------------
         ! Interpolate within the grid for this time.
         !-------------------------------------------------------------------------------------------

         W_YL_Z  = ( W_YL_ZH - W_YL_ZL )*Z + W_YL_ZL
         W_YH_Z  = ( W_YH_ZH - W_YH_ZL )*Z + W_YH_ZL
         Wnd(IG) = ( W_YH_Z  - W_YL_Z  )*Y + W_YL_Z

         IX = IXHI  ! repeat for the second time (X) slice

      END DO !IX

      !----------------------------------------------------------------------------------------------
      ! Interpolate between the two times.
      !----------------------------------------------------------------------------------------------
      
      HW_LinearInterp( IC ) = ( Wnd(2) - Wnd(1) ) * X + Wnd(1)    ! interpolated velocity
      
   END DO !IDIM


   RETURN
   
END FUNCTION HW_LinearInterp
!====================================================================================================
SUBROUTINE HW_Terminate( ErrStat )
!  This subroutine cleans up any data that is still allocated.  The (possibly) open files are 
!  closed in InflowWindMod.
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   ErrStat = 0

   IF ( ALLOCATED( WindData  ) )   DEALLOCATE( WindData,  STAT=ErrStat )   
   
   Initialized = .FALSE.


END SUBROUTINE HW_Terminate
!====================================================================================================
END MODULE HAWCWind
MODULE HHWind
! This module contains all the data and procedures that define hub-height wind files. This could 
! more accurately be called a point wind file since the wind speed at any point is calculated by 
! shear applied to the point where wind is defined.  It is basically uniform wind over the rotor disk.
! The entire file is read on initialization, then the columns that make up the wind file are
! interpolated to the time requested, and wind is calculated based on the location in space.
!
! the file contains header information (rows that contain "!"), followed by numeric data stored in
! 8 columns:   (1) Time                                  [s]
!              (2) Horizontal wind speed       (V)       [m/s]
!              (3) Wind direction              (Delta)   [deg]
!              (4) Vertical wind speed         (VZ)      [m/s]
!              (5) Horizontal linear shear     (HLinShr) [-]
!              (6) Vertical power-law shear    (VShr)    [-]
!              (7) Vertical linear shear       (VLinShr) [-]
!              (8) Gust (horizontal) velocity  (VGust)   [m/s]
!
! The horizontal wind speed at (X, Y, Z) is then calculated using the interpolated columns by
!   Vh = V * ( Z/RefHt ) ** VShr                                        ! power-law wind shear
!      + V * HLinShr/RefWid * ( Y * COS(Delta) + X * SIN(Delta) )       ! horizontal linear shear
!      + V * VLinShr/RefWid * ( Z-RefHt )                               ! vertical linear shear
!      + VGust                                                          ! gust speed
!----------------------------------------------------------------------------------------------------

   USE                     NWTC_Library
   USE                     SharedInflowDefns
   
   IMPLICIT                NONE
   PRIVATE

      
   REAL(ReKi), ALLOCATABLE      :: Tdata  (:)                              ! Time array from the HH wind file
   REAL(ReKi), ALLOCATABLE      :: DELTA  (:)                              ! HH Wind direction (angle)
   REAL(ReKi), ALLOCATABLE      :: V      (:)                              ! HH horizontal wind speed
   REAL(ReKi), ALLOCATABLE      :: VZ     (:)                              ! wind, including tower shadow, along the Z axis
   REAL(ReKi), ALLOCATABLE      :: HSHR   (:)                              ! HH Horizontal linear shear
   REAL(ReKi), ALLOCATABLE      :: VSHR   (:)                              ! HH vertical shear exponent
   REAL(ReKi), ALLOCATABLE      :: VLINSHR(:)                              ! HH vertical linear shear
   REAL(ReKi), ALLOCATABLE      :: VGUST  (:)                              ! HH wind gust

   REAL(ReKi)                   :: LinearizeDels(7)                        ! The delta values for linearization -- perhaps at some point, this could be T/F and we determine the deltas by sqrt(eps) or something similar
   REAL(ReKi)                   :: RefHt                                   ! reference height; was HH (hub height); used to center the wind
   REAL(ReKi)                   :: RefWid                                  ! reference width; was 2*R (=rotor diameter); used to scale the linear shear
   
   INTEGER                      :: NumDataLines
   INTEGER, SAVE                :: TimeIndx = 0                            ! An index into the Tdata array (to allow us faster searching, starting search from previous one)

   LOGICAL, SAVE                :: Linearize = .FALSE.                     ! If this is TRUE, we are linearizing
   
   TYPE, PUBLIC                 :: HH_Info
      REAL(ReKi)                :: ReferenceHeight
      REAL(ReKi)                :: Width
   END TYPE HH_Info
      
   PUBLIC                       :: HH_Init
   PUBLIC                       :: HH_GetWindSpeed
   PUBLIC                       :: HH_Terminate
   PUBLIC                       :: HH_SetLinearizeDels
   PUBLIC                       :: HH_Get_ADhack_WindSpeed                  ! REMOVE THIS!!!!

CONTAINS
!====================================================================================================
SUBROUTINE HH_Init(UnWind, WindFile, WindInfo, ErrStat)
! A subroutine to initialize the HHWind module.  It reads the HH file and stores the data in an
! array to use later.  It requires an initial reference height (hub height) and width (rotor diameter),
! both in meters, which are used to define the volume where wind velocities will be calculated.  This
! information is necessary because of the way the shears are defined.
!----------------------------------------------------------------------------------------------------

      ! Passed Variables:
      
   INTEGER,      INTENT(IN)    :: UnWind                       ! unit number for reading wind files
   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered
   TYPE(HH_Info),INTENT(IN)    :: WindInfo                     ! Additional information needed to initialize this wind type
   
   CHARACTER(*), INTENT(IN)    :: WindFile                     ! Name of the text HH wind file

      ! local variables
            
   INTEGER, PARAMETER          :: NumCols = 8                  ! Number of columns in the HH file
   REAL(ReKi)                  :: TmpData(NumCols)             ! Temp variable for reading all columns from a line 
   REAL(ReKi)                  :: DelDiff                      ! Temp variable for storing the direction difference

   INTEGER                     :: I
   INTEGER                     :: NumComments
   INTEGER                     :: ILine                        ! Counts the line number in the file
   INTEGER, PARAMETER          :: MaxTries = 100
   CHARACTER(1024)             :: Line                         ! Temp variable for reading whole line from file

    
   !-------------------------------------------------------------------------------------------------
   ! Check that it's not already initialized
   !-------------------------------------------------------------------------------------------------
      
   IF ( TimeIndx /= 0 ) THEN  
      CALL WrScr( ' HHWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
      
      LinearizeDels(:) = 0.0
      Linearize        = .FALSE.
   END IF   

  
   !-------------------------------------------------------------------------------------------------
   ! Open the file for reading
   !-------------------------------------------------------------------------------------------------
   CALL OpenFInpFile (UnWind, TRIM(WindFile), ErrStat)
   
   IF ( ErrStat /= 0 ) RETURN

   !-------------------------------------------------------------------------------------------------
   ! Find the number of comment lines
   !-------------------------------------------------------------------------------------------------
   LINE = '!'                          ! Initialize the line for the DO WHILE LOOP
   NumComments = -1
   
   DO WHILE (INDEX( LINE, '!' ) > 0 ) ! Lines containing "!" are treated as comment lines
      NumComments = NumComments + 1
      
      READ(UnWind,'( A )',IOSTAT=ErrStat) LINE
            
      IF ( ErrStat /=0 ) THEN
         CALL WrScr ( ' Error reading from HH wind file on line '//TRIM(Num2LStr(NumComments))//'.' )
         RETURN
      END IF
      
   END DO !WHILE
   
   !-------------------------------------------------------------------------------------------------
   ! Find the number of data lines
   !-------------------------------------------------------------------------------------------------
   NumDataLines = 0
   
   READ(LINE,*,IOSTAT=ErrStat) ( TmpData(I), I=1,NumCols )

   DO WHILE (ErrStat == 0)  ! read the rest of the file (until an error occurs)
      NumDataLines = NumDataLines + 1               
      
      READ(UnWind,*,IOSTAT=ErrStat) ( TmpData(I), I=1,NumCols )

   END DO !WHILE


   IF (NumDataLines < 1) THEN
      CALL WrScr ( ' Error reading data from HH wind file on line '//TRIM(Num2LStr(NumDataLines+NumComments))//'.' )
      RETURN
   ELSE
      CALL WrScr ( ' Reading '//TRIM(Num2LStr(NumDataLines))//' lines of data from the HH wind file.' )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Allocate arrays for the HH data
   !-------------------------------------------------------------------------------------------------
   ! BJJ note: If the subroutine AllocAry() is called, the CVF compiler with A2AD does not work
   !   properly.  The arrays are not properly read even though they've been allocated.
   !-------------------------------------------------------------------------------------------------
   
   IF (.NOT. ALLOCATED(Tdata) ) THEN
      ALLOCATE ( Tdata(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH time array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(V) ) THEN
      ALLOCATE ( V(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH horizontal wind speed array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(Delta) ) THEN
      ALLOCATE ( Delta(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH wind direction array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VZ) ) THEN
      ALLOCATE ( VZ(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH vertical wind speed array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(HShr) ) THEN
      ALLOCATE ( HShr(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH horizontal linear shear array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VShr) ) THEN
      ALLOCATE ( VShr(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH vertical power-law shear exponent array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VLinShr) ) THEN
      ALLOCATE ( VLinShr(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH vertical linear shear array.' )
         RETURN
      END IF   
   END IF

   IF (.NOT. ALLOCATED(VGust) ) THEN
      ALLOCATE ( VGust(NumDataLines) , STAT=ErrStat )
      IF ( ErrStat /=0 ) THEN
         CALL WrScr( 'Error allocating memory for the HH gust velocity array.' )
         RETURN
      END IF   
   END IF
   

   !-------------------------------------------------------------------------------------------------
   ! Rewind the file (to the beginning) and skip the comment lines
   !-------------------------------------------------------------------------------------------------
   REWIND( UnWind )
   
   DO I=1,NumComments
      CALL ReadCom( UnWind, TRIM(WindFile), 'Header line #'//TRIM(Num2LStr(I)), ErrStat )
      IF ( ErrStat /= 0 ) RETURN
   END DO !I


   !-------------------------------------------------------------------------------------------------
   ! Read the data arrays
   !-------------------------------------------------------------------------------------------------

   DO I=1,NumDataLines
         
      CALL ReadAry( UnWind, TRIM(WindFile), TmpData(1:NumCols), NumCols, 'TmpData', & 
                'Data from HH line '//TRIM(Num2LStr(NumComments+I)), ErrStat )
      IF (ErrStat /= 0) RETURN
                 
      Tdata(  I) = TmpData(1)
      V(      I) = TmpData(2)
      Delta(  I) = TmpData(3)*D2R 
      VZ(     I) = TmpData(4)
      HShr(   I) = TmpData(5)
      VShr(   I) = TmpData(6)
      VLinSHR(I) = TmpData(7)
      VGust(  I) = TmpData(8)           
      
   END DO !I


   !-------------------------------------------------------------------------------------------------
   ! Make sure the wind direction isn't jumping more than 180 degrees between any 2 consecutive
   ! input times.  (Avoids interpolation errors with modular arithemetic.)
   !-------------------------------------------------------------------------------------------------

   DO I=2,NumDataLines
   
      ILine = 1
      
      DO WHILE ( ILine < MaxTries )
     
         DelDiff = ( Delta(I) - Delta(I-1) )

         IF ( ABS( DelDiff ) < Pi ) EXIT  ! exit inner loop

         Delta(I) = Delta(I) - SIGN( TwoPi, DelDiff )
         
         ILine = ILine + 1

      END DO
      
      IF ( ILine >= MaxTries ) THEN
         CALL WrScr( ' Error calculating wind direction from HH file. Delta(' &
               // TRIM(Num2LStr(I  )) // ') = ' // TRIM(Num2LStr(Delta(I))) // '; Delta(' & 
               // TRIM(Num2LStr(I+1)) // ') = ' // TRIM(Num2LStr(Delta(I+1))) )
         ErrStat = 1
      END IF
           

   END DO !I


   !-------------------------------------------------------------------------------------------------
   ! Close the file
   !-------------------------------------------------------------------------------------------------
   
   CLOSE( UnWind )
   

   !-------------------------------------------------------------------------------------------------
   ! Print warnings and messages
   !-------------------------------------------------------------------------------------------------
!   CALL WrScr ( ' Processed '//TRIM( Num2LStr( NumDataLines ) )//' records of HH data' )
   
   
   IF ( Tdata(1) > 0.0 ) THEN
      CALL ProgWarn( 'The hub-height wind file : "'//TRIM(ADJUSTL(WindFile))//'" starts at a time '// & 
                     'greater than zero. Interpolation errors may result.')
   ENDIF
   
   IF ( NumDataLines == 1 ) THEN
      CALL WrScr( ' Only 1 line in HH wind file. Steady, hub-height horizontal wind speed = '//TRIM(Num2LStr(V(1)))//' m/s.' )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Set the initial index into the time array (it indicates that we've initialized the module, too)
   ! and initialize the spatial scaling for the wind calculations
   !-------------------------------------------------------------------------------------------------
   TimeIndx = 1            

   RefHt  = WindInfo%ReferenceHeight
   RefWid = WindInfo%Width   


   RETURN
     
END SUBROUTINE HH_Init
!====================================================================================================
FUNCTION HH_GetWindSpeed(Time, InputPosition, ErrStat)
! This subroutine linearly interpolates the columns in the HH input file to get the values for 
! the requested time, then uses the interpolated values to calclate the wind speed at a point
! in space represented by InputPosition.
!----------------------------------------------------------------------------------------------------

   REAL(ReKi),        INTENT(IN) :: Time                 ! time from the start of the simulation
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)     ! input information: positions X,Y,Z
   INTEGER,           INTENT(OUT):: ErrStat              ! error status
   TYPE(InflIntrpOut)            :: HH_GetWindSpeed      ! return velocities (U,V,W)
   
   REAL(ReKi)                    :: CosDelta             ! cosine of Delta_tmp
   REAL(ReKi)                    :: Delta_tmp            ! interpolated Delta   at input TIME
   REAL(ReKi)                    :: HShr_tmp             ! interpolated HShr    at input TIME
   REAL(ReKi)                    :: P                    ! temporary storage for slope (in time) used in linear interpolation
   REAL(ReKi)                    :: SinDelta             ! sine of Delta_tmp
   REAL(ReKi)                    :: V_tmp                ! interpolated V       at input TIME
   REAL(ReKi)                    :: VGust_tmp            ! interpolated VGust   at input TIME
   REAL(ReKi)                    :: VLinShr_tmp          ! interpolated VLinShr at input TIME
   REAL(ReKi)                    :: VShr_tmp             ! interpolated VShr    at input TIME
   REAL(ReKi)                    :: VZ_tmp               ! interpolated VZ      at input TIME
   REAL(ReKi)                    :: V1                   ! temporary storage for horizontal velocity
   

   !-------------------------------------------------------------------------------------------------
   ! verify the module was initialized first
   !-------------------------------------------------------------------------------------------------

   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Error: Call HH_Init() before getting wind speed.')
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
      
   !-------------------------------------------------------------------------------------------------
   ! Linearly interpolate in time (or used nearest-neighbor to extrapolate) 
   ! (compare with NWTC_Num.f90\InterpStpReal)
   !-------------------------------------------------------------------------------------------------

    IF ( Linearize ) THEN  !get the perturbed wind speed

      TimeIndx      = 1
      V_tmp         = V      (1) + LinearizeDels(1)
      Delta_tmp     = Delta  (1) + LinearizeDels(2)
      VZ_tmp        = VZ     (1) + LinearizeDels(3)
      HShr_tmp      = HShr   (1) + LinearizeDels(4)
      VShr_tmp      = VShr   (1) + LinearizeDels(5)
      VLinShr_tmp   = VLinShr(1) + LinearizeDels(6)
      VGust_tmp     = VGust  (1) + LinearizeDels(7)

      ! Let's check the limits.
   ELSE IF ( Time <= Tdata(1) .OR. NumDataLines == 1 )  THEN
   
      TimeIndx      = 1
      V_tmp         = V      (1)
      Delta_tmp     = Delta  (1)
      VZ_tmp        = VZ     (1)
      HShr_tmp      = HShr   (1)
      VShr_tmp      = VShr   (1)
      VLinShr_tmp   = VLinShr(1)
      VGust_tmp     = VGust  (1)   
         
   ELSE IF ( Time >= Tdata(NumDataLines) )  THEN
   
      TimeIndx      = NumDataLines - 1
      V_tmp         = V      (NumDataLines)
      Delta_tmp     = Delta  (NumDataLines)
      VZ_tmp        = VZ     (NumDataLines)
      HShr_tmp      = HShr   (NumDataLines)
      VShr_tmp      = VShr   (NumDataLines)
      VLinShr_tmp   = VLinShr(NumDataLines)
      VGust_tmp     = VGust  (NumDataLines)
      
   ELSE
   
         ! Let's interpolate!

      TimeIndx = MAX( MIN( TimeIndx, NumDataLines-1 ), 1 )

      DO

         IF ( Time < Tdata(TimeIndx) )  THEN

            TimeIndx = TimeIndx - 1

         ELSE IF ( Time >= Tdata(TimeIndx+1) )  THEN

            TimeIndx = TimeIndx + 1

         ELSE
            P           = ( Time - Tdata(TimeIndx) )/( Tdata(TimeIndx+1) - Tdata(TimeIndx) )
            V_tmp       = ( V(      TimeIndx+1) - V(      TimeIndx) )*P + V(      TimeIndx)
            Delta_tmp   = ( Delta(  TimeIndx+1) - Delta(  TimeIndx) )*P + Delta(  TimeIndx)
            VZ_tmp      = ( VZ(     TimeIndx+1) - VZ(     TimeIndx) )*P + VZ(     TimeIndx)
            HShr_tmp    = ( HShr(   TimeIndx+1) - HShr(   TimeIndx) )*P + HShr(   TimeIndx)
            VShr_tmp    = ( VShr(   TimeIndx+1) - VShr(   TimeIndx) )*P + VShr(   TimeIndx)
            VLinShr_tmp = ( VLinShr(TimeIndx+1) - VLinShr(TimeIndx) )*P + VLinShr(TimeIndx)
            VGust_tmp   = ( VGust(  TimeIndx+1) - VGust(  TimeIndx) )*P + VGust(  TimeIndx)
            EXIT

         END IF

      END DO
      
   END IF

   
   !-------------------------------------------------------------------------------------------------
   ! calculate the wind speed at this time
   !-------------------------------------------------------------------------------------------------
   
   CosDelta = COS( Delta_tmp )
   SinDelta = SIN( Delta_tmp )
   
   V1 = V_tmp * ( ( InputPosition(3)/RefHt ) ** VShr_tmp &                                  ! power-law wind shear
        + ( HShr_tmp   * ( InputPosition(2) * CosDelta + InputPosition(1) * SinDelta ) &    ! horizontal linear shear
        +  VLinShr_tmp * ( InputPosition(3)-RefHt ) )/RefWid  ) &                           ! vertical linear shear
        + VGUST_tmp                                                                         ! gust speed
   
   HH_GetWindSpeed%Velocity(1) =  V1 * CosDelta
   HH_GetWindSpeed%Velocity(2) = -V1 * SinDelta
   HH_GetWindSpeed%Velocity(3) =  VZ_tmp      


   RETURN

END FUNCTION HH_GetWindSpeed
!====================================================================================================
FUNCTION HH_Get_ADHack_WindSpeed(Time, InputPosition, ErrStat)
! This subroutine linearly interpolates the columns in the HH input file to get the values for 
! the requested time, then uses the interpolated values to calclate the wind speed at a point
! in space represented by InputPosition. THIS FUNCTION SHOULD BE REMOVED!!!!! (used for DISK VEL ONLY)
!----------------------------------------------------------------------------------------------------

   REAL(ReKi),        INTENT(IN) :: Time                 ! time from the start of the simulation
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)     ! input information: positions X,Y,Z   -   NOT USED HERE!!!
   INTEGER,           INTENT(OUT):: ErrStat              ! error status
   TYPE(InflIntrpOut)            :: HH_Get_ADHack_WindSpeed      ! return velocities (U,V,W)
   
   REAL(ReKi)                    :: Delta_tmp            ! interpolated Delta   at input TIME
   REAL(ReKi)                    :: P                    ! temporary storage for slope (in time) used in linear interpolation
   REAL(ReKi)                    :: V_tmp                ! interpolated V       at input TIME
   REAL(ReKi)                    :: VZ_tmp               ! interpolated VZ      at input TIME
   

   !-------------------------------------------------------------------------------------------------
   ! verify the module was initialized first
   !-------------------------------------------------------------------------------------------------

   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Error: Call HH_Init() before getting wind speed.')
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
      
   !-------------------------------------------------------------------------------------------------
   ! Linearly interpolate in time (or use nearest-neighbor to extrapolate) 
   ! (compare with NWTC_Num.f90\InterpStpReal)
   !-------------------------------------------------------------------------------------------------

     ! Let's check the limits.

   IF ( Time <= Tdata(1) .OR. NumDataLines == 1)  THEN
   
      TimeIndx      = 1
      V_tmp         = V      (1)
      Delta_tmp     = Delta  (1)
      VZ_tmp        = VZ     (1)
         
   ELSE IF ( Time >= Tdata(NumDataLines) )  THEN
   
      TimeIndx      = NumDataLines - 1
      V_tmp         = V      (NumDataLines)
      Delta_tmp     = Delta  (NumDataLines)
      VZ_tmp        = VZ     (NumDataLines)
      
   ELSE
   
         ! Let's interpolate!

      TimeIndx = MAX( MIN( TimeIndx, NumDataLines-1 ), 1 )

      DO

         IF ( Time < Tdata(TimeIndx) )  THEN

            TimeIndx = TimeIndx - 1

         ELSE IF ( Time >= Tdata(TimeIndx+1) )  THEN

            TimeIndx = TimeIndx + 1

         ELSE
            P           = ( Time - Tdata(TimeIndx) )/( Tdata(TimeIndx+1) - Tdata(TimeIndx) )
            V_tmp       = ( V(      TimeIndx+1) - V(      TimeIndx) )*P + V(      TimeIndx)
            Delta_tmp   = ( Delta(  TimeIndx+1) - Delta(  TimeIndx) )*P + Delta(  TimeIndx)
            VZ_tmp      = ( VZ(     TimeIndx+1) - VZ(     TimeIndx) )*P + VZ(     TimeIndx)
            EXIT

         END IF

      END DO
      
   END IF
   
   !-------------------------------------------------------------------------------------------------
   ! calculate the wind speed at this time
   !-------------------------------------------------------------------------------------------------
      
   HH_Get_ADHack_WindSpeed%Velocity(1) =  V_tmp * COS( Delta_tmp )
   HH_Get_ADHack_WindSpeed%Velocity(2) = -V_tmp * SIN( Delta_tmp )
   HH_Get_ADHack_WindSpeed%Velocity(3) =  VZ_tmp      


   RETURN

END FUNCTION HH_Get_ADHack_WindSpeed
!====================================================================================================
SUBROUTINE HH_SetLinearizeDels( Perturbations, ErrStat )
! This subroutine sets the perturbation values for the linearization scheme.
!----------------------------------------------------------------------------------------------------

   REAL(ReKi),       INTENT(IN)  :: Perturbations(7)     ! purturbations for each of the 7 input parameters
   INTEGER,          INTENT(OUT) :: ErrStat              ! time from the start of the simulation

   !-------------------------------------------------------------------------------------------------
   ! verify the module was initialized first
   !-------------------------------------------------------------------------------------------------

   IF ( TimeIndx == 0 ) THEN
      CALL WrScr( ' Error: Call HH_Init() before getting wind speed.')
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF

   Linearize = .TRUE.
   LinearizeDels(:) = Perturbations(:)

   RETURN

END SUBROUTINE HH_SetLinearizeDels
!====================================================================================================
SUBROUTINE HH_Terminate(ErrStat)

   INTEGER,      INTENT(OUT)   :: ErrStat                      ! determines if an error has been encountered

   INTEGER                     :: SumErrs
   
   SumErrs = 0

   IF ( ALLOCATED(Tdata  ) ) DEALLOCATE( Tdata,   STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(DELTA  ) ) DEALLOCATE( DELTA,   STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(V      ) ) DEALLOCATE( V,       STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VZ     ) ) DEALLOCATE( VZ,      STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(HSHR   ) ) DEALLOCATE( HSHR,    STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VSHR   ) ) DEALLOCATE( VSHR,    STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VGUST  ) ) DEALLOCATE( VGUST,   STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)
   
   IF ( ALLOCATED(VLINSHR) ) DEALLOCATE( VLINSHR, STAT=ErrStat )
   SumErrs = SumErrs + ABS(ErrStat)

   ErrStat  = SumErrs
   TimeIndx = 0            
   
END SUBROUTINE HH_Terminate   
!====================================================================================================
END MODULE HHWind
MODULE UserWind
!  The purpose of this module is to allow user-defined wind.  
!----------------------------------------------------------------------------------------------------

   USE                           NWTC_Library
   USE                           SharedInflowDefns

   IMPLICIT                      NONE
   PRIVATE
    
    
      ! define variables for UserWind here
      
   LOGICAL, SAVE              :: Initialized = .FALSE.         ! This variable indicates if the initialization routine has been run
   
   REAL(ReKi)                 :: UWmeanU                       ! Possibly instantaneous, disk-averaged wind speeds.
   REAL(ReKi)                 :: UWmeanV                       !
   REAL(ReKi)                 :: UWmeanW                       !   
   

      ! allow the initialization and termination routines to be public (called from outside)

   PUBLIC                     :: UsrWnd_Init
   PUBLIC                     :: UsrWnd_Terminate
   PUBLIC                     :: UsrWnd_GetValue
   PUBLIC                     :: UsrWnd_GetWindSpeed

CONTAINS
!====================================================================================================
SUBROUTINE UsrWnd_Init(ErrStat)
!  This subroutine is called at the beginning of
!----------------------------------------------------------------------------------------------------

   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   !-------------------------------------------------------------------------------------------------
   ! Check that the module hasn't already been initialized.
   !-------------------------------------------------------------------------------------------------
      
   IF ( Initialized ) THEN  
      CALL WrScr( ' UserWind has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
      CALL NWTC_Init()
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Perform any initialization steps here (read input files, etc.)
   !-------------------------------------------------------------------------------------------------
   
   CALL WrScr( '***** NOTE: User-defined wind employed *****' )


      ! Set the disk-average wind vector.
   
   UWmeanU = 10.0
   UWmeanV =  0.0
   UWmeanW =  0.0

   
   !-------------------------------------------------------------------------------------------------
   ! Set the initialization flag
   !-------------------------------------------------------------------------------------------------
   
   Initialized = .TRUE.
   
   RETURN

END SUBROUTINE UsrWnd_Init
!====================================================================================================
FUNCTION UsrWnd_GetValue(VarName, ErrStat)
!  This function returns a real scalar value whose name is listed in the VarName input argument.
!  If the name is not recognized, an error is returned in ErrStat.
!----------------------------------------------------------------------------------------------------
   
   CHARACTER(*),   INTENT(IN)    :: VarName
   INTEGER,        INTENT(OUT)   :: ErrStat           ! return 0 if no errors; non-zero otherwise
   REAL(ReKi)                    :: UsrWnd_GetValue

   
   CHARACTER(20)                 :: VarNameUC         ! upper-case VarName
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   

   IF ( .NOT. Initialized ) THEN   
      CALL WrScr( 'Initialize UserWind before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Return the requested values.
   !-------------------------------------------------------------------------------------------------   

   VarNameUC = VarName
   CALL Conv2UC( VarNameUC )

   SELECT CASE ( TRIM(VarNameUC) )
   
      CASE ('MEANU' )
         UsrWnd_GetValue = UWmeanU
         
      CASE ('MEANV' )
         UsrWnd_GetValue = UWmeanV

      CASE ('MEANW' )
         UsrWnd_GetValue = UWmeanW
         
      CASE DEFAULT
         CALL WrScr( ' Invalid variable name in UsrWnd_GetValue().' )
         ErrStat = 1
         
   END SELECT
      
   

END FUNCTION UsrWnd_GetValue
!====================================================================================================
FUNCTION UsrWnd_GetWindSpeed(Time, InputPosition, ErrStat)
! This function receives time and position (in InputInfo) where (undisturbed) velocities are 
! requested. It returns the velocities at the specified time and space.
!----------------------------------------------------------------------------------------------------
   
   REAL(ReKi),        INTENT(IN) :: Time
   REAL(ReKi),        INTENT(IN) :: InputPosition(3)        ! X,Y,Z (z is 0 at ground level)
   INTEGER,           INTENT(OUT):: ErrStat                 ! return 0 if no errors; non-zero otherwise
   TYPE(InflIntrpOut)            :: UsrWnd_GetWindSpeed
   
   
   !-------------------------------------------------------------------------------------------------
   ! Check that the module has been initialized.
   !-------------------------------------------------------------------------------------------------   
   IF ( .NOT. Initialized ) THEN   
      CALL WrScr( 'Initialize UserWind before calling its subroutines.' )
      ErrStat = 1
      RETURN
   ELSE
      ErrStat = 0
   END IF
   
   
   !-------------------------------------------------------------------------------------------------
   ! Calculate the wind speed at this time and position.
   !-------------------------------------------------------------------------------------------------   
   !     Time
   !     X = InputPosition(1)           ! relative to the undeflected tower centerline (positive downwind)
   !     Y = InputPosition(2)           ! relative to the undeflected tower centerline (positive left when looking downwind)
   !     Z = InputPosition(3)           ! relative to the ground (0 is ground level)
   !-------------------------------------------------------------------------------------------------

      ! We'll test this with steady winds for now.

   UsrWnd_GetWindSpeed%Velocity(1) = 10.0    ! U velocity (along positive X)
   UsrWnd_GetWindSpeed%Velocity(2) =  0.0    ! V velocity (along positive Y)
   UsrWnd_GetWindSpeed%Velocity(3) =  0.0    ! V velocity (along positive Z)
   

END FUNCTION UsrWnd_GetWindSpeed
!====================================================================================================
SUBROUTINE UsrWnd_Terminate(ErrStat)
!  This subroutine is called at the end of program execution (including after fatal errors occur).  
!  It should close any files that could be open and deallocate any arrays that have been allocated.
!----------------------------------------------------------------------------------------------------
      
   INTEGER,    INTENT(OUT)    :: ErrStat           ! return 0 if no errors; non-zero otherwise

   ErrStat = 0

   !-------------------------------------------------------------------------------------------------
   ! Close files
   !-------------------------------------------------------------------------------------------------
      
      
   !-------------------------------------------------------------------------------------------------
   ! Deallocate arrays
   !-------------------------------------------------------------------------------------------------

      
   !-------------------------------------------------------------------------------------------------
   ! Set the initialization flag
   !-------------------------------------------------------------------------------------------------
   
   Initialized = .FALSE.

END SUBROUTINE UsrWnd_Terminate
!====================================================================================================
END MODULE UserWind
MODULE InflowWind
! This module is used to read and process the (undisturbed) inflow winds.  It must be initialized
! using WindInf_Init() with the name of the file, the file type, and possibly reference height and
! width (depending on the type of wind file being used).  This module calls appropriate routines
! in the wind modules so that the type of wind becomes seamless to the user.  WindInf_Terminate()
! should be called when the program has finshed.
!
! Data are assumed to be in units of meters and seconds.  Z is measured from the ground (NOT the hub!).
!
!  7 Oct 2009    Initial Release with AeroDyn 13.00.00      B. Jonkman, NREL/NWTC
! 14 Nov 2011    v1.00.01b-bjj                              B. Jonkman
!  1 Aug 2012    v1.01.00a-bjj                              B. Jonkman
! 10 Aug 2012    v1.01.00b-bjj                              B. Jonkman
!----------------------------------------------------------------------------------------------------

   USE                              NWTC_Library
   USE                              SharedInflowDefns

   !-------------------------------------------------------------------------------------------------
   ! The included wind modules
   !-------------------------------------------------------------------------------------------------

   USE                              FFWind               ! full-field binary wind files
   USE                              HHWind               ! hub-height text wind files
   USE                              FDWind               ! 4-D binary wind files
   USE                              CTWind               ! coherent turbulence from KH billow - binary file superimposed on another wind type
   USE                              UserWind             ! user-defined wind module
   USE                              HAWCWind             ! full-field binary wind files in HAWC format


   IMPLICIT                         NONE
   PRIVATE

   !-------------------------------------------------------------------------------------------------
   ! Private internal variables
   !-------------------------------------------------------------------------------------------------

   INTEGER, SAVE                  :: WindType = Undef_Wind  ! Wind Type Flag

   INTEGER                        :: UnWind   = 91          ! The unit number used for wind inflow files

   LOGICAL, SAVE                  :: CT_Flag  = .FALSE.     ! determines if coherent turbulence is used

   !-------------------------------------------------------------------------------------------------
   ! Definitions of public types and routines
   !-------------------------------------------------------------------------------------------------

   TYPE, PUBLIC :: InflInitInfo
      CHARACTER(1024)             :: WindFileName
      INTEGER                     :: WindFileType
      REAL(ReKi)                  :: ReferenceHeight        ! reference height for HH and/or 4D winds (was hub height), in meters
      REAL(ReKi)                  :: Width                  ! width of the HH file (was 2*R), in meters
   END TYPE InflInitInfo

   PUBLIC                         :: WindInf_Init           ! Initialization subroutine
   PUBLIC                         :: WindInf_GetVelocity    ! function to get wind speed at point in space and time
   PUBLIC                         :: WindInf_Terminate      ! subroutine to clean up

   PUBLIC                         :: WindInf_ADhack_diskVel ! used to keep old AeroDyn functionality--remove soon!
   PUBLIC                         :: WindInf_ADhack_DIcheck ! used to keep old AeroDyn functionality--remove soon!
   PUBLIC                         :: WindInf_LinearizePerturbation !used for linearization; should be modified
!!----Removed during conversion to new framework
!!       PUBLIC                         :: WindInf_GetMean        ! function to get the mean wind speed at a point in space
!!       PUBLIC                         :: WindInf_GetStdDev      ! function to calculate standard deviation at a point in space
!!       PUBLIC                         :: WindInf_GetTI          ! function to get TI at a point in space

   CHARACTER(99),PARAMETER        :: WindInfVer = 'InflowWind (v1.01.00b-bjj, 10-Aug-2012)'

CONTAINS
!====================================================================================================
SUBROUTINE WindInf_Init( FileInfo, ErrStat )
!  Open and read the wind files, allocating space for necessary variables
!
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   TYPE(InflInitInfo), INTENT(IN)   :: FileInfo
   INTEGER,            INTENT(OUT)  :: ErrStat

      ! Local variables

   TYPE(HH_Info)                    :: HHInitInfo
   TYPE(CT_Backgr)                  :: BackGrndValues

   REAL(ReKi)                       :: Height
   REAL(ReKi)                       :: HalfWidth
   CHARACTER(1024)                  :: FileName


   IF ( WindType /= Undef_Wind ) THEN
      CALL WrScr( ' Wind inflow has already been initialized.' )
      ErrStat = 1
      RETURN
   ELSE
      WindType = FileInfo%WindFileType
      FileName = FileInfo%WindFileName
      CALL NWTC_Init()
      CALL WrScr1( ' Using '//TRIM( WindInfVer ) )

   END IF

   !-------------------------------------------------------------------------------------------------
   ! Get default wind type, based on file name, if requested
   !-------------------------------------------------------------------------------------------------
   IF ( FileInfo%WindFileType == DEFAULT_Wind ) THEN
      WindType = GetWindType( FileName, ErrStat )
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Check for coherent turbulence file (KH superimposed on a background wind file)
   ! Initialize the CTWind module and initialize the module of the other wind type.
   !-------------------------------------------------------------------------------------------------

   IF ( WindType == CTP_Wind ) THEN

      CALL CT_Init(UnWind, FileName, BackGrndValues, ErrStat)
      IF (ErrStat /= 0) THEN
         CALL WindInf_Terminate( ErrStat )
         WindType = Undef_Wind
         ErrStat  = 1
         RETURN
      END IF

      FileName = BackGrndValues%WindFile
      WindType = BackGrndValues%WindFileType
      CT_Flag  = BackGrndValues%CoherentStr

   ELSE

      CT_Flag  = .FALSE.

   END IF


   !-------------------------------------------------------------------------------------------------
   ! Initialize based on the wind type
   !-------------------------------------------------------------------------------------------------

   SELECT CASE ( WindType )

      CASE (HH_Wind)

         HHInitInfo%ReferenceHeight = FileInfo%ReferenceHeight
         HHInitInfo%Width           = FileInfo%Width

         CALL HH_Init( UnWind, FileName, HHInitInfo, ErrStat )

!        IF (CT_Flag) CALL CT_SetRefVal(FileInfo%ReferenceHeight, 0.5*FileInfo%Width, ErrStat)
         IF (ErrStat == 0 .AND. CT_Flag) CALL CT_SetRefVal(FileInfo%ReferenceHeight, REAL(0.0, ReKi), ErrStat)


      CASE (FF_Wind)

         CALL FF_Init( UnWind, FileName, ErrStat )


            ! Set CT parameters

         IF ( ErrStat == 0 .AND. CT_Flag ) THEN
            Height     = FF_GetValue('HubHeight', ErrStat)
            IF ( ErrStat /= 0 ) Height = FileInfo%ReferenceHeight

            HalfWidth  = 0.5*FF_GetValue('GridWidth', ErrStat)
            IF ( ErrStat /= 0 ) HalfWidth = 0

            CALL CT_SetRefVal(Height, HalfWidth, ErrStat)
         END IF


      CASE (UD_Wind)

         CALL UsrWnd_Init(ErrStat)


      CASE (FD_Wind)

         CALL FD_Init(UnWind, FileName, FileInfo%ReferenceHeight, ErrStat)

      CASE (HAWC_Wind)

         CALL HW_Init( UnWind, FileName, ErrStat )

      CASE DEFAULT

         CALL WrScr(' Error: Undefined wind type in WindInflow_Init()' )
         ErrStat = 1
         RETURN

   END SELECT

   IF ( ErrStat /= 0 ) THEN
      CALL WindInf_Terminate( ErrStat )  !Just in case we've allocated something
      WindType = Undef_Wind
      ErrStat  = 1
   END IF

   RETURN

END SUBROUTINE WindInf_Init
!====================================================================================================
FUNCTION WindInf_GetVelocity(Time, InputPosition, ErrStat)
! Get the wind speed at a point in space and time
!----------------------------------------------------------------------------------------------------

      ! passed variables
   REAL(ReKi),       INTENT(IN)  :: Time
   REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
   INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise

      ! local variables
   TYPE(InflIntrpOut)            :: WindInf_GetVelocity     ! U, V, W velocities
   TYPE(InflIntrpOut)            :: CTWindSpeed             ! U, V, W velocities to superimpose on background wind


   ErrStat = 0

   SELECT CASE ( WindType )
      CASE (HH_Wind)
         WindInf_GetVelocity = HH_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE (FF_Wind)
         WindInf_GetVelocity = FF_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE (UD_Wind)
         WindInf_GetVelocity = UsrWnd_GetWindSpeed( Time, InputPosition, ErrStat )

      CASE (FD_Wind)
         WindInf_GetVelocity = FD_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE (HAWC_Wind)
         WindInf_GetVelocity = HW_GetWindSpeed(     Time, InputPosition, ErrStat )

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in WindInf_GetVelocity(). ' &
                   //'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1
         WindInf_GetVelocity%Velocity(:) = 0.0

   END SELECT


   IF (ErrStat /= 0) THEN

      WindInf_GetVelocity%Velocity(:) = 0.0

   ELSE

         ! Add coherent turbulence to background wind

      IF (CT_Flag) THEN

         CTWindSpeed = CT_GetWindSpeed(Time, InputPosition, ErrStat)
         IF (ErrStat /=0 ) RETURN

         WindInf_GetVelocity%Velocity(:) = WindInf_GetVelocity%Velocity(:) + CTWindSpeed%Velocity(:)

      ENDIF

   ENDIF

END FUNCTION WindInf_GetVelocity
!====================================================================================================
!!    !====================================================================================================
FUNCTION GetWindType( FileName, ErrStat )
!  This subroutine checks the file FileName to see what kind of wind file we are using.  Used when
!  the wind file type is unknown.
!----------------------------------------------------------------------------------------------------


   IMPLICIT             NONE


      ! Passed Variables:

   CHARACTER(*),INTENT(INOUT) :: FileName
   INTEGER, INTENT(OUT)       :: ErrStat

      ! Function definition
   INTEGER                    :: GetWindType

      ! Local Variables:

   INTEGER                    :: IND
   LOGICAL                    :: Exists

   CHARACTER(  3)             :: FileNameEnd
   CHARACTER(  8)             :: WndFilNam

   CHARACTER(1024)            :: FileRoot


   ErrStat = 0

   !-------------------------------------------------------------------------------------------------
   ! Check for user-defined wind file first; file starts with "USERWIND"
   !-------------------------------------------------------------------------------------------------

   WndFilNam = FileName
   CALL Conv2UC( WndFilNam )

   IF ( WndFilNam == 'USERWIND' )  THEN

      CALL WrScr1( ' Detected user-defined wind file.' )
      GetWindType = UD_Wind

      RETURN
   END IF

   !-------------------------------------------------------------------------------------------------
   ! Get the file extension (or at least what we expect the extension to be)
   !-------------------------------------------------------------------------------------------------
   CALL GetRoot ( FileName, FileRoot )                      ! Get the root name

   IND = LEN_TRIM( FileRoot ) + 1
   IF ( IND < LEN_TRIM( FileName ) ) THEN
      FileNameEnd = FileName(IND+1:)                        ! Get the extenstion, starting at first character past (may not be the whole "extension")
      CALL Conv2UC (FileNameEnd)
   ELSE
      FileNameEnd = ""
      IND = 0
   END IF


   !-------------------------------------------------------------------------------------------------
   ! If there was no '.' in the file name, assume FF, and add a .wnd extension
   !-------------------------------------------------------------------------------------------------
   IF ( IND == 0 ) THEN
      CALL WrScr1(' No file extension found. Assuming '//TRIM(FileName)// &
                  ' is a binary FF wind file with a ".wnd" extension.')
      GetWindType = FF_Wind
      FileName = TRIM(FileName)//'.wnd'
      RETURN
   END IF


   !-------------------------------------------------------------------------------------------------
   ! Base the file type on the extension
   !-------------------------------------------------------------------------------------------------
   SELECT CASE ( TRIM(FileNameEnd) )
      CASE ('WND')

            ! If a summary file exists, assume FF; otherwise, assume HH file.

         INQUIRE ( FILE=FileName(1:IND)//'sum' , EXIST=Exists )
         IF (Exists) THEN
            CALL WrScr1(' Assuming '//TRIM(FileName)//' is a binary FF wind file.')
            GetWindType = FF_Wind
         ELSE
            CALL WrScr1(' Assuming '//TRIM(FileName)//' is a formatted HH wind file.')
            GetWindType = HH_Wind
         END IF

      CASE ('BTS')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a binary FF wind file.')
         GetWindType = FF_Wind

      CASE ('CTP')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a coherent turbulence wind file.')
         GetWindType = CTP_Wind

      CASE ('FDP')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a binary 4-dimensional wind file.')
         GetWindType = FD_Wind

      CASE ('HWC')
         CALL WrScr1(' Assuming '//TRIM(FileName)//' contains full-field wind parameters in HAWC format.')
         GetWindType = HAWC_Wind

      CASE DEFAULT
         CALL WrScr1(' Assuming '//TRIM(FileName)//' is a formatted HH wind file.')
         GetWindType = HH_Wind

   END SELECT


RETURN
END FUNCTION GetWindType
!====================================================================================================
SUBROUTINE WindInf_LinearizePerturbation( LinPerturbations, ErrStat )
! This function is used in FAST's linearization scheme.  It should be fixed at some point.
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER,    INTENT(OUT)    :: ErrStat

   REAL(ReKi), INTENT(IN)     :: LinPerturbations(7)

      ! Local variables


   ErrStat = 0

   SELECT CASE ( WindType )
      CASE (HH_Wind)

         CALL HH_SetLinearizeDels( LinPerturbations, ErrStat )

      CASE ( FF_Wind, UD_Wind, FD_Wind, HAWC_Wind )

         CALL WrScr( ' Error: Linearization is valid only with HH wind files.' )
         ErrStat = 1

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in WindInf_LinearizePerturbation(). '// &
                     'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1

   END SELECT


END SUBROUTINE WindInf_LinearizePerturbation
!====================================================================================================
FUNCTION WindInf_ADhack_diskVel( Time, InpPosition, ErrStat )
! This function should be deleted ASAP.  It's purpose is to reproduce results of AeroDyn 12.57;
! when a consensus on the definition of "average velocity" is determined, this function will be
! removed.  InpPosition(2) should be the rotor radius; InpPosition(3) should be hub height
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   REAL(ReKi), INTENT(IN)     :: Time
   REAL(ReKi), INTENT(IN)     :: InpPosition(3)
   INTEGER, INTENT(OUT)       :: ErrStat

      ! Function definition
   REAL(ReKi)                 :: WindInf_ADhack_diskVel(3)

      ! Local variables
   TYPE(InflIntrpOut)         :: NewVelocity             ! U, V, W velocities
   REAL(ReKi)                 :: Position(3)
   INTEGER                    :: IY
   INTEGER                    :: IZ


   ErrStat = 0

   SELECT CASE ( WindType )
      CASE (HH_Wind)

!      VXGBAR =  V * COS( DELTA )
!      VYGBAR = -V * SIN( DELTA )
!      VZGBAR =  VZ

         Position    = (/ REAL(0.0, ReKi), REAL(0.0, ReKi), InpPosition(3) /)
         NewVelocity = HH_Get_ADHack_WindSpeed(Time, Position, ErrStat)

         WindInf_ADhack_diskVel(:) = NewVelocity%Velocity(:)


      CASE (FF_Wind)
!      VXGBAR = MeanFFWS
!      VYGBAR = 0.0
!      VZGBAR = 0.0

         WindInf_ADhack_diskVel(1)   = FF_GetValue('MEANFFWS', ErrStat)
         WindInf_ADhack_diskVel(2:3) = 0.0

      CASE (UD_Wind)
!      VXGBAR = UWmeanU
!      VYGBAR = UWmeanV
!      VZGBAR = UWmeanW

         WindInf_ADhack_diskVel(1)   = UsrWnd_GetValue('MEANU', ErrStat)
         IF (ErrStat /= 0) RETURN
         WindInf_ADhack_diskVel(2)   = UsrWnd_GetValue('MEANV', ErrStat)
         IF (ErrStat /= 0) RETURN
         WindInf_ADhack_diskVel(3)   = UsrWnd_GetValue('MEANW', ErrStat)

      CASE (FD_Wind)
!      XGrnd = 0.0
!      YGrnd = 0.5*RotDiam
!      ZGrnd = 0.5*RotDiam
!      CALL FD_Interp
!      VXGBAR = FDWind( 1 )
!      VYGBAR = FDWind( 2 )
!      VZGBAR = FDWind( 3 )
!
!      XGrnd =  0.0
!      YGrnd = -0.5*RotDiam
!      ZGrnd =  0.5*RotDiam
!      CALL FD_Interp
!      VXGBAR = VXGBAR + FDWind( 1 )
!      VYGBAR = VYGBAR + FDWind( 2 )
!      VZGBAR = VZGBAR + FDWind( 3 )
!
!      XGrnd =  0.0
!      YGrnd = -0.5*RotDiam
!      ZGrnd = -0.5*RotDiam
!      CALL FD_Interp
!      VXGBAR = VXGBAR + FDWind( 1 )
!      VYGBAR = VYGBAR + FDWind( 2 )
!      VZGBAR = VZGBAR + FDWind( 3 )
!
!      XGrnd =  0.0
!      YGrnd =  0.5*RotDiam
!      ZGrnd = -0.5*RotDiam
!      CALL FD_Interp
!      VXGBAR = 0.25*( VXGBAR + FDWind( 1 ) )
!      VYGBAR = 0.25*( VYGBAR + FDWind( 2 ) )
!      VZGBAR = 0.25*( VZGBAR + FDWind( 3 ) )


         Position(1) = 0.0
         WindInf_ADhack_diskVel(:) = 0.0

         DO IY = -1,1,2
            Position(2)  =  IY*FD_GetValue('RotDiam',ErrStat)

            DO IZ = -1,1,2
               Position(3)  = IZ*InpPosition(2) + InpPosition(3)

               NewVelocity = WindInf_GetVelocity(Time, Position, ErrStat)
               WindInf_ADhack_diskVel(:) = WindInf_ADhack_diskVel(:) + NewVelocity%Velocity(:)
            END DO
         END DO
         WindInf_ADhack_diskVel(:) = 0.25*WindInf_ADhack_diskVel(:)

      CASE (HAWC_Wind)
         WindInf_ADhack_diskVel(1)   = HW_GetValue('UREF', ErrStat)
         WindInf_ADhack_diskVel(2:3) = 0.0

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in WindInf_ADhack_diskVel(). '// &
                    'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1

   END SELECT

   RETURN

END FUNCTION WindInf_ADhack_diskVel
!====================================================================================================
FUNCTION WindInf_ADhack_DIcheck( ErrStat )
! This function should be deleted ASAP.  It's purpose is to reproduce results of AeroDyn 12.57;
! it performs a wind speed check for the dynamic inflow initialization
! it returns MFFWS for the FF wind files; for all others, a sufficiently large number is used ( > 8 m/s)
!----------------------------------------------------------------------------------------------------

      ! Passed variables

   INTEGER, INTENT(OUT)       :: ErrStat

      ! Function definition
   REAL(ReKi)                 :: WindInf_ADhack_DIcheck


   ErrStat = 0

   SELECT CASE ( WindType )
      CASE (HH_Wind, UD_Wind, FD_Wind )

         WindInf_ADhack_DIcheck = 50  ! just return something greater than 8 m/s

      CASE (FF_Wind)

         WindInf_ADhack_DIcheck = FF_GetValue('MEANFFWS', ErrStat)

      CASE (HAWC_Wind)

         WindInf_ADhack_DIcheck = HW_GetValue('UREF', ErrStat)

      CASE DEFAULT
         CALL WrScr(' Error: Undefined wind type in WindInf_ADhack_DIcheck(). '// &
                    'Call WindInflow_Init() before calling this function.' )
         ErrStat = 1

   END SELECT

   RETURN

END FUNCTION WindInf_ADhack_DIcheck
!====================================================================================================
SUBROUTINE WindInf_Terminate( ErrStat )
! Clean up the allocated variables and close all open files.  Reset the initialization flag so
! that we have to reinitialize before calling the routines again.
!----------------------------------------------------------------------------------------------------

   INTEGER, INTENT(OUT)       :: ErrStat     !bjj: do we care if there's an error on cleanup?


      ! Close the wind file, if it happens to be open

   CLOSE( UnWind )


      ! End the sub-modules (deallocates their arrays and closes their files):

   SELECT CASE ( WindType )

      CASE (HH_Wind)
         CALL HH_Terminate(     ErrStat )

      CASE (FF_Wind)
         CALL FF_Terminate(     ErrStat )

      CASE (UD_Wind)
         CALL UsrWnd_Terminate( ErrStat )

      CASE (FD_Wind)
         CALL FD_Terminate(     ErrStat )

      CASE (HAWC_Wind)
         CALL HW_Terminate(     ErrStat )

      CASE ( Undef_Wind )
         ! Do nothing

      CASE DEFAULT  ! keep this check to make sure that all new wind types have a terminate function
         CALL WrScr(' Undefined wind type in WindInf_Terminate().' )
         ErrStat = 1

   END SELECT

!   IF (CT_Flag) CALL CT_Terminate( ErrStat )
   CALL CT_Terminate( ErrStat )


      ! Reset the wind type so that the initialization routine must be called
  WindType = Undef_Wind
   CT_Flag  = .FALSE.


END SUBROUTINE WindInf_Terminate
!====================================================================================================
END MODULE InflowWind





!!----Remove this functionality for now. Might put it back in sometime after the conversion to the new framework ----
!!    FUNCTION WindInf_GetMean(StartTime, EndTime, delta_time, InputPosition,  ErrStat )
!!    !  This function returns the mean wind speed
!!    !----------------------------------------------------------------------------------------------------
!!
!!          ! passed variables
!!       REAL(ReKi),       INTENT(IN)  :: StartTime
!!       REAL(ReKi),       INTENT(IN)  :: EndTime
!!       REAL(ReKi),       INTENT(IN)  :: delta_time
!!       REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
!!       INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise
!!
!!          ! function definition
!!       REAL(ReKi)                    :: WindInf_GetMean(3)      ! MEAN U, V, W
!!
!!          ! local variables
!!       REAL(ReKi)                    :: Time
!!       REAL(DbKi)                    :: SumVel(3)
!!       INTEGER                       :: I
!!       INTEGER                       :: Nt
!!
!!       TYPE(InflIntrpOut)            :: NewVelocity             ! U, V, W velocities
!!
!!
!!       Nt = (EndTime - StartTime) / delta_time
!!
!!       SumVel(:) = 0.0
!!       ErrStat   = 0
!!
!!
!!       DO I=1,Nt
!!
!!          Time = StartTime + (I-1)*delta_time
!!
!!          NewVelocity = WindInf_GetVelocity(Time, InputPosition, ErrStat)
!!          IF ( ErrStat /= 0 ) THEN
!!             WindInf_GetMean(:) = SumVel(:) / REAL(I-1, ReKi)
!!             RETURN
!!          ELSE
!!             SumVel(:) = SumVel(:) + NewVelocity%Velocity(:)
!!          END IF
!!
!!       END DO
!!
!!       WindInf_GetMean(:) = SumVel(:) / REAL(Nt, ReKi)
!!
!!
!!    END FUNCTION WindInf_GetMean
!!    !====================================================================================================
!!    FUNCTION WindInf_GetStdDev(StartTime, EndTime, delta_time, InputPosition,  ErrStat )
!!    !  This function returns the mean wind speed (mean, std, TI, etc)
!!    !----------------------------------------------------------------------------------------------------
!!
!!          ! passed variables
!!       REAL(ReKi),       INTENT(IN)  :: StartTime
!!       REAL(ReKi),       INTENT(IN)  :: EndTime
!!       REAL(ReKi),       INTENT(IN)  :: delta_time
!!       REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
!!       INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise
!!
!!          ! function definition
!!       REAL(ReKi)                    :: WindInf_GetStdDev(3)    ! STD U, V, W
!!
!!          ! local variables
!!       REAL(ReKi)                    :: Time
!!       REAL(ReKi), ALLOCATABLE       :: Velocity(:,:)
!!       REAL(DbKi)                    :: SumAry(3)
!!       REAL(DbKi)                    :: MeanVel(3)
!!       INTEGER                       :: I
!!       INTEGER                       :: Nt
!!
!!       TYPE(InflIntrpOut)            :: NewVelocity             ! U, V, W velocities
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Initialize
!!       !-------------------------------------------------------------------------------------------------
!!
!!       WindInf_GetStdDev(:) = 0.0
!!
!!       Nt = (EndTime - StartTime) / delta_time
!!
!!       IF ( Nt < 2 ) RETURN    ! StdDev is 0
!!
!!
!!       IF (.NOT. ALLOCATED(Velocity)) THEN
!!    !      CALL AllocAry( Velocity, 3, Nt, 'StdDev velocity', ErrStat)
!!          ALLOCATE ( Velocity(3, Nt), STAT=ErrStat )
!!
!!          IF ( ErrStat /= 0 )  THEN
!!             CALL WrScr ( ' Error allocating memory for the StdDev velocity array.' )
!!             RETURN
!!          END IF
!!       END IF
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the mean, storing the velocity for later
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          Time = StartTime + (I-1)*delta_time
!!
!!          NewVelocity = WindInf_GetVelocity(Time, InputPosition, ErrStat)
!!          IF ( ErrStat /= 0 ) RETURN
!!          Velocity(:,I) = NewVelocity%Velocity(:)
!!          SumAry(:)     = SumAry(:) + NewVelocity%Velocity(:)
!!
!!       END DO
!!
!!       MeanVel(:) = SumAry(:) / REAL(Nt, ReKi)
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the standard deviation
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          SumAry(:) = SumAry(:) + ( Velocity(:,I) - MeanVel(:) )**2
!!
!!       END DO ! I
!!
!!       WindInf_GetStdDev(:) = SQRT( SumAry(:) / ( Nt - 1 ) )
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Deallocate
!!       !-------------------------------------------------------------------------------------------------
!!       IF ( ALLOCATED(Velocity) ) DEALLOCATE( Velocity )
!!
!!
!!    END FUNCTION WindInf_GetStdDev
!!    !====================================================================================================
!!    FUNCTION WindInf_GetTI(StartTime, EndTime, delta_time, InputPosition,  ErrStat )
!!    !  This function returns the TI of the wind speed.  It's basically a copy of WindInf_GetStdDev,
!!    !  except the return value is divided by the mean U-component wind speed.
!!    !----------------------------------------------------------------------------------------------------
!!
!!          ! passed variables
!!       REAL(ReKi),       INTENT(IN)  :: StartTime
!!       REAL(ReKi),       INTENT(IN)  :: EndTime
!!       REAL(ReKi),       INTENT(IN)  :: delta_time
!!       REAL(ReKi),       INTENT(IN)  :: InputPosition(3)        ! X, Y, Z positions
!!       INTEGER,          INTENT(OUT) :: ErrStat                 ! Return 0 if no error; non-zero otherwise
!!
!!          ! function definition
!!       REAL(ReKi)                    :: WindInf_GetTI(3)        ! TI U, V, W
!!
!!          ! local variables
!!       REAL(ReKi)                    :: Time
!!       REAL(ReKi), ALLOCATABLE       :: Velocity(:,:)
!!       REAL(DbKi)                    :: SumAry(3)
!!       REAL(DbKi)                    :: MeanVel(3)
!!       INTEGER                       :: I
!!       INTEGER                       :: Nt
!!
!!       TYPE(InflIntrpOut)            :: NewVelocity             ! U, V, W velocities
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Initialize
!!       !-------------------------------------------------------------------------------------------------
!!
!!       WindInf_GetTI(:) = 0.0
!!
!!       Nt = (EndTime - StartTime) / delta_time
!!
!!       IF ( Nt < 2 ) RETURN    ! StdDev is 0
!!
!!
!!       IF (.NOT. ALLOCATED(Velocity)) THEN
!!    !      CALL AllocAry( Velocity, 3, Nt, 'TI velocity', ErrStat)
!!          ALLOCATE ( Velocity(3, Nt), STAT=ErrStat )
!!
!!          IF ( ErrStat /= 0 )  THEN
!!             CALL WrScr ( ' Error allocating memory for the TI velocity array.' )
!!             RETURN
!!          END IF
!!       END IF
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the mean, storing the velocity for later
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          Time = StartTime + (I-1)*delta_time
!!
!!          NewVelocity = WindInf_GetVelocity(Time, InputPosition, ErrStat)
!!          IF ( ErrStat /= 0 ) RETURN
!!          Velocity(:,I) = NewVelocity%Velocity(:)
!!          SumAry(:)     = SumAry(:) + NewVelocity%Velocity(:)
!!
!!       END DO
!!
!!       MeanVel(:) = SumAry(:) / REAL(Nt, ReKi)
!!
!!       IF ( ABS(MeanVel(1)) <= EPSILON(MeanVel(1)) ) THEN
!!          CALL WrScr( ' Wind speed is small in WindInf_GetTI(). TI is undefined.' )
!!          ErrStat = 1
!!          RETURN
!!       END IF
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Calculate the standard deviation
!!       !-------------------------------------------------------------------------------------------------
!!       SumAry(:) = 0.0
!!
!!       DO I=1,Nt
!!
!!          SumAry(:) = SumAry(:) + ( Velocity(:,I) - MeanVel(:) )**2
!!
!!       END DO ! I
!!
!!       WindInf_GetTI(:) = SQRT( SumAry(:) / ( Nt - 1 ) ) / MeanVel(1)
!!
!!
!!       !-------------------------------------------------------------------------------------------------
!!       ! Deallocate
!!       !-------------------------------------------------------------------------------------------------
!!       IF ( ALLOCATED(Velocity) ) DEALLOCATE( Velocity )
!!
!!
!!    END FUNCTION WindInf_GetTI
