This was the text from an e-mail sent 2013.03.19 from DIA by iphone.

Hi,

First, my apologies for not getting this email out yesterday (as a result I am typing this on my phone from memory). I just wanted to give you a quick overview of how to compile InfowWind and what it is looking for in terms of inputs. I have tested this on Linux and Mac, but unfortunately did not get a chance to test it with IVF.

The source code for the modularization InflowWind is located on the branch (https://windsvn.nrel.gov/InflowWind/branches/modularization/). Currently, the full field (IfW_FFWind.f90) and hub height (IfW_HHWind.f90) have been converted to the framework. Also, the interface module (InflowWind_module.f90) has been converted. The way I wrote it, both the full field and hub height modules fully conform to the modular framework, so if there are any issues with the InflowWind module, you can call them separately (same inputs and calls).

To compile InflowWind, you will need the following pieces:
- IfW_HHWind_Types.f90 (Reg-IfW_HHWind.txt)
- IfW_HHWind.f90
- IfW_FFWind_Types.f90 (Reg-IfW_FFWind.txt)
- IfW_FFWind.f90
- InflowWind_module_Types.f90 (no reins try file as this will get merged)
- InflowWind_Types.f90 (Reg-InflowWind.txt but it has a few minor issues when generated by the registry program - at least the version I was using)
- InflowWind_module.f90

There is also a driver program. The makefile will generate this (it also generates some of the types files, though I just realized that won't necessarily work for you). Also, within the Testing subdirectory there are drivers for the hub height and full field sub modules. There is a makefile there as well that makes those modules.

The sub modules and the interface module expect three pieces of information during initialization (InitInputType): WindfileName, RefHeight, Width (can't remember the exact names). The modules will deal with the rest of the information. After initialization, the stored wind data is in the OtherStates_Type.

For inputs for CalcOutput, only a 2D array of data points is needed. This is a 3xN array, where N is the number of coordinates to process. The first index is for x, y, z respectively. This will need to be allocated before each call just in case the number of points changes between calls (don't know why that might happen, but to preserve flexibility I insist on this). The index order was chosen so as to easily deal with a single point - I ran into an issue with this at one point.

The output (OutputData_Type) contains a corresponding U,V,W array of velocities. This gets allocated in CalcOutput. It is also a 3xN array.

Well, that's all I can think of at the moment. If you have any questions, please contact me today as I am currently sitting in DIA waiting for my flight. I will be reachable by email (and maybe phone) until 8 pm eastern time. I won't have email access again until late on the 28th when I return from Senegal. So, if you have questions or if anything is unclear, please ask them today if possible.

Andy
