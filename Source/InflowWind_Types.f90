!STARTOFREGISTRYGENERATEDFILE './InflowWind_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry (v2.03.01, 18-June-2014)
!*********************************************************************************************************************************
! InflowWind_Types
!.................................................................................................................................
! This file is part of InflowWind.
!
! Copyright (C) 2012-2014 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE InflowWind_Types
! This module contains all of the user-defined types needed in InflowWind. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE IfW_UniformWind_Types
USE IfW_HAWCWind_Types
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Undef_WindNumber = 0      ! This is the code for an undefined WindFileType [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Steady_WindNumber = 1      ! Steady wind.  Calculated internally. [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Uniform_WindNumber = 2      ! Uniform wind.  Formally known as a Hub-Height wind file. [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TSFF_WindNumber = 3      ! TurbSim full-field binary file. [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: BladedFF_WindNumber = 4      ! Bladed style binary full-field file.  Includes native bladed format [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: HAWC_WindNumber = 5      ! HAWC wind file. [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: User_WindNumber = 6      ! User defined wind. [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Highest_WindNumber = 6      ! Highest wind number supported. [-]
! =========  InflowWind_InputFile  =======
  TYPE, PUBLIC :: InflowWind_InputFile
    LOGICAL  :: EchoFlag      ! Echo the input file [-]
    INTEGER(IntKi)  :: WindType = 0      ! Type of windfile [-]
    REAL(ReKi)  :: PropogationDir      ! Direction of wind propogation (meteorological direction) [(degrees)]
    INTEGER(IntKi)  :: NWindVel      ! Number of points to output the wind velocity (0 to 9) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WindVxiList      ! List of X coordinates for wind velocity measurements [meters]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WindVyiList      ! List of Y coordinates for wind velocity measurements [meters]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WindVziList      ! List of Z coordinates for wind velocity measurements [meters]
    REAL(ReKi)  :: Steady_HWindSpeed      ! Steady wind -- horizontal windspeed [meters/s]
    REAL(ReKi)  :: Steady_RefHt      ! Steady wind -- reference height [meters]
    REAL(ReKi)  :: Steady_PLexp      ! Steady wind -- power law exponent [-]
    CHARACTER(1024)  :: Uniform_FileName      ! Uniform wind -- filename [-]
    REAL(ReKi)  :: Uniform_RefHt      ! Uniform wind -- reference height [meters]
    CHARACTER(1024)  :: TSFF_FileName      ! TurbSim Full-Field -- filename [-]
    CHARACTER(1024)  :: Bladed_FileName      ! Bladed-style Full-Field -- filename [-]
    LOGICAL  :: Bladed_TowerFile      ! Bladed-style Full-Field -- tower file exists [-]
    LOGICAL  :: CTTS_CoherentTurb      ! Coherent turbulence data exists [-]
    CHARACTER(1024)  :: CTTS_FileName      ! Name of coherent turbulence file [-]
    CHARACTER(1024)  :: CTTS_Path      ! Path to coherent turbulence binary data files [-]
    CHARACTER(1024)  :: HAWC_FileName_u      ! HAWC -- u component binary data file name [-]
    CHARACTER(1024)  :: HAWC_FileName_v      ! HAWC -- v component binary data file name [-]
    CHARACTER(1024)  :: HAWC_FileName_w      ! HAWC -- w component binary data file name [-]
    INTEGER(IntKi)  :: HAWC_nx      ! HAWC -- number of grids in x direction [-]
    INTEGER(IntKi)  :: HAWC_ny      ! HAWC -- number of grids in y direction [-]
    INTEGER(IntKi)  :: HAWC_nz      ! HAWC -- number of grids in z direction [-]
    REAL(ReKi)  :: HAWC_dx      ! HAWC -- distance between points in x direction [meters]
    REAL(ReKi)  :: HAWC_dy      ! HAWC -- distance between points in y direction [meters]
    REAL(ReKi)  :: HAWC_dz      ! HAWC -- distance between points in z direction [meters]
    REAL(ReKi)  :: HAWC_RefHt      ! HAWC -- reference height [meters]
    INTEGER(IntKi)  :: HAWC_ScaleMethod      ! HAWC -- scale method [-]
    REAL(ReKi)  :: HAWC_SFx      ! HAWC -- turbulence scaling factor x direction [-]
    REAL(ReKi)  :: HAWC_SFy      ! HAWC -- turbulence scaling factor y direction [-]
    REAL(ReKi)  :: HAWC_SFz      ! HAWC -- turbulence scaling factor z direction [-]
    REAL(ReKi)  :: HAWC_SigmaFx      ! HAWC -- turbulence standard deviation x direction [-]
    REAL(ReKi)  :: HAWC_SigmaFy      ! HAWC -- turbulence standard deviation y direction [-]
    REAL(ReKi)  :: HAWC_SigmaFz      ! HAWC -- turbulence standard deviation z direction [-]
    REAL(ReKi)  :: HAWC_TStart      ! HAWC -- start time for turbulence scaling [seconds]
    REAL(ReKi)  :: HAWC_TEnd      ! HAWC -- end time for turbulence scaling [seconds]
    REAL(ReKi)  :: HAWC_URef      ! HAWC -- Mean u-component wind speed at the reference height [meters]
    CHARACTER(1024)  :: HAWC_ProfileType      ! HAWC -- Wind profile type ('LOG'=logarithmic, 'PL'=power law, or 'UD'=user defined) [-]
    REAL(ReKi)  :: HAWC_PLExp      ! HAWC -- Power law exponent (used for PL wind profile type only) [-]
    REAL(ReKi)  :: HAWC_Z0      ! HAWC -- Surface roughness length (used for LOG wind profile type only) [-]
    LOGICAL  :: SumPrint      ! Print summary info [-]
    INTEGER(IntKi)  :: NumOuts      ! Number of parameters in the output list (number of outputs requested) [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: OutList      ! List of user-requested output channels [-]
  END TYPE InflowWind_InputFile
! =======================
! =========  InflowWind_InitInputType  =======
  TYPE, PUBLIC :: InflowWind_InitInputType
    CHARACTER(1024)  :: InputFileName      ! Name of the InflowWind input file to use [-]
    REAL(DbKi)  :: DT      ! Time step.  Supplied by driver [seconds]
    REAL(ReKi)  :: ReferenceHeight      ! Hub height of the turbine [meters]
    REAL(ReKi)  :: Width      ! Width of the wind field to use [meters]
    LOGICAL  :: UseInputFile = .TRUE.      ! Should we read everthing from an input file, or do we get it some other way [-]
    TYPE(InflowWind_InputFile)  :: PassedFileData      ! If we don't use the input file, pass everything through this [-]
  END TYPE InflowWind_InitInputType
! =======================
! =========  InflowWind_InitOutputType  =======
  TYPE, PUBLIC :: InflowWind_InitOutputType
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      ! Names of output-to-file channels [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      ! Units of output-to-file channels [-]
    TYPE(ProgDesc)  :: Ver      ! Version information of InflowWind module [-]
    REAL(ReKi)  :: HubHeight      ! Height of the hub [meters]
    TYPE(IfW_UniformWind_InitOutputType)  :: UniformWind      ! UniformWind InitOutput info [-]
  END TYPE InflowWind_InitOutputType
! =======================
! =========  InflowWind_OtherStateType  =======
  TYPE, PUBLIC :: InflowWind_OtherStateType
    INTEGER(IntKi)  :: TimeIndex = 0      ! An Index into the TData array [-]
    TYPE(IfW_UniformWind_OtherStateType)  :: UniformWind      ! OtherStates from UniformWind [-]
  END TYPE InflowWind_OtherStateType
! =======================
! =========  InflowWind_ParameterType  =======
  TYPE, PUBLIC :: InflowWind_ParameterType
    CHARACTER(1024)  :: WindFileName      ! Name of the wind file to use [-]
    CHARACTER(1024)  :: WindFileNameRoot      ! Root name of the wind file to use [-]
    CHARACTER(3)  :: WindFileExt      ! Extention of the name of the wind file [-]
    CHARACTER(1024)  :: InputFileName      ! Name of the InflowWind input   file to use [-]
    CHARACTER(1024)  :: RootFileName      ! Root of the InflowWind input   filename [-]
    CHARACTER(1024)  :: EchoFileName      ! Name of the InflowWind echo    file to use [-]
    CHARACTER(1024)  :: SumFileName      ! Name of the InflowWind summary file to use [-]
    LOGICAL  :: WriteSumFile      ! Write a summary file [-]
    INTEGER(IntKi)  :: UnitSumFile      ! Unit number for the summary file [-]
    LOGICAL  :: Initialized = .FALSE.      ! Flag to indicate if the module was initialized [-]
    LOGICAL  :: CTTS_Flag = .FALSE.      ! determines if coherent turbulence is used [-]
    REAL(DbKi)  :: DT      ! Time step for cont. state integration & disc. state update [seconds]
    REAL(ReKi)  :: PropogationDir      ! Direction of wind propogation [radians]
    INTEGER(IntKi)  :: WindType = 0      ! Type of wind -- set to Undef_Wind initially [-]
    REAL(ReKi)  :: ReferenceHeight      ! Height of the wind turbine [meters]
    REAL(ReKi)  :: Width      ! Width of the wind array [meters]
    REAL(ReKi)  :: HalfWidth      ! Half the Width of the wind array [meters]
    INTEGER(IntKi)  :: NWindVel      ! Number of points in the wind velocity list [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WindVxiList      ! List of X coordinates for wind velocity measurements [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WindVyiList      ! List of Y coordinates for wind velocity measurements [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WindVziList      ! List of Z coordinates for wind velocity measurements [-]
    TYPE(IfW_UniformWind_ParameterType)  :: UniformWind      ! Parameters from UniformWind [-]
    TYPE(IfW_HAWCWind_ParameterType)  :: HAWCWind      ! Parameters from HAWCWind [-]
  END TYPE InflowWind_ParameterType
! =======================
! =========  InflowWind_InputType  =======
  TYPE, PUBLIC :: InflowWind_InputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Position      ! Array holding the input positions at a given timestep [meters]
  END TYPE InflowWind_InputType
! =======================
! =========  InflowWind_OutputType  =======
  TYPE, PUBLIC :: InflowWind_OutputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Velocity      ! Array holding the U,V,W velocity for a given timestep [meters/sec]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      ! Array with values to output to file [-]
  END TYPE InflowWind_OutputType
! =======================
! =========  InflowWind_ContinuousStateType  =======
  TYPE, PUBLIC :: InflowWind_ContinuousStateType
    REAL(ReKi)  :: DummyContState      ! Remove this variable if you have continuous states [-]
  END TYPE InflowWind_ContinuousStateType
! =======================
! =========  InflowWind_DiscreteStateType  =======
  TYPE, PUBLIC :: InflowWind_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState      ! Remove this variable if you have discrete states [-]
  END TYPE InflowWind_DiscreteStateType
! =======================
! =========  InflowWind_ConstraintStateType  =======
  TYPE, PUBLIC :: InflowWind_ConstraintStateType
    REAL(ReKi)  :: DummyConstrState      ! Remove this variable if you have constraint states [-]
  END TYPE InflowWind_ConstraintStateType
! =======================
CONTAINS
 SUBROUTINE InflowWind_Copyinputfile( SrcinputfileData, DstinputfileData, CtrlCode, ErrStat, ErrMsg )
   TYPE(inflowwind_inputfile), INTENT(INOUT) :: SrcinputfileData
   TYPE(inflowwind_inputfile), INTENT(INOUT) :: DstinputfileData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstinputfileData%EchoFlag = SrcinputfileData%EchoFlag
   DstinputfileData%WindType = SrcinputfileData%WindType
   DstinputfileData%PropogationDir = SrcinputfileData%PropogationDir
   DstinputfileData%NWindVel = SrcinputfileData%NWindVel
IF (ALLOCATED(SrcinputfileData%WindVxiList)) THEN
   i1_l = LBOUND(SrcinputfileData%WindVxiList,1)
   i1_u = UBOUND(SrcinputfileData%WindVxiList,1)
   IF (.NOT. ALLOCATED(DstinputfileData%WindVxiList)) THEN 
      ALLOCATE(DstinputfileData%WindVxiList(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'InflowWind_Copyinputfile: Error allocating DstinputfileData%WindVxiList.'
         RETURN
      END IF
   END IF
   DstinputfileData%WindVxiList = SrcinputfileData%WindVxiList
ENDIF
IF (ALLOCATED(SrcinputfileData%WindVyiList)) THEN
   i1_l = LBOUND(SrcinputfileData%WindVyiList,1)
   i1_u = UBOUND(SrcinputfileData%WindVyiList,1)
   IF (.NOT. ALLOCATED(DstinputfileData%WindVyiList)) THEN 
      ALLOCATE(DstinputfileData%WindVyiList(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'InflowWind_Copyinputfile: Error allocating DstinputfileData%WindVyiList.'
         RETURN
      END IF
   END IF
   DstinputfileData%WindVyiList = SrcinputfileData%WindVyiList
ENDIF
IF (ALLOCATED(SrcinputfileData%WindVziList)) THEN
   i1_l = LBOUND(SrcinputfileData%WindVziList,1)
   i1_u = UBOUND(SrcinputfileData%WindVziList,1)
   IF (.NOT. ALLOCATED(DstinputfileData%WindVziList)) THEN 
      ALLOCATE(DstinputfileData%WindVziList(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'InflowWind_Copyinputfile: Error allocating DstinputfileData%WindVziList.'
         RETURN
      END IF
   END IF
   DstinputfileData%WindVziList = SrcinputfileData%WindVziList
ENDIF
   DstinputfileData%Steady_HWindSpeed = SrcinputfileData%Steady_HWindSpeed
   DstinputfileData%Steady_RefHt = SrcinputfileData%Steady_RefHt
   DstinputfileData%Steady_PLexp = SrcinputfileData%Steady_PLexp
   DstinputfileData%Uniform_FileName = SrcinputfileData%Uniform_FileName
   DstinputfileData%Uniform_RefHt = SrcinputfileData%Uniform_RefHt
   DstinputfileData%TSFF_FileName = SrcinputfileData%TSFF_FileName
   DstinputfileData%Bladed_FileName = SrcinputfileData%Bladed_FileName
   DstinputfileData%Bladed_TowerFile = SrcinputfileData%Bladed_TowerFile
   DstinputfileData%CTTS_CoherentTurb = SrcinputfileData%CTTS_CoherentTurb
   DstinputfileData%CTTS_FileName = SrcinputfileData%CTTS_FileName
   DstinputfileData%CTTS_Path = SrcinputfileData%CTTS_Path
   DstinputfileData%HAWC_FileName_u = SrcinputfileData%HAWC_FileName_u
   DstinputfileData%HAWC_FileName_v = SrcinputfileData%HAWC_FileName_v
   DstinputfileData%HAWC_FileName_w = SrcinputfileData%HAWC_FileName_w
   DstinputfileData%HAWC_nx = SrcinputfileData%HAWC_nx
   DstinputfileData%HAWC_ny = SrcinputfileData%HAWC_ny
   DstinputfileData%HAWC_nz = SrcinputfileData%HAWC_nz
   DstinputfileData%HAWC_dx = SrcinputfileData%HAWC_dx
   DstinputfileData%HAWC_dy = SrcinputfileData%HAWC_dy
   DstinputfileData%HAWC_dz = SrcinputfileData%HAWC_dz
   DstinputfileData%HAWC_RefHt = SrcinputfileData%HAWC_RefHt
   DstinputfileData%HAWC_ScaleMethod = SrcinputfileData%HAWC_ScaleMethod
   DstinputfileData%HAWC_SFx = SrcinputfileData%HAWC_SFx
   DstinputfileData%HAWC_SFy = SrcinputfileData%HAWC_SFy
   DstinputfileData%HAWC_SFz = SrcinputfileData%HAWC_SFz
   DstinputfileData%HAWC_SigmaFx = SrcinputfileData%HAWC_SigmaFx
   DstinputfileData%HAWC_SigmaFy = SrcinputfileData%HAWC_SigmaFy
   DstinputfileData%HAWC_SigmaFz = SrcinputfileData%HAWC_SigmaFz
   DstinputfileData%HAWC_TStart = SrcinputfileData%HAWC_TStart
   DstinputfileData%HAWC_TEnd = SrcinputfileData%HAWC_TEnd
   DstinputfileData%HAWC_URef = SrcinputfileData%HAWC_URef
   DstinputfileData%HAWC_ProfileType = SrcinputfileData%HAWC_ProfileType
   DstinputfileData%HAWC_PLExp = SrcinputfileData%HAWC_PLExp
   DstinputfileData%HAWC_Z0 = SrcinputfileData%HAWC_Z0
   DstinputfileData%SumPrint = SrcinputfileData%SumPrint
   DstinputfileData%NumOuts = SrcinputfileData%NumOuts
IF (ALLOCATED(SrcinputfileData%OutList)) THEN
   i1_l = LBOUND(SrcinputfileData%OutList,1)
   i1_u = UBOUND(SrcinputfileData%OutList,1)
   IF (.NOT. ALLOCATED(DstinputfileData%OutList)) THEN 
      ALLOCATE(DstinputfileData%OutList(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'InflowWind_Copyinputfile: Error allocating DstinputfileData%OutList.'
         RETURN
      END IF
   END IF
   DstinputfileData%OutList = SrcinputfileData%OutList
ENDIF
 END SUBROUTINE InflowWind_Copyinputfile

 SUBROUTINE InflowWind_Destroyinputfile( inputfileData, ErrStat, ErrMsg )
  TYPE(inflowwind_inputfile), INTENT(INOUT) :: inputfileData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(inputfileData%WindVxiList)) THEN
   DEALLOCATE(inputfileData%WindVxiList)
ENDIF
IF (ALLOCATED(inputfileData%WindVyiList)) THEN
   DEALLOCATE(inputfileData%WindVyiList)
ENDIF
IF (ALLOCATED(inputfileData%WindVziList)) THEN
   DEALLOCATE(inputfileData%WindVziList)
ENDIF
IF (ALLOCATED(inputfileData%OutList)) THEN
   DEALLOCATE(inputfileData%OutList)
ENDIF
 END SUBROUTINE InflowWind_Destroyinputfile

 SUBROUTINE InflowWind_Packinputfile( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(inflowwind_inputfile),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! WindType
  Re_BufSz   = Re_BufSz   + 1  ! PropogationDir
  Int_BufSz  = Int_BufSz  + 1  ! NWindVel
  Re_BufSz    = Re_BufSz    + SIZE( InData%WindVxiList )  ! WindVxiList 
  Re_BufSz    = Re_BufSz    + SIZE( InData%WindVyiList )  ! WindVyiList 
  Re_BufSz    = Re_BufSz    + SIZE( InData%WindVziList )  ! WindVziList 
  Re_BufSz   = Re_BufSz   + 1  ! Steady_HWindSpeed
  Re_BufSz   = Re_BufSz   + 1  ! Steady_RefHt
  Re_BufSz   = Re_BufSz   + 1  ! Steady_PLexp
  Re_BufSz   = Re_BufSz   + 1  ! Uniform_RefHt
  Int_BufSz  = Int_BufSz  + 1  ! HAWC_nx
  Int_BufSz  = Int_BufSz  + 1  ! HAWC_ny
  Int_BufSz  = Int_BufSz  + 1  ! HAWC_nz
  Re_BufSz   = Re_BufSz   + 1  ! HAWC_dx
  Re_BufSz   = Re_BufSz   + 1  ! HAWC_dy
  Re_BufSz   = Re_BufSz   + 1  ! HAWC_dz
  Re_BufSz   = Re_BufSz   + 1  ! HAWC_RefHt
  Int_BufSz  = Int_BufSz  + 1  ! HAWC_ScaleMethod
  Re_BufSz   = Re_BufSz   + 1  ! HAWC_SFx
  Re_BufSz   = Re_BufSz   + 1  ! HAWC_SFy
  Re_BufSz   = Re_BufSz   + 1  ! HAWC_SFz
  Re_BufSz   = Re_BufSz   + 1  ! HAWC_SigmaFx
  Re_BufSz   = Re_BufSz   + 1  ! HAWC_SigmaFy
  Re_BufSz   = Re_BufSz   + 1  ! HAWC_SigmaFz
  Re_BufSz   = Re_BufSz   + 1  ! HAWC_TStart
  Re_BufSz   = Re_BufSz   + 1  ! HAWC_TEnd
  Re_BufSz   = Re_BufSz   + 1  ! HAWC_URef
  Re_BufSz   = Re_BufSz   + 1  ! HAWC_PLExp
  Re_BufSz   = Re_BufSz   + 1  ! HAWC_Z0
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%WindType )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PropogationDir )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NWindVel )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%WindVxiList) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WindVxiList))-1 ) =  PACK(InData%WindVxiList ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WindVxiList)
  ENDIF
  IF ( ALLOCATED(InData%WindVyiList) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WindVyiList))-1 ) =  PACK(InData%WindVyiList ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WindVyiList)
  ENDIF
  IF ( ALLOCATED(InData%WindVziList) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WindVziList))-1 ) =  PACK(InData%WindVziList ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WindVziList)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Steady_HWindSpeed )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Steady_RefHt )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Steady_PLexp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Uniform_RefHt )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%HAWC_nx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%HAWC_ny )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%HAWC_nz )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HAWC_dx )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HAWC_dy )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HAWC_dz )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HAWC_RefHt )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%HAWC_ScaleMethod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HAWC_SFx )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HAWC_SFy )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HAWC_SFz )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HAWC_SigmaFx )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HAWC_SigmaFy )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HAWC_SigmaFz )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HAWC_TStart )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HAWC_TEnd )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HAWC_URef )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HAWC_PLExp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HAWC_Z0 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE InflowWind_Packinputfile

 SUBROUTINE InflowWind_UnPackinputfile( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(inflowwind_inputfile), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%WindType = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%PropogationDir = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NWindVel = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%WindVxiList) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WindVxiList,1))); mask1 = .TRUE.
    OutData%WindVxiList = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WindVxiList))-1 ),mask1,OutData%WindVxiList)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WindVxiList)
  ENDIF
  IF ( ALLOCATED(OutData%WindVyiList) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WindVyiList,1))); mask1 = .TRUE.
    OutData%WindVyiList = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WindVyiList))-1 ),mask1,OutData%WindVyiList)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WindVyiList)
  ENDIF
  IF ( ALLOCATED(OutData%WindVziList) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WindVziList,1))); mask1 = .TRUE.
    OutData%WindVziList = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WindVziList))-1 ),mask1,OutData%WindVziList)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WindVziList)
  ENDIF
  OutData%Steady_HWindSpeed = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Steady_RefHt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Steady_PLexp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Uniform_RefHt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HAWC_nx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%HAWC_ny = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%HAWC_nz = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%HAWC_dx = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HAWC_dy = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HAWC_dz = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HAWC_RefHt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HAWC_ScaleMethod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%HAWC_SFx = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HAWC_SFy = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HAWC_SFz = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HAWC_SigmaFx = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HAWC_SigmaFy = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HAWC_SigmaFz = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HAWC_TStart = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HAWC_TEnd = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HAWC_URef = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HAWC_PLExp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HAWC_Z0 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE InflowWind_UnPackinputfile

 SUBROUTINE InflowWind_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(InflowWind_initinputtype), INTENT(INOUT) :: SrcInitInputData
   TYPE(InflowWind_initinputtype), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%InputFileName = SrcInitInputData%InputFileName
   DstInitInputData%DT = SrcInitInputData%DT
   DstInitInputData%ReferenceHeight = SrcInitInputData%ReferenceHeight
   DstInitInputData%Width = SrcInitInputData%Width
   DstInitInputData%UseInputFile = SrcInitInputData%UseInputFile
      CALL InflowWind_Copyinputfile( SrcInitInputData%PassedFileData, DstInitInputData%PassedFileData, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE InflowWind_CopyInitInput

 SUBROUTINE InflowWind_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(InflowWind_initinputtype), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL InflowWind_Destroyinputfile( InitInputData%PassedFileData, ErrStat, ErrMsg )
 END SUBROUTINE InflowWind_DestroyInitInput

 SUBROUTINE InflowWind_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(InflowWind_initinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_PassedFileData_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_PassedFileData_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_PassedFileData_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! DT
  Re_BufSz   = Re_BufSz   + 1  ! ReferenceHeight
  Re_BufSz   = Re_BufSz   + 1  ! Width
  CALL InflowWind_Packinputfile( Re_PassedFileData_Buf, Db_PassedFileData_Buf, Int_PassedFileData_Buf, InData%PassedFileData, ErrStat, ErrMsg, .TRUE. ) ! PassedFileData 
  IF(ALLOCATED(Re_PassedFileData_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_PassedFileData_Buf  ) ! PassedFileData
  IF(ALLOCATED(Db_PassedFileData_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_PassedFileData_Buf  ) ! PassedFileData
  IF(ALLOCATED(Int_PassedFileData_Buf))Int_BufSz = Int_BufSz + SIZE( Int_PassedFileData_Buf ) ! PassedFileData
  IF(ALLOCATED(Re_PassedFileData_Buf))  DEALLOCATE(Re_PassedFileData_Buf)
  IF(ALLOCATED(Db_PassedFileData_Buf))  DEALLOCATE(Db_PassedFileData_Buf)
  IF(ALLOCATED(Int_PassedFileData_Buf)) DEALLOCATE(Int_PassedFileData_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%ReferenceHeight )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Width )
  Re_Xferred   = Re_Xferred   + 1
  CALL InflowWind_Packinputfile( Re_PassedFileData_Buf, Db_PassedFileData_Buf, Int_PassedFileData_Buf, InData%PassedFileData, ErrStat, ErrMsg, OnlySize ) ! PassedFileData 
  IF(ALLOCATED(Re_PassedFileData_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PassedFileData_Buf)-1 ) = Re_PassedFileData_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_PassedFileData_Buf)
  ENDIF
  IF(ALLOCATED(Db_PassedFileData_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PassedFileData_Buf)-1 ) = Db_PassedFileData_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_PassedFileData_Buf)
  ENDIF
  IF(ALLOCATED(Int_PassedFileData_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PassedFileData_Buf)-1 ) = Int_PassedFileData_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_PassedFileData_Buf)
  ENDIF
  IF( ALLOCATED(Re_PassedFileData_Buf) )  DEALLOCATE(Re_PassedFileData_Buf)
  IF( ALLOCATED(Db_PassedFileData_Buf) )  DEALLOCATE(Db_PassedFileData_Buf)
  IF( ALLOCATED(Int_PassedFileData_Buf) ) DEALLOCATE(Int_PassedFileData_Buf)
 END SUBROUTINE InflowWind_PackInitInput

 SUBROUTINE InflowWind_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(InflowWind_initinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_PassedFileData_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_PassedFileData_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_PassedFileData_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%ReferenceHeight = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Width = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
 ! first call InflowWind_Packinputfile to get correctly sized buffers for unpacking
  CALL InflowWind_Packinputfile( Re_PassedFileData_Buf, Db_PassedFileData_Buf, Int_PassedFileData_Buf, OutData%PassedFileData, ErrStat, ErrMsg, .TRUE. ) ! PassedFileData 
  IF(ALLOCATED(Re_PassedFileData_Buf)) THEN
    Re_PassedFileData_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PassedFileData_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_PassedFileData_Buf)
  ENDIF
  IF(ALLOCATED(Db_PassedFileData_Buf)) THEN
    Db_PassedFileData_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PassedFileData_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_PassedFileData_Buf)
  ENDIF
  IF(ALLOCATED(Int_PassedFileData_Buf)) THEN
    Int_PassedFileData_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PassedFileData_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_PassedFileData_Buf)
  ENDIF
  CALL InflowWind_UnPackinputfile( Re_PassedFileData_Buf, Db_PassedFileData_Buf, Int_PassedFileData_Buf, OutData%PassedFileData, ErrStat, ErrMsg ) ! PassedFileData 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE InflowWind_UnPackInitInput

 SUBROUTINE InflowWind_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(InflowWind_initoutputtype), INTENT(INOUT) :: SrcInitOutputData
   TYPE(InflowWind_initoutputtype), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'InflowWind_CopyInitOutput: Error allocating DstInitOutputData%WriteOutputHdr.'
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'InflowWind_CopyInitOutput: Error allocating DstInitOutputData%WriteOutputUnt.'
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat, ErrMsg )
   DstInitOutputData%HubHeight = SrcInitOutputData%HubHeight
      CALL IfW_UniformWind_CopyInitOutput( SrcInitOutputData%UniformWind, DstInitOutputData%UniformWind, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE InflowWind_CopyInitOutput

 SUBROUTINE InflowWind_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(InflowWind_initoutputtype), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
   DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
   DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Ver, ErrStat, ErrMsg )
  CALL IfW_UniformWind_DestroyInitOutput( InitOutputData%UniformWind, ErrStat, ErrMsg )
 END SUBROUTINE InflowWind_DestroyInitOutput

 SUBROUTINE InflowWind_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(InflowWind_initoutputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Ver_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_UniformWind_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_UniformWind_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_UniformWind_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Db_Ver_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Int_Ver_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Ver_Buf ) ! Ver
  IF(ALLOCATED(Re_Ver_Buf))  DEALLOCATE(Re_Ver_Buf)
  IF(ALLOCATED(Db_Ver_Buf))  DEALLOCATE(Db_Ver_Buf)
  IF(ALLOCATED(Int_Ver_Buf)) DEALLOCATE(Int_Ver_Buf)
  Re_BufSz   = Re_BufSz   + 1  ! HubHeight
  CALL IfW_UniformWind_PackInitOutput( Re_UniformWind_Buf, Db_UniformWind_Buf, Int_UniformWind_Buf, InData%UniformWind, ErrStat, ErrMsg, .TRUE. ) ! UniformWind 
  IF(ALLOCATED(Re_UniformWind_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_UniformWind_Buf  ) ! UniformWind
  IF(ALLOCATED(Db_UniformWind_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_UniformWind_Buf  ) ! UniformWind
  IF(ALLOCATED(Int_UniformWind_Buf))Int_BufSz = Int_BufSz + SIZE( Int_UniformWind_Buf ) ! UniformWind
  IF(ALLOCATED(Re_UniformWind_Buf))  DEALLOCATE(Re_UniformWind_Buf)
  IF(ALLOCATED(Db_UniformWind_Buf))  DEALLOCATE(Db_UniformWind_Buf)
  IF(ALLOCATED(Int_UniformWind_Buf)) DEALLOCATE(Int_UniformWind_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, OnlySize ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 ) = Re_Ver_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 ) = Db_Ver_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 ) = Int_Ver_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  IF( ALLOCATED(Re_Ver_Buf) )  DEALLOCATE(Re_Ver_Buf)
  IF( ALLOCATED(Db_Ver_Buf) )  DEALLOCATE(Db_Ver_Buf)
  IF( ALLOCATED(Int_Ver_Buf) ) DEALLOCATE(Int_Ver_Buf)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HubHeight )
  Re_Xferred   = Re_Xferred   + 1
  CALL IfW_UniformWind_PackInitOutput( Re_UniformWind_Buf, Db_UniformWind_Buf, Int_UniformWind_Buf, InData%UniformWind, ErrStat, ErrMsg, OnlySize ) ! UniformWind 
  IF(ALLOCATED(Re_UniformWind_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_UniformWind_Buf)-1 ) = Re_UniformWind_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_UniformWind_Buf)
  ENDIF
  IF(ALLOCATED(Db_UniformWind_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_UniformWind_Buf)-1 ) = Db_UniformWind_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_UniformWind_Buf)
  ENDIF
  IF(ALLOCATED(Int_UniformWind_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_UniformWind_Buf)-1 ) = Int_UniformWind_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_UniformWind_Buf)
  ENDIF
  IF( ALLOCATED(Re_UniformWind_Buf) )  DEALLOCATE(Re_UniformWind_Buf)
  IF( ALLOCATED(Db_UniformWind_Buf) )  DEALLOCATE(Db_UniformWind_Buf)
  IF( ALLOCATED(Int_UniformWind_Buf) ) DEALLOCATE(Int_UniformWind_Buf)
 END SUBROUTINE InflowWind_PackInitOutput

 SUBROUTINE InflowWind_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(InflowWind_initoutputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Ver_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_UniformWind_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_UniformWind_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_UniformWind_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call NWTC_Library_Packprogdesc to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    Re_Ver_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    Db_Ver_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    Int_Ver_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  CALL NWTC_Library_UnPackprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg ) ! Ver 
  OutData%HubHeight = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
 ! first call IfW_UniformWind_PackInitOutput to get correctly sized buffers for unpacking
  CALL IfW_UniformWind_PackInitOutput( Re_UniformWind_Buf, Db_UniformWind_Buf, Int_UniformWind_Buf, OutData%UniformWind, ErrStat, ErrMsg, .TRUE. ) ! UniformWind 
  IF(ALLOCATED(Re_UniformWind_Buf)) THEN
    Re_UniformWind_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_UniformWind_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_UniformWind_Buf)
  ENDIF
  IF(ALLOCATED(Db_UniformWind_Buf)) THEN
    Db_UniformWind_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_UniformWind_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_UniformWind_Buf)
  ENDIF
  IF(ALLOCATED(Int_UniformWind_Buf)) THEN
    Int_UniformWind_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_UniformWind_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_UniformWind_Buf)
  ENDIF
  CALL IfW_UniformWind_UnPackInitOutput( Re_UniformWind_Buf, Db_UniformWind_Buf, Int_UniformWind_Buf, OutData%UniformWind, ErrStat, ErrMsg ) ! UniformWind 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE InflowWind_UnPackInitOutput

 SUBROUTINE InflowWind_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(InflowWind_otherstatetype), INTENT(INOUT) :: SrcOtherStateData
   TYPE(InflowWind_otherstatetype), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstOtherStateData%TimeIndex = SrcOtherStateData%TimeIndex
      CALL IfW_UniformWind_CopyOtherState( SrcOtherStateData%UniformWind, DstOtherStateData%UniformWind, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE InflowWind_CopyOtherState

 SUBROUTINE InflowWind_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(InflowWind_otherstatetype), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL IfW_UniformWind_DestroyOtherState( OtherStateData%UniformWind, ErrStat, ErrMsg )
 END SUBROUTINE InflowWind_DestroyOtherState

 SUBROUTINE InflowWind_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(InflowWind_otherstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_UniformWind_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_UniformWind_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_UniformWind_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! TimeIndex
  CALL IfW_UniformWind_PackOtherState( Re_UniformWind_Buf, Db_UniformWind_Buf, Int_UniformWind_Buf, InData%UniformWind, ErrStat, ErrMsg, .TRUE. ) ! UniformWind 
  IF(ALLOCATED(Re_UniformWind_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_UniformWind_Buf  ) ! UniformWind
  IF(ALLOCATED(Db_UniformWind_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_UniformWind_Buf  ) ! UniformWind
  IF(ALLOCATED(Int_UniformWind_Buf))Int_BufSz = Int_BufSz + SIZE( Int_UniformWind_Buf ) ! UniformWind
  IF(ALLOCATED(Re_UniformWind_Buf))  DEALLOCATE(Re_UniformWind_Buf)
  IF(ALLOCATED(Db_UniformWind_Buf))  DEALLOCATE(Db_UniformWind_Buf)
  IF(ALLOCATED(Int_UniformWind_Buf)) DEALLOCATE(Int_UniformWind_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%TimeIndex )
  Int_Xferred   = Int_Xferred   + 1
  CALL IfW_UniformWind_PackOtherState( Re_UniformWind_Buf, Db_UniformWind_Buf, Int_UniformWind_Buf, InData%UniformWind, ErrStat, ErrMsg, OnlySize ) ! UniformWind 
  IF(ALLOCATED(Re_UniformWind_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_UniformWind_Buf)-1 ) = Re_UniformWind_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_UniformWind_Buf)
  ENDIF
  IF(ALLOCATED(Db_UniformWind_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_UniformWind_Buf)-1 ) = Db_UniformWind_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_UniformWind_Buf)
  ENDIF
  IF(ALLOCATED(Int_UniformWind_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_UniformWind_Buf)-1 ) = Int_UniformWind_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_UniformWind_Buf)
  ENDIF
  IF( ALLOCATED(Re_UniformWind_Buf) )  DEALLOCATE(Re_UniformWind_Buf)
  IF( ALLOCATED(Db_UniformWind_Buf) )  DEALLOCATE(Db_UniformWind_Buf)
  IF( ALLOCATED(Int_UniformWind_Buf) ) DEALLOCATE(Int_UniformWind_Buf)
 END SUBROUTINE InflowWind_PackOtherState

 SUBROUTINE InflowWind_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(InflowWind_otherstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_UniformWind_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_UniformWind_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_UniformWind_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%TimeIndex = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
 ! first call IfW_UniformWind_PackOtherState to get correctly sized buffers for unpacking
  CALL IfW_UniformWind_PackOtherState( Re_UniformWind_Buf, Db_UniformWind_Buf, Int_UniformWind_Buf, OutData%UniformWind, ErrStat, ErrMsg, .TRUE. ) ! UniformWind 
  IF(ALLOCATED(Re_UniformWind_Buf)) THEN
    Re_UniformWind_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_UniformWind_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_UniformWind_Buf)
  ENDIF
  IF(ALLOCATED(Db_UniformWind_Buf)) THEN
    Db_UniformWind_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_UniformWind_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_UniformWind_Buf)
  ENDIF
  IF(ALLOCATED(Int_UniformWind_Buf)) THEN
    Int_UniformWind_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_UniformWind_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_UniformWind_Buf)
  ENDIF
  CALL IfW_UniformWind_UnPackOtherState( Re_UniformWind_Buf, Db_UniformWind_Buf, Int_UniformWind_Buf, OutData%UniformWind, ErrStat, ErrMsg ) ! UniformWind 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE InflowWind_UnPackOtherState

 SUBROUTINE InflowWind_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(InflowWind_parametertype), INTENT(INOUT) :: SrcParamData
   TYPE(InflowWind_parametertype), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%WindFileName = SrcParamData%WindFileName
   DstParamData%WindFileNameRoot = SrcParamData%WindFileNameRoot
   DstParamData%WindFileExt = SrcParamData%WindFileExt
   DstParamData%InputFileName = SrcParamData%InputFileName
   DstParamData%RootFileName = SrcParamData%RootFileName
   DstParamData%EchoFileName = SrcParamData%EchoFileName
   DstParamData%SumFileName = SrcParamData%SumFileName
   DstParamData%WriteSumFile = SrcParamData%WriteSumFile
   DstParamData%UnitSumFile = SrcParamData%UnitSumFile
   DstParamData%Initialized = SrcParamData%Initialized
   DstParamData%CTTS_Flag = SrcParamData%CTTS_Flag
   DstParamData%DT = SrcParamData%DT
   DstParamData%PropogationDir = SrcParamData%PropogationDir
   DstParamData%WindType = SrcParamData%WindType
   DstParamData%ReferenceHeight = SrcParamData%ReferenceHeight
   DstParamData%Width = SrcParamData%Width
   DstParamData%HalfWidth = SrcParamData%HalfWidth
   DstParamData%NWindVel = SrcParamData%NWindVel
IF (ALLOCATED(SrcParamData%WindVxiList)) THEN
   i1_l = LBOUND(SrcParamData%WindVxiList,1)
   i1_u = UBOUND(SrcParamData%WindVxiList,1)
   IF (.NOT. ALLOCATED(DstParamData%WindVxiList)) THEN 
      ALLOCATE(DstParamData%WindVxiList(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'InflowWind_CopyParam: Error allocating DstParamData%WindVxiList.'
         RETURN
      END IF
   END IF
   DstParamData%WindVxiList = SrcParamData%WindVxiList
ENDIF
IF (ALLOCATED(SrcParamData%WindVyiList)) THEN
   i1_l = LBOUND(SrcParamData%WindVyiList,1)
   i1_u = UBOUND(SrcParamData%WindVyiList,1)
   IF (.NOT. ALLOCATED(DstParamData%WindVyiList)) THEN 
      ALLOCATE(DstParamData%WindVyiList(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'InflowWind_CopyParam: Error allocating DstParamData%WindVyiList.'
         RETURN
      END IF
   END IF
   DstParamData%WindVyiList = SrcParamData%WindVyiList
ENDIF
IF (ALLOCATED(SrcParamData%WindVziList)) THEN
   i1_l = LBOUND(SrcParamData%WindVziList,1)
   i1_u = UBOUND(SrcParamData%WindVziList,1)
   IF (.NOT. ALLOCATED(DstParamData%WindVziList)) THEN 
      ALLOCATE(DstParamData%WindVziList(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'InflowWind_CopyParam: Error allocating DstParamData%WindVziList.'
         RETURN
      END IF
   END IF
   DstParamData%WindVziList = SrcParamData%WindVziList
ENDIF
      CALL IfW_UniformWind_CopyParam( SrcParamData%UniformWind, DstParamData%UniformWind, CtrlCode, ErrStat, ErrMsg )
      CALL IfW_HAWCWind_CopyParam( SrcParamData%HAWCWind, DstParamData%HAWCWind, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE InflowWind_CopyParam

 SUBROUTINE InflowWind_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(InflowWind_parametertype), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%WindVxiList)) THEN
   DEALLOCATE(ParamData%WindVxiList)
ENDIF
IF (ALLOCATED(ParamData%WindVyiList)) THEN
   DEALLOCATE(ParamData%WindVyiList)
ENDIF
IF (ALLOCATED(ParamData%WindVziList)) THEN
   DEALLOCATE(ParamData%WindVziList)
ENDIF
  CALL IfW_UniformWind_DestroyParam( ParamData%UniformWind, ErrStat, ErrMsg )
  CALL IfW_HAWCWind_DestroyParam( ParamData%HAWCWind, ErrStat, ErrMsg )
 END SUBROUTINE InflowWind_DestroyParam

 SUBROUTINE InflowWind_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(InflowWind_parametertype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_UniformWind_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_UniformWind_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_UniformWind_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_HAWCWind_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_HAWCWind_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_HAWCWind_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! UnitSumFile
  Db_BufSz   = Db_BufSz   + 1  ! DT
  Re_BufSz   = Re_BufSz   + 1  ! PropogationDir
  Int_BufSz  = Int_BufSz  + 1  ! WindType
  Re_BufSz   = Re_BufSz   + 1  ! ReferenceHeight
  Re_BufSz   = Re_BufSz   + 1  ! Width
  Re_BufSz   = Re_BufSz   + 1  ! HalfWidth
  Int_BufSz  = Int_BufSz  + 1  ! NWindVel
  Re_BufSz    = Re_BufSz    + SIZE( InData%WindVxiList )  ! WindVxiList 
  Re_BufSz    = Re_BufSz    + SIZE( InData%WindVyiList )  ! WindVyiList 
  Re_BufSz    = Re_BufSz    + SIZE( InData%WindVziList )  ! WindVziList 
  CALL IfW_UniformWind_PackParam( Re_UniformWind_Buf, Db_UniformWind_Buf, Int_UniformWind_Buf, InData%UniformWind, ErrStat, ErrMsg, .TRUE. ) ! UniformWind 
  IF(ALLOCATED(Re_UniformWind_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_UniformWind_Buf  ) ! UniformWind
  IF(ALLOCATED(Db_UniformWind_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_UniformWind_Buf  ) ! UniformWind
  IF(ALLOCATED(Int_UniformWind_Buf))Int_BufSz = Int_BufSz + SIZE( Int_UniformWind_Buf ) ! UniformWind
  IF(ALLOCATED(Re_UniformWind_Buf))  DEALLOCATE(Re_UniformWind_Buf)
  IF(ALLOCATED(Db_UniformWind_Buf))  DEALLOCATE(Db_UniformWind_Buf)
  IF(ALLOCATED(Int_UniformWind_Buf)) DEALLOCATE(Int_UniformWind_Buf)
  CALL IfW_HAWCWind_PackParam( Re_HAWCWind_Buf, Db_HAWCWind_Buf, Int_HAWCWind_Buf, InData%HAWCWind, ErrStat, ErrMsg, .TRUE. ) ! HAWCWind 
  IF(ALLOCATED(Re_HAWCWind_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_HAWCWind_Buf  ) ! HAWCWind
  IF(ALLOCATED(Db_HAWCWind_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_HAWCWind_Buf  ) ! HAWCWind
  IF(ALLOCATED(Int_HAWCWind_Buf))Int_BufSz = Int_BufSz + SIZE( Int_HAWCWind_Buf ) ! HAWCWind
  IF(ALLOCATED(Re_HAWCWind_Buf))  DEALLOCATE(Re_HAWCWind_Buf)
  IF(ALLOCATED(Db_HAWCWind_Buf))  DEALLOCATE(Db_HAWCWind_Buf)
  IF(ALLOCATED(Int_HAWCWind_Buf)) DEALLOCATE(Int_HAWCWind_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%UnitSumFile )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PropogationDir )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%WindType )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%ReferenceHeight )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Width )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%HalfWidth )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NWindVel )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%WindVxiList) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WindVxiList))-1 ) =  PACK(InData%WindVxiList ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WindVxiList)
  ENDIF
  IF ( ALLOCATED(InData%WindVyiList) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WindVyiList))-1 ) =  PACK(InData%WindVyiList ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WindVyiList)
  ENDIF
  IF ( ALLOCATED(InData%WindVziList) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WindVziList))-1 ) =  PACK(InData%WindVziList ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WindVziList)
  ENDIF
  CALL IfW_UniformWind_PackParam( Re_UniformWind_Buf, Db_UniformWind_Buf, Int_UniformWind_Buf, InData%UniformWind, ErrStat, ErrMsg, OnlySize ) ! UniformWind 
  IF(ALLOCATED(Re_UniformWind_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_UniformWind_Buf)-1 ) = Re_UniformWind_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_UniformWind_Buf)
  ENDIF
  IF(ALLOCATED(Db_UniformWind_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_UniformWind_Buf)-1 ) = Db_UniformWind_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_UniformWind_Buf)
  ENDIF
  IF(ALLOCATED(Int_UniformWind_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_UniformWind_Buf)-1 ) = Int_UniformWind_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_UniformWind_Buf)
  ENDIF
  IF( ALLOCATED(Re_UniformWind_Buf) )  DEALLOCATE(Re_UniformWind_Buf)
  IF( ALLOCATED(Db_UniformWind_Buf) )  DEALLOCATE(Db_UniformWind_Buf)
  IF( ALLOCATED(Int_UniformWind_Buf) ) DEALLOCATE(Int_UniformWind_Buf)
  CALL IfW_HAWCWind_PackParam( Re_HAWCWind_Buf, Db_HAWCWind_Buf, Int_HAWCWind_Buf, InData%HAWCWind, ErrStat, ErrMsg, OnlySize ) ! HAWCWind 
  IF(ALLOCATED(Re_HAWCWind_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_HAWCWind_Buf)-1 ) = Re_HAWCWind_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_HAWCWind_Buf)
  ENDIF
  IF(ALLOCATED(Db_HAWCWind_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_HAWCWind_Buf)-1 ) = Db_HAWCWind_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_HAWCWind_Buf)
  ENDIF
  IF(ALLOCATED(Int_HAWCWind_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_HAWCWind_Buf)-1 ) = Int_HAWCWind_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_HAWCWind_Buf)
  ENDIF
  IF( ALLOCATED(Re_HAWCWind_Buf) )  DEALLOCATE(Re_HAWCWind_Buf)
  IF( ALLOCATED(Db_HAWCWind_Buf) )  DEALLOCATE(Db_HAWCWind_Buf)
  IF( ALLOCATED(Int_HAWCWind_Buf) ) DEALLOCATE(Int_HAWCWind_Buf)
 END SUBROUTINE InflowWind_PackParam

 SUBROUTINE InflowWind_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(InflowWind_parametertype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_UniformWind_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_UniformWind_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_UniformWind_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_HAWCWind_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_HAWCWind_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_HAWCWind_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%UnitSumFile = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%PropogationDir = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WindType = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%ReferenceHeight = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Width = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%HalfWidth = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NWindVel = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%WindVxiList) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WindVxiList,1))); mask1 = .TRUE.
    OutData%WindVxiList = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WindVxiList))-1 ),mask1,OutData%WindVxiList)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WindVxiList)
  ENDIF
  IF ( ALLOCATED(OutData%WindVyiList) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WindVyiList,1))); mask1 = .TRUE.
    OutData%WindVyiList = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WindVyiList))-1 ),mask1,OutData%WindVyiList)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WindVyiList)
  ENDIF
  IF ( ALLOCATED(OutData%WindVziList) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WindVziList,1))); mask1 = .TRUE.
    OutData%WindVziList = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WindVziList))-1 ),mask1,OutData%WindVziList)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WindVziList)
  ENDIF
 ! first call IfW_UniformWind_PackParam to get correctly sized buffers for unpacking
  CALL IfW_UniformWind_PackParam( Re_UniformWind_Buf, Db_UniformWind_Buf, Int_UniformWind_Buf, OutData%UniformWind, ErrStat, ErrMsg, .TRUE. ) ! UniformWind 
  IF(ALLOCATED(Re_UniformWind_Buf)) THEN
    Re_UniformWind_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_UniformWind_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_UniformWind_Buf)
  ENDIF
  IF(ALLOCATED(Db_UniformWind_Buf)) THEN
    Db_UniformWind_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_UniformWind_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_UniformWind_Buf)
  ENDIF
  IF(ALLOCATED(Int_UniformWind_Buf)) THEN
    Int_UniformWind_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_UniformWind_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_UniformWind_Buf)
  ENDIF
  CALL IfW_UniformWind_UnPackParam( Re_UniformWind_Buf, Db_UniformWind_Buf, Int_UniformWind_Buf, OutData%UniformWind, ErrStat, ErrMsg ) ! UniformWind 
 ! first call IfW_HAWCWind_PackParam to get correctly sized buffers for unpacking
  CALL IfW_HAWCWind_PackParam( Re_HAWCWind_Buf, Db_HAWCWind_Buf, Int_HAWCWind_Buf, OutData%HAWCWind, ErrStat, ErrMsg, .TRUE. ) ! HAWCWind 
  IF(ALLOCATED(Re_HAWCWind_Buf)) THEN
    Re_HAWCWind_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_HAWCWind_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_HAWCWind_Buf)
  ENDIF
  IF(ALLOCATED(Db_HAWCWind_Buf)) THEN
    Db_HAWCWind_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_HAWCWind_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_HAWCWind_Buf)
  ENDIF
  IF(ALLOCATED(Int_HAWCWind_Buf)) THEN
    Int_HAWCWind_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_HAWCWind_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_HAWCWind_Buf)
  ENDIF
  CALL IfW_HAWCWind_UnPackParam( Re_HAWCWind_Buf, Db_HAWCWind_Buf, Int_HAWCWind_Buf, OutData%HAWCWind, ErrStat, ErrMsg ) ! HAWCWind 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE InflowWind_UnPackParam

 SUBROUTINE InflowWind_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(InflowWind_inputtype), INTENT(INOUT) :: SrcInputData
   TYPE(InflowWind_inputtype), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInputData%Position)) THEN
   i1_l = LBOUND(SrcInputData%Position,1)
   i1_u = UBOUND(SrcInputData%Position,1)
   i2_l = LBOUND(SrcInputData%Position,2)
   i2_u = UBOUND(SrcInputData%Position,2)
   IF (.NOT. ALLOCATED(DstInputData%Position)) THEN 
      ALLOCATE(DstInputData%Position(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'InflowWind_CopyInput: Error allocating DstInputData%Position.'
         RETURN
      END IF
   END IF
   DstInputData%Position = SrcInputData%Position
ENDIF
 END SUBROUTINE InflowWind_CopyInput

 SUBROUTINE InflowWind_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(InflowWind_inputtype), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InputData%Position)) THEN
   DEALLOCATE(InputData%Position)
ENDIF
 END SUBROUTINE InflowWind_DestroyInput

 SUBROUTINE InflowWind_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(InflowWind_inputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%Position )  ! Position 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%Position) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Position))-1 ) =  PACK(InData%Position ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Position)
  ENDIF
 END SUBROUTINE InflowWind_PackInput

 SUBROUTINE InflowWind_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(InflowWind_inputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%Position) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Position,1),SIZE(OutData%Position,2))); mask2 = .TRUE.
    OutData%Position = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Position))-1 ),mask2,OutData%Position)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Position)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE InflowWind_UnPackInput

 SUBROUTINE InflowWind_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(InflowWind_outputtype), INTENT(INOUT) :: SrcOutputData
   TYPE(InflowWind_outputtype), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%Velocity)) THEN
   i1_l = LBOUND(SrcOutputData%Velocity,1)
   i1_u = UBOUND(SrcOutputData%Velocity,1)
   i2_l = LBOUND(SrcOutputData%Velocity,2)
   i2_u = UBOUND(SrcOutputData%Velocity,2)
   IF (.NOT. ALLOCATED(DstOutputData%Velocity)) THEN 
      ALLOCATE(DstOutputData%Velocity(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'InflowWind_CopyOutput: Error allocating DstOutputData%Velocity.'
         RETURN
      END IF
   END IF
   DstOutputData%Velocity = SrcOutputData%Velocity
ENDIF
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
   i1_l = LBOUND(SrcOutputData%WriteOutput,1)
   i1_u = UBOUND(SrcOutputData%WriteOutput,1)
   IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
      ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'InflowWind_CopyOutput: Error allocating DstOutputData%WriteOutput.'
         RETURN
      END IF
   END IF
   DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE InflowWind_CopyOutput

 SUBROUTINE InflowWind_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(InflowWind_outputtype), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OutputData%Velocity)) THEN
   DEALLOCATE(OutputData%Velocity)
ENDIF
IF (ALLOCATED(OutputData%WriteOutput)) THEN
   DEALLOCATE(OutputData%WriteOutput)
ENDIF
 END SUBROUTINE InflowWind_DestroyOutput

 SUBROUTINE InflowWind_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(InflowWind_outputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%Velocity )  ! Velocity 
  Re_BufSz    = Re_BufSz    + SIZE( InData%WriteOutput )  ! WriteOutput 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%Velocity) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Velocity))-1 ) =  PACK(InData%Velocity ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Velocity)
  ENDIF
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WriteOutput))-1 ) =  PACK(InData%WriteOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WriteOutput)
  ENDIF
 END SUBROUTINE InflowWind_PackOutput

 SUBROUTINE InflowWind_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(InflowWind_outputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%Velocity) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Velocity,1),SIZE(OutData%Velocity,2))); mask2 = .TRUE.
    OutData%Velocity = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Velocity))-1 ),mask2,OutData%Velocity)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Velocity)
  ENDIF
  IF ( ALLOCATED(OutData%WriteOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WriteOutput,1))); mask1 = .TRUE.
    OutData%WriteOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WriteOutput))-1 ),mask1,OutData%WriteOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WriteOutput)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE InflowWind_UnPackOutput

 SUBROUTINE InflowWind_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(InflowWind_continuousstatetype), INTENT(INOUT) :: SrcContStateData
   TYPE(InflowWind_continuousstatetype), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstContStateData%DummyContState = SrcContStateData%DummyContState
 END SUBROUTINE InflowWind_CopyContState

 SUBROUTINE InflowWind_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(InflowWind_continuousstatetype), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE InflowWind_DestroyContState

 SUBROUTINE InflowWind_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(InflowWind_continuousstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyContState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyContState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE InflowWind_PackContState

 SUBROUTINE InflowWind_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(InflowWind_continuousstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyContState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE InflowWind_UnPackContState

 SUBROUTINE InflowWind_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(InflowWind_discretestatetype), INTENT(INOUT) :: SrcDiscStateData
   TYPE(InflowWind_discretestatetype), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE InflowWind_CopyDiscState

 SUBROUTINE InflowWind_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(InflowWind_discretestatetype), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE InflowWind_DestroyDiscState

 SUBROUTINE InflowWind_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(InflowWind_discretestatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyDiscState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyDiscState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE InflowWind_PackDiscState

 SUBROUTINE InflowWind_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(InflowWind_discretestatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyDiscState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE InflowWind_UnPackDiscState

 SUBROUTINE InflowWind_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(InflowWind_constraintstatetype), INTENT(INOUT) :: SrcConstrStateData
   TYPE(InflowWind_constraintstatetype), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
 END SUBROUTINE InflowWind_CopyConstrState

 SUBROUTINE InflowWind_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(InflowWind_constraintstatetype), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE InflowWind_DestroyConstrState

 SUBROUTINE InflowWind_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(InflowWind_constraintstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyConstrState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyConstrState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE InflowWind_PackConstrState

 SUBROUTINE InflowWind_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(InflowWind_constraintstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyConstrState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE InflowWind_UnPackConstrState


 SUBROUTINE InflowWind_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(InflowWind_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(InflowWind_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in InflowWind_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in InflowWind_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ALLOCATED(u_out%Position) .AND. ALLOCATED(u(1)%Position)) THEN
  u_out%Position = u(1)%Position
END IF ! check if allocated
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in InflowWind_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%Position) .AND. ALLOCATED(u(1)%Position)) THEN
  ALLOCATE(b2(SIZE(u_out%Position,1),SIZE(u_out%Position,2) ))
  ALLOCATE(c2(SIZE(u_out%Position,1),SIZE(u_out%Position,2) ))
  b2 = -(u(1)%Position - u(2)%Position)/t(2)
  u_out%Position = u(1)%Position + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in InflowWind_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in InflowWind_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in InflowWind_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%Position) .AND. ALLOCATED(u(1)%Position)) THEN
  ALLOCATE(b2(SIZE(u_out%Position,1),SIZE(u_out%Position,2) ))
  ALLOCATE(c2(SIZE(u_out%Position,1),SIZE(u_out%Position,2) ))
  b2 = (t(3)**2*(u(1)%Position - u(2)%Position) + t(2)**2*(-u(1)%Position + u(3)%Position))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%Position + t(3)*u(2)%Position - t(2)*u(3)%Position ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Position = u(1)%Position + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in InflowWind_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE InflowWind_Input_ExtrapInterp


 SUBROUTINE InflowWind_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(InflowWind_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(InflowWind_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in InflowWind_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in InflowWind_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ALLOCATED(u_out%Velocity) .AND. ALLOCATED(u(1)%Velocity)) THEN
  u_out%Velocity = u(1)%Velocity
END IF ! check if allocated
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  u_out%WriteOutput = u(1)%WriteOutput
END IF ! check if allocated
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in InflowWind_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%Velocity) .AND. ALLOCATED(u(1)%Velocity)) THEN
  ALLOCATE(b2(SIZE(u_out%Velocity,1),SIZE(u_out%Velocity,2) ))
  ALLOCATE(c2(SIZE(u_out%Velocity,1),SIZE(u_out%Velocity,2) ))
  b2 = -(u(1)%Velocity - u(2)%Velocity)/t(2)
  u_out%Velocity = u(1)%Velocity + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = -(u(1)%WriteOutput - u(2)%WriteOutput)/t(2)
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in InflowWind_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in InflowWind_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in InflowWind_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%Velocity) .AND. ALLOCATED(u(1)%Velocity)) THEN
  ALLOCATE(b2(SIZE(u_out%Velocity,1),SIZE(u_out%Velocity,2) ))
  ALLOCATE(c2(SIZE(u_out%Velocity,1),SIZE(u_out%Velocity,2) ))
  b2 = (t(3)**2*(u(1)%Velocity - u(2)%Velocity) + t(2)**2*(-u(1)%Velocity + u(3)%Velocity))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%Velocity + t(3)*u(2)%Velocity - t(2)*u(3)%Velocity ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Velocity = u(1)%Velocity + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = (t(3)**2*(u(1)%WriteOutput - u(2)%WriteOutput) + t(2)**2*(-u(1)%WriteOutput + u(3)%WriteOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%WriteOutput + t(3)*u(2)%WriteOutput - t(2)*u(3)%WriteOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in InflowWind_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE InflowWind_Output_ExtrapInterp

END MODULE InflowWind_Types
!ENDOFREGISTRYGENERATEDFILE
